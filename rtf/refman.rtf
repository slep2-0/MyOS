{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment My Project }My Project}
{\comment Generated by doxygen 1.14.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt My Project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b _AHCI_PORT_CTX} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _BLOCK_DEVICE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _BLOCK_HEADER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _BOOT_INFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _BUGCHECK_ADDITIONALS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _CPU} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _CTX_FRAME} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DPC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EFI_MEMORY_DESCRIPTOR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _FAT32_FSINFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _FIS_REG_H2D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _GOP_PARAMS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_CMD_HEADER} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_CMD_TBL} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_MEM} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_PORT} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_PRDT_ENTRY} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _IDT_ENTRY_64} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _IDT_PTR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _INT_FRAME} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _Queue} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _SPINLOCK} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _Thread} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FS_DRIVER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LASTFUNC_HISTORY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LFN_ENTRY_BUFFER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MOUNTED_FS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TIME_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b assert.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b kernel.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b kernel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b mtstatus.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b time.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b trace.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/{\b bugcheck.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/{\b bugcheck.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/{\b apic.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/{\b apic.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/{\b pit.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/{\b pit.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpuid/{\b cpuid.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/{\b dpc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/{\b dpc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/{\b dpc_list.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/{\b dpc_list.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/{\b irql.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/{\b irql.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/{\b scheduler.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/{\b scheduler.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/spinlock/{\b spinlock.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/{\b thread.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/{\b thread.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/defs/{\b stdarg_myos.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/{\b block.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/{\b block.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/{\b font8x16.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/{\b gop.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/{\b gop.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/{\b idt.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/{\b idt.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/{\b isr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/{\b handlers.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/{\b handlers.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/{\b scancodes.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/{\b atomic.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/{\b intrin.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/{\b memory.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/{\b memory.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/{\b allocator.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/{\b allocator.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/{\b uefi_memory.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/{\b paging.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/{\b paging.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_AHCI_PORT_CTX Struct Reference\par \pard\plain 
{\tc\tcl2 \v _AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX}
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HBA_PORT} * {\b port}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HBA_CMD_TBL} * {\b cmd_tbl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b clb}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b fis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} {\b bdev}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 46} of file {\b ahci.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bdev\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:bdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} bdev}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b ahci.c}.}\par
}
{\xe \v clb\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:clb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* clb}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b ahci.c}.}\par
}
{\xe \v cmd_tbl\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:cmd_tbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HBA_CMD_TBL}* cmd_tbl}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b ahci.c}.}\par
}
{\xe \v fis\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:fis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* fis}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ahci.c}.}\par
}
{\xe \v port\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HBA_PORT}* port}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b ahci.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_BLOCK_DEVICE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE}
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
\par
{
{\f2 #include <block.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b read_sector} )(struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, void *buf)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b write_sector} )(struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, const void *buf)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b dev_data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 14} of file {\b block.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dev_data\:_BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE\:dev_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* dev_data}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b block.h}.}\par
}
{\xe \v read_sector\:_BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE\:read_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* read_sector) (struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, void *buf)}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b block.h}.}\par
}
{\xe \v write_sector\:_BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE\:write_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* write_sector) (struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, const void *buf)}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b block.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/{\b block.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_BLOCK_HEADER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _BLOCK_HEADER}
{\xe \v _BLOCK_HEADER}
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\par
{
{\f2 #include <memory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BLOCK_HEADER} * {\b next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b in_use}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b kind}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 38} of file {\b memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v in_use\:_BLOCK_HEADER}
{\xe \v _BLOCK_HEADER\:in_use}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool in_use}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b memory.h}.}\par
}
{\xe \v kind\:_BLOCK_HEADER}
{\xe \v _BLOCK_HEADER\:kind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t kind}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b memory.h}.}\par
}
{\xe \v next\:_BLOCK_HEADER}
{\xe \v _BLOCK_HEADER\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _BLOCK_HEADER}* next}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b memory.h}.}\par
}
{\xe \v size\:_BLOCK_HEADER}
{\xe \v _BLOCK_HEADER\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t size}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/{\b memory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_BOOT_INFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v _BOOT_INFO}
{\xe \v _BOOT_INFO}
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
\par
{
{\f2 #include <uefi_memory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} * {\b Gop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EFI_MEMORY_DESCRIPTOR} * {\b MemoryMap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b MapSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b DescriptorSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b DescriptorVersion}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b AhciCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t * {\b AhciBarBases}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b KernelStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b Pml4Phys}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 32} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AhciBarBases\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:AhciBarBases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t* AhciBarBases}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b uefi_memory.h}.}\par
}
{\xe \v AhciCount\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:AhciCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t AhciCount}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b uefi_memory.h}.}\par
}
{\xe \v DescriptorSize\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:DescriptorSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t DescriptorSize}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b uefi_memory.h}.}\par
}
{\xe \v DescriptorVersion\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:DescriptorVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t DescriptorVersion}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b uefi_memory.h}.}\par
}
{\xe \v Gop\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:Gop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS}* Gop}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b uefi_memory.h}.}\par
}
{\xe \v KernelStackTop\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:KernelStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t KernelStackTop}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b uefi_memory.h}.}\par
}
{\xe \v MapSize\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:MapSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MapSize}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b uefi_memory.h}.}\par
}
{\xe \v MemoryMap\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:MemoryMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EFI_MEMORY_DESCRIPTOR}* MemoryMap}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b uefi_memory.h}.}\par
}
{\xe \v Pml4Phys\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:Pml4Phys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t Pml4Phys}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/{\b uefi_memory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_BUGCHECK_ADDITIONALS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _BUGCHECK_ADDITIONALS}
{\xe \v _BUGCHECK_ADDITIONALS}
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
\par
{
{\f2 #include <bugcheck.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b str} [512]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b num}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int64_t {\b signednum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b boolean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b ptr}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 62} of file {\b bugcheck.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v boolean\:_BUGCHECK_ADDITIONALS}
{\xe \v _BUGCHECK_ADDITIONALS\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool boolean}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b bugcheck.h}.}\par
}
{\xe \v num\:_BUGCHECK_ADDITIONALS}
{\xe \v _BUGCHECK_ADDITIONALS\:num}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t num}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b bugcheck.h}.}\par
}
{\xe \v ptr\:_BUGCHECK_ADDITIONALS}
{\xe \v _BUGCHECK_ADDITIONALS\:ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* ptr}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b bugcheck.h}.}\par
}
{\xe \v signednum\:_BUGCHECK_ADDITIONALS}
{\xe \v _BUGCHECK_ADDITIONALS\:signednum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int64_t signednum}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b bugcheck.h}.}\par
}
{\xe \v str\:_BUGCHECK_ADDITIONALS}
{\xe \v _BUGCHECK_ADDITIONALS\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char str[512]}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b bugcheck.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/{\b bugcheck.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_CPU Struct Reference\par \pard\plain 
{\tc\tcl2 \v _CPU}
{\xe \v _CPU}
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRQL} {\b currentIrql}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b schedulerEnabled}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} * {\b currentThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Queue} {\b readyQueue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 148} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v currentIrql\:_CPU}
{\xe \v _CPU\:currentIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IRQL} currentIrql}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b cpu_types.h}.}\par
}
{\xe \v currentThread\:_CPU}
{\xe \v _CPU\:currentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread}* currentThread}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b cpu_types.h}.}\par
}
{\xe \v readyQueue\:_CPU}
{\xe \v _CPU\:readyQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Queue} readyQueue}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b cpu_types.h}.}\par
}
{\xe \v schedulerEnabled\:_CPU}
{\xe \v _CPU\:schedulerEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool schedulerEnabled}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_CTX_FRAME Struct Reference\par \pard\plain 
{\tc\tcl2 \v _CTX_FRAME}
{\xe \v _CTX_FRAME}
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r15}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r14}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r13}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r12}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r11}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r10}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r9}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rbp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rdi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rsi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rdx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rcx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rbx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rax}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rsp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rip}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 69} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v r10\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r10}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r11\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r11}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r12\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r12}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r12}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r13\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r13}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r13}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r14\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r14}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r14}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r15\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r15}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r15}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r8\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r8}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v r9\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:r9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r9}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b cpu_types.h}.}\par
}
{\xe \v rax\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rax}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rbp\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rbp}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rbx\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rbx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rbx}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rcx\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rcx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rcx}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rdi\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rdi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rdi}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rdx\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rdx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rdx}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rip\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rip}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b cpu_types.h}.}\par
}
{\xe \v rsi\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rsi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rsi}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b cpu_types.h}.}\par
}
{\xe \v rsp\:_CTX_FRAME}
{\xe \v _CTX_FRAME\:rsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rsp}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DPC Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DPC}
{\xe \v _DPC}
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b DPC} * {\b Next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b callbackWithCtx} )(void *{\b ctx})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b callback} )(void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTX_FRAME} * {\b ctx}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback without any CONTEXT (no registers), used to invoke {\b DPC}'s like scheduler. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DPC_KIND} {\b Kind}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b hasCtx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DPC_PRIORITY} {\b priority}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 138} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v callback\:_DPC}
{\xe \v _DPC\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* callback) (void)}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b cpu_types.h}.}\par
}
{\xe \v callbackWithCtx\:_DPC}
{\xe \v _DPC\:callbackWithCtx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* callbackWithCtx) (void *{\b ctx})}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b cpu_types.h}.}\par
}
{\xe \v ctx\:_DPC}
{\xe \v _DPC\:ctx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTX_FRAME}* ctx}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback without any CONTEXT (no registers), used to invoke {\b DPC}'s like scheduler. }}\par
{
Definition at line {\b 142} of file {\b cpu_types.h}.}\par
}
{\xe \v hasCtx\:_DPC}
{\xe \v _DPC\:hasCtx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool hasCtx}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b cpu_types.h}.}\par
}
{\xe \v Kind\:_DPC}
{\xe \v _DPC\:Kind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DPC_KIND} Kind}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b cpu_types.h}.}\par
}
{\xe \v Next\:_DPC}
{\xe \v _DPC\:Next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b DPC}* Next}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b cpu_types.h}.}\par
}
{\xe \v priority\:_DPC}
{\xe \v _DPC\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DPC_PRIORITY} priority}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EFI_MEMORY_DESCRIPTOR Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR}
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
\par
{
{\f2 #include <uefi_memory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Pad}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b PhysicalStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b VirtualStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b NumberOfPages}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Attribute}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Attribute\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:Attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Attribute}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b uefi_memory.h}.}\par
}
{\xe \v NumberOfPages\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:NumberOfPages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t NumberOfPages}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b uefi_memory.h}.}\par
}
{\xe \v Pad\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:Pad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Pad}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b uefi_memory.h}.}\par
}
{\xe \v PhysicalStart\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:PhysicalStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t PhysicalStart}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b uefi_memory.h}.}\par
}
{\xe \v Type\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Type}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b uefi_memory.h}.}\par
}
{\xe \v VirtualStart\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:VirtualStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t VirtualStart}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/{\b uefi_memory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_FAT32_FSINFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v _FAT32_FSINFO}
{\xe \v _FAT32_FSINFO}
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
\par
{
{\f2 #include <fat32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b first_data_sector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b root_cluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sectors_per_fat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b bytes_per_sector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sectors_per_cluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fat_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b reserved_sector_count}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 83} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bytes_per_sector\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:bytes_per_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bytes_per_sector}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b fat32.h}.}\par
}
{\xe \v fat_start\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:fat_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fat_start}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b fat32.h}.}\par
}
{\xe \v first_data_sector\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:first_data_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t first_data_sector}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b fat32.h}.}\par
}
{\xe \v reserved_sector_count\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:reserved_sector_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t reserved_sector_count}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b fat32.h}.}\par
}
{\xe \v root_cluster\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:root_cluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t root_cluster}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b fat32.h}.}\par
}
{\xe \v sectors_per_cluster\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:sectors_per_cluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sectors_per_cluster}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b fat32.h}.}\par
}
{\xe \v sectors_per_fat\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:sectors_per_fat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sectors_per_fat}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_FIS_REG_H2D Struct Reference\par \pard\plain 
{\tc\tcl2 \v _FIS_REG_H2D}
{\xe \v _FIS_REG_H2D}
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b fis_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b pmport}: 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv0}: 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b c}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b command}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b featurel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b device}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba4}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba5}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b featureh}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b countl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b counth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b icc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b control}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv1} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) \par
}{
Definition at line {\b 75} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v c\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t c}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b ahci.h}.}\par
}
{\xe \v command\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t command}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b ahci.h}.}\par
}
{\xe \v control\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t control}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b ahci.h}.}\par
}
{\xe \v counth\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:counth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t counth}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b ahci.h}.}\par
}
{\xe \v countl\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:countl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t countl}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b ahci.h}.}\par
}
{\xe \v device\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t device}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b ahci.h}.}\par
}
{\xe \v featureh\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:featureh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t featureh}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b ahci.h}.}\par
}
{\xe \v featurel\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:featurel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t featurel}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b ahci.h}.}\par
}
{\xe \v fis_type\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:fis_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t fis_type}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b ahci.h}.}\par
}
{\xe \v icc\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:icc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t icc}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b ahci.h}.}\par
}
{\xe \v lba0\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba0}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b ahci.h}.}\par
}
{\xe \v lba1\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba1}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b ahci.h}.}\par
}
{\xe \v lba2\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba2}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b ahci.h}.}\par
}
{\xe \v lba3\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba3}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b ahci.h}.}\par
}
{\xe \v lba4\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba4}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b ahci.h}.}\par
}
{\xe \v lba5\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba5}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b ahci.h}.}\par
}
{\xe \v pmport\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:pmport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t pmport}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b ahci.h}.}\par
}
{\xe \v rsv0\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:rsv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv0}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv1[4]}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_GOP_PARAMS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _GOP_PARAMS}
{\xe \v _GOP_PARAMS}
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
\par
{
{\f2 #include <uefi_memory.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b FrameBufferBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b FrameBufferSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Width}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Height}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PixelsPerScanLine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v FrameBufferBase\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:FrameBufferBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t FrameBufferBase}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b uefi_memory.h}.}\par
}
{\xe \v FrameBufferSize\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:FrameBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t FrameBufferSize}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b uefi_memory.h}.}\par
}
{\xe \v Height\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:Height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Height}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b uefi_memory.h}.}\par
}
{\xe \v PixelsPerScanLine\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:PixelsPerScanLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PixelsPerScanLine}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b uefi_memory.h}.}\par
}
{\xe \v Width\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:Width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Width}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/{\b uefi_memory.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_CMD_HEADER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER}
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b dw0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b prdbc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ctba}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ctbau}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv1} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) \par
}{
Definition at line {\b 128} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ctba\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:ctba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ctba}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b ahci.h}.}\par
}
{\xe \v ctbau\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:ctbau}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ctbau}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b ahci.h}.}\par
}
{\xe \v dw0\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:dw0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t dw0}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b ahci.h}.}\par
}
{\xe \v prdbc\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:prdbc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t prdbc}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv1[4]}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_CMD_TBL Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL}
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b cfis} [64]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b acmd} [16]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv} [48]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HBA_PRDT_ENTRY} {\b prdt_entry} [1]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. \par
}{
Definition at line {\b 110} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v acmd\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:acmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t acmd[16]}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b ahci.h}.}\par
}
{\xe \v cfis\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:cfis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t cfis[64]}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b ahci.h}.}\par
}
{\xe \v prdt_entry\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:prdt_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HBA_PRDT_ENTRY} prdt_entry[1]}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b ahci.h}.}\par
}
{\xe \v rsv\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:rsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv[48]}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_MEM Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_MEM}
{\xe \v _HBA_MEM}
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ghc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b is}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b pi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b vs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ccc_ctl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ccc_pts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b em_loc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b em_ctl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cap2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b bohc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv} [0xA0 - 0x2C]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b venor} [0x100 - 0xA0]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) \par
}{
Definition at line {\b 31} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bohc\:_HBA_MEM}
{\xe \v _HBA_MEM\:bohc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bohc}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b ahci.h}.}\par
}
{\xe \v cap\:_HBA_MEM}
{\xe \v _HBA_MEM\:cap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cap}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b ahci.h}.}\par
}
{\xe \v cap2\:_HBA_MEM}
{\xe \v _HBA_MEM\:cap2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cap2}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ahci.h}.}\par
}
{\xe \v ccc_ctl\:_HBA_MEM}
{\xe \v _HBA_MEM\:ccc_ctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ccc_ctl}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b ahci.h}.}\par
}
{\xe \v ccc_pts\:_HBA_MEM}
{\xe \v _HBA_MEM\:ccc_pts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ccc_pts}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b ahci.h}.}\par
}
{\xe \v em_ctl\:_HBA_MEM}
{\xe \v _HBA_MEM\:em_ctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t em_ctl}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b ahci.h}.}\par
}
{\xe \v em_loc\:_HBA_MEM}
{\xe \v _HBA_MEM\:em_loc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t em_loc}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b ahci.h}.}\par
}
{\xe \v ghc\:_HBA_MEM}
{\xe \v _HBA_MEM\:ghc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ghc}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ahci.h}.}\par
}
{\xe \v is\:_HBA_MEM}
{\xe \v _HBA_MEM\:is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t is}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b ahci.h}.}\par
}
{\xe \v pi\:_HBA_MEM}
{\xe \v _HBA_MEM\:pi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t pi}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b ahci.h}.}\par
}
{\xe \v rsv\:_HBA_MEM}
{\xe \v _HBA_MEM\:rsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv[0xA0 - 0x2C]}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ahci.h}.}\par
}
{\xe \v venor\:_HBA_MEM}
{\xe \v _HBA_MEM\:venor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t venor[0x100 - 0xA0]}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b ahci.h}.}\par
}
{\xe \v vs\:_HBA_MEM}
{\xe \v _HBA_MEM\:vs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t vs}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_PORT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_PORT}
{\xe \v _HBA_PORT}
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b clb}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b clbu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fb}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fbu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b is}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ie}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cmd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b tfd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sig}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ssts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sctl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b serr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sact}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ci}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sntf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fbs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv1} [11]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b vendor} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) \par
}{
Definition at line {\b 49} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ci\:_HBA_PORT}
{\xe \v _HBA_PORT\:ci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ci}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b ahci.h}.}\par
}
{\xe \v clb\:_HBA_PORT}
{\xe \v _HBA_PORT\:clb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t clb}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ahci.h}.}\par
}
{\xe \v clbu\:_HBA_PORT}
{\xe \v _HBA_PORT\:clbu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t clbu}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b ahci.h}.}\par
}
{\xe \v cmd\:_HBA_PORT}
{\xe \v _HBA_PORT\:cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cmd}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b ahci.h}.}\par
}
{\xe \v fb\:_HBA_PORT}
{\xe \v _HBA_PORT\:fb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fb}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ahci.h}.}\par
}
{\xe \v fbs\:_HBA_PORT}
{\xe \v _HBA_PORT\:fbs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fbs}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b ahci.h}.}\par
}
{\xe \v fbu\:_HBA_PORT}
{\xe \v _HBA_PORT\:fbu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fbu}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b ahci.h}.}\par
}
{\xe \v ie\:_HBA_PORT}
{\xe \v _HBA_PORT\:ie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ie}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b ahci.h}.}\par
}
{\xe \v is\:_HBA_PORT}
{\xe \v _HBA_PORT\:is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t is}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ahci.h}.}\par
}
{\xe \v rsv0\:_HBA_PORT}
{\xe \v _HBA_PORT\:rsv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv0}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_HBA_PORT}
{\xe \v _HBA_PORT\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv1[11]}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b ahci.h}.}\par
}
{\xe \v sact\:_HBA_PORT}
{\xe \v _HBA_PORT\:sact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sact}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ahci.h}.}\par
}
{\xe \v sctl\:_HBA_PORT}
{\xe \v _HBA_PORT\:sctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sctl}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b ahci.h}.}\par
}
{\xe \v serr\:_HBA_PORT}
{\xe \v _HBA_PORT\:serr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t serr}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b ahci.h}.}\par
}
{\xe \v sig\:_HBA_PORT}
{\xe \v _HBA_PORT\:sig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sig}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ahci.h}.}\par
}
{\xe \v sntf\:_HBA_PORT}
{\xe \v _HBA_PORT\:sntf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sntf}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b ahci.h}.}\par
}
{\xe \v ssts\:_HBA_PORT}
{\xe \v _HBA_PORT\:ssts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ssts}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b ahci.h}.}\par
}
{\xe \v tfd\:_HBA_PORT}
{\xe \v _HBA_PORT\:tfd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t tfd}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b ahci.h}.}\par
}
{\xe \v vendor\:_HBA_PORT}
{\xe \v _HBA_PORT\:vendor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t vendor[4]}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_PRDT_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY}
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b dba}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b dbau}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b dbc}: 22\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv1}: 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b i}: 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. \par
}{
Definition at line {\b 98} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dba\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:dba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t dba}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b ahci.h}.}\par
}
{\xe \v dbau\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:dbau}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t dbau}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b ahci.h}.}\par
}
{\xe \v dbc\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:dbc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t dbc}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b ahci.h}.}\par
}
{\xe \v i\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:i}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t i}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b ahci.h}.}\par
}
{\xe \v rsv0\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:rsv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv0}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv1}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_IDT_ENTRY_64 Struct Reference\par \pard\plain 
{\tc\tcl2 \v _IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64}
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
\par
{
{\f2 #include <idt.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b offset_low}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b selector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ist}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b type_attr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b offset_mid}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b offset_high}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b zero}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 82} of file {\b idt.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ist\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:ist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ist}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b idt.h}.}\par
}
{\xe \v offset_high\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:offset_high}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t offset_high}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b idt.h}.}\par
}
{\xe \v offset_low\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:offset_low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t offset_low}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b idt.h}.}\par
}
{\xe \v offset_mid\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:offset_mid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t offset_mid}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b idt.h}.}\par
}
{\xe \v selector\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:selector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t selector}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b idt.h}.}\par
}
{\xe \v type_attr\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:type_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t type_attr}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b idt.h}.}\par
}
{\xe \v zero\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:zero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t zero}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b idt.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/{\b idt.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_IDT_PTR Struct Reference\par \pard\plain 
{\tc\tcl2 \v _IDT_PTR}
{\xe \v _IDT_PTR}
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
\par
{
{\f2 #include <idt.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b limit}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b base}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 77} of file {\b idt.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v base\:_IDT_PTR}
{\xe \v _IDT_PTR\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t base}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b idt.h}.}\par
}
{\xe \v limit\:_IDT_PTR}
{\xe \v _IDT_PTR\:limit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t limit}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b idt.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/{\b idt.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_INT_FRAME Struct Reference\par \pard\plain 
{\tc\tcl2 \v _INT_FRAME}
{\xe \v _INT_FRAME}
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b vector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b error_code}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b cs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rflags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rsp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b ss}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 56} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v cs\:_INT_FRAME}
{\xe \v _INT_FRAME\:cs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t cs}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b cpu_types.h}.}\par
}
{\xe \v error_code\:_INT_FRAME}
{\xe \v _INT_FRAME\:error_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t error_code}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b cpu_types.h}.}\par
}
{\xe \v rflags\:_INT_FRAME}
{\xe \v _INT_FRAME\:rflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rflags}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b cpu_types.h}.}\par
}
{\xe \v rip\:_INT_FRAME}
{\xe \v _INT_FRAME\:rip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rip}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b cpu_types.h}.}\par
}
{\xe \v rsp\:_INT_FRAME}
{\xe \v _INT_FRAME\:rsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rsp}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b cpu_types.h}.}\par
}
{\xe \v ss\:_INT_FRAME}
{\xe \v _INT_FRAME\:ss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t ss}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b cpu_types.h}.}\par
}
{\xe \v vector\:_INT_FRAME}
{\xe \v _INT_FRAME\:vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t vector}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_Queue Struct Reference\par \pard\plain 
{\tc\tcl2 \v _Queue}
{\xe \v _Queue}
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} * {\b head}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} * {\b tail}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 78} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v head\:_Queue}
{\xe \v _Queue\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread}* head}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b cpu_types.h}.}\par
}
{\xe \v tail\:_Queue}
{\xe \v _Queue\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread}* tail}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_SPINLOCK Struct Reference\par \pard\plain 
{\tc\tcl2 \v _SPINLOCK}
{\xe \v _SPINLOCK}
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
atomic_flag {\b LOCKED}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 51} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v LOCKED\:_SPINLOCK}
{\xe \v _SPINLOCK\:LOCKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
atomic_flag LOCKED}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_Thread Struct Reference\par \pard\plain 
{\tc\tcl2 \v _Thread}
{\xe \v _Thread}
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
\par
{
{\f2 #include <cpu_types.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTX_FRAME} {\b registers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b THREAD_STATE} {\b threadState}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b timeSlice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b origTimeSlice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} * {\b nextThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b TID}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b startStackPtr}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 103} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v nextThread\:_Thread}
{\xe \v _Thread\:nextThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread}* nextThread}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b cpu_types.h}.}\par
}
{\xe \v origTimeSlice\:_Thread}
{\xe \v _Thread\:origTimeSlice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t origTimeSlice}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b cpu_types.h}.}\par
}
{\xe \v registers\:_Thread}
{\xe \v _Thread\:registers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTX_FRAME} registers}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b cpu_types.h}.}\par
}
{\xe \v startStackPtr\:_Thread}
{\xe \v _Thread\:startStackPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* startStackPtr}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 120} of file {\b cpu_types.h}.}\par
}
{\xe \v threadState\:_Thread}
{\xe \v _Thread\:threadState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b THREAD_STATE} threadState}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b cpu_types.h}.}\par
}
{\xe \v TID\:_Thread}
{\xe \v _Thread\:TID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t TID}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b cpu_types.h}.}\par
}
{\xe \v timeSlice\:_Thread}
{\xe \v _Thread\:timeSlice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t timeSlice}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/{\b cpu_types.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FS_DRIVER Struct Reference\par \pard\plain 
{\tc\tcl2 \v FS_DRIVER}
{\xe \v FS_DRIVER}
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
\par
{
{\f2 #include <vfs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b init} )(uint8_t device_id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b read} )(const char *filename, uint32_t *file_size_out, void **buffer_out)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b write} )(const char *path, const void *data, uint32_t size, uint32_t mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b delete} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b mkdir} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b rmdir} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool(* {\b is_dir_empty} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b listdir} )(const char *path, char *listings, size_t max_len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b listrootdir} )(void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 18} of file {\b vfs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v delete\:FS_DRIVER}
{\xe \v FS_DRIVER\:delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* delete) (const char *path)}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b vfs.h}.}\par
}
{\xe \v init\:FS_DRIVER}
{\xe \v FS_DRIVER\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* init) (uint8_t device_id)}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b vfs.h}.}\par
}
{\xe \v is_dir_empty\:FS_DRIVER}
{\xe \v FS_DRIVER\:is_dir_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool(* is_dir_empty) (const char *path)}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b vfs.h}.}\par
}
{\xe \v listdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:listdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* listdir) (const char *path, char *listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b vfs.h}.}\par
}
{\xe \v listrootdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:listrootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* listrootdir) (void)}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b vfs.h}.}\par
}
{\xe \v mkdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:mkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* mkdir) (const char *path)}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b vfs.h}.}\par
}
{\xe \v read\:FS_DRIVER}
{\xe \v FS_DRIVER\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* read) (const char *filename, uint32_t *file_size_out, void **buffer_out)}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b vfs.h}.}\par
}
{\xe \v rmdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:rmdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* rmdir) (const char *path)}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b vfs.h}.}\par
}
{\xe \v write\:FS_DRIVER}
{\xe \v FS_DRIVER\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* write) (const char *path, const void *data, uint32_t size, uint32_t mode)}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b vfs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LASTFUNC_HISTORY Struct Reference\par \pard\plain 
{\tc\tcl2 \v LASTFUNC_HISTORY}
{\xe \v LASTFUNC_HISTORY}
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
\par
{
{\f2 #include <trace.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b names} [{\b LASTFUNC_HISTORY_SIZE}][{\b LASTFUNC_BUFFER_SIZE}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b current_index}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b trace.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v current_index\:LASTFUNC_HISTORY}
{\xe \v LASTFUNC_HISTORY\:current_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int current_index}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b trace.h}.}\par
}
{\xe \v names\:LASTFUNC_HISTORY}
{\xe \v LASTFUNC_HISTORY\:names}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t names[{\b LASTFUNC_HISTORY_SIZE}][{\b LASTFUNC_BUFFER_SIZE}]}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b trace.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b trace.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LFN_ENTRY_BUFFER Struct Reference\par \pard\plain 
{\tc\tcl2 \v LFN_ENTRY_BUFFER}
{\xe \v LFN_ENTRY_BUFFER}
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b name_chars} [13]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v name_chars\:LFN_ENTRY_BUFFER}
{\xe \v LFN_ENTRY_BUFFER\:name_chars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t name_chars[13]}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MOUNTED_FS Struct Reference\par \pard\plain 
{\tc\tcl2 \v MOUNTED_FS}
{\xe \v MOUNTED_FS}
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FS_DRIVER} * {\b driver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b device_id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b mount_point}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 12} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v device_id\:MOUNTED_FS}
{\xe \v MOUNTED_FS\:device_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t device_id}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b vfs.c}.}\par
}
{\xe \v driver\:MOUNTED_FS}
{\xe \v MOUNTED_FS\:driver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FS_DRIVER}* driver}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b vfs.c}.}\par
}
{\xe \v mount_point\:MOUNTED_FS}
{\xe \v MOUNTED_FS\:mount_point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* mount_point}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TIME_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v TIME_ENTRY}
{\xe \v TIME_ENTRY}
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
\par
{
{\f2 #include <time.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b second}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b minute}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b hour}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b day}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b month}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b year}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 18} of file {\b time.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v day\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t day}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b time.h}.}\par
}
{\xe \v hour\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t hour}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b time.h}.}\par
}
{\xe \v minute\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t minute}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b time.h}.}\par
}
{\xe \v month\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t month}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b time.h}.}\par
}
{\xe \v second\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t second}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b time.h}.}\par
}
{\xe \v year\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t year}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b time.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b time.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "bugcheck/bugcheck.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b assert}(...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v assert\:assert.h}
{\xe \v assert.h\:assert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define assert( ...)}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 do} \{ \} {\cf19 while}(0)\par
}
{
Definition at line {\b 54} of file {\b assert.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
assert.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Runtime Assertion Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_ASSERT_H}\par
00008 {\cf21 #define X86_ASSERT_H}\par
00009 \par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stdint.h>}\par
00013 {\cf21 #include "bugcheck/bugcheck.h"}\par
00014 {\cf21 #ifdef DEBUG}\par
00015 __attribute__((noreturn))\par
00016 {\cf17 static} {\cf18 void} assert_fail({\cf17 const} {\cf18 char}* expr, {\cf17 const} {\cf18 char}* reason, {\cf17 const} {\cf18 char}* file, {\cf17 const} {\cf18 char}* func, {\cf18 int} line) \{\par
00017     {\cf20 // Getting here means a runtime assertion has failed (assert())}\par
00018     BUGCHECK_ADDITIONALS addt = \{ 0 \};\par
00019 \par
00020     {\cf20 // It can be versatile, with a reason or not.}\par
00021     {\cf19 if} (reason) \{\par
00022         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "An assertion has failed (%s)\\nReason: %s\\nLocation: %s:%d, function %s"}, expr, reason, file, line, func);\par
00023         CTX_FRAME ctx;\par
00024         SAVE_CTX_FRAME(&ctx);\par
00025         MtBugcheckEx(&ctx, NULL, ASSERTION_FAILURE, &addt, {\cf17 true});\par
00026     \}\par
00027     {\cf19 else} \{\par
00028         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "An assertion has failed (%s)\\nLocation: %s:%d, function %s"}, expr, file, line, func);\par
00029         CTX_FRAME ctx;\par
00030         SAVE_CTX_FRAME(&ctx);\par
00031         MtBugcheckEx(&ctx, NULL, ASSERTION_FAILURE, &addt, {\cf17 true});\par
00032     \}\par
00033 \par
00034     __builtin_unreachable();\par
00035 \}\par
00036 \par
00037 {\cf20 // Helper macros for argument counting}\par
00038 {\cf21 #define GET_MACRO(_1,_2,NAME,...) NAME}\par
00039 \par
00040 {\cf20 // Base macros}\par
00041 {\cf21 #define ASSERT1(expr) \\}\par
00042 {\cf21     ((expr) ? (void)0 : assert_fail(#expr, NULL, __FILE__, __func__, __LINE__))}\par
00043 \par
00044 {\cf21 #define ASSERT2(expr, reason) \\}\par
00045 {\cf21     ((expr) ? (void)0 : assert_fail(#expr, reason, __FILE__, __func__, __LINE__))}\par
00046 \par
00047 {\cf20 // assert(expression) OR assert(expression, "expression must be ...")}\par
00048 {\cf21 #define assert(...) GET_MACRO(__VA_ARGS__, ASSERT2, ASSERT1)(__VA_ARGS__)}\par
00049 \par
00050 {\cf21 #else}\par
00051 {\cf20 // Make intellisense be quiet.}\par
00052 \par
00053 {\cf20 // assert(expression) OR assert(expression, "expression must be ...")}\par
00054 {\cf21 #define assert(...) do \{ \} while(0)}\par
00055 {\cf21 #endif}\par
00056 \par
00057 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.c}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "bugcheck.h"}\par
{\f2 #include "../trace.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NOTHING}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((noreturn))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtBugcheckEx} ({\b CTX_FRAME} *context, {\b INT_FRAME} *{\b int_frame}, {\b BUGCHECK_CODES} {\b err_code}, {\b BUGCHECK_ADDITIONALS} *{\b additional}, bool {\b isAdditionals})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LASTFUNC_HISTORY} {\b lastfunc_history}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBugChecking}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} {\b cpu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_y}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v NOTHING\:bugcheck.c}
{\xe \v bugcheck.c\:NOTHING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NOTHING}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b bugcheck.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:bugcheck.c}
{\xe \v bugcheck.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((noreturn) )}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b bugcheck.c}.}\par
}
{\xe \v MtBugcheckEx\:bugcheck.c}
{\xe \v bugcheck.c\:MtBugcheckEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtBugcheckEx ({\b CTX_FRAME} * context, {\b INT_FRAME} * int_frame, {\b BUGCHECK_CODES} err_code, {\b BUGCHECK_ADDITIONALS} * additional, bool isAdditionals)}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 322} of file {\b bugcheck.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cpu\:bugcheck.c}
{\xe \v bugcheck.c\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} cpu{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b kernel.c}.}\par
}
{\xe \v cursor_x\:bugcheck.c}
{\xe \v bugcheck.c\:cursor_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_x{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.c}.}\par
}
{\xe \v cursor_y\:bugcheck.c}
{\xe \v bugcheck.c\:cursor_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_y{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.c}.}\par
}
{\xe \v gop_local\:bugcheck.c}
{\xe \v bugcheck.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b gop.c}.}\par
}
{\xe \v isBugChecking\:bugcheck.c}
{\xe \v bugcheck.c\:isBugChecking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBugChecking{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b kernel.c}.}\par
}
{\xe \v lastfunc_history\:bugcheck.c}
{\xe \v bugcheck.c\:lastfunc_history}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LASTFUNC_HISTORY} lastfunc_history{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bugcheck.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.c}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Bugcheck functions implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "bugcheck.h"}\par
00008 {\cf21 #include "../trace.h"}\par
00009 \par
00010 {\cf21 #ifndef NOTHING}\par
00011 {\cf21 #define NOTHING}\par
00012 {\cf21 #endif}\par
00013 \par
00014 {\cf20 // We require GOP, so we extern it.}\par
00015 {\cf17 extern} GOP_PARAMS gop_local;\par
00016 {\cf17 extern} LASTFUNC_HISTORY lastfunc_history;\par
00017 {\cf17 extern} {\cf18 bool} isBugChecking;\par
00018 {\cf17 extern} CPU cpu;\par
00019 \par
00020 {\cf17 extern} uint32_t cursor_x;\par
00021 {\cf17 extern} uint32_t cursor_y;\par
00022 \par
00023 {\cf17 static} {\cf17 inline} {\cf18 bool} is_canonical_ptr(uint64_t x) \{\par
00024     {\cf20 // x86_64 canonical: bits 63..48 must be sign-extension of bit 47}\par
00025     uint64_t hi = x >> 47;\par
00026     {\cf19 return} (hi == 0 || hi == 0x1FFFF);\par
00027 \}\par
00028 \par
00029 {\cf17 static} {\cf18 void} print_stack_trace({\cf18 int} depth) \{\par
00030     {\cf19 return};\par
00031     uint64_t* rbp = (uint64_t*)__read_rbp();\par
00032     {\cf19 for} ({\cf18 int} i = 0; rbp != NULL && i < depth; ++i) \{\par
00033         {\cf19 if} (!MtIsAddressValid(({\cf18 void}*)rbp)) {\cf19 break};\par
00034         {\cf19 if} (!MtIsAddressValid(({\cf18 void}*)(rbp + 1))) {\cf19 break};\par
00035 \par
00036         uint64_t saved_ret = *(rbp + 1);\par
00037 \par
00038         {\cf20 /* Validate saved_ret before any symbolization/dereference */}\par
00039         {\cf19 if} (!is_canonical_ptr(saved_ret)) {\cf19 break};\par
00040         {\cf20 /* optional: ensure saved_ret is in known kernel text range if you have that info */}\par
00041         {\cf20 /* if (!address_in_kernel_text(saved_ret)) break; */}\par
00042 \par
00043         {\cf20 /* Print raw hex \'97 avoid any logger symbolization that may dereference */}\par
00044         gop_printf(COLOR_ORANGE, {\cf22 "frame %d rbp=%016llx ret=%016llx\\n"},\par
00045             i,\par
00046             ({\cf18 unsigned} {\cf18 long} {\cf18 long})(uintptr_t)rbp,\par
00047             ({\cf18 unsigned} {\cf18 long} {\cf18 long})saved_ret);\par
00048 \par
00049         uint64_t next_rbp_val = *rbp;\par
00050         {\cf19 if} (next_rbp_val == 0) {\cf19 break};\par
00051         {\cf19 if} (!is_canonical_ptr(next_rbp_val)) {\cf19 break};\par
00052 \par
00053         {\cf20 /* SANITY: next RBP should be at a *higher* address (older frame)}\par
00054 {\cf20            and not unreasonably far away. Enforce both direction and delta. */}\par
00055         uintptr_t cur = (uintptr_t)rbp;\par
00056         uintptr_t next = (uintptr_t)next_rbp_val;\par
00057         {\cf19 if} (next <= cur) {\cf19 break};\par
00058         {\cf19 if} (next - cur > (16 * 1024 * 1024)) {\cf19 break}; {\cf20 /* 16MB cap */}\par
00059 \par
00060         {\cf20 /* optional: require alignment */}\par
00061         {\cf19 if} (next & 0xF) {\cf19 break};\par
00062 \par
00063         rbp = (uint64_t*)(uintptr_t)next_rbp_val;\par
00064     \}\par
00065 \}\par
00066 \par
00067 \par
00068 {\cf17 static} {\cf18 void} print_lastfunc_chain(uint32_t color) \{\par
00069     {\cf20 // Start at the oldest entry: that's the slot `index` points to (next write).}\par
00070     {\cf18 int} idx = lastfunc_history.current_index;\par
00071 \par
00072     {\cf18 int} start = (idx + 1) % LASTFUNC_HISTORY_SIZE;\par
00073     {\cf18 bool} first = {\cf17 true};\par
00074     {\cf19 for} ({\cf18 int} i = 0; i < LASTFUNC_HISTORY_SIZE; i++) \{ {\cf20 // start from oldest to newest}\par
00075         idx = (start + i) % LASTFUNC_HISTORY_SIZE;\par
00076         {\cf18 char}* name = ({\cf18 char}*)lastfunc_history.names[idx];\par
00077         {\cf19 if} (!*name) {\cf19 break};\par
00078         {\cf19 if} (!first) \{\par
00079             gop_printf_forced(color, {\cf22 " -> "});\par
00080         \}\par
00081         gop_printf_forced(color, {\cf22 "%s"}, name);\par
00082         first = {\cf17 false};\par
00083     \}\par
00084 \}\par
00085 \par
00086 {\cf20 // switched to uint64_t and not BUGCHECK_CODES since the custom ones arent in that enum, and compiler throws an error.}\par
00087 {\cf17 static} {\cf18 void} resolveStopCode({\cf18 char}** s, uint64_t stopcode) \{\par
00088     {\cf19 switch} (stopcode) \{\par
00089     {\cf19 case} DIVIDE_BY_ZERO:\par
00090         *s = {\cf22 "DIVIDE_BY_ZERO"};\par
00091         {\cf19 break};\par
00092     {\cf19 case} SINGLE_STEP:\par
00093         *s = {\cf22 "SINGLE_STEP"};\par
00094         {\cf19 break};\par
00095     {\cf19 case} NON_MASKABLE_INTERRUPT:\par
00096         *s = {\cf22 "NON_MASKABLE_INTERRUPT"};\par
00097         {\cf19 break};\par
00098     {\cf19 case} BREAKPOINT:\par
00099         *s = {\cf22 "BREAKPOINT"};\par
00100         {\cf19 break};\par
00101     {\cf19 case} OVERFLOW:\par
00102         *s = {\cf22 "OVERFLOW"};\par
00103         {\cf19 break};\par
00104     {\cf19 case} BOUNDS_CHECK:\par
00105         *s = {\cf22 "BOUNDS_CHECK"};\par
00106         {\cf19 break};\par
00107     {\cf19 case} INVALID_OPCODE:\par
00108         *s = {\cf22 "INVALID_OPCODE"};\par
00109         {\cf19 break};\par
00110     {\cf19 case} NO_COPROCESSOR:\par
00111         *s = {\cf22 "NO_COPROCESSOR"};\par
00112         {\cf19 break};\par
00113     {\cf19 case} DOUBLE_FAULT:\par
00114         *s = {\cf22 "DOUBLE_FAULT"};\par
00115         {\cf19 break};\par
00116     {\cf19 case} COPROCESSOR_SEGMENT_OVERRUN:\par
00117         *s = {\cf22 "COPROCESSOR_SEGMENT_OVERRUN"};\par
00118         {\cf19 break};\par
00119     {\cf19 case} INVALID_TSS:\par
00120         *s = {\cf22 "INVALID_TSS"};\par
00121         {\cf19 break};\par
00122     {\cf19 case} SEGMENT_SELECTOR_NOTPRESENT:\par
00123         *s = {\cf22 "SEGMENT_SELECTOR_NOTPRESENT"};\par
00124         {\cf19 break};\par
00125     {\cf19 case} STACK_SEGMENT_OVERRUN:\par
00126         *s = {\cf22 "STACK_SEGMENT_OVERRUN"};\par
00127         {\cf19 break};\par
00128     {\cf19 case} GENERAL_PROTECTION_FAULT:\par
00129         *s = {\cf22 "GENERAL_PROTECTION_FAULT"};\par
00130         {\cf19 break};\par
00131     {\cf19 case} PAGE_FAULT:\par
00132         *s = {\cf22 "PAGE_FAULT"};\par
00133         {\cf19 break};\par
00134     {\cf19 case} RESERVED:\par
00135         *s = {\cf22 "RESERVED"};\par
00136         {\cf19 break};\par
00137     {\cf19 case} FLOATING_POINT_ERROR:\par
00138         *s = {\cf22 "FLOATING_POINT_ERROR"};\par
00139         {\cf19 break};\par
00140     {\cf19 case} ALIGNMENT_CHECK:\par
00141         *s = {\cf22 "ALIGNMENT_CHECK"};\par
00142         {\cf19 break};\par
00143     {\cf19 case} SEVERE_MACHINE_CHECK:\par
00144         *s = {\cf22 "SEVERE_MACHINE_CHECK"};\par
00145         {\cf19 break};\par
00146     {\cf19 case} MEMORY_MAP_SIZE_OVERRUN:\par
00147         *s = {\cf22 "MEMORY_MAP_SIZE_OVERRUN"};\par
00148         {\cf19 break};\par
00149     {\cf19 case} MANUALLY_INITIATED_CRASH:\par
00150         *s = {\cf22 "MANUALLY_INITIATED_CRASH"};\par
00151         {\cf19 break};\par
00152     {\cf19 case} BAD_PAGING:\par
00153         *s = {\cf22 "BAD_PAGING"};\par
00154         {\cf19 break};\par
00155     {\cf19 case} BLOCK_DEVICE_LIMIT_REACHED:\par
00156         *s = {\cf22 "BLOCK_DEVICE_LIMIT_REACHED"};\par
00157         {\cf19 break};\par
00158     {\cf19 case} NULL_POINTER_DEREFERENCE:\par
00159         *s = {\cf22 "NULL_POINTER_DEREFERENCE"};\par
00160         {\cf19 break};\par
00161     {\cf19 case} FILESYSTEM_PANIC:\par
00162         *s = {\cf22 "FILESYSTEM_PANIC"};\par
00163         {\cf19 break};\par
00164     {\cf19 case} UNABLE_TO_INIT_TRACELASTFUNC:\par
00165         *s = {\cf22 "UNABLE_TO_INIT_TRACELASTFUNC"};\par
00166         {\cf19 break};\par
00167     {\cf19 case} FRAME_LIMIT_REACHED:\par
00168         *s = {\cf22 "FRAME_LIMIT_REACHED"};\par
00169         {\cf19 break};\par
00170     {\cf19 case} IRQL_NOT_LESS_OR_EQUAL:\par
00171         *s = {\cf22 "IRQL_NOT_LESS_OR_EQUAL"};\par
00172         {\cf19 break};\par
00173     {\cf19 case} INVALID_IRQL_SUPPLIED:\par
00174         *s = {\cf22 "INVALID_IRQL_SUPPLIED"};\par
00175         {\cf19 break};\par
00176     {\cf19 case} NULL_CTX_RECEIVED:\par
00177         *s = {\cf22 "NULL_CTX_RECEIVED"};\par
00178         {\cf19 break};\par
00179     {\cf19 case} THREAD_EXIT_FAILURE:\par
00180         *s = {\cf22 "THREAD_EXIT_FAILURE"};\par
00181         {\cf19 break};\par
00182     {\cf19 case} BAD_AHCI_COUNT:\par
00183         *s = {\cf22 "BAD_AHCI_COUNT"};\par
00184         {\cf19 break};\par
00185     {\cf19 case} AHCI_INIT_FAILED:\par
00186         *s = {\cf22 "AHCI_INIT_FAILED"};\par
00187         {\cf19 break};\par
00188     {\cf19 case} MEMORY_LIMIT_REACHED:\par
00189         *s = {\cf22 "MEMORY_LIMIT_REACHED"};\par
00190         {\cf19 break};\par
00191     {\cf19 case} HEAP_ALLOCATION_FAILED:\par
00192         *s = {\cf22 "HEAP_ALLOCATION_FAILED"};\par
00193         {\cf19 break};\par
00194     {\cf19 case} NULL_THREAD:\par
00195         *s = {\cf22 "NULL_THREAD"};\par
00196         {\cf19 break};\par
00197     {\cf19 case} FATAL_IRQL_CORRUPTION:\par
00198         *s = {\cf22 "FATAL_IRQL_CORRUPTION"};\par
00199         {\cf19 break};\par
00200     {\cf19 case} THREAD_ID_CREATION_FAILURE:\par
00201         *s = {\cf22 "THREAD_ID_CREATION_FAILURE"};\par
00202         {\cf19 break};\par
00203     {\cf19 case} ASSERTION_FAILURE:\par
00204         *s = {\cf22 "ASSERTION_FAILURE"};\par
00205         {\cf19 break};\par
00206     {\cf19 default}:\par
00207         *s = {\cf22 "UNKNOWN_BUGCHECK_CODE"};\par
00208         {\cf19 break};\par
00209     \}\par
00210 \}\par
00211 \par
00212 __attribute__((noreturn))\par
00213 {\cf18 void} MtBugcheck(CTX_FRAME* context, INT_FRAME* int_frame, BUGCHECK_CODES err_code, uint32_t additional, {\cf18 bool} isAdditionals) \{\par
00214     {\cf20 // Critical system error, instead of triple faulting, we hang the system with specified error codes.}\par
00215     {\cf20 // Disable interrupts if they werent disabled before.}\par
00216     __cli();\par
00217     isBugChecking = {\cf17 true};\par
00218     {\cf18 bool} isThereIntFrame = (int_frame) ? {\cf17 true} : {\cf17 false}; {\cf20 // basic ternary}\par
00219 {\cf21 #ifdef DEBUG}\par
00220     IRQL recordedIrql = cpu.currentIrql;\par
00221 {\cf21 #endif}\par
00222     {\cf20 // Force to be redrawn from the top, instead of last place.}\par
00223     cursor_x = 0;\par
00224     cursor_y = 0;\par
00225     _MtSetIRQL(HIGH_LEVEL); {\cf20 // SET the irql to high level (not raise) (we could raise, but this takes less cycles and so is faster) (When I will integrate multi core functionality, this should SetIRQL to each cpu core.}\par
00226 \par
00227     {\cf20 // Clear the screen to blue (bsod windows style)}\par
00228     gop_clear_screen(&gop_local, 0xFF0035b8);\par
00229     {\cf20 // check if nullptr deref.}\par
00230     {\cf19 if} (err_code == PAGE_FAULT && isAdditionals && additional == 0) \{\par
00231         err_code = NULL_POINTER_DEREFERENCE;\par
00232     \}\par
00233     {\cf20 // Write some debugging and an error message}\par
00234     gop_printf_forced(0xFFFFFFFF, {\cf22 "FATAL ERROR: Your system has encountered a fatal error.\\n\\n"});\par
00235     gop_printf_forced(0xFFFFFFFF, {\cf22 "Your system has been stopped for safety.\\n\\n"});\par
00236     {\cf18 char}* stopCodeToStr = {\cf22 ""}; {\cf20 // empty at first.}\par
00237     resolveStopCode(&stopCodeToStr, err_code);\par
00238     uint64_t rspIfExist;\par
00239     {\cf19 if} (context) \{\par
00240         rspIfExist = (context->rsp) ? context->rsp : (uint64_t)(-1);\par
00241     \}\par
00242     gop_printf_forced(0xFFFFFFFF, {\cf22 "**STOP CODE: "});\par
00243     gop_printf_forced(0xFF8B0000, {\cf22 "%s"}, stopCodeToStr);\par
00244     gop_printf_forced(0xFF00FF00, {\cf22 " (numerical: %d)**"}, err_code);\par
00245     {\cf19 if} (context) \{\par
00246         gop_printf_forced(0xFFFFFFFF,\par
00247             {\cf22 "\\n\\nRegisters:\\n\\n"}\par
00248             {\cf22 "RAX: %p RBX: %p RCX: %p RDX: %p\\n\\n"}\par
00249             {\cf22 "RSI: %p RDI: %p RBP: %p RSP: %p\\n\\n"}\par
00250             {\cf22 "R8 : %p R9 : %p R10: %p R11: %p \\n\\n"}\par
00251             {\cf22 "R12: %p R13: %p R14: %p R15: %p\\n\\n\\n"},\par
00252             context->rax,\par
00253             context->rbx,\par
00254             context->rcx,\par
00255             context->rdx,\par
00256             context->rsi,\par
00257             context->rdi,\par
00258             context->rbp,\par
00259             rspIfExist,\par
00260             context->r8,\par
00261             context->r9,\par
00262             context->r10,\par
00263             context->r11,\par
00264             context->r12,\par
00265             context->r13,\par
00266             context->r14,\par
00267             context->r15\par
00268         );\par
00269     \}\par
00270     {\cf19 else} \{\par
00271         gop_printf_forced(0xFFFF0000, {\cf22 "\\n\\n\\n**ERROR: NO REGISTERS.**\\n"});\par
00272     \}\par
00273     {\cf20 // don't alert if there is no interrupt frame, the user shouldn't care and know. - i should do an IFDEF here for debug, but I could not remember that I didn't define, i'd rather keep it like this for now.}\par
00274     {\cf19 if} (isThereIntFrame) \{\par
00275         gop_printf_forced((uint32_t)-1,\par
00276             {\cf22 "Exceptions:\\n\\n"}\par
00277             {\cf22 "Vector Number: %d Error Code: %d\\n\\n"}\par
00278             {\cf22 "RIP: %p CS: %p RFLAGS: %b\\n"},\par
00279             int_frame->vector,\par
00280             int_frame->error_code,\par
00281             int_frame->rip,\par
00282             int_frame->cs,\par
00283             int_frame->rflags\par
00284         );\par
00285     \}\par
00286 {\cf21 #ifdef DEBUG}\par
00287     gop_printf_forced(0xFFFFA500, {\cf22 "**Last IRQL: %d**\\n"}, recordedIrql);\par
00288 {\cf21 #endif}\par
00289     {\cf19 if} (isAdditionals) \{\par
00290         {\cf19 if} (err_code == PAGE_FAULT) \{\par
00291             gop_printf_forced(0xFFFFA500, {\cf22 "\\n\\n**FAULTY ADDRESS: %p**\\n"}, additional);\par
00292         \}\par
00293         {\cf19 else} \{\par
00294             gop_printf_forced(0xFFBF40BF, {\cf22 "\\n\\n**ADDITIONALS: %p**\\n"}, additional);\par
00295         \}\par
00296     \}\par
00297 {\cf21 #ifdef DEBUG}\par
00298     uint32_t currTid = (cpu.currentThread) ? cpu.currentThread->TID : (uint32_t)-1;\par
00299     gop_printf_forced(0xFFFFFF00, {\cf22 "Current Thread ID: %d\\n"}, currTid);\par
00300 {\cf21 #endif}\par
00301 {\cf21 #ifdef DEBUG}\par
00302     {\cf19 if} (lastfunc_history.names[lastfunc_history.current_index][0] != {\cf23 '\\0'}) \{\par
00303         gop_printf_forced(0xFFBF40BF, {\cf22 "\\n**FUNCTION TRACE (oldest to newest): "});\par
00304         print_lastfunc_chain(0xFFBF40BF);\par
00305         gop_printf_forced(0xFFBF40BF, {\cf22 "**"});\par
00306     \}\par
00307 \par
00308     {\cf20 // call stack trace}\par
00309     gop_printf(COLOR_GREEN, {\cf22 "\\n\\nCall Stack Trace:\\n"});\par
00310     print_stack_trace(10); {\cf20 // 10 function calls;}\par
00311 {\cf21 #endif}\par
00312     {\cf20 //test}\par
00313     update_pic_mask_for_current_irql();\par
00314     __cli();\par
00315     {\cf20 // spin the CPU.}\par
00316     {\cf19 while} (1) \{\par
00317         NOTHING;\par
00318     \}\par
00319 \}\par
00320 \par
00321 \par
00322 {\cf18 void} MtBugcheckEx(CTX_FRAME* context, INT_FRAME* int_frame, BUGCHECK_CODES err_code, BUGCHECK_ADDITIONALS* additional, {\cf18 bool} isAdditionals) \{\par
00323     {\cf20 // Critical system error, instead of triple faulting, we hang the system with specified error codes.}\par
00324     {\cf20 // Disable interrupts if they werent disabled before.}\par
00325     __cli();\par
00326     isBugChecking = {\cf17 true};\par
00327     {\cf18 bool} isThereIntFrame = (int_frame) ? {\cf17 true} : {\cf17 false}; {\cf20 // basic ternary}\par
00328 {\cf21 #ifdef DEBUG}\par
00329     IRQL recordedIrql = cpu.currentIrql;\par
00330 {\cf21 #endif}\par
00331     {\cf20 // Force to be redrawn from the top, instead of last place.}\par
00332     cursor_x = 0;\par
00333     cursor_y = 0;\par
00334     _MtSetIRQL(HIGH_LEVEL); {\cf20 // SET the irql to high level (not raise) (we could raise, but this takes less cycles and so is faster) (When I will integrate multi core functionality, this should SetIRQL to each cpu core. TODO}\par
00335 \par
00336     {\cf20 // Clear the screen to blue (bsod windows style)}\par
00337     gop_clear_screen(&gop_local, 0xFF0035b8);\par
00338     {\cf20 // Write some debugging and an error message}\par
00339     gop_printf_forced(0xFFFFFFFF, {\cf22 "FATAL ERROR: Your system has encountered a fatal error.\\n\\n"});\par
00340     gop_printf_forced(0xFFFFFFFF, {\cf22 "Your system has been stopped for safety.\\n\\n"});\par
00341     {\cf18 char}* stopCodeToStr = {\cf22 ""}; {\cf20 // empty at first.}\par
00342     resolveStopCode(&stopCodeToStr, err_code);\par
00343     uint64_t rspIfExist;\par
00344     {\cf19 if} (context) \{\par
00345         rspIfExist = (context->rsp) ? context->rsp : (uint64_t)(-1);\par
00346     \}\par
00347     gop_printf_forced(0xFFFFFFFF, {\cf22 "**STOP CODE: "});\par
00348     gop_printf_forced(0xFF8B0000, {\cf22 "%s"}, stopCodeToStr);\par
00349     gop_printf_forced(0xFF00FF00, {\cf22 " (numerical: %d)**"}, err_code);\par
00350     {\cf19 if} (context) \{\par
00351         gop_printf_forced(0xFFFFFFFF,\par
00352             {\cf22 "\\n\\nRegisters:\\n\\n"}\par
00353             {\cf22 "RAX: %p RBX: %p RCX: %p RDX: %p\\n\\n"}\par
00354             {\cf22 "RSI: %p RDI: %p RBP: %p RSP: %p\\n\\n"}\par
00355             {\cf22 "R8 : %p R9 : %p R10: %p R11: %p \\n\\n"}\par
00356             {\cf22 "R12: %p R13: %p R14: %p R15: %p\\n\\n\\n"},\par
00357             context->rax,\par
00358             context->rbx,\par
00359             context->rcx,\par
00360             context->rdx,\par
00361             context->rsi,\par
00362             context->rdi,\par
00363             context->rbp,\par
00364             rspIfExist,\par
00365             context->r8,\par
00366             context->r9,\par
00367             context->r10,\par
00368             context->r11,\par
00369             context->r12,\par
00370             context->r13,\par
00371             context->r14,\par
00372             context->r15\par
00373         );\par
00374     \}\par
00375     {\cf19 else} \{\par
00376         gop_printf_forced(0xFFFF0000, {\cf22 "\\n\\n\\n**ERROR: NO REGISTERS.**\\n"});\par
00377     \}\par
00378     {\cf20 // don't alert if there is no interrupt frame, the user shouldn't care and know. - i should do an IFDEF here for debug, but I could not remember that I didn't define, i'd rather keep it like this for now.}\par
00379     {\cf19 if} (isThereIntFrame) \{\par
00380         gop_printf_forced((uint32_t)-1,\par
00381             {\cf22 "Exceptions:\\n\\n"}\par
00382             {\cf22 "Vector Number: %d Error Code: %p\\n\\n"}\par
00383             {\cf22 "RIP: %p CS: %p RFLAGS: %b\\n"},\par
00384             int_frame->vector,\par
00385             int_frame->error_code,\par
00386             int_frame->rip,\par
00387             int_frame->cs,\par
00388             int_frame->rflags\par
00389         );\par
00390     \}\par
00391 {\cf21 #ifdef DEBUG}\par
00392     gop_printf_forced(0xFFFFA500, {\cf22 "**Last IRQL: %d**\\n"}, recordedIrql);\par
00393 {\cf21 #endif}\par
00394 {\cf21 #ifdef DEBUG}\par
00395     int32_t currTid = (cpu.currentThread) ? cpu.currentThread->TID : (uint32_t)-1;\par
00396     gop_printf_forced(0xFFFFFF00, {\cf22 "Current Thread ID: %d\\n"}, currTid);\par
00397 {\cf21 #endif}\par
00398     {\cf19 if} (isAdditionals) \{\par
00399         {\cf19 if} (additional->boolean) \{\par
00400             gop_printf_forced(COLOR_RED, {\cf22 "**BOOLEAN ADDITIONAL: %d**\\n"}, additional->boolean);\par
00401         \}\par
00402         {\cf19 if} (additional->num) \{\par
00403             gop_printf_forced(COLOR_RED, {\cf22 "**UNSIGNED NUMBER ADDITIONAL: %d**\\n"}, additional->num);\par
00404         \}\par
00405         {\cf19 if} (additional->ptr) \{\par
00406             gop_printf_forced(COLOR_RED, {\cf22 "**POINTER ADDITIONAL: %p**\\n"}, additional->ptr);\par
00407         \}\par
00408         {\cf19 if} (additional->signednum) \{\par
00409             gop_printf_forced(COLOR_RED, {\cf22 "**SIGNED NUMBER ADDITIONAL: %d**\\n"}, additional->signednum);\par
00410         \}\par
00411         {\cf19 if} (additional->str) \{\par
00412             gop_printf_forced(COLOR_RED, {\cf22 "**STRING ADDITIONAL: %s**\\n"}, additional->str);\par
00413         \}\par
00414     \}\par
00415 \par
00416 {\cf21 #ifdef DEBUG}\par
00417     {\cf19 if} (lastfunc_history.names[lastfunc_history.current_index][0] != {\cf23 '\\0'}) \{\par
00418         gop_printf_forced(0xFFBF40BF, {\cf22 "\\n\\n**FUNCTION TRACE (oldest to newest): "});\par
00419         print_lastfunc_chain(0xFFBF40BF);\par
00420         gop_printf_forced(0xFFBF40BF, {\cf22 "**"});\par
00421     \}\par
00422 \par
00423 \par
00424     {\cf20 // call stack trace}\par
00425     gop_printf(COLOR_GREEN, {\cf22 "\\n\\nCall Stack Trace:\\n"});\par
00426     print_stack_trace(10); {\cf20 // 10 function calls;}\par
00427 {\cf21 #endif}\par
00428     {\cf20 //test}\par
00429     update_pic_mask_for_current_irql();\par
00430     __cli();\par
00431     {\cf20 // spin the CPU.}\par
00432     {\cf19 while} (1) \{\par
00433         NOTHING;\par
00434     \}\par
00435 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.h}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../cpu/irql/irql.h"}\par
{\f2 #include "../drivers/gop/gop.h"}\par
{\f2 #include "../trace.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BUGCHECK_ADDITIONALS}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _BUGCHECK_CODES} {\b BUGCHECK_CODES}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BUGCHECK_ADDITIONALS} {\b BUGCHECK_ADDITIONALS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _BUGCHECK_CODES} \{ {\b DIVIDE_BY_ZERO}
, {\b SINGLE_STEP}
, {\b NON_MASKABLE_INTERRUPT}
, {\b BREAKPOINT}
, {\b OVERFLOW}
, {\b BOUNDS_CHECK}
, {\b INVALID_OPCODE}
, {\b NO_COPROCESSOR}
, {\b DOUBLE_FAULT}
, {\b COPROCESSOR_SEGMENT_OVERRUN}
, {\b INVALID_TSS}
, {\b SEGMENT_SELECTOR_NOTPRESENT}
, {\b STACK_SEGMENT_OVERRUN}
, {\b GENERAL_PROTECTION_FAULT}
, {\b PAGE_FAULT}
, {\b RESERVED}
, {\b FLOATING_POINT_ERROR}
, {\b ALIGNMENT_CHECK}
, {\b SEVERE_MACHINE_CHECK}
, {\b MEMORY_MAP_SIZE_OVERRUN} = 0xBEEF
, {\b MANUALLY_INITIATED_CRASH} = 0xBABE
, {\b BAD_PAGING} = 0xBAD
, {\b BLOCK_DEVICE_LIMIT_REACHED} = 0x420
, {\b NULL_POINTER_DEREFERENCE} = 0xDEAD
, {\b FILESYSTEM_PANIC} = 0xFA11
, {\b UNABLE_TO_INIT_TRACELASTFUNC} = 0xACE
, {\b FRAME_LIMIT_REACHED} = 0xBADA55
, {\b IRQL_NOT_LESS_OR_EQUAL} = 0x1337
, {\b INVALID_IRQL_SUPPLIED} = 0x69420
, {\b NULL_CTX_RECEIVED} = 0xF1FA
, {\b THREAD_EXIT_FAILURE} = 0x123123FF
, {\b BAD_AHCI_COUNT}
, {\b AHCI_INIT_FAILED}
, {\b MEMORY_LIMIT_REACHED}
, {\b HEAP_ALLOCATION_FAILED}
, {\b NULL_THREAD}
, {\b FATAL_IRQL_CORRUPTION}
, {\b THREAD_ID_CREATION_FAILURE}
, {\b FRAME_ALLOCATION_FAILED}
, {\b FRAME_BITMAP_CREATION_FAILURE}
, {\b ASSERTION_FAILURE}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((noreturn)) void MtBugcheck({\b CTX_FRAME} *context\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INT_FRAME} * {\b int_frame}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INT_FRAME} {\b BUGCHECK_CODES} {\b err_code}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INT_FRAME} {\b BUGCHECK_CODES} uint32_t {\b additional}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INT_FRAME} {\b BUGCHECK_CODES} uint32_t bool {\b isAdditionals}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BUGCHECK_ADDITIONALS\:bugcheck.h}
{\xe \v bugcheck.h\:BUGCHECK_ADDITIONALS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BUGCHECK_ADDITIONALS} {\b BUGCHECK_ADDITIONALS}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v BUGCHECK_CODES\:bugcheck.h}
{\xe \v bugcheck.h\:BUGCHECK_CODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _BUGCHECK_CODES} {\b BUGCHECK_CODES}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _BUGCHECK_CODES\:bugcheck.h}
{\xe \v bugcheck.h\:_BUGCHECK_CODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _BUGCHECK_CODES}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DIVIDE_BY_ZERO\:bugcheck.h}
{\xe \v bugcheck.h\:DIVIDE_BY_ZERO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIVIDE_BY_ZERO{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\cell }{\cell }{\row }
{\xe \v SINGLE_STEP\:bugcheck.h}
{\xe \v bugcheck.h\:SINGLE_STEP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SINGLE_STEP{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\cell }{\cell }{\row }
{\xe \v NON_MASKABLE_INTERRUPT\:bugcheck.h}
{\xe \v bugcheck.h\:NON_MASKABLE_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NON_MASKABLE_INTERRUPT{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
\cell }{\cell }{\row }
{\xe \v BREAKPOINT\:bugcheck.h}
{\xe \v bugcheck.h\:BREAKPOINT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BREAKPOINT{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\cell }{\cell }{\row }
{\xe \v OVERFLOW\:bugcheck.h}
{\xe \v bugcheck.h\:OVERFLOW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid OVERFLOW{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\cell }{\cell }{\row }
{\xe \v BOUNDS_CHECK\:bugcheck.h}
{\xe \v bugcheck.h\:BOUNDS_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BOUNDS_CHECK{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
\cell }{\cell }{\row }
{\xe \v INVALID_OPCODE\:bugcheck.h}
{\xe \v bugcheck.h\:INVALID_OPCODE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_OPCODE{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
\cell }{\cell }{\row }
{\xe \v NO_COPROCESSOR\:bugcheck.h}
{\xe \v bugcheck.h\:NO_COPROCESSOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NO_COPROCESSOR{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\cell }{\cell }{\row }
{\xe \v DOUBLE_FAULT\:bugcheck.h}
{\xe \v bugcheck.h\:DOUBLE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DOUBLE_FAULT{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
\cell }{\cell }{\row }
{\xe \v COPROCESSOR_SEGMENT_OVERRUN\:bugcheck.h}
{\xe \v bugcheck.h\:COPROCESSOR_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid COPROCESSOR_SEGMENT_OVERRUN{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
\cell }{\cell }{\row }
{\xe \v INVALID_TSS\:bugcheck.h}
{\xe \v bugcheck.h\:INVALID_TSS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_TSS{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
\cell }{\cell }{\row }
{\xe \v SEGMENT_SELECTOR_NOTPRESENT\:bugcheck.h}
{\xe \v bugcheck.h\:SEGMENT_SELECTOR_NOTPRESENT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SEGMENT_SELECTOR_NOTPRESENT{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
\cell }{\cell }{\row }
{\xe \v STACK_SEGMENT_OVERRUN\:bugcheck.h}
{\xe \v bugcheck.h\:STACK_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid STACK_SEGMENT_OVERRUN{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
\cell }{\cell }{\row }
{\xe \v GENERAL_PROTECTION_FAULT\:bugcheck.h}
{\xe \v bugcheck.h\:GENERAL_PROTECTION_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid GENERAL_PROTECTION_FAULT{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\cell }{\cell }{\row }
{\xe \v PAGE_FAULT\:bugcheck.h}
{\xe \v bugcheck.h\:PAGE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_FAULT{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\cell }{\cell }{\row }
{\xe \v RESERVED\:bugcheck.h}
{\xe \v bugcheck.h\:RESERVED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid RESERVED{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\cell }{\cell }{\row }
{\xe \v FLOATING_POINT_ERROR\:bugcheck.h}
{\xe \v bugcheck.h\:FLOATING_POINT_ERROR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FLOATING_POINT_ERROR{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
\cell }{\cell }{\row }
{\xe \v ALIGNMENT_CHECK\:bugcheck.h}
{\xe \v bugcheck.h\:ALIGNMENT_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ALIGNMENT_CHECK{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\cell }{\cell }{\row }
{\xe \v SEVERE_MACHINE_CHECK\:bugcheck.h}
{\xe \v bugcheck.h\:SEVERE_MACHINE_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SEVERE_MACHINE_CHECK{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
\cell }{\cell }{\row }
{\xe \v MEMORY_MAP_SIZE_OVERRUN\:bugcheck.h}
{\xe \v bugcheck.h\:MEMORY_MAP_SIZE_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_MAP_SIZE_OVERRUN{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Custom ones. \par
}\cell }{\row }
{\xe \v MANUALLY_INITIATED_CRASH\:bugcheck.h}
{\xe \v bugcheck.h\:MANUALLY_INITIATED_CRASH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MANUALLY_INITIATED_CRASH{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
\cell }{\cell }{\row }
{\xe \v BAD_PAGING\:bugcheck.h}
{\xe \v bugcheck.h\:BAD_PAGING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BAD_PAGING{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\cell }{\cell }{\row }
{\xe \v BLOCK_DEVICE_LIMIT_REACHED\:bugcheck.h}
{\xe \v bugcheck.h\:BLOCK_DEVICE_LIMIT_REACHED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BLOCK_DEVICE_LIMIT_REACHED{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
\cell }{\cell }{\row }
{\xe \v NULL_POINTER_DEREFERENCE\:bugcheck.h}
{\xe \v bugcheck.h\:NULL_POINTER_DEREFERENCE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NULL_POINTER_DEREFERENCE{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\cell }{\cell }{\row }
{\xe \v FILESYSTEM_PANIC\:bugcheck.h}
{\xe \v bugcheck.h\:FILESYSTEM_PANIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FILESYSTEM_PANIC{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
\cell }{\cell }{\row }
{\xe \v UNABLE_TO_INIT_TRACELASTFUNC\:bugcheck.h}
{\xe \v bugcheck.h\:UNABLE_TO_INIT_TRACELASTFUNC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid UNABLE_TO_INIT_TRACELASTFUNC{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\cell }{\cell }{\row }
{\xe \v FRAME_LIMIT_REACHED\:bugcheck.h}
{\xe \v bugcheck.h\:FRAME_LIMIT_REACHED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FRAME_LIMIT_REACHED{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
\cell }{\cell }{\row }
{\xe \v IRQL_NOT_LESS_OR_EQUAL\:bugcheck.h}
{\xe \v bugcheck.h\:IRQL_NOT_LESS_OR_EQUAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQL_NOT_LESS_OR_EQUAL{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\cell }{\cell }{\row }
{\xe \v INVALID_IRQL_SUPPLIED\:bugcheck.h}
{\xe \v bugcheck.h\:INVALID_IRQL_SUPPLIED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_IRQL_SUPPLIED{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
\cell }{\cell }{\row }
{\xe \v NULL_CTX_RECEIVED\:bugcheck.h}
{\xe \v bugcheck.h\:NULL_CTX_RECEIVED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NULL_CTX_RECEIVED{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\cell }{\cell }{\row }
{\xe \v THREAD_EXIT_FAILURE\:bugcheck.h}
{\xe \v bugcheck.h\:THREAD_EXIT_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_EXIT_FAILURE{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\cell }{\cell }{\row }
{\xe \v BAD_AHCI_COUNT\:bugcheck.h}
{\xe \v bugcheck.h\:BAD_AHCI_COUNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BAD_AHCI_COUNT{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\cell }{\cell }{\row }
{\xe \v AHCI_INIT_FAILED\:bugcheck.h}
{\xe \v bugcheck.h\:AHCI_INIT_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid AHCI_INIT_FAILED{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\cell }{\cell }{\row }
{\xe \v MEMORY_LIMIT_REACHED\:bugcheck.h}
{\xe \v bugcheck.h\:MEMORY_LIMIT_REACHED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_LIMIT_REACHED{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
\cell }{\cell }{\row }
{\xe \v HEAP_ALLOCATION_FAILED\:bugcheck.h}
{\xe \v bugcheck.h\:HEAP_ALLOCATION_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HEAP_ALLOCATION_FAILED{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
\cell }{\cell }{\row }
{\xe \v NULL_THREAD\:bugcheck.h}
{\xe \v bugcheck.h\:NULL_THREAD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NULL_THREAD{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
\cell }{\cell }{\row }
{\xe \v FATAL_IRQL_CORRUPTION\:bugcheck.h}
{\xe \v bugcheck.h\:FATAL_IRQL_CORRUPTION}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FATAL_IRQL_CORRUPTION{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\cell }{\cell }{\row }
{\xe \v THREAD_ID_CREATION_FAILURE\:bugcheck.h}
{\xe \v bugcheck.h\:THREAD_ID_CREATION_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_ID_CREATION_FAILURE{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
\cell }{\cell }{\row }
{\xe \v FRAME_ALLOCATION_FAILED\:bugcheck.h}
{\xe \v bugcheck.h\:FRAME_ALLOCATION_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FRAME_ALLOCATION_FAILED{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
\cell }{\cell }{\row }
{\xe \v FRAME_BITMAP_CREATION_FAILURE\:bugcheck.h}
{\xe \v bugcheck.h\:FRAME_BITMAP_CREATION_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FRAME_BITMAP_CREATION_FAILURE{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\cell }{\cell }{\row }
{\xe \v ASSERTION_FAILURE\:bugcheck.h}
{\xe \v bugcheck.h\:ASSERTION_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ASSERTION_FAILURE{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 17} of file {\b bugcheck.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:bugcheck.h}
{\xe \v bugcheck.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((noreturn) )}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v additional\:bugcheck.h}
{\xe \v bugcheck.h\:additional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b INT_FRAME} {\b BUGCHECK_CODES} {\b BUGCHECK_ADDITIONALS} * additional}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b bugcheck.h}.}\par
}
{\xe \v err_code\:bugcheck.h}
{\xe \v bugcheck.h\:err_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b INT_FRAME} {\b BUGCHECK_CODES} err_code}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b bugcheck.h}.}\par
}
{\xe \v int_frame\:bugcheck.h}
{\xe \v bugcheck.h\:int_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b INT_FRAME} * int_frame}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b bugcheck.h}.}\par
}
{\xe \v isAdditionals\:bugcheck.h}
{\xe \v bugcheck.h\:isAdditionals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b INT_FRAME} {\b BUGCHECK_CODES} {\b BUGCHECK_ADDITIONALS} bool isAdditionals}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b bugcheck.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bugcheck.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/bugcheck/bugcheck.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Bugcheck function headers and additionals.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_BUGCHECK_H}\par
00007 {\cf21 #define X86_BUGCHECK_H}\par
00008  {\cf20 // Standard headers, required.}\par
00009 {\cf21 #include <stddef.h>}\par
00010 {\cf21 #include <stdbool.h>}\par
00011 {\cf21 #include <stdint.h>}\par
00012 {\cf21 #include "../cpu/irql/irql.h"}\par
00013 {\cf21 #include "../drivers/gop/gop.h"}\par
00014 {\cf21 #include "../trace.h"}\par
00015 \par
00016 {\cf20 // Bugcheck error code enums, use same exception list from CPU.}\par
00017 {\cf17 typedef} {\cf17 enum} _BUGCHECK_CODES \{\par
00018     DIVIDE_BY_ZERO,\par
00019     SINGLE_STEP,\par
00020     NON_MASKABLE_INTERRUPT,\par
00021     BREAKPOINT,\par
00022     OVERFLOW,\par
00023     BOUNDS_CHECK,\par
00024     INVALID_OPCODE,\par
00025     NO_COPROCESSOR,\par
00026     DOUBLE_FAULT,\par
00027     COPROCESSOR_SEGMENT_OVERRUN,\par
00028     INVALID_TSS,\par
00029     SEGMENT_SELECTOR_NOTPRESENT,\par
00030     STACK_SEGMENT_OVERRUN,\par
00031     GENERAL_PROTECTION_FAULT,\par
00032     PAGE_FAULT,\par
00033     RESERVED,\par
00034     FLOATING_POINT_ERROR,\par
00035     ALIGNMENT_CHECK,\par
00036     SEVERE_MACHINE_CHECK,\par
00038     MEMORY_MAP_SIZE_OVERRUN = 0xBEEF, {\cf20 // The memory map has grown beyond the limit (unused).}\par
00039     MANUALLY_INITIATED_CRASH = 0xBABE, {\cf20 // A function has manually initiated a bugcheck for testing/unknown reasons with this specific code.}\par
00040     BAD_PAGING = 0xBAD, {\cf20 // Unused...}\par
00041     BLOCK_DEVICE_LIMIT_REACHED = 0x420, {\cf20 // 1056 - Something tried to register a block device, but the limit has been reached, bugcheck system.}\par
00042     NULL_POINTER_DEREFERENCE = 0xDEAD, {\cf20 // Attempted dereference of a null pointer.}\par
00043     FILESYSTEM_PANIC = 0xFA11, {\cf20 // FileSystem PANIC, usually something wrong has happened}\par
00044     UNABLE_TO_INIT_TRACELASTFUNC = 0xACE, {\cf20 // TraceLastFunc init failed in kernel_main}\par
00045     FRAME_LIMIT_REACHED = 0xBADA55, {\cf20 // frame limit reached when trying to allocate a physical frame.}\par
00046     IRQL_NOT_LESS_OR_EQUAL = 0x1337, {\cf20 // Access to functions while going over the max IRQL set for them. Or raising to lower \\ lowering to higher IRQL than current IRQL.}\par
00047     INVALID_IRQL_SUPPLIED = 0x69420, {\cf20 // Invalid IRQL supplied to raising / lowering IRQL.}\par
00048     NULL_CTX_RECEIVED = 0xF1FA, {\cf20 // A null context frame has been received to a function.}\par
00049     THREAD_EXIT_FAILURE = 0x123123FF, {\cf20 // A thread exitted but did not schedule (somehow).}\par
00050     BAD_AHCI_COUNT, {\cf20 // AHCI Count has went over the required limit}\par
00051     AHCI_INIT_FAILED, {\cf20 // Initialization of AHCI has failed..}\par
00052     MEMORY_LIMIT_REACHED, {\cf20 // The amount of physical memory has reached its maximum, allocation has failed.}\par
00053     HEAP_ALLOCATION_FAILED, {\cf20 // Allocating from the HEAP failed for an unknown reason.}\par
00054     NULL_THREAD, {\cf20 // A thread given to the scheduler is NULL.}\par
00055     FATAL_IRQL_CORRUPTION, {\cf20 // IRQL Has been corrupted, somehow. Probably a buffer overflow.}\par
00056     THREAD_ID_CREATION_FAILURE, {\cf20 // Creation of a TID (Thread ID) has failed due to reaching maximum TIDs in use by the system.}\par
00057     FRAME_ALLOCATION_FAILED, {\cf20 // Allocating a physical frame from the frame bitmap has failed.}\par
00058     FRAME_BITMAP_CREATION_FAILURE, {\cf20 // Creating the frame bitmap resulted in a failure.}\par
00059     ASSERTION_FAILURE, {\cf20 // Runtime Assertion Failure (assert())}\par
00060 \} BUGCHECK_CODES;\par
00061 \par
00062 {\cf17 typedef} {\cf17 struct }_BUGCHECK_ADDITIONALS \{\par
00063     {\cf20 // A String (NO NEED FOR NEWLINE CHAR)}\par
00064     {\cf18 char} str[512];\par
00065     {\cf20 // A Number (UNSIGNED)}\par
00066     uint64_t num;\par
00067     {\cf20 // A Number (SIGNED)}\par
00068     int64_t signednum;\par
00069     {\cf20 // A Boolean}\par
00070     {\cf18 bool} boolean;\par
00071     {\cf20 // A general pointer.}\par
00072     {\cf18 void}* ptr;\par
00073 \} BUGCHECK_ADDITIONALS;\par
00074 \par
00075 {\cf20 // Function to initiate bugcheck.}\par
00076 __attribute__((noreturn))\par
00077 void MtBugcheck(CTX_FRAME* context, INT_FRAME* int_frame, BUGCHECK_CODES err_code, uint32_t additional, {\cf18 bool} isAdditionals);\par
00078 \par
00079 {\cf20 // Function to initiate bugcheck + Revised additionals}\par
00080 __attribute__((noreturn))\par
00081 {\cf18 void} MtBugcheckEx(CTX_FRAME* context, INT_FRAME* int_frame, BUGCHECK_CODES err_code, BUGCHECK_ADDITIONALS* additional, {\cf18 bool} isAdditionals);\par
00082 \par
00083 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.c}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "apic.h"}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../memory/paging/paging.h"}\par
{\f2 #include "../../memory/allocator/allocator.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IA32_APIC_BASE_MSR}\~ 0x1BULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APIC_BASE_RESERVED}\~ 0xFFF0000000000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_PAGE_SIZE}\~ 0x1000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_MAP_FLAGS}\~ ({\b PAGE_PRESENT} | {\b PAGE_RW} | {\b PAGE_PCD})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_DEFAULT_PADDR}\~ 0xFEE00000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APIC_LVT_TIMER_PERIODIC}\~ (1U << 17)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APIC_TIMER_MASKED}\~ (1U << 16)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b LAPIC_ID} = 0x020
, {\b LAPIC_VERSION} = 0x030
, {\b LAPIC_TPR} = 0x080
, {\b LAPIC_EOI} = 0x0B0
, {\b LAPIC_SVR} = 0x0F0
, {\b LAPIC_ESR} = 0x280
, {\b LAPIC_ICR_LOW} = 0x300
, {\b LAPIC_ICR_HIGH} = 0x310
, {\b LAPIC_LVT_TIMER} = 0x320
, {\b LAPIC_LVT_THERMAL} = 0x330
, {\b LAPIC_LVT_PCC} = 0x340
, {\b LAPIC_LVT_LINT0} = 0x350
, {\b LAPIC_LVT_LINT1} = 0x360
, {\b LAPIC_LVT_ERROR} = 0x370
, {\b LAPIC_TIMER_INITCNT} = 0x380
, {\b LAPIC_TIMER_CURRCNT} = 0x390
, {\b LAPIC_TIMER_DIV} = 0x3E0
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_enable} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_init_bsp} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_send_ipi} (uint8_t apic_id, uint8_t vector, uint32_t flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b init_lapic_timer} (uint32_t hz)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v APIC_BASE_RESERVED\:apic.c}
{\xe \v apic.c\:APIC_BASE_RESERVED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APIC_BASE_RESERVED\~ 0xFFF0000000000000ULL}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b apic.c}.}\par
}
{\xe \v APIC_LVT_TIMER_PERIODIC\:apic.c}
{\xe \v apic.c\:APIC_LVT_TIMER_PERIODIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APIC_LVT_TIMER_PERIODIC\~ (1U << 17)}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b apic.c}.}\par
}
{\xe \v APIC_TIMER_MASKED\:apic.c}
{\xe \v apic.c\:APIC_TIMER_MASKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APIC_TIMER_MASKED\~ (1U << 16)}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b apic.c}.}\par
}
{\xe \v IA32_APIC_BASE_MSR\:apic.c}
{\xe \v apic.c\:IA32_APIC_BASE_MSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IA32_APIC_BASE_MSR\~ 0x1BULL}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b apic.c}.}\par
}
{\xe \v LAPIC_DEFAULT_PADDR\:apic.c}
{\xe \v apic.c\:LAPIC_DEFAULT_PADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_DEFAULT_PADDR\~ 0xFEE00000ULL}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b apic.c}.}\par
}
{\xe \v LAPIC_MAP_FLAGS\:apic.c}
{\xe \v apic.c\:LAPIC_MAP_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_MAP_FLAGS\~ ({\b PAGE_PRESENT} | {\b PAGE_RW} | {\b PAGE_PCD})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b apic.c}.}\par
}
{\xe \v LAPIC_PAGE_SIZE\:apic.c}
{\xe \v apic.c\:LAPIC_PAGE_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_PAGE_SIZE\~ 0x1000}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b apic.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LAPIC_ID\:apic.c}
{\xe \v apic.c\:LAPIC_ID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ID{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
\cell }{\cell }{\row }
{\xe \v LAPIC_VERSION\:apic.c}
{\xe \v apic.c\:LAPIC_VERSION}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_VERSION{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
\cell }{\cell }{\row }
{\xe \v LAPIC_TPR\:apic.c}
{\xe \v apic.c\:LAPIC_TPR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TPR{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
\cell }{\cell }{\row }
{\xe \v LAPIC_EOI\:apic.c}
{\xe \v apic.c\:LAPIC_EOI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_EOI{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
\cell }{\cell }{\row }
{\xe \v LAPIC_SVR\:apic.c}
{\xe \v apic.c\:LAPIC_SVR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_SVR{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\cell }{\cell }{\row }
{\xe \v LAPIC_ESR\:apic.c}
{\xe \v apic.c\:LAPIC_ESR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ESR{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
\cell }{\cell }{\row }
{\xe \v LAPIC_ICR_LOW\:apic.c}
{\xe \v apic.c\:LAPIC_ICR_LOW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ICR_LOW{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
\cell }{\cell }{\row }
{\xe \v LAPIC_ICR_HIGH\:apic.c}
{\xe \v apic.c\:LAPIC_ICR_HIGH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ICR_HIGH{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_TIMER\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_TIMER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_TIMER{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_THERMAL\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_THERMAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_THERMAL{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_PCC\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_PCC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_PCC{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_LINT0\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_LINT0}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_LINT0{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_LINT1\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_LINT1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_LINT1{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_ERROR\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_ERROR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_ERROR{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
\cell }{\cell }{\row }
{\xe \v LAPIC_TIMER_INITCNT\:apic.c}
{\xe \v apic.c\:LAPIC_TIMER_INITCNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TIMER_INITCNT{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
\cell }{\cell }{\row }
{\xe \v LAPIC_TIMER_CURRCNT\:apic.c}
{\xe \v apic.c\:LAPIC_TIMER_CURRCNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TIMER_CURRCNT{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
\cell }{\cell }{\row }
{\xe \v LAPIC_TIMER_DIV\:apic.c}
{\xe \v apic.c\:LAPIC_TIMER_DIV}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TIMER_DIV{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 15} of file {\b apic.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_lapic_timer\:apic.c}
{\xe \v apic.c\:init_lapic_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int init_lapic_timer (uint32_t hz)}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b apic.c}.}\par
}
{\xe \v lapic_enable\:apic.c}
{\xe \v apic.c\:lapic_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_enable (void )}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b apic.c}.}\par
}
{\xe \v lapic_eoi\:apic.c}
{\xe \v apic.c\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void )}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b apic.c}.}\par
}
{\xe \v lapic_init_bsp\:apic.c}
{\xe \v apic.c\:lapic_init_bsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_init_bsp (void )}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b apic.c}.}\par
}
{\xe \v lapic_send_ipi\:apic.c}
{\xe \v apic.c\:lapic_send_ipi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_send_ipi (uint8_t apic_id, uint8_t vector, uint32_t flags)}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b apic.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
apic.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.c}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "apic.h"}\par
00002 {\cf21 #include <stddef.h>}\par
00003 {\cf21 #include <stdint.h>}\par
00004 {\cf21 #include "../../memory/paging/paging.h"}\par
00005 {\cf21 #include "../../memory/allocator/allocator.h"}\par
00006 \par
00007 {\cf21 #define IA32_APIC_BASE_MSR     0x1BULL}\par
00008 {\cf21 #define APIC_BASE_RESERVED     0xFFF0000000000000ULL}\par
00009 \par
00010 {\cf21 #define LAPIC_PAGE_SIZE    0x1000}\par
00011 {\cf20 // page flags - adapt names to your kernel constants:}\par
00012 {\cf21 #define LAPIC_MAP_FLAGS (PAGE_PRESENT | PAGE_RW | PAGE_PCD)}\par
00013 \par
00014 {\cf20 // LAPIC register offsets (32-bit registers)}\par
00015 {\cf17 enum} \{\par
00016     LAPIC_ID = 0x020,\par
00017     LAPIC_VERSION = 0x030,\par
00018     LAPIC_TPR = 0x080,\par
00019     LAPIC_EOI = 0x0B0,\par
00020     LAPIC_SVR = 0x0F0,\par
00021     LAPIC_ESR = 0x280,\par
00022     LAPIC_ICR_LOW = 0x300,\par
00023     LAPIC_ICR_HIGH = 0x310,\par
00024     LAPIC_LVT_TIMER = 0x320,\par
00025     LAPIC_LVT_THERMAL = 0x330,\par
00026     LAPIC_LVT_PCC = 0x340,\par
00027     LAPIC_LVT_LINT0 = 0x350,\par
00028     LAPIC_LVT_LINT1 = 0x360,\par
00029     LAPIC_LVT_ERROR = 0x370,\par
00030     LAPIC_TIMER_INITCNT = 0x380,\par
00031     LAPIC_TIMER_CURRCNT = 0x390,\par
00032     LAPIC_TIMER_DIV = 0x3E0\par
00033 \};\par
00034 \par
00035 \par
00036 {\cf21 #define LAPIC_DEFAULT_PADDR    0xFEE00000ULL}\par
00037 {\cf17 static} {\cf17 volatile} uint32_t* lapic = NULL;\par
00038 {\cf17 static} uint64_t lapic_phys = LAPIC_DEFAULT_PADDR;\par
00039 \par
00040 {\cf20 // --- low-level mmio helpers (assumes lapic mapped to virtual memory) ---}\par
00041 {\cf17 static} {\cf17 inline} uint32_t lapic_mmio_read(uint32_t off) \{\par
00042     {\cf19 return} lapic[off / 4];\par
00043 \}\par
00044 {\cf17 static} {\cf17 inline} {\cf18 void} lapic_mmio_write(uint32_t off, uint32_t val) \{\par
00045     tracelast_func({\cf22 "lapic_mmio_write"});\par
00046     lapic[off / 4] = val;\par
00047     (void)lapic_mmio_read(LAPIC_ID); {\cf20 // serializing read to ensure write completes}\par
00048 \}\par
00049 \par
00050 {\cf20 // Wait for ICR delivery to complete (ICR low: bit 12 = Delivery Status)}\par
00051 {\cf17 static} {\cf18 void} lapic_wait_icr({\cf18 void}) \{\par
00052     {\cf19 while} (lapic_mmio_read(LAPIC_ICR_LOW) & (1 << 12)) \{\par
00053         {\cf20 /* spin */}\par
00054     \}\par
00055 \}\par
00056 \par
00057 {\cf17 static} {\cf18 void} map_lapic({\cf18 void}) \{\par
00058     {\cf19 if} (lapic) {\cf19 return};\par
00059     tracelast_func({\cf22 "map_lapic"});\par
00060 \par
00061     {\cf18 void}* virt = ({\cf18 void}*)(lapic_phys + PHYS_MEM_OFFSET);\par
00062 \par
00063     {\cf20 // Map the single LAPIC page (phys -> virt)}\par
00064     map_page(virt, lapic_phys, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00065 \par
00066     {\cf20 // store the mmio base pointer}\par
00067     lapic = ({\cf17 volatile} uint32_t*)virt;\par
00068 \}\par
00069 \par
00070 \par
00071 {\cf20 // Enable local APIC via IA32_APIC_BASE MSR and set SVR}\par
00072 {\cf18 void} lapic_enable({\cf18 void}) \{\par
00073     tracelast_func({\cf22 "lapic_enable"});\par
00074     uint64_t apic_msr = __readmsr(IA32_APIC_BASE_MSR);\par
00075     {\cf19 if} (!(apic_msr & (1ULL << 11))) \{\par
00076         {\cf20 // set APIC global enable}\par
00077         apic_msr |= (1ULL << 11);\par
00078         {\cf20 // optionally set a custom base in apic_msr bits [35:12] if not default}\par
00079         {\cf20 // wrmsr(IA32_APIC_BASE_MSR, apic_msr);}\par
00080         __writemsr(IA32_APIC_BASE_MSR, apic_msr);\par
00081     \}\par
00082     map_lapic();\par
00083 \par
00084     {\cf20 // Set Spurious Vector Register and enable (bit 8 = APIC enable)}\par
00085     {\cf20 // choose an interrupt vector for spurious (e.g., 0xFF). Keep vector values consistent with your IDT.}\par
00086     uint32_t svr = (0xFF) | (1 << 8);\par
00087     lapic_mmio_write(LAPIC_SVR, svr);\par
00088 \}\par
00089 \par
00090 {\cf20 // Initialize BSP's LAPIC (call early from kernel init on BSP)}\par
00091 {\cf18 void} lapic_init_bsp({\cf18 void}) \{\par
00092     tracelast_func({\cf22 "lapic_init_bsp"});\par
00093     {\cf20 // If your bootloader set APIC base adjust lapic_phys by reading MSR:}\par
00094     uint64_t apic_msr = __readmsr(IA32_APIC_BASE_MSR);\par
00095     uint64_t base = (apic_msr & 0xFFFFF000ULL);\par
00096     {\cf19 if} (base) lapic_phys = base;\par
00097     map_lapic();\par
00098 \par
00099     lapic_enable();\par
00100 \par
00101     {\cf20 // mask LINT0/LINT1 as appropriate, clear error status, etc.}\par
00102     lapic_mmio_write(LAPIC_LVT_LINT0, (1U << 16)); {\cf20 // mask}\par
00103     lapic_mmio_write(LAPIC_LVT_LINT1, (1U << 16)); {\cf20 // mask}\par
00104     lapic_mmio_write(LAPIC_LVT_ERROR, (1U << 16)); {\cf20 // mask (until handler in place)}\par
00105     lapic_mmio_write(LAPIC_EOI, 0);\par
00106 \}\par
00107 \par
00108 {\cf20 // send IPI to APIC id}\par
00109 {\cf18 void} lapic_send_ipi(uint8_t apic_id, uint8_t vector, uint32_t flags) \{\par
00110     uint32_t high = ((uint32_t)apic_id) << 24;\par
00111     lapic_mmio_write(LAPIC_ICR_HIGH, high);\par
00112     lapic_mmio_write(LAPIC_ICR_LOW, (uint32_t)vector | flags);\par
00113     lapic_wait_icr();\par
00114 \}\par
00115 \par
00116 {\cf18 void} lapic_eoi({\cf18 void}) \{\par
00117     lapic_mmio_write(LAPIC_EOI, 0);\par
00118 \}\par
00119 \par
00120 {\cf20 // --- Timer calibration and init ---}\par
00121 {\cf20 // NOTE: the APIC timer is a downward counter. Strategy:}\par
00122 {\cf20 //  1. Set divide to known divisor.}\par
00123 {\cf20 //  2. Write initcount = 0xFFFFFFFF.}\par
00124 {\cf20 //  3. Wait EXACTLY 100 ms via PIT/HPET.}\par
00125 {\cf20 //  4. curr = read current count -> ticks_in_100ms = start - curr}\par
00126 {\cf20 //  5. ticks_per_period(10ms) = ticks_in_100ms / 10}\par
00127 {\cf20 //  6. Program LVT timer to periodic and initial count = ticks_per_period}\par
00128 {\cf20 //}\par
00129 {\cf20 // Replace pit_sleep_ms() with your accurate sleep.}\par
00130 {\cf21 #define APIC_LVT_TIMER_PERIODIC (1U << 17)}\par
00131 {\cf21 #define APIC_TIMER_MASKED        (1U << 16)}\par
00132 \par
00133 {\cf17 static} uint32_t calibrate_lapic_ticks_per_10ms({\cf18 void}) \{\par
00134     {\cf20 // choose divide config: here set encode 0x3 (divide by 16). Adjust if needed.}\par
00135     lapic_mmio_write(LAPIC_TIMER_DIV, 0x3);\par
00136 \par
00137     {\cf17 const} uint32_t start = 0xFFFFFFFFU;\par
00138     lapic_mmio_write(LAPIC_TIMER_INITCNT, start);\par
00139 \par
00140     pit_sleep_ms(100);\par
00141 \par
00142     uint32_t curr = lapic_mmio_read(LAPIC_TIMER_CURRCNT);\par
00143     uint32_t ticks = start - curr;\par
00144     {\cf19 if} (ticks == 0) {\cf19 return} 0;\par
00145     {\cf19 return} ticks / 10; {\cf20 // ticks per 10ms -> for 100Hz (10ms period)}\par
00146 \}\par
00147 \par
00148 {\cf18 int} init_lapic_timer(uint32_t hz) \{\par
00149     {\cf19 if} (hz == 0) {\cf19 return} -1;\par
00150     map_lapic();\par
00151 \par
00152     {\cf20 // calibrate using 100ms window}\par
00153     uint32_t ticks_per_10ms = calibrate_lapic_ticks_per_10ms();\par
00154     {\cf19 if} (ticks_per_10ms == 0) {\cf19 return} -2;\par
00155 \par
00156     {\cf20 // compute target initial count}\par
00157     {\cf20 // desired_period_ms = 1000 / hz}\par
00158     uint32_t period_ms = 1000 / hz;\par
00159     {\cf20 // ticks_per_10ms: ticks per 10ms, so ticks_per_ms = ticks_per_10ms / 10}\par
00160     {\cf20 // initial_count = ticks_per_ms * period_ms = ticks_per_10ms * period_ms / 10}\par
00161     uint64_t initial = ((uint64_t)ticks_per_10ms * (uint64_t)period_ms) / 10ULL;\par
00162     {\cf19 if} (initial == 0) initial = 1;\par
00163 \par
00164     {\cf20 // mask the timer while programming}\par
00165     lapic_mmio_write(LAPIC_LVT_TIMER, APIC_LVT_TIMER_PERIODIC | 0xEF {\cf20 /* IDT vector 0xEF */});\par
00166     lapic_mmio_write(LAPIC_TIMER_INITCNT, (uint32_t)initial);\par
00167     {\cf19 return} 0;\par
00168 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.h}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "../../intrin/intrin.h"}\par
{\f2 #include "pit.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_init_bsp} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_enable} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapic_read} (uint32_t reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_write} (uint32_t reg, uint32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_send_ipi} (uint8_t apic_id, uint8_t vector, uint32_t flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b init_lapic_timer} (uint32_t hz)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_lapic_timer\:apic.h}
{\xe \v apic.h\:init_lapic_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int init_lapic_timer (uint32_t hz)}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b apic.c}.}\par
}
{\xe \v lapic_enable\:apic.h}
{\xe \v apic.h\:lapic_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_enable (void )}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b apic.c}.}\par
}
{\xe \v lapic_eoi\:apic.h}
{\xe \v apic.h\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void )}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b apic.c}.}\par
}
{\xe \v lapic_init_bsp\:apic.h}
{\xe \v apic.h\:lapic_init_bsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_init_bsp (void )}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b apic.c}.}\par
}
{\xe \v lapic_read\:apic.h}
{\xe \v apic.h\:lapic_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapic_read (uint32_t reg)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lapic_send_ipi\:apic.h}
{\xe \v apic.h\:lapic_send_ipi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_send_ipi (uint8_t apic_id, uint8_t vector, uint32_t flags)}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b apic.c}.}\par
}
{\xe \v lapic_write\:apic.h}
{\xe \v apic.h\:lapic_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_write (uint32_t reg, uint32_t value)}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
apic.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/apic.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_APIC_H}\par
00002 {\cf21 #define X86_APIC_H}\par
00003 \par
00004 {\cf21 #include <stdint.h>}\par
00005 {\cf21 #include <stdbool.h>}\par
00006 {\cf21 #include "../../intrin/intrin.h"}\par
00007 {\cf21 #include "pit.h"}\par
00008 \par
00009 {\cf18 void} lapic_init_bsp({\cf18 void});                    {\cf20 // call once on BSP early}\par
00010 {\cf18 void} lapic_enable({\cf18 void});\par
00011 uint32_t lapic_read(uint32_t reg);\par
00012 {\cf18 void} lapic_write(uint32_t reg, uint32_t value);\par
00013 {\cf18 void} lapic_eoi({\cf18 void});\par
00014 {\cf18 void} lapic_send_ipi(uint8_t apic_id, uint8_t vector, uint32_t flags);\par
00015 {\cf18 int} init_lapic_timer(uint32_t hz);           {\cf20 // calibrate + start periodic timer at `hz` (returns 0 on success)}\par
00016 \par
00017 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.c}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "pit.h"}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../intrin/intrin.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_FREQ_HZ}\~ 1193182U\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CMD_PORT}\~ 0x43\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CH0_PORT}\~ 0x40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CMD_MODE2_LBHB}\~ 0x34\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CMD_LATCH_CH0}\~ 0x00\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pit_sleep_ms} (uint32_t ms)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PIT_CH0_PORT\:pit.c}
{\xe \v pit.c\:PIT_CH0_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CH0_PORT\~ 0x40}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b pit.c}.}\par
}
{\xe \v PIT_CMD_LATCH_CH0\:pit.c}
{\xe \v pit.c\:PIT_CMD_LATCH_CH0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CMD_LATCH_CH0\~ 0x00}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b pit.c}.}\par
}
{\xe \v PIT_CMD_MODE2_LBHB\:pit.c}
{\xe \v pit.c\:PIT_CMD_MODE2_LBHB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CMD_MODE2_LBHB\~ 0x34}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b pit.c}.}\par
}
{\xe \v PIT_CMD_PORT\:pit.c}
{\xe \v pit.c\:PIT_CMD_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CMD_PORT\~ 0x43}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b pit.c}.}\par
}
{\xe \v PIT_FREQ_HZ\:pit.c}
{\xe \v pit.c\:PIT_FREQ_HZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_FREQ_HZ\~ 1193182U}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b pit.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pit_sleep_ms\:pit.c}
{\xe \v pit.c\:pit_sleep_ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pit_sleep_ms (uint32_t ms)}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b pit.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pit.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "pit.h"}\par
00002 {\cf21 #include <stdint.h>}\par
00003 {\cf21 #include "../../intrin/intrin.h"}\par
00004 \par
00005 {\cf20 /* cli/sti helpers */}\par
00006 {\cf17 static} {\cf17 inline} {\cf18 void} disable_interrupts({\cf18 void}) \{ __asm__ {\cf17 volatile} ({\cf22 "cli"} ::: {\cf22 "memory"}); \}\par
00007 {\cf17 static} {\cf17 inline} {\cf18 void} enable_interrupts({\cf18 void}) \{ __asm__ {\cf17 volatile} ({\cf22 "sti"}); \}\par
00008 \par
00009 {\cf20 /* PIT constants */}\par
00010 {\cf21 #define PIT_FREQ_HZ 1193182U}\par
00011 {\cf21 #define PIT_CMD_PORT 0x43}\par
00012 {\cf21 #define PIT_CH0_PORT 0x40}\par
00013 \par
00014 {\cf20 /* Command bytes:}\par
00015 {\cf20    - 0x34 = channel 0, lobyte/hibyte, mode 2 (rate generator), binary}\par
00016 {\cf20    - 0x00 = latch command for channel 0 (bits 7..6 = 00, rest 0 = latch)}\par
00017 {\cf20 */}\par
00018 {\cf21 #define PIT_CMD_MODE2_LBHB 0x34}\par
00019 {\cf21 #define PIT_CMD_LATCH_CH0  0x00}\par
00020 \par
00021 {\cf20 /* Sleep ms implementation (blocking). Uses chunks <= 0xFFFF PIT ticks. */}\par
00022 {\cf18 void} pit_sleep_ms(uint32_t ms) \{\par
00023     {\cf19 if} (ms == 0) {\cf19 return};\par
00024 \par
00025     {\cf20 /* total ticks needed (rounded up) */}\par
00026     uint64_t total_ticks = ((uint64_t)PIT_FREQ_HZ * ms + 999) / 1000;\par
00027 \par
00028     {\cf19 while} (total_ticks > 0) \{\par
00029         {\cf20 /* chunk <= 0xFFFF for PIT 16-bit counter (0 means 65536) */}\par
00030         uint32_t chunk = (total_ticks > 0xFFFF) ? 0xFFFF : (uint32_t)total_ticks;\par
00031         {\cf19 if} (chunk == 0) chunk = 0xFFFF;\par
00032 \par
00033         {\cf20 /* Program PIT channel 0 (mode 2, lobyte/hibyte) with 'chunk' reload */}\par
00034         __outbyte(PIT_CMD_PORT, PIT_CMD_MODE2_LBHB);\par
00035         __outbyte(PIT_CH0_PORT, (uint8_t)(chunk & 0xFF));         {\cf20 // low byte}\par
00036         __outbyte(PIT_CH0_PORT, (uint8_t)((chunk >> 8) & 0xFF));  {\cf20 // high byte}\par
00037 \par
00038         {\cf20 /* Read a latched current count and then poll until elapsed >= chunk */}\par
00039         disable_interrupts();\par
00040 \par
00041         {\cf20 /* latch current count into internal latch register */}\par
00042         __outbyte(PIT_CMD_PORT, PIT_CMD_LATCH_CH0);\par
00043 \par
00044         {\cf20 /* read latched low/high bytes */}\par
00045         uint16_t start = (uint16_t)__inbyte(PIT_CH0_PORT) | ((uint16_t)__inbyte(PIT_CH0_PORT) << 8);\par
00046 \par
00047         {\cf19 while} (1) \{\par
00048             {\cf20 /* latch and read current count again */}\par
00049             __outbyte(PIT_CMD_PORT, PIT_CMD_LATCH_CH0);\par
00050             uint16_t curr = (uint16_t)__inbyte(PIT_CH0_PORT) | ((uint16_t)__inbyte(PIT_CH0_PORT) << 8);\par
00051 \par
00052             {\cf20 /* elapsed = (start - curr) modulo 65536 */}\par
00053             uint16_t elapsed = (uint16_t)(start - curr);\par
00054 \par
00055             {\cf19 if} ((uint32_t)elapsed >= chunk) {\cf19 break};\par
00056             {\cf20 /* small CPU-friendly pause */}\par
00057             __asm__ {\cf17 volatile}({\cf22 "pause"});\par
00058         \}\par
00059 \par
00060         enable_interrupts();\par
00061 \par
00062         total_ticks -= chunk;\par
00063     \}\par
00064 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.h}
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pit_sleep_ms} (uint32_t ms)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pit_sleep_ms\:pit.h}
{\xe \v pit.h\:pit_sleep_ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pit_sleep_ms (uint32_t ms)}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b pit.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pit.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/apic/pit.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86PIT_H}\par
00002 {\cf21 #define X86PIT_H}\par
00003 \par
00004 {\cf21 #include <stdint.h>}\par
00005 {\cf18 void} pit_sleep_ms(uint32_t ms);\par
00006 \par
00007 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu.h}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdatomic.h>}\par
{\f2 #include "cpu_types.h"}\par
{\f2 #include "irql/irql.h"}\par
{\f2 #include "spinlock/spinlock.h"}\par
{\f2 #include "dpc/dpc.h"}\par
{\f2 #include "dpc/dpc_list.h"}\par
{\f2 #include "scheduler/scheduler.h"}\par
{\f2 #include "thread/thread.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SAVE_CTX_FRAME}(ctx_ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GET_RIP}(RIPVAR_NOPTR)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_interrupt_frame} ({\b INT_FRAME} *frame)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read the current interrupt frame. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitCPU} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b queueLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} {\b cpu}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v GET_RIP\:cpu.h}
{\xe \v cpu.h\:GET_RIP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GET_RIP( RIPVAR_NOPTR)}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     __asm__ __volatile__ ({\cf22 "lea (%%rip), %0"} : {\cf22 "=r"} (RIPVAR_NOPTR));\par
}
{
Definition at line {\b 80} of file {\b cpu.h}.}\par
}
{\xe \v SAVE_CTX_FRAME\:cpu.h}
{\xe \v cpu.h\:SAVE_CTX_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SAVE_CTX_FRAME( ctx_ptr)}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b cpu.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitCPU\:cpu.h}
{\xe \v cpu.h\:InitCPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitCPU (void )}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b kernel.c}.}\par
}
{\xe \v read_interrupt_frame\:cpu.h}
{\xe \v cpu.h\:read_interrupt_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_interrupt_frame ({\b INT_FRAME} * frame)}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read the current interrupt frame. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frame} \cell }{{\b INT_FRAME} pointer.\cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cpu\:cpu.h}
{\xe \v cpu.h\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} cpu{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b kernel.c}.}\par
}
{\xe \v queueLock\:cpu.h}
{\xe \v cpu.h\:queueLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} queueLock{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b scheduler.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cpu.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Core CPU Sturcture and definitions.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_CPU_H}\par
00008 {\cf21 #define X86_CPU_H}\par
00009 \par
00010 {\cf21 #ifdef __INTELLISENSE__}\par
00011 {\cf21 #define __asm__ __asm}\par
00012 {\cf21 #endif}\par
00013 \par
00014 {\cf21 #ifndef __INTELLISENSE__}\par
00015 {\cf21 #define SAVE_CTX_FRAME(ctx_ptr)                            \\}\par
00016 {\cf21     do \{                                                   \\}\par
00017 {\cf21         __asm__ volatile (                                \\}\par
00018 {\cf21             }{\cf20 /* push all 16 GPRs */}{\cf21                         \\}\par
00019 {\cf21             "push %%rax\\n\\t"                              \\}\par
00020 {\cf21             "push %%rbx\\n\\t"                              \\}\par
00021 {\cf21             "push %%rcx\\n\\t"                              \\}\par
00022 {\cf21             "push %%rdx\\n\\t"                              \\}\par
00023 {\cf21             "push %%rsi\\n\\t"                              \\}\par
00024 {\cf21             "push %%rdi\\n\\t"                              \\}\par
00025 {\cf21             "push %%rbp\\n\\t"                              \\}\par
00026 {\cf21             "push %%r8\\n\\t"                               \\}\par
00027 {\cf21             "push %%r9\\n\\t"                               \\}\par
00028 {\cf21             "push %%r10\\n\\t"                              \\}\par
00029 {\cf21             "push %%r11\\n\\t"                              \\}\par
00030 {\cf21             "push %%r12\\n\\t"                              \\}\par
00031 {\cf21             "push %%r13\\n\\t"                              \\}\par
00032 {\cf21             "push %%r14\\n\\t"                              \\}\par
00033 {\cf21             "push %%r15\\n\\t"                              \\}\par
00034 {\cf21                                                             \\}\par
00035 {\cf21             }{\cf20 /* store saved regs into the CTX_FRAME */}{\cf21       \\}\par
00036 {\cf21             "mov %%r15,  0x00(%[c])\\n\\t"                   \\}\par
00037 {\cf21             "mov %%r14,  0x08(%[c])\\n\\t"                   \\}\par
00038 {\cf21             "mov %%r13,  0x10(%[c])\\n\\t"                   \\}\par
00039 {\cf21             "mov %%r12,  0x18(%[c])\\n\\t"                   \\}\par
00040 {\cf21             "mov %%r11,  0x20(%[c])\\n\\t"                   \\}\par
00041 {\cf21             "mov %%r10,  0x28(%[c])\\n\\t"                   \\}\par
00042 {\cf21             "mov %%r9,   0x30(%[c])\\n\\t"                   \\}\par
00043 {\cf21             "mov %%r8,   0x38(%[c])\\n\\t"                   \\}\par
00044 {\cf21             "mov %%rbp,  0x40(%[c])\\n\\t"                   \\}\par
00045 {\cf21             "mov %%rdi,  0x48(%[c])\\n\\t"                   \\}\par
00046 {\cf21             "mov %%rsi,  0x50(%[c])\\n\\t"                   \\}\par
00047 {\cf21             "mov %%rdx,  0x58(%[c])\\n\\t"                   \\}\par
00048 {\cf21             "mov %%rcx,  0x60(%[c])\\n\\t"                   \\}\par
00049 {\cf21             "mov %%rbx,  0x68(%[c])\\n\\t"                   \\}\par
00050 {\cf21             "mov %%rax,  0x70(%[c])\\n\\t"                   \\}\par
00051 {\cf21             }{\cf20 /* RSP before the first push = (current RSP + 15*8) */}{\cf21  \\}\par
00052 {\cf21             "lea 0x78(%%rax), %%rax\\n\\t" }{\cf20 /* compute offset in-place */}{\cf21  \\}\par
00053 {\cf21             "mov %%rax, 0x78(%[c])\\n\\t"                   \\}\par
00054 {\cf21                                                             \\}\par
00055 {\cf21             }{\cf20 /* pop in reverse order */}{\cf21                      \\}\par
00056 {\cf21             "pop  %%r15\\n\\t"                               \\}\par
00057 {\cf21             "pop  %%r14\\n\\t"                               \\}\par
00058 {\cf21             "pop  %%r13\\n\\t"                               \\}\par
00059 {\cf21             "pop  %%r12\\n\\t"                               \\}\par
00060 {\cf21             "pop  %%r11\\n\\t"                               \\}\par
00061 {\cf21             "pop  %%r10\\n\\t"                               \\}\par
00062 {\cf21             "pop  %%r9\\n\\t"                                \\}\par
00063 {\cf21             "pop  %%r8\\n\\t"                                \\}\par
00064 {\cf21             "pop  %%rbp\\n\\t"                               \\}\par
00065 {\cf21             "pop  %%rdi\\n\\t"                               \\}\par
00066 {\cf21             "pop  %%rsi\\n\\t"                               \\}\par
00067 {\cf21             "pop  %%rdx\\n\\t"                               \\}\par
00068 {\cf21             "pop  %%rcx\\n\\t"                               \\}\par
00069 {\cf21             "pop  %%rbx\\n\\t"                               \\}\par
00070 {\cf21             "pop  %%rax\\n\\t"                               \\}\par
00071 {\cf21             :                                              \\}\par
00072 {\cf21             : [c] "r" (ctx_ptr)     }{\cf20 /* loads ctx_ptr into a temp reg */}{\cf21  \\}\par
00073 {\cf21             : "memory"              }{\cf20 /* we write to memory */}{\cf21          \\}\par
00074 {\cf21         );                                                     \\}\par
00075 {\cf21     \} while (0)}\par
00076 {\cf21 #else}\par
00077 {\cf21 #define SAVE_CTX_FRAME(ctx_ptr) (void*)(0)}\par
00078 {\cf21 #endif}\par
00079 \par
00080 {\cf21 #define GET_RIP(RIPVAR_NOPTR) \\}\par
00081 {\cf21     __asm__ __volatile__ ("lea (%%rip), %0" : "=r" (RIPVAR_NOPTR));}\par
00082 \par
00083 {\cf20 // instead of including kernel.h this time which causes problems, ill include each file I need.}\par
00084 {\cf21 #include <stdbool.h>}\par
00085 {\cf21 #include <stddef.h>}\par
00086 {\cf21 #include <stdint.h>}\par
00087 {\cf21 #include <stdatomic.h>}\par
00088 {\cf21 #include "cpu_types.h"}\par
00089 {\cf21 #include "irql/irql.h"}\par
00090 {\cf21 #include "spinlock/spinlock.h"}\par
00091 {\cf21 #include "dpc/dpc.h"}\par
00092 {\cf21 #include "dpc/dpc_list.h"}\par
00093 {\cf21 #include "scheduler/scheduler.h"}\par
00094 {\cf21 #include "thread/thread.h"}\par
00095 \par
00100 {\cf18 void} read_interrupt_frame(INT_FRAME* frame);\par
00101 \par
00102 {\cf21 #ifndef UNREFERENCED_PARAMETER}\par
00103 {\cf21 #define UNREFERENCED_PARAMETER(x) (void)(x)}\par
00104 {\cf21 #endif}\par
00105 \par
00106 {\cf17 extern} SPINLOCK queueLock;\par
00107 \par
00112 {\cf21 #ifndef CONTAINING_RECORD}\par
00113 {\cf21 #define CONTAINING_RECORD(ptr, type, member) \\}\par
00114 {\cf21     ((type *)((char *)(ptr) - offsetof(type, member)))}\par
00115 {\cf21 #endif}\par
00116 \par
00117 {\cf17 static} {\cf17 inline} {\cf18 void} enqueue(Queue* queue, Thread* thread) \{\par
00118     tracelast_func({\cf22 "enqueue"});\par
00119     uint64_t flags;\par
00120     MtAcquireSpinlock(&queueLock, &flags);\par
00121     thread->nextThread = NULL;\par
00122     {\cf19 if} (!queue->head) queue->head = thread;\par
00123     {\cf19 else} queue->tail->nextThread = thread;\par
00124     queue->tail = thread;\par
00125     MtReleaseSpinlock(&queueLock, flags);\par
00126 \}\par
00127 \par
00128 {\cf17 static} {\cf17 inline} Thread* dequeue(Queue* q) \{\par
00129     tracelast_func({\cf22 "dequeue"});\par
00130     uint64_t flags;\par
00131     MtAcquireSpinlock(&queueLock, &flags);\par
00132     {\cf19 if} (!q->head) \{\par
00133         {\cf19 return} NULL;\par
00134     \}\par
00135 \par
00136     Thread* t = q->head;\par
00137     q->head = t->nextThread;\par
00138     {\cf19 if} (!q->head) \{\par
00139         q->tail = NULL;\par
00140     \}\par
00141     t->nextThread = NULL;\par
00142     MtReleaseSpinlock(&queueLock, flags);\par
00143     {\cf19 return} t;\par
00144 \}\par
00145 \par
00146 {\cf18 void} InitCPU({\cf18 void}); {\cf20 // defined in kernel.c}\par
00147 \par
00148 {\cf17 extern} CPU cpu; {\cf20 // Grab from KERNEL.C}\par
00149 \par
00150 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu_types.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu_types.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu_types.h}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdatomic.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SPINLOCK}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _INT_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _CTX_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _Queue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _Thread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _CPU}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TICK_MS}\~ 4\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _THREAD_STATE} {\b THREAD_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _Thread} {\b Thread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DPC} {\b DPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _Queue} {\b Queue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _CPU} {\b CPU}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _IRQL} {\b IRQL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _SPINLOCK} {\b SPINLOCK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _INT_FRAME} {\b INT_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _CTX_FRAME} {\b CTX_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _timeSliceMs} {\b timeSliceMs}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do not use for timeSlicing a thread, use the {\b timeSliceTicks} enum. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _timeSliceTicks} {\b timeSliceTicks}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to determine how much time in ms a thread should have before being involuntarily relinquished. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _DPC_PRIORITY} {\b DPC_PRIORITY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _DPC_KIND} {\b DPC_KIND}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _THREAD_STATE} \{ {\b RUNNING}
, {\b READY}
, {\b BLOCKED}
, {\b TERMINATING}
, {\b TERMINATED}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _IRQL} \{ {\b PASSIVE_LEVEL} = 0
, {\b DISPATCH_LEVEL} = 2
, {\b DIRQL_SECONDARY_ATA} = 12
, {\b DIRQL_PRIMARY_ATA} = 13
, {\b DIRQL_FPU} = 14
, {\b DIRQL_MOUSE} = 15
, {\b DIRQL_PERIPHERAL11} = 16
, {\b DIRQL_PERIPHERAL10} = 17
, {\b DIRQL_PERIPHERAL9} = 18
, {\b DIRQL_RTC} = 19
, {\b DIRQL_LPT1} = 20
, {\b DIRQL_FLOPPY} = 21
, {\b DIRQL_SOUND_LPT2} = 22
, {\b DIRQL_COM1} = 23
, {\b DIRQL_COM2} = 24
, {\b DIRQL_CASCADE} = 25
, {\b DIRQL_KEYBOARD} = 26
, {\b DIRQL_TIMER} = 27
, {\b PROFILE_LEVEL} = 27
, {\b CLOCK_LEVEL} = 28
, {\b SYNCH_LEVEL} = 29
, {\b POWER_LEVEL} = 30
, {\b HIGH_LEVEL} = 31
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _timeSliceMs} \{ {\b ____DONT_USE_DEFAULT_TIMESLICE_MS} = 40
, {\b ____DONT_USE_LOW_TIMESLICE_MS} = 16
, {\b ____DONT_USE_HIGH_TIMESLICE_MS} = 100
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do not use for timeSlicing a thread, use the {\b timeSliceTicks} enum. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _timeSliceTicks} \{ {\b LOW_TIMESLICE_TICKS} = ____DONT_USE_LOW_TIMESLICE_MS / TICK_MS
, {\b DEFAULT_TIMESLICE_TICKS} = ____DONT_USE_DEFAULT_TIMESLICE_MS / TICK_MS
, {\b HIGH_TIMESLICE_TICKS} = ____DONT_USE_HIGH_TIMESLICE_MS / TICK_MS
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to determine how much time in ms a thread should have before being involuntarily relinquished. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _DPC_PRIORITY} \{ {\b NO_PRIORITY} = 0
, {\b LOW_PRIORITY} = 25
, {\b MEDIUM_PRIORITY} = 50
, {\b HIGH_PRIORITY} = 75
, {\b SYSTEM_PRIORITY} = 99
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _DPC_KIND} \{ {\b NO_KIND} = 0
, {\b DPC_SCHEDULE}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TICK_MS\:cpu_types.h}
{\xe \v cpu_types.h\:TICK_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TICK_MS\~ 4}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b cpu_types.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CPU\:cpu_types.h}
{\xe \v cpu_types.h\:CPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _CPU} {\b CPU}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b cpu_types.h}.}\par
}
{\xe \v CTX_FRAME\:cpu_types.h}
{\xe \v cpu_types.h\:CTX_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _CTX_FRAME} {\b CTX_FRAME}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DPC\:cpu_types.h}
{\xe \v cpu_types.h\:DPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DPC} {\b DPC}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b cpu_types.h}.}\par
}
{\xe \v DPC_KIND\:cpu_types.h}
{\xe \v cpu_types.h\:DPC_KIND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _DPC_KIND} {\b DPC_KIND}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DPC_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:DPC_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _DPC_PRIORITY} {\b DPC_PRIORITY}}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INT_FRAME\:cpu_types.h}
{\xe \v cpu_types.h\:INT_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _INT_FRAME} {\b INT_FRAME}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IRQL\:cpu_types.h}
{\xe \v cpu_types.h\:IRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _IRQL} {\b IRQL}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Queue\:cpu_types.h}
{\xe \v cpu_types.h\:Queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _Queue} {\b Queue}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b cpu_types.h}.}\par
}
{\xe \v SPINLOCK\:cpu_types.h}
{\xe \v cpu_types.h\:SPINLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _SPINLOCK} {\b SPINLOCK}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Thread\:cpu_types.h}
{\xe \v cpu_types.h\:Thread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _Thread} {\b Thread}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b cpu_types.h}.}\par
}
{\xe \v THREAD_STATE\:cpu_types.h}
{\xe \v cpu_types.h\:THREAD_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _THREAD_STATE} {\b THREAD_STATE}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v timeSliceMs\:cpu_types.h}
{\xe \v cpu_types.h\:timeSliceMs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _timeSliceMs} {\b timeSliceMs}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do not use for timeSlicing a thread, use the {\b timeSliceTicks} enum. }}\par
}
{\xe \v timeSliceTicks\:cpu_types.h}
{\xe \v cpu_types.h\:timeSliceTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _timeSliceTicks} {\b timeSliceTicks}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to determine how much time in ms a thread should have before being involuntarily relinquished. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _DPC_KIND\:cpu_types.h}
{\xe \v cpu_types.h\:_DPC_KIND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _DPC_KIND}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NO_KIND\:cpu_types.h}
{\xe \v cpu_types.h\:NO_KIND}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NO_KIND{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\cell }{\cell }{\row }
{\xe \v DPC_SCHEDULE\:cpu_types.h}
{\xe \v cpu_types.h\:DPC_SCHEDULE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DPC_SCHEDULE{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 132} of file {\b cpu_types.h}.}\par
}
{\xe \v _DPC_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:_DPC_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _DPC_PRIORITY}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NO_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:NO_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NO_PRIORITY{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\cell }{\cell }{\row }
{\xe \v LOW_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:LOW_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LOW_PRIORITY{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\cell }{\cell }{\row }
{\xe \v MEDIUM_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:MEDIUM_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEDIUM_PRIORITY{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
\cell }{\cell }{\row }
{\xe \v HIGH_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:HIGH_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HIGH_PRIORITY{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\cell }{\cell }{\row }
{\xe \v SYSTEM_PRIORITY\:cpu_types.h}
{\xe \v cpu_types.h\:SYSTEM_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SYSTEM_PRIORITY{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 124} of file {\b cpu_types.h}.}\par
}
{\xe \v _IRQL\:cpu_types.h}
{\xe \v cpu_types.h\:_IRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _IRQL}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PASSIVE_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:PASSIVE_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PASSIVE_LEVEL{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
\cell }{\cell }{\row }
{\xe \v DISPATCH_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:DISPATCH_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DISPATCH_LEVEL{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
\cell }{\cell }{\row }
{\xe \v DIRQL_SECONDARY_ATA\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_SECONDARY_ATA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_SECONDARY_ATA{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
\cell }{\cell }{\row }
{\xe \v DIRQL_PRIMARY_ATA\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_PRIMARY_ATA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_PRIMARY_ATA{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
\cell }{\cell }{\row }
{\xe \v DIRQL_FPU\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_FPU}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_FPU{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\cell }{\cell }{\row }
{\xe \v DIRQL_MOUSE\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_MOUSE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_MOUSE{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
\cell }{\cell }{\row }
{\xe \v DIRQL_PERIPHERAL11\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_PERIPHERAL11}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_PERIPHERAL11{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\cell }{\cell }{\row }
{\xe \v DIRQL_PERIPHERAL10\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_PERIPHERAL10}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_PERIPHERAL10{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\cell }{\cell }{\row }
{\xe \v DIRQL_PERIPHERAL9\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_PERIPHERAL9}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_PERIPHERAL9{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
\cell }{\cell }{\row }
{\xe \v DIRQL_RTC\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_RTC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_RTC{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
\cell }{\cell }{\row }
{\xe \v DIRQL_LPT1\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_LPT1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_LPT1{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
\cell }{\cell }{\row }
{\xe \v DIRQL_FLOPPY\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_FLOPPY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_FLOPPY{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\cell }{\cell }{\row }
{\xe \v DIRQL_SOUND_LPT2\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_SOUND_LPT2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_SOUND_LPT2{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
\cell }{\cell }{\row }
{\xe \v DIRQL_COM1\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_COM1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_COM1{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
\cell }{\cell }{\row }
{\xe \v DIRQL_COM2\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_COM2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_COM2{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
\cell }{\cell }{\row }
{\xe \v DIRQL_CASCADE\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_CASCADE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_CASCADE{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
\cell }{\cell }{\row }
{\xe \v DIRQL_KEYBOARD\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_KEYBOARD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_KEYBOARD{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
\cell }{\cell }{\row }
{\xe \v DIRQL_TIMER\:cpu_types.h}
{\xe \v cpu_types.h\:DIRQL_TIMER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIRQL_TIMER{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
\cell }{\cell }{\row }
{\xe \v PROFILE_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:PROFILE_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROFILE_LEVEL{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
\cell }{\cell }{\row }
{\xe \v CLOCK_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:CLOCK_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CLOCK_LEVEL{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
\cell }{\cell }{\row }
{\xe \v SYNCH_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:SYNCH_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SYNCH_LEVEL{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
\cell }{\cell }{\row }
{\xe \v POWER_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:POWER_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid POWER_LEVEL{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
\cell }{\cell }{\row }
{\xe \v HIGH_LEVEL\:cpu_types.h}
{\xe \v cpu_types.h\:HIGH_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HIGH_LEVEL{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 24} of file {\b cpu_types.h}.}\par
}
{\xe \v _THREAD_STATE\:cpu_types.h}
{\xe \v cpu_types.h\:_THREAD_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _THREAD_STATE}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v RUNNING\:cpu_types.h}
{\xe \v cpu_types.h\:RUNNING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid RUNNING{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
\cell }{\cell }{\row }
{\xe \v READY\:cpu_types.h}
{\xe \v cpu_types.h\:READY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid READY{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\cell }{\cell }{\row }
{\xe \v BLOCKED\:cpu_types.h}
{\xe \v cpu_types.h\:BLOCKED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BLOCKED{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
\cell }{\cell }{\row }
{\xe \v TERMINATING\:cpu_types.h}
{\xe \v cpu_types.h\:TERMINATING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid TERMINATING{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
\cell }{\cell }{\row }
{\xe \v TERMINATED\:cpu_types.h}
{\xe \v cpu_types.h\:TERMINATED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid TERMINATED{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 12} of file {\b cpu_types.h}.}\par
}
{\xe \v _timeSliceMs\:cpu_types.h}
{\xe \v cpu_types.h\:_timeSliceMs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _timeSliceMs}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Do not use for timeSlicing a thread, use the {\b timeSliceTicks} enum. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ____DONT_USE_DEFAULT_TIMESLICE_MS\:cpu_types.h}
{\xe \v cpu_types.h\:____DONT_USE_DEFAULT_TIMESLICE_MS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ____DONT_USE_DEFAULT_TIMESLICE_MS{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
\cell }{\cell }{\row }
{\xe \v ____DONT_USE_LOW_TIMESLICE_MS\:cpu_types.h}
{\xe \v cpu_types.h\:____DONT_USE_LOW_TIMESLICE_MS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ____DONT_USE_LOW_TIMESLICE_MS{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
\cell }{\cell }{\row }
{\xe \v ____DONT_USE_HIGH_TIMESLICE_MS\:cpu_types.h}
{\xe \v cpu_types.h\:____DONT_USE_HIGH_TIMESLICE_MS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ____DONT_USE_HIGH_TIMESLICE_MS{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 88} of file {\b cpu_types.h}.}\par
}
{\xe \v _timeSliceTicks\:cpu_types.h}
{\xe \v cpu_types.h\:_timeSliceTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _timeSliceTicks}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to determine how much time in ms a thread should have before being involuntarily relinquished. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LOW_TIMESLICE_TICKS\:cpu_types.h}
{\xe \v cpu_types.h\:LOW_TIMESLICE_TICKS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LOW_TIMESLICE_TICKS{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
\cell }{\cell }{\row }
{\xe \v DEFAULT_TIMESLICE_TICKS\:cpu_types.h}
{\xe \v cpu_types.h\:DEFAULT_TIMESLICE_TICKS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEFAULT_TIMESLICE_TICKS{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\cell }{\cell }{\row }
{\xe \v HIGH_TIMESLICE_TICKS\:cpu_types.h}
{\xe \v cpu_types.h\:HIGH_TIMESLICE_TICKS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HIGH_TIMESLICE_TICKS{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 97} of file {\b cpu_types.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cpu_types.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu_types.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpu_types.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_CPU_TYPES_H}\par
00002 {\cf21 #define X86_CPU_TYPES_H}\par
00003 \par
00004 {\cf20 // Standard headers, required.}\par
00005 {\cf21 #include <stddef.h>}\par
00006 {\cf21 #include <stdbool.h>}\par
00007 {\cf21 #include <stdint.h>}\par
00008 {\cf21 #include <stdatomic.h>}\par
00009 \par
00010 {\cf20 // Global - Per CPU.}\par
00011 \par
00012 {\cf17 typedef} {\cf17 enum} _THREAD_STATE \{ RUNNING, READY, BLOCKED, TERMINATING, TERMINATED \} THREAD_STATE;\par
00013 \par
00014 {\cf20 // Forwards}\par
00015 {\cf17 typedef} {\cf17 struct }_Thread Thread;\par
00016 {\cf17 typedef} {\cf17 struct }_DPC DPC;\par
00017 {\cf17 typedef} {\cf17 struct }_Queue Queue;\par
00018 {\cf17 typedef} {\cf17 struct }_CPU CPU;\par
00019 \par
00020 {\cf20 // Scheduling disabling is by flipping a global flag, I should make a CPU structure that is the current CPU states and data.}\par
00021 {\cf20 // Interrupts are disabled based on the IRQL <=, so even at the IRQL level they are in they are disabled.}\par
00022 \par
00023 {\cf20 // Interrupt Request Level - Changing this will mask IRQ lines, as well as disabling features of the OS/CPU, like disabling the scheduler when raisng to >= DISPATCH_LEVEL.}\par
00024 {\cf17 typedef} {\cf17 enum} _IRQL \{\par
00025     PASSIVE_LEVEL = 0,   {\cf20 // Normal thread execution, all interrupts enabled.}\par
00026     DISPATCH_LEVEL = 2,   {\cf20 // Scheduler disabled, page faults fatal. (page faults are always fatal for now, until I implement an exception handler TODO)}\par
00027     {\cf20 // Device DIRQLs (chosen so IRQn + DIRQL = PROFILE_LEVEL (27))}\par
00028     DIRQL_SECONDARY_ATA = 12,   {\cf20 // IRQ15 \'96 Secondary ATA Channel  }\par
00029     DIRQL_PRIMARY_ATA = 13,     {\cf20 // IRQ14 \'96 Primary ATA Channel  }\par
00030     DIRQL_FPU = 14,             {\cf20 // IRQ13 \'96 FPU / Coprocessor  }\par
00031     DIRQL_MOUSE = 15,           {\cf20 // IRQ12 \'96 Mouse  }\par
00032     DIRQL_PERIPHERAL11 = 16,    {\cf20 // IRQ11 \'96 Free for peripherals  }\par
00033     DIRQL_PERIPHERAL10 = 17,    {\cf20 // IRQ10 \'96 Free for peripherals  }\par
00034     DIRQL_PERIPHERAL9 = 18,     {\cf20 // IRQ9  \'96 Free / redirected cascade  }\par
00035     DIRQL_RTC = 19,             {\cf20 // IRQ8  \'96 RTC / CMOS Alarm  }\par
00036     DIRQL_LPT1 = 20,            {\cf20 // IRQ7  \'96 LPT1 / Printer  }\par
00037     DIRQL_FLOPPY = 21,          {\cf20 // IRQ6  \'96 Floppy Disk  }\par
00038     DIRQL_SOUND_LPT2 = 22,      {\cf20 // IRQ5  \'96 Sound Card / LPT2  }\par
00039     DIRQL_COM1 = 23,            {\cf20 // IRQ4  \'96 Serial COM1  }\par
00040     DIRQL_COM2 = 24,            {\cf20 // IRQ3  \'96 Serial COM2  }\par
00041     DIRQL_CASCADE = 25,         {\cf20 // IRQ2  \'96 Cascade (IRQs\'A08\'9615)  }\par
00042     DIRQL_KEYBOARD = 26,        {\cf20 // IRQ1  \'96 Keyboard  }\par
00043     DIRQL_TIMER = 27,           {\cf20 // IRQ0  \'96 System Timer  }\par
00044     PROFILE_LEVEL = 27,  {\cf20 // Profile timer interrupts (alias of DIRQL_TIMER)}\par
00045     CLOCK_LEVEL = 28,  {\cf20 // Clock/timer interrupts (second-level timer) (actual clock IRQ timer, for scheduler, time-of-day clock, and general timers, even context switching)}\par
00046     SYNCH_LEVEL = 29,  {\cf20 // Synchronization level (internal kernel use) (unused in my kernel (until SMP), this level is used for multi core CPU synchronization)}\par
00047     POWER_LEVEL = 30,  {\cf20 // Power failure interrupts}\par
00048     HIGH_LEVEL = 31   {\cf20 // NMI and machine-check (non-maskable) (also gets set at bugchecks, to mask all interrupts)}\par
00049 \} IRQL;\par
00050 \par
00051 {\cf17 typedef} {\cf17 struct }_SPINLOCK \{\par
00052     atomic_flag LOCKED;\par
00053 \} SPINLOCK;\par
00054 \par
00055 {\cf21 #pragma pack(push, 1)}\par
00056 {\cf17 typedef} {\cf17 struct }_INT_FRAME \{\par
00057     uint64_t vector;\par
00058     uint64_t error_code;\par
00059     uint64_t rip;\par
00060     uint64_t cs;\par
00061     uint64_t rflags;\par
00062     uint64_t rsp;         {\cf20 // Always present in our software frame}\par
00063     uint64_t ss;          {\cf20 // Always present in our software frame}\par
00064 \} INT_FRAME;\par
00065 {\cf21 #pragma pack(pop)}\par
00066 \par
00067 {\cf20 // Context frame for saving/restoring thread state}\par
00068 {\cf21 #pragma pack(push, 1)}\par
00069 {\cf17 typedef} {\cf17 struct }_CTX_FRAME \{\par
00070     {\cf20 // General-purpose registers, in whatever order your save/restore stub uses}\par
00071     uint64_t r15, r14, r13, r12, r11, r10, r9, r8;\par
00072     uint64_t rbp, rdi, rsi, rdx, rcx, rbx, rax;\par
00073     uint64_t rsp;\par
00074     uint64_t rip;\par
00075 \} CTX_FRAME;\par
00076 {\cf21 #pragma pack(pop)}\par
00077 \par
00078 {\cf17 typedef} {\cf17 struct }_Queue \{\par
00079     Thread* head;\par
00080     Thread* tail;\par
00081 \} Queue;\par
00082 \par
00083 {\cf21 #define TICK_MS 4}\par
00084 \par
00088 {\cf17 typedef} {\cf17 enum} _timeSliceMs \{\par
00089     ____DONT_USE_DEFAULT_TIMESLICE_MS = 40, {\cf20 // Default.}\par
00090     ____DONT_USE_LOW_TIMESLICE_MS = 16, {\cf20 // Low timeslice, for threads/processes with low-none impact on the system.}\par
00091     ____DONT_USE_HIGH_TIMESLICE_MS = 100, {\cf20 // Most time to schedule, used for performance critical tasks.}\par
00092 \} timeSliceMs;\par
00093 \par
00097 {\cf17 typedef} {\cf17 enum} _timeSliceTicks \{\par
00098     LOW_TIMESLICE_TICKS = ____DONT_USE_LOW_TIMESLICE_MS / TICK_MS,   {\cf20 // 4 MS}\par
00099     DEFAULT_TIMESLICE_TICKS = ____DONT_USE_DEFAULT_TIMESLICE_MS / TICK_MS,   {\cf20 // 10 MS}\par
00100     HIGH_TIMESLICE_TICKS = ____DONT_USE_HIGH_TIMESLICE_MS / TICK_MS,   {\cf20 // 25 MS}\par
00101 \} timeSliceTicks;\par
00102 \par
00103 {\cf17 typedef} {\cf17 struct }_Thread \{\par
00104     {\cf20 // CPU Registers for context switching}\par
00105     CTX_FRAME registers;\par
00106 \par
00107     {\cf20 // Scheduling metadata}\par
00108     THREAD_STATE threadState;\par
00109 \par
00110     {\cf20 // Remaining ticks until switch.}\par
00111     uint32_t timeSlice;\par
00112     uint32_t origTimeSlice;\par
00113 \par
00114     Thread* nextThread; {\cf20 // For queue linking.}\par
00115 \par
00116     {\cf20 // Thread ID.}\par
00117     uint32_t TID;\par
00118 \par
00119     {\cf20 // Original Stack Pointer (to free)}\par
00120     {\cf18 void}* startStackPtr;\par
00121     {\cf20 // TODO later: priority, affinity, wait list pointer, etc.}\par
00122 \} Thread;\par
00123 \par
00124 {\cf17 typedef} {\cf17 enum} _DPC_PRIORITY \{\par
00125     NO_PRIORITY = 0,\par
00126     LOW_PRIORITY = 25,\par
00127     MEDIUM_PRIORITY = 50,\par
00128     HIGH_PRIORITY = 75,\par
00129     SYSTEM_PRIORITY = 99\par
00130 \} DPC_PRIORITY;\par
00131 \par
00132 {\cf17 typedef} {\cf17 enum} _DPC_KIND \{\par
00133     NO_KIND = 0,\par
00134     DPC_SCHEDULE,\par
00136 \} DPC_KIND;\par
00137 \par
00138 {\cf17 typedef} {\cf17 struct }_DPC \{\par
00139     {\cf17 volatile} DPC* Next; {\cf20 // Next DPC in the pending queue.}\par
00140     void (*callbackWithCtx)({\cf18 void}* ctx); {\cf20 // Callback entry for this DPC, along with context register info.}\par
00141     void (*callback)(void); \par
00142     CTX_FRAME* ctx; {\cf20 // Caller supplied context pointer (registers)}\par
00143     DPC_KIND Kind;\par
00144     {\cf18 bool} hasCtx;\par
00145     DPC_PRIORITY priority; {\cf20 // A higher value will run earlier than the lower value}\par
00146 \} DPC;\par
00147 \par
00148 {\cf17 typedef} {\cf17 struct }_CPU \{\par
00149     IRQL currentIrql; {\cf20 // Current IRQL global state.}\par
00150     {\cf18 bool} schedulerEnabled; {\cf20 // True/False value if the global scheduler is enabled.}\par
00151     Thread* currentThread; {\cf20 // Pointer to the current thread struct.}\par
00152     Queue readyQueue; {\cf20 // Queue for the next scheduling.}\par
00153 \} CPU;\par
00154 \par
00155 {\cf21 #ifndef _MSC_VER}\par
00156 {\cf17 _Static_assert}({\cf17 sizeof}(CTX_FRAME) == 0x88, {\cf22 "CTX_FRAME must be 0x88 bytes"});\par
00157 {\cf17 _Static_assert}(offsetof(CTX_FRAME, rsp) == 0x78, {\cf22 "CTX_FRAME.rsp offset must be 0x78"});\par
00158 {\cf17 _Static_assert}(offsetof(CTX_FRAME, rip) == 0x80, {\cf22 "CTX_FRAME.rip offset must be 0x80"});\par
00159 \par
00160 {\cf17 _Static_assert}({\cf17 sizeof}(Thread) >= 0xA0, {\cf22 "Thread must be at least 0xA0 bytes"});\par
00161 {\cf17 _Static_assert}(offsetof(Thread, threadState) == 0x88, {\cf22 "Thread.threadState offset must be 0x88"});\par
00162 {\cf17 _Static_assert}(offsetof(Thread, timeSlice) == 0x8C, {\cf22 "Thread.timeSlice offset must be 0x8C"});\par
00163 {\cf17 _Static_assert}(offsetof(Thread, origTimeSlice) == 0x90, {\cf22 "Thread.origTimeSlice offset must be 0x90"});\par
00164 {\cf17 _Static_assert}(offsetof(Thread, nextThread) == 0x98, {\cf22 "Thread.nextThread offset must be 0x98"});\par
00165 {\cf21 #endif}\par
00166 \par
00167 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpuid/cpuid.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpuid/cpuid.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpuid/cpuid.h}
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <cpuid.h>}\par
{\f2 #include "../../memory/memory.h"}\par
{\f2 #include "../../trace.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AMD}\~ "AuthenticAMD"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AMD_OLD}\~ "AMDisbetter!"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_INTEL}\~ "GenuineIntel"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VIA}\~ "VIA VIA VIA "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_TRANSMETA}\~ "GenuineTMx86"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_TRANSMETA_OLD}\~ "TransmetaCPU"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_CYRIX}\~ "CyrixInstead"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_CENTAUR}\~ "CentaurHauls"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_NEXGEN}\~ "NexGenDriven"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_UMC}\~ "UMC UMC UMC "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_SIS}\~ "SiS SiS SiS "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_NSC}\~ "Geode by NSC"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_RISE}\~ "RiseRiseRise"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VORTEX}\~ "Vortex86 SoC"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AO486}\~ "MiSTer AO486"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AO486_OLD}\~ "GenuineAO486"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_ZHAOXIN}\~ "  Shanghai  "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_HYGON}\~ "HygonGenuine"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_ELBRUS}\~ "E2K MACHINE "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_QEMU}\~ "TCGTCGTCGTCG"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_KVM}\~ " KVMKVMKVM  "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VMWARE}\~ "VMwareVMware"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VIRTUALBOX}\~ "VBoxVBoxVBox"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_XEN}\~ "XenVMMXenVMM"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_HYPERV}\~ "Microsoft Hv"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_PARALLELS}\~ " prl hyperv "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_PARALLELS_ALT}\~ " lrpepyh vr "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_BHYVE}\~ "bhyve bhyve "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_QNX}\~ " QNXQVMBSQG "\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b CPUID_FEAT_ECX_SSE3} = 1 << 0
, {\b CPUID_FEAT_ECX_PCLMUL} = 1 << 1
, {\b CPUID_FEAT_ECX_DTES64} = 1 << 2
, {\b CPUID_FEAT_ECX_MONITOR} = 1 << 3
, {\b CPUID_FEAT_ECX_DS_CPL} = 1 << 4
, {\b CPUID_FEAT_ECX_VMX} = 1 << 5
, {\b CPUID_FEAT_ECX_SMX} = 1 << 6
, {\b CPUID_FEAT_ECX_EST} = 1 << 7
, {\b CPUID_FEAT_ECX_TM2} = 1 << 8
, {\b CPUID_FEAT_ECX_SSSE3} = 1 << 9
, {\b CPUID_FEAT_ECX_CID} = 1 << 10
, {\b CPUID_FEAT_ECX_SDBG} = 1 << 11
, {\b CPUID_FEAT_ECX_FMA} = 1 << 12
, {\b CPUID_FEAT_ECX_CX16} = 1 << 13
, {\b CPUID_FEAT_ECX_XTPR} = 1 << 14
, {\b CPUID_FEAT_ECX_PDCM} = 1 << 15
, {\b CPUID_FEAT_ECX_PCID} = 1 << 17
, {\b CPUID_FEAT_ECX_DCA} = 1 << 18
, {\b CPUID_FEAT_ECX_SSE4_1} = 1 << 19
, {\b CPUID_FEAT_ECX_SSE4_2} = 1 << 20
, {\b CPUID_FEAT_ECX_X2APIC} = 1 << 21
, {\b CPUID_FEAT_ECX_MOVBE} = 1 << 22
, {\b CPUID_FEAT_ECX_POPCNT} = 1 << 23
, {\b CPUID_FEAT_ECX_TSC} = 1 << 24
, {\b CPUID_FEAT_ECX_AES} = 1 << 25
, {\b CPUID_FEAT_ECX_XSAVE} = 1 << 26
, {\b CPUID_FEAT_ECX_OSXSAVE} = 1 << 27
, {\b CPUID_FEAT_ECX_AVX} = 1 << 28
, {\b CPUID_FEAT_ECX_F16C} = 1 << 29
, {\b CPUID_FEAT_ECX_RDRAND} = 1 << 30
, {\b CPUID_FEAT_ECX_HYPERVISOR} = 1 << 31
, {\b CPUID_FEAT_EDX_FPU} = 1 << 0
, {\b CPUID_FEAT_EDX_VME} = 1 << 1
, {\b CPUID_FEAT_EDX_DE} = 1 << 2
, {\b CPUID_FEAT_EDX_PSE} = 1 << 3
, {\b CPUID_FEAT_EDX_TSC} = 1 << 4
, {\b CPUID_FEAT_EDX_MSR} = 1 << 5
, {\b CPUID_FEAT_EDX_PAE} = 1 << 6
, {\b CPUID_FEAT_EDX_MCE} = 1 << 7
, {\b CPUID_FEAT_EDX_CX8} = 1 << 8
, {\b CPUID_FEAT_EDX_APIC} = 1 << 9
, {\b CPUID_FEAT_EDX_SEP} = 1 << 11
, {\b CPUID_FEAT_EDX_MTRR} = 1 << 12
, {\b CPUID_FEAT_EDX_PGE} = 1 << 13
, {\b CPUID_FEAT_EDX_MCA} = 1 << 14
, {\b CPUID_FEAT_EDX_CMOV} = 1 << 15
, {\b CPUID_FEAT_EDX_PAT} = 1 << 16
, {\b CPUID_FEAT_EDX_PSE36} = 1 << 17
, {\b CPUID_FEAT_EDX_PSN} = 1 << 18
, {\b CPUID_FEAT_EDX_CLFLUSH} = 1 << 19
, {\b CPUID_FEAT_EDX_DS} = 1 << 21
, {\b CPUID_FEAT_EDX_ACPI} = 1 << 22
, {\b CPUID_FEAT_EDX_MMX} = 1 << 23
, {\b CPUID_FEAT_EDX_FXSR} = 1 << 24
, {\b CPUID_FEAT_EDX_SSE} = 1 << 25
, {\b CPUID_FEAT_EDX_SSE2} = 1 << 26
, {\b CPUID_FEAT_EDX_SS} = 1 << 27
, {\b CPUID_FEAT_EDX_HTT} = 1 << 28
, {\b CPUID_FEAT_EDX_TM} = 1 << 29
, {\b CPUID_FEAT_EDX_IA64} = 1 << 30
, {\b CPUID_FEAT_EDX_PBE} = 1 << 31
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkcpuid} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if the CPUID assembly instruction is available in the current {\b CPU}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CPUID_VENDOR_AMD\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_AMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AMD\~ "AuthenticAMD"}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_AMD_OLD\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_AMD_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AMD_OLD\~ "AMDisbetter!"}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_AO486\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_AO486}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AO486\~ "MiSTer AO486"}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_AO486_OLD\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_AO486_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AO486_OLD\~ "GenuineAO486"}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_BHYVE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_BHYVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_BHYVE\~ "bhyve bhyve "}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_CENTAUR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_CENTAUR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_CENTAUR\~ "CentaurHauls"}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_CYRIX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_CYRIX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_CYRIX\~ "CyrixInstead"}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_ELBRUS\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_ELBRUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_ELBRUS\~ "E2K MACHINE "}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_HYGON\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_HYGON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_HYGON\~ "HygonGenuine"}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_HYPERV\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_HYPERV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_HYPERV\~ "Microsoft Hv"}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_INTEL\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_INTEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_INTEL\~ "GenuineIntel"}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_KVM\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_KVM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_KVM\~ " KVMKVMKVM  "}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_NEXGEN\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_NEXGEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_NEXGEN\~ "NexGenDriven"}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_NSC\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_NSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_NSC\~ "Geode by NSC"}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_PARALLELS\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_PARALLELS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_PARALLELS\~ " prl hyperv "}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_PARALLELS_ALT\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_PARALLELS_ALT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_PARALLELS_ALT\~ " lrpepyh vr "}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_QEMU\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_QEMU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_QEMU\~ "TCGTCGTCGTCG"}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_QNX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_QNX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_QNX\~ " QNXQVMBSQG "}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_RISE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_RISE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_RISE\~ "RiseRiseRise"}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_SIS\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_SIS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_SIS\~ "SiS SiS SiS "}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_TRANSMETA\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_TRANSMETA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_TRANSMETA\~ "GenuineTMx86"}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_TRANSMETA_OLD\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_TRANSMETA_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_TRANSMETA_OLD\~ "TransmetaCPU"}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_UMC\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_UMC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_UMC\~ "UMC UMC UMC "}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_VIA\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_VIA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VIA\~ "VIA VIA VIA "}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_VIRTUALBOX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_VIRTUALBOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VIRTUALBOX\~ "VBoxVBoxVBox"}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_VMWARE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_VMWARE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VMWARE\~ "VMwareVMware"}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_VORTEX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_VORTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VORTEX\~ "Vortex86 SoC"}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_XEN\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_XEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_XEN\~ "XenVMMXenVMM"}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b cpuid.h}.}\par
}
{\xe \v CPUID_VENDOR_ZHAOXIN\:cpuid.h}
{\xe \v cpuid.h\:CPUID_VENDOR_ZHAOXIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_ZHAOXIN\~ "  Shanghai  "}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b cpuid.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CPUID_FEAT_ECX_SSE3\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_SSE3}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSE3{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_PCLMUL\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_PCLMUL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_PCLMUL{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_DTES64\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_DTES64}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_DTES64{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_MONITOR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_MONITOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_MONITOR{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_DS_CPL\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_DS_CPL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_DS_CPL{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_VMX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_VMX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_VMX{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SMX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_SMX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SMX{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_EST\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_EST}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_EST{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_TM2\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_TM2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_TM2{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SSSE3\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_SSSE3}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSSE3{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_CID\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_CID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_CID{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SDBG\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_SDBG}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SDBG{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_FMA\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_FMA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_FMA{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_CX16\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_CX16}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_CX16{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_XTPR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_XTPR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_XTPR{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_PDCM\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_PDCM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_PDCM{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_PCID\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_PCID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_PCID{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_DCA\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_DCA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_DCA{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SSE4_1\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_SSE4_1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSE4_1{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SSE4_2\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_SSE4_2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSE4_2{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_X2APIC\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_X2APIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_X2APIC{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_MOVBE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_MOVBE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_MOVBE{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_POPCNT\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_POPCNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_POPCNT{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_TSC\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_TSC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_TSC{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_AES\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_AES}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_AES{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_XSAVE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_XSAVE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_XSAVE{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_OSXSAVE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_OSXSAVE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_OSXSAVE{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_AVX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_AVX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_AVX{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_F16C\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_F16C}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_F16C{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_RDRAND\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_RDRAND}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_RDRAND{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_HYPERVISOR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_ECX_HYPERVISOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_HYPERVISOR{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_FPU\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_FPU}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_FPU{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_VME\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_VME}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_VME{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_DE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_DE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_DE{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PSE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PSE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PSE{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_TSC\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_TSC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_TSC{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MSR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_MSR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MSR{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PAE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PAE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PAE{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MCE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_MCE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MCE{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_CX8\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_CX8}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_CX8{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_APIC\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_APIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_APIC{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SEP\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_SEP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SEP{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MTRR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_MTRR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MTRR{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PGE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PGE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PGE{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MCA\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_MCA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MCA{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_CMOV\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_CMOV}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_CMOV{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PAT\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PAT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PAT{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PSE36\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PSE36}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PSE36{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PSN\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PSN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PSN{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_CLFLUSH\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_CLFLUSH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_CLFLUSH{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_DS\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_DS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_DS{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_ACPI\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_ACPI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_ACPI{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MMX\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_MMX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MMX{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_FXSR\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_FXSR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_FXSR{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SSE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_SSE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SSE{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SSE2\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_SSE2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SSE2{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SS\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_SS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SS{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_HTT\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_HTT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_HTT{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_TM\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_TM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_TM{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_IA64\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_IA64}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_IA64{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PBE\:cpuid.h}
{\xe \v cpuid.h\:CPUID_FEAT_EDX_PBE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PBE{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 45} of file {\b cpuid.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v checkcpuid\:cpuid.h}
{\xe \v cpuid.h\:checkcpuid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkcpuid (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if the CPUID assembly instruction is available in the current {\b CPU}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True / False based if present or not.\par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cpuid.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpuid/cpuid.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/cpuid/cpuid.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_CPUID}\par
00002 {\cf21 #define X86_CPUID}\par
00003 \par
00004 {\cf21 #include <stddef.h>}\par
00005 {\cf21 #include <stdbool.h>}\par
00006 {\cf21 #include <stdint.h>}\par
00007 {\cf21 #include <cpuid.h>}\par
00008 {\cf21 #include "../../memory/memory.h"}\par
00009 \par
00010 {\cf21 #include "../../trace.h"}\par
00011 \par
00012 {\cf20 // Vendor strings from CPUs.}\par
00013 {\cf21 #define CPUID_VENDOR_AMD           "AuthenticAMD"}\par
00014 {\cf21 #define CPUID_VENDOR_AMD_OLD       "AMDisbetter!" }{\cf20 // Early engineering samples of AMD K5 processor}\par
00015 {\cf21 #define CPUID_VENDOR_INTEL         "GenuineIntel"}\par
00016 {\cf21 #define CPUID_VENDOR_VIA           "VIA VIA VIA "}\par
00017 {\cf21 #define CPUID_VENDOR_TRANSMETA     "GenuineTMx86"}\par
00018 {\cf21 #define CPUID_VENDOR_TRANSMETA_OLD "TransmetaCPU"}\par
00019 {\cf21 #define CPUID_VENDOR_CYRIX         "CyrixInstead"}\par
00020 {\cf21 #define CPUID_VENDOR_CENTAUR       "CentaurHauls"}\par
00021 {\cf21 #define CPUID_VENDOR_NEXGEN        "NexGenDriven"}\par
00022 {\cf21 #define CPUID_VENDOR_UMC           "UMC UMC UMC "}\par
00023 {\cf21 #define CPUID_VENDOR_SIS           "SiS SiS SiS "}\par
00024 {\cf21 #define CPUID_VENDOR_NSC           "Geode by NSC"}\par
00025 {\cf21 #define CPUID_VENDOR_RISE          "RiseRiseRise"}\par
00026 {\cf21 #define CPUID_VENDOR_VORTEX        "Vortex86 SoC"}\par
00027 {\cf21 #define CPUID_VENDOR_AO486         "MiSTer AO486"}\par
00028 {\cf21 #define CPUID_VENDOR_AO486_OLD     "GenuineAO486"}\par
00029 {\cf21 #define CPUID_VENDOR_ZHAOXIN       "  Shanghai  "}\par
00030 {\cf21 #define CPUID_VENDOR_HYGON         "HygonGenuine"}\par
00031 {\cf21 #define CPUID_VENDOR_ELBRUS        "E2K MACHINE "}\par
00032 \par
00033 {\cf20 // Vendor strings from hypervisors.}\par
00034 {\cf21 #define CPUID_VENDOR_QEMU          "TCGTCGTCGTCG"}\par
00035 {\cf21 #define CPUID_VENDOR_KVM           " KVMKVMKVM  "}\par
00036 {\cf21 #define CPUID_VENDOR_VMWARE        "VMwareVMware"}\par
00037 {\cf21 #define CPUID_VENDOR_VIRTUALBOX    "VBoxVBoxVBox"}\par
00038 {\cf21 #define CPUID_VENDOR_XEN           "XenVMMXenVMM"}\par
00039 {\cf21 #define CPUID_VENDOR_HYPERV        "Microsoft Hv"}\par
00040 {\cf21 #define CPUID_VENDOR_PARALLELS     " prl hyperv "}\par
00041 {\cf21 #define CPUID_VENDOR_PARALLELS_ALT " lrpepyh vr " }{\cf20 // Sometimes Parallels incorrectly encodes "prl hyperv" as "lrpepyh vr" due to an endianness mismatch.}\par
00042 {\cf21 #define CPUID_VENDOR_BHYVE         "bhyve bhyve "}\par
00043 {\cf21 #define CPUID_VENDOR_QNX           " QNXQVMBSQG "}\par
00044 \par
00045 {\cf17 enum} \{\par
00046     CPUID_FEAT_ECX_SSE3         = 1 << 0,\par
00047     CPUID_FEAT_ECX_PCLMUL       = 1 << 1,\par
00048     CPUID_FEAT_ECX_DTES64       = 1 << 2,\par
00049     CPUID_FEAT_ECX_MONITOR      = 1 << 3,\par
00050     CPUID_FEAT_ECX_DS_CPL       = 1 << 4,\par
00051     CPUID_FEAT_ECX_VMX          = 1 << 5,\par
00052     CPUID_FEAT_ECX_SMX          = 1 << 6,\par
00053     CPUID_FEAT_ECX_EST          = 1 << 7,\par
00054     CPUID_FEAT_ECX_TM2          = 1 << 8,\par
00055     CPUID_FEAT_ECX_SSSE3        = 1 << 9,\par
00056     CPUID_FEAT_ECX_CID          = 1 << 10,\par
00057     CPUID_FEAT_ECX_SDBG         = 1 << 11,\par
00058     CPUID_FEAT_ECX_FMA          = 1 << 12,\par
00059     CPUID_FEAT_ECX_CX16         = 1 << 13,\par
00060     CPUID_FEAT_ECX_XTPR         = 1 << 14,\par
00061     CPUID_FEAT_ECX_PDCM         = 1 << 15,\par
00062     CPUID_FEAT_ECX_PCID         = 1 << 17,\par
00063     CPUID_FEAT_ECX_DCA          = 1 << 18,\par
00064     CPUID_FEAT_ECX_SSE4_1       = 1 << 19,\par
00065     CPUID_FEAT_ECX_SSE4_2       = 1 << 20,\par
00066     CPUID_FEAT_ECX_X2APIC       = 1 << 21,\par
00067     CPUID_FEAT_ECX_MOVBE        = 1 << 22,\par
00068     CPUID_FEAT_ECX_POPCNT       = 1 << 23,\par
00069     CPUID_FEAT_ECX_TSC          = 1 << 24,\par
00070     CPUID_FEAT_ECX_AES          = 1 << 25,\par
00071     CPUID_FEAT_ECX_XSAVE        = 1 << 26,\par
00072     CPUID_FEAT_ECX_OSXSAVE      = 1 << 27,\par
00073     CPUID_FEAT_ECX_AVX          = 1 << 28,\par
00074     CPUID_FEAT_ECX_F16C         = 1 << 29,\par
00075     CPUID_FEAT_ECX_RDRAND       = 1 << 30,\par
00076     CPUID_FEAT_ECX_HYPERVISOR   = 1 << 31,\par
00077 \par
00078     CPUID_FEAT_EDX_FPU          = 1 << 0,\par
00079     CPUID_FEAT_EDX_VME          = 1 << 1,\par
00080     CPUID_FEAT_EDX_DE           = 1 << 2,\par
00081     CPUID_FEAT_EDX_PSE          = 1 << 3,\par
00082     CPUID_FEAT_EDX_TSC          = 1 << 4,\par
00083     CPUID_FEAT_EDX_MSR          = 1 << 5,\par
00084     CPUID_FEAT_EDX_PAE          = 1 << 6,\par
00085     CPUID_FEAT_EDX_MCE          = 1 << 7,\par
00086     CPUID_FEAT_EDX_CX8          = 1 << 8,\par
00087     CPUID_FEAT_EDX_APIC         = 1 << 9,\par
00088     CPUID_FEAT_EDX_SEP          = 1 << 11,\par
00089     CPUID_FEAT_EDX_MTRR         = 1 << 12,\par
00090     CPUID_FEAT_EDX_PGE          = 1 << 13,\par
00091     CPUID_FEAT_EDX_MCA          = 1 << 14,\par
00092     CPUID_FEAT_EDX_CMOV         = 1 << 15,\par
00093     CPUID_FEAT_EDX_PAT          = 1 << 16,\par
00094     CPUID_FEAT_EDX_PSE36        = 1 << 17,\par
00095     CPUID_FEAT_EDX_PSN          = 1 << 18,\par
00096     CPUID_FEAT_EDX_CLFLUSH      = 1 << 19,\par
00097     CPUID_FEAT_EDX_DS           = 1 << 21,\par
00098     CPUID_FEAT_EDX_ACPI         = 1 << 22,\par
00099     CPUID_FEAT_EDX_MMX          = 1 << 23,\par
00100     CPUID_FEAT_EDX_FXSR         = 1 << 24,\par
00101     CPUID_FEAT_EDX_SSE          = 1 << 25,\par
00102     CPUID_FEAT_EDX_SSE2         = 1 << 26,\par
00103     CPUID_FEAT_EDX_SS           = 1 << 27,\par
00104     CPUID_FEAT_EDX_HTT          = 1 << 28,\par
00105     CPUID_FEAT_EDX_TM           = 1 << 29,\par
00106     CPUID_FEAT_EDX_IA64         = 1 << 30,\par
00107     CPUID_FEAT_EDX_PBE          = 1 << 31\par
00108 \};\par
00109 \par
00114 {\cf17 extern} {\cf18 bool} checkcpuid({\cf18 void});\par
00115 \par
00116 {\cf20 // Get CPU Model number}\par
00117 {\cf17 static} {\cf17 inline} {\cf18 int} getCpuModel({\cf18 void}) \{\par
00118     {\cf18 int} ebx, unused;\par
00119     __cpuid(0, unused, ebx, unused, unused);\par
00120     {\cf19 return} ebx;\par
00121 \}\par
00122 \par
00123 {\cf20 // Check for APIC Availability}\par
00124 {\cf17 static} {\cf17 inline} {\cf18 bool} checkApic({\cf18 void}) \{\par
00125     {\cf18 unsigned} {\cf18 int} eax, ebx, ecx, edx;\par
00126     __cpuid(1, eax, ebx, ecx, edx);\par
00127     {\cf19 return} edx & (1 << 9); {\cf20 // bit 9 = APIC}\par
00128 \}\par
00129 \par
00130 {\cf17 static} {\cf17 inline} {\cf18 void} getCpuName({\cf18 char}* name) \{\par
00131     {\cf18 unsigned} {\cf18 int} regs[4];\par
00132     {\cf18 char}* p = name;\par
00133 \par
00134     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < 3; i++) \{\par
00135         __cpuid(0x80000002 + i, regs[0], regs[1], regs[2], regs[3]);\par
00136         kmemcpy(p, regs, {\cf17 sizeof}(regs));\par
00137         p += {\cf17 sizeof}(regs);\par
00138     \}\par
00139     *p = {\cf23 '\\0'}; {\cf20 // Null-terminate}\par
00140 \}\par
00141 \par
00142 \par
00143 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.c}
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "dpc.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_dpc_system} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtQueueDPC} (volatile {\b DPC} *dpc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RetireDPCs} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b DPC} * {\b dpcQueueHead} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b DPC} * {\b dpcQueueTail} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b schedule_pending} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_dpc_system\:dpc.c}
{\xe \v dpc.c\:init_dpc_system}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_dpc_system (void )}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deferred procedure calls (Like in Windows - {\f2 https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-dpcs}) Basically, they are function calls that happen in the interrupt service routine, in order to lower {\b IRQL} instead of staying in such a high {\b IRQL}. And to manage things that happen inside of the service routine effictively. \par
}{
Definition at line {\b 16} of file {\b dpc.c}.}\par
}
{\xe \v MtQueueDPC\:dpc.c}
{\xe \v dpc.c\:MtQueueDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtQueueDPC (volatile {\b DPC} * dpc)}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enqueue {\b DPC} for deferred exceution Safe to at ANY {\b IRQL}. \par
}{
Definition at line {\b 21} of file {\b dpc.c}.}\par
}
{\xe \v RetireDPCs\:dpc.c}
{\xe \v dpc.c\:RetireDPCs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RetireDPCs (void )}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Walk through the {\b DPC} queue, raising the {\b IRQL} to DISPATCH_LEVEL in the process. This gets called in a kernel idle (main) function thread. \par
}{
Definition at line {\b 54} of file {\b dpc.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v dpcQueueHead\:dpc.c}
{\xe \v dpc.c\:dpcQueueHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b DPC}* dpcQueueHead = NULL}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b dpc.c}.}\par
}
{\xe \v dpcQueueTail\:dpc.c}
{\xe \v dpc.c\:dpcQueueTail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b DPC}* dpcQueueTail = NULL}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b dpc.c}.}\par
}
{\xe \v schedule_pending\:dpc.c}
{\xe \v dpc.c\:schedule_pending}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool schedule_pending = false}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b dpc.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dpc.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      DPC Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "dpc.h"}\par
00008 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00009 \par
00010 {\cf17 volatile} DPC* dpcQueueHead = NULL;\par
00011 {\cf17 volatile} DPC* dpcQueueTail = NULL;\par
00012 \par
00013 {\cf17 volatile} {\cf18 bool} schedule_pending = {\cf17 false};\par
00014 {\cf17 static} SPINLOCK dpc_lock; {\cf20 // SPINLOCK for the dpc, only 1 thread is allowed to use it at a time.}\par
00015 \par
00016 {\cf18 void} init_dpc_system({\cf18 void}) \{\par
00017     tracelast_func({\cf22 "init_dpc_system"});\par
00018     dpcQueueHead = dpcQueueTail = NULL;\par
00019 \}\par
00020 \par
00021 {\cf18 void} MtQueueDPC({\cf17 volatile} DPC* dpc) \{\par
00022     tracelast_func({\cf22 "queue_dpc"});\par
00023     {\cf19 if} (!dpc) {\cf19 return};\par
00024     dpc->Next = NULL;\par
00025 \par
00026     {\cf20 // Sorted insertion mechanism by priority (higher priority -> inserted to the head)}\par
00027     {\cf19 if} (!dpcQueueHead) \{\par
00028         {\cf20 // Starting with empty queue.}\par
00029         dpcQueueHead = dpcQueueTail = dpc;\par
00030         {\cf19 return};\par
00031     \}\par
00032     {\cf20 // not an empty queue -> check priority.}\par
00033     {\cf20 // check if the priority is highest.}\par
00034     {\cf19 if} (dpc->priority > dpcQueueHead->priority) \{\par
00035         {\cf20 // Insert at the front (head)}\par
00036         dpc->Next = dpcQueueHead;\par
00037         dpcQueueHead = dpc;\par
00038         {\cf19 return};\par
00039     \}\par
00040     {\cf20 // else, find our insertion point.}\par
00041     {\cf17 volatile} DPC* cur = dpcQueueHead;\par
00042     {\cf20 // Check each DPC entry for it's priority, and insert the DPC requested accordingly.}\par
00043     {\cf19 while} (cur->Next && cur->Next->priority >= dpc->priority) \{\par
00044         cur = cur->Next;\par
00045     \}\par
00046     {\cf20 // Singular linked list.}\par
00047     dpc->Next = cur->Next;\par
00048     cur->Next = dpc;\par
00049     {\cf19 if} (!dpc->Next) \{\par
00050         dpcQueueTail = dpc;\par
00051     \}\par
00052 \}\par
00053 \par
00054 {\cf18 void} RetireDPCs({\cf18 void}) \{\par
00055     tracelast_func({\cf22 "RetireDPCs"});\par
00056     {\cf19 if} (!dpcQueueHead) {\cf19 return};\par
00057 \par
00058     IRQL oldIrql;\par
00059     uint64_t flags;\par
00060 \par
00061     {\cf20 // 1) Raise once}\par
00062     MtRaiseIRQL(DISPATCH_LEVEL, &oldIrql);\par
00063 \par
00064     {\cf20 // 2) Acquire lock for the whole drain}\par
00065     MtAcquireSpinlock(&dpc_lock, &flags);\par
00066 \par
00067     {\cf20 // 3) Drain the queue}\par
00068     {\cf19 while} (dpcQueueHead) \{\par
00069         {\cf17 volatile} DPC* d = dpcQueueHead;\par
00070         dpcQueueHead = d->Next;\par
00071         {\cf19 if} (!dpcQueueHead) \{\par
00072             dpcQueueTail = NULL;\par
00073         \}\par
00074         {\cf20 // release lock so callback can queue new DPCs if needed}\par
00075         MtReleaseSpinlock(&dpc_lock, flags);\par
00076 \par
00077         {\cf20 // STILL at DISPATCH_LEVEL}\par
00078         {\cf19 if} (d->hasCtx)      d->callbackWithCtx(d->ctx);\par
00079         {\cf19 else} {\cf19 if} (d->callback) d->callback();\par
00080 \par
00081         {\cf20 // re-acquire for next pop}\par
00082         MtAcquireSpinlock(&dpc_lock, &flags);\par
00083     \}\par
00084 \par
00085     {\cf20 // 4) Release lock and lower once}\par
00086     MtReleaseSpinlock(&dpc_lock, flags);\par
00087     MtLowerIRQL(oldIrql);\par
00088 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.h}
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include "../cpu.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_dpc_system} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtQueueDPC} (volatile {\b DPC} *dpc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RetireDPCs} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_dpc_system\:dpc.h}
{\xe \v dpc.h\:init_dpc_system}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_dpc_system (void )}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deferred procedure calls (Like in Windows - {\f2 https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-dpcs}) Basically, they are function calls that happen in the interrupt service routine, in order to lower {\b IRQL} instead of staying in such a high {\b IRQL}. And to manage things that happen inside of the service routine effictively. \par
}{
Definition at line {\b 16} of file {\b dpc.c}.}\par
}
{\xe \v MtQueueDPC\:dpc.h}
{\xe \v dpc.h\:MtQueueDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtQueueDPC (volatile {\b DPC} * dpc)}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Enqueue {\b DPC} for deferred exceution Safe to at ANY {\b IRQL}. \par
}{
Definition at line {\b 21} of file {\b dpc.c}.}\par
}
{\xe \v RetireDPCs\:dpc.h}
{\xe \v dpc.h\:RetireDPCs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RetireDPCs (void )}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Walk through the {\b DPC} queue, raising the {\b IRQL} to DISPATCH_LEVEL in the process. This gets called in a kernel idle (main) function thread. \par
}{
Definition at line {\b 54} of file {\b dpc.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dpc.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      DPC Types and Function Headers.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_DPC_H}\par
00008 {\cf21 #define X86_DPC_H}\par
00009 \par
00010 {\cf21 #include <stdbool.h>}\par
00011 {\cf21 #include <stdint.h>}\par
00012 {\cf21 #include <stddef.h>}\par
00013 {\cf21 #include "../cpu.h"}\par
00014 \par
00018 {\cf18 void} init_dpc_system({\cf18 void});\par
00019 \par
00022 {\cf18 void} MtQueueDPC({\cf17 volatile} DPC* dpc);\par
00023 \par
00026 {\cf18 void} RetireDPCs({\cf18 void});\par
00027 \par
00028 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.c}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../cpu.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ScheduleDPC} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ScheduleDPC, used to enable the Scheduling_needed flag to TRUE. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b schedule_pending}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ScheduleDPC\:dpc_list.c}
{\xe \v dpc_list.c\:ScheduleDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ScheduleDPC (void )}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ScheduleDPC, used to enable the Scheduling_needed flag to TRUE. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line {\b 10} of file {\b dpc_list.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v schedule_pending\:dpc_list.c}
{\xe \v dpc_list.c\:schedule_pending}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool schedule_pending{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b dpc.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dpc_list.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Full DPC Function list (for kernel ISR's)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../cpu.h"}\par
00008 {\cf17 extern} {\cf17 volatile} {\cf18 bool} schedule_pending;\par
00009 \par
00010 {\cf18 void} ScheduleDPC({\cf18 void}) \{\par
00011     schedule_pending = {\cf17 true};\par
00012 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.h}
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b keyboard_dpc} (void *ctxfr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Keyboard Handling {\b DPC}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ScheduleDPC} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ScheduleDPC, used to enable the Scheduling_needed flag to TRUE. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v keyboard_dpc\:dpc_list.h}
{\xe \v dpc_list.h\:keyboard_dpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void keyboard_dpc (void * ctxfr)}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Keyboard Handling {\b DPC}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scancode} \cell }{Scancode (RDI)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i extended} \cell }{Is Extended Scancode? (RSI)\cell }
{\row }
}
}}
{\xe \v ScheduleDPC\:dpc_list.h}
{\xe \v dpc_list.h\:ScheduleDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ScheduleDPC (void )}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ScheduleDPC, used to enable the Scheduling_needed flag to TRUE. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line {\b 10} of file {\b dpc_list.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dpc_list.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/dpc/dpc_list.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      DPC Function list.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_DPC_FUNCS_H}\par
00008 {\cf21 #define X86_DPC_FUNCS_H}\par
00009 \par
00015 {\cf18 void} keyboard_dpc({\cf18 void}* ctxfr);\par
00016 \par
00021 {\cf18 void} ScheduleDPC({\cf18 void});\par
00022 \par
00023 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.c}
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "irql.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
{\f2 #include "../../interrupts/idt.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IRQ_LINES}\~ (sizeof({\b irq_irql}) / sizeof({\b irq_irql}[0]))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update_pic_mask_for_current_irql} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtGetCurrentIRQL} ({\b IRQL} *out)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtRaiseIRQL} ({\b IRQL} new_irql, {\b IRQL} *old_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtLowerIRQL} ({\b IRQL} new_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _MtSetIRQL} ({\b IRQL} new_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enforce_max_irql} ({\b IRQL} max_allowed, void *RIP)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRQL} {\b irq_irql} [16]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IRQ_LINES\:irql.c}
{\xe \v irql.c\:IRQ_LINES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IRQ_LINES\~ (sizeof({\b irq_irql}) / sizeof({\b irq_irql}[0]))}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b irql.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _MtSetIRQL\:irql.c}
{\xe \v irql.c\:_MtSetIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _MtSetIRQL ({\b IRQL} new_irql)}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b irql.c}.}\par
}
{\xe \v enforce_max_irql\:irql.c}
{\xe \v irql.c\:enforce_max_irql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void enforce_max_irql ({\b IRQL} max_allowed, void * RIP)}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b irql.c}.}\par
}
{\xe \v MtGetCurrentIRQL\:irql.c}
{\xe \v irql.c\:MtGetCurrentIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtGetCurrentIRQL ({\b IRQL} * out)}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b irql.c}.}\par
}
{\xe \v MtLowerIRQL\:irql.c}
{\xe \v irql.c\:MtLowerIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtLowerIRQL ({\b IRQL} new_irql)}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b irql.c}.}\par
}
{\xe \v MtRaiseIRQL\:irql.c}
{\xe \v irql.c\:MtRaiseIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtRaiseIRQL ({\b IRQL} new_irql, {\b IRQL} * old_irql)}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b irql.c}.}\par
}
{\xe \v update_pic_mask_for_current_irql\:irql.c}
{\xe \v irql.c\:update_pic_mask_for_current_irql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update_pic_mask_for_current_irql (void )}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b irql.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v irq_irql\:irql.c}
{\xe \v irql.c\:irq_irql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IRQL} irq_irql[16]}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    DIRQL_TIMER, DIRQL_KEYBOARD, DIRQL_CASCADE, DIRQL_COM2,\par
    DIRQL_COM1, DIRQL_SOUND_LPT2, DIRQL_FLOPPY, DIRQL_LPT1,\par
    DIRQL_RTC, DIRQL_PERIPHERAL9, DIRQL_PERIPHERAL10, DIRQL_PERIPHERAL11,\par
    DIRQL_MOUSE, DIRQL_FPU, DIRQL_PRIMARY_ATA, DIRQL_SECONDARY_ATA\par
\}\par
}
{
Definition at line {\b 11} of file {\b irql.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
irql.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      IRQL Implementation (Fixed with Dispatch Level scheduling toggle)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "irql.h"}\par
00008 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00009 {\cf21 #include "../../interrupts/idt.h"}\par
00010 \par
00011 IRQL irq_irql[16] = \{\par
00012     DIRQL_TIMER, DIRQL_KEYBOARD, DIRQL_CASCADE, DIRQL_COM2,\par
00013     DIRQL_COM1, DIRQL_SOUND_LPT2, DIRQL_FLOPPY, DIRQL_LPT1,\par
00014     DIRQL_RTC, DIRQL_PERIPHERAL9, DIRQL_PERIPHERAL10, DIRQL_PERIPHERAL11,\par
00015     DIRQL_MOUSE, DIRQL_FPU, DIRQL_PRIMARY_ATA, DIRQL_SECONDARY_ATA\par
00016 \};\par
00017 \par
00018 {\cf21 #define IRQ_LINES (sizeof(irq_irql) / sizeof(irq_irql[0]))}\par
00019 \par
00020 {\cf17 static} {\cf17 inline} {\cf18 bool} interrupts_enabled({\cf18 void}) \{\par
00021     {\cf18 unsigned} {\cf18 long} flags;\par
00022     __asm__ __volatile__({\cf22 "pushfq; popq %0"} : {\cf22 "=r"}(flags));\par
00023     {\cf19 return} (flags & (1UL << 9)) != 0; {\cf20 // IF is bit 9}\par
00024 \}\par
00025 \par
00026 {\cf20 // IMPORTANT: We disable interrupts around PIC updates to avoid races.}\par
00027 {\cf18 void} update_pic_mask_for_current_irql({\cf18 void}) \{\par
00028     {\cf18 bool} prev_if = interrupts_enabled();\par
00029     __cli();\par
00030     IRQL level = cpu.currentIrql;\par
00031 \par
00032     {\cf20 // Mask any IRQ whose assigned IRQL is <= the current CPU IRQL.}\par
00033     {\cf20 // Unmask any IRQ whose assigned IRQL is > the current CPU IRQL.}\par
00034     {\cf19 for} (uint8_t i = 0; i < IRQ_LINES; i++) \{\par
00035         {\cf19 if} (irq_irql[i] <= level) \{\par
00036             mask_irq(i);\par
00037         \}\par
00038         {\cf19 else} \{\par
00039             unmask_irq(i);\par
00040         \}\par
00041     \}\par
00042     {\cf19 if} (prev_if) __sti();\par
00043 \}\par
00044 \par
00045 {\cf17 static} {\cf17 inline} {\cf18 void} toggle_scheduler({\cf18 void}) \{\par
00046     {\cf20 // schedulerEnabled should be true only at IRQL < DISPATCH_LEVEL}\par
00047     cpu.schedulerEnabled = (cpu.currentIrql < DISPATCH_LEVEL);\par
00048 \}\par
00049 \par
00050 {\cf18 void} MtGetCurrentIRQL(IRQL* out) \{\par
00051     tracelast_func({\cf22 "GetCurrentIRQL"});\par
00052     *out = atomic_load_explicit(&cpu.currentIrql, memory_order_acquire);\par
00053 \}\par
00054 \par
00055 {\cf18 void} MtRaiseIRQL(IRQL new_irql, IRQL* old_irql) \{\par
00056     {\cf18 bool} prev_if = interrupts_enabled();\par
00057     __cli();\par
00058     tracelast_func({\cf22 "RaiseIRQL"});\par
00059 \par
00060     {\cf19 if} (old_irql) \{\par
00061         *old_irql = cpu.currentIrql;\par
00062     \}\par
00063 \par
00064     IRQL curr = atomic_load_explicit(&cpu.currentIrql, memory_order_acquire);\par
00065     {\cf19 if} (new_irql < curr) \{\par
00066         CTX_FRAME ctx;\par
00067         SAVE_CTX_FRAME(&ctx);\par
00068         BUGCHECK_ADDITIONALS addt = \{ 0 \};\par
00069         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "Attempted to raise IRQL to a lower level than current IRQL."});\par
00070         MtBugcheckEx(&ctx, NULL, IRQL_NOT_LESS_OR_EQUAL, &addt, {\cf17 true});\par
00071     \}\par
00072 \par
00073     cpu.currentIrql = new_irql;\par
00074     toggle_scheduler();\par
00075     update_pic_mask_for_current_irql();\par
00076     {\cf19 if} (prev_if) __sti();\par
00077 \}\par
00078 \par
00079 {\cf18 void} MtLowerIRQL(IRQL new_irql) \{\par
00080     {\cf18 bool} prev_if = interrupts_enabled();\par
00081     __cli();\par
00082     tracelast_func({\cf22 "LowerIRQL"});\par
00083 \par
00084     IRQL curr = atomic_load_explicit(&cpu.currentIrql, memory_order_acquire);\par
00085     {\cf19 if} (new_irql > curr) \{\par
00086         CTX_FRAME ctx;\par
00087         SAVE_CTX_FRAME(&ctx);\par
00088         BUGCHECK_ADDITIONALS addt = \{ 0 \};\par
00089         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "Attempted to lower IRQL to a higher level than current IRQL."});\par
00090         MtBugcheckEx(&ctx, NULL, IRQL_NOT_LESS_OR_EQUAL, &addt, {\cf17 true});\par
00091     \}\par
00092 \par
00093     cpu.currentIrql = new_irql;\par
00094     toggle_scheduler();\par
00095     update_pic_mask_for_current_irql();\par
00096     {\cf19 if} (prev_if) __sti();\par
00097 \}\par
00098 \par
00099 {\cf20 // This function should be used sparingly, only during initialization.}\par
00100 {\cf18 void} _MtSetIRQL(IRQL new_irql) \{\par
00101     {\cf18 bool} prev_if = interrupts_enabled();\par
00102     __cli();\par
00103     tracelast_func({\cf22 "_SetIRQL"});\par
00104 \par
00105     cpu.currentIrql = new_irql;\par
00106     toggle_scheduler();\par
00107     update_pic_mask_for_current_irql();\par
00108     {\cf19 if} (prev_if) __sti();\par
00109 \}\par
00110 \par
00111 {\cf18 void} enforce_max_irql(IRQL max_allowed, {\cf18 void}* RIP) \{\par
00112     {\cf18 bool} prev_if = interrupts_enabled();\par
00113     __cli();\par
00114     IRQL curr = atomic_load_explicit(&cpu.currentIrql, memory_order_acquire);\par
00115     {\cf19 if} (curr > max_allowed) \{\par
00116         CTX_FRAME ctx;\par
00117         SAVE_CTX_FRAME(&ctx);\par
00118         BUGCHECK_ADDITIONALS addt = \{ 0 \};\par
00119         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "Function was called above its maximum IRQL limit."});\par
00120         addt.ptr = RIP;\par
00121         MtBugcheckEx(&ctx, NULL, IRQL_NOT_LESS_OR_EQUAL, &addt, {\cf17 true});\par
00122     \}\par
00123     {\cf19 if} (prev_if) __sti();\par
00124 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.h}
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "../cpu_types.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update_pic_mask_for_current_irql} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtGetCurrentIRQL} ({\b IRQL} *current_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtRaiseIRQL} ({\b IRQL} new_irql, {\b IRQL} *old_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtLowerIRQL} ({\b IRQL} new_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _MtSetIRQL} ({\b IRQL} new_irql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enforce_max_irql} ({\b IRQL} max_allowed, void *RIP)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} {\b cpu}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _MtSetIRQL\:irql.h}
{\xe \v irql.h\:_MtSetIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _MtSetIRQL ({\b IRQL} new_irql)}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b irql.c}.}\par
}
{\xe \v enforce_max_irql\:irql.h}
{\xe \v irql.h\:enforce_max_irql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void enforce_max_irql ({\b IRQL} max_allowed, void * RIP)}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b irql.c}.}\par
}
{\xe \v MtGetCurrentIRQL\:irql.h}
{\xe \v irql.h\:MtGetCurrentIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtGetCurrentIRQL ({\b IRQL} * current_irql)}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b irql.c}.}\par
}
{\xe \v MtLowerIRQL\:irql.h}
{\xe \v irql.h\:MtLowerIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtLowerIRQL ({\b IRQL} new_irql)}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b irql.c}.}\par
}
{\xe \v MtRaiseIRQL\:irql.h}
{\xe \v irql.h\:MtRaiseIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtRaiseIRQL ({\b IRQL} new_irql, {\b IRQL} * old_irql)}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b irql.c}.}\par
}
{\xe \v update_pic_mask_for_current_irql\:irql.h}
{\xe \v irql.h\:update_pic_mask_for_current_irql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update_pic_mask_for_current_irql (void )}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b irql.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cpu\:irql.h}
{\xe \v irql.h\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} cpu{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
irql.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/irql/irql.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      IRQL Header for MatanelOS.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_IRQL_H}\par
00007 {\cf21 #define X86_IRQL_H}\par
00008 \par
00009  {\cf20 // Standard headers, required.}\par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stdint.h>}\par
00013 {\cf21 #include "../../trace.h"}\par
00014 {\cf21 #include "../cpu_types.h"}\par
00015 \par
00016 {\cf17 extern} CPU cpu;\par
00017 \par
00018 {\cf20 // Functions}\par
00019 {\cf18 void} update_pic_mask_for_current_irql({\cf18 void});\par
00020 \par
00021 {\cf18 void} MtGetCurrentIRQL(IRQL* current_irql);\par
00022 \par
00023 {\cf18 void} MtRaiseIRQL(IRQL new_irql, IRQL* old_irql);\par
00024 \par
00025 {\cf18 void} MtLowerIRQL(IRQL new_irql);\par
00026 \par
00027 {\cf20 // Use carefully, non careful use could halt machine.}\par
00028 {\cf18 void} _MtSetIRQL(IRQL new_irql);\par
00029 \par
00030 {\cf18 void} enforce_max_irql(IRQL max_allowed, {\cf18 void}* RIP);\par
00031 \par
00032 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.c}
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "scheduler.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IDLE_STACK_SIZE}\~ 4096\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b restore_context} ({\b CTX_FRAME} *regs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_idle_checks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitScheduler} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Schedule} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b queueLock} = \{ .LOCKED = ATOMIC_FLAG_INIT \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} {\b idleThread}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IDLE_STACK_SIZE\:scheduler.c}
{\xe \v scheduler.c\:IDLE_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IDLE_STACK_SIZE\~ 4096}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b scheduler.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitScheduler\:scheduler.c}
{\xe \v scheduler.c\:InitScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitScheduler (void )}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b scheduler.c}.}\par
}
{\xe \v kernel_idle_checks\:scheduler.c}
{\xe \v scheduler.c\:kernel_idle_checks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_idle_checks (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b kernel.c}.}\par
}
{\xe \v restore_context\:scheduler.c}
{\xe \v scheduler.c\:restore_context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void restore_context ({\b CTX_FRAME} * regs){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Schedule\:scheduler.c}
{\xe \v scheduler.c\:Schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Schedule (void )}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b scheduler.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v idleThread\:scheduler.c}
{\xe \v scheduler.c\:idleThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread} idleThread}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b scheduler.c}.}\par
}
{\xe \v queueLock\:scheduler.c}
{\xe \v scheduler.c\:queueLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} queueLock = \{ .LOCKED = ATOMIC_FLAG_INIT \}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b scheduler.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
scheduler.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20     * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20     * LICENSE:      GPLv3}\par
00004 {\cf20     * PURPOSE:      Scheduler Implementation.}\par
00005 {\cf20     */}\par
00006 \par
00007 {\cf21 #include "scheduler.h"}\par
00008 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00009 \par
00010 {\cf20 // assembly stubs to save and restore register contexts.}\par
00011 {\cf17 extern} {\cf18 void} restore_context(CTX_FRAME* regs);\par
00012 \par
00013 SPINLOCK queueLock = \{ .LOCKED = ATOMIC_FLAG_INIT \};\par
00014 \par
00015 {\cf20 // Idle thread, runs when no other is ready.}\par
00016 Thread idleThread;\par
00017 {\cf20 // Stack for idle thread}\par
00018 {\cf21 #define IDLE_STACK_SIZE 4096}\par
00019 {\cf17 static} uint8_t idleStack[IDLE_STACK_SIZE] __attribute__((aligned(16)));\par
00020 {\cf17 extern} {\cf18 void} kernel_idle_checks({\cf18 void});\par
00021 \par
00022 {\cf20 // In Scheduler.c}\par
00023 {\cf18 void} InitScheduler({\cf18 void}) \{\par
00024     tracelast_func({\cf22 "InitScheduler"});\par
00025     cpu.schedulerEnabled = {\cf17 true};\par
00026 \par
00027     CTX_FRAME cfm;\par
00028     kmemset(&cfm, 0, {\cf17 sizeof}(cfm)); {\cf20 // Start with a clean, all-zero context}\par
00029 \par
00030     {\cf20 // Set only the essential registers for starting the thread}\par
00031     cfm.rsp = (uint64_t)(idleStack + IDLE_STACK_SIZE);\par
00032     cfm.rip = (uint64_t)kernel_idle_checks;\par
00033 \par
00034     {\cf20 // Assign the clean context to the idle thread}\par
00035     idleThread.registers = cfm;\par
00036     idleThread.threadState = READY;\par
00037     idleThread.nextThread = NULL;\par
00038     idleThread.TID = 0; {\cf20 // Scheduler thread, TID is 0.}\par
00039 \par
00040     cpu.currentThread = NULL;\par
00041 \par
00042     {\cf20 // The ready queue starts empty}\par
00043     cpu.readyQueue.head = cpu.readyQueue.tail = NULL;\par
00044 \}\par
00045 \par
00046 {\cf20 // Enqueue the thread if it's still RUNNABLE.}\par
00047 {\cf17 static} {\cf18 void} enqueue_runnable(Thread* t) \{\par
00048     tracelast_func({\cf22 "enqueue_runnable"});\par
00049     {\cf19 if} (!t) \{\par
00050         CTX_FRAME ctx;\par
00051         SAVE_CTX_FRAME(&ctx);\par
00052         BUGCHECK_ADDITIONALS addt;\par
00053         kmemset(({\cf18 void}*)&addt, 0, {\cf17 sizeof}(BUGCHECK_ADDITIONALS));\par
00054         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "Thread was to be enqueued, but it is a null pointer."});\par
00055         MtBugcheckEx(&ctx, NULL, NULL_THREAD, &addt, {\cf17 true});\par
00056     \}\par
00057     {\cf19 if} (t->threadState == RUNNING) \{\par
00058         t->threadState = READY;\par
00059         enqueue(&cpu.readyQueue, t); {\cf20 // Insert into CPU ready queue}\par
00060     \}\par
00061 \}\par
00062 \par
00063 {\cf18 void} Schedule({\cf18 void}) \{\par
00064     tracelast_func({\cf22 "Schedule"});\par
00065     IRQL oldIrql;\par
00066     MtRaiseIRQL(DISPATCH_LEVEL, &oldIrql);\par
00067 \par
00068     Thread* prev = cpu.currentThread;\par
00069 \par
00070     {\cf19 if} (prev && prev != &idleThread && prev->threadState == RUNNING) \{\par
00071         {\cf20 // The current thread's registers were already saved in isr_stub. (look after the pushes)}\par
00072         enqueue_runnable(prev);\par
00073     \}\par
00074 \par
00075     Thread* next = dequeue(&cpu.readyQueue);\par
00076 \par
00077     {\cf19 if} (!next) \{\par
00078         next = &idleThread;\par
00079     \}\par
00080     {\cf20 //gop_printf(COLOR_RED, "The thread's timeslice before change is: %d", next->timeSlice);}\par
00081     next->threadState = RUNNING;\par
00082     next->timeSlice = next->origTimeSlice;\par
00083     cpu.currentThread = next;\par
00084 \par
00085     MtLowerIRQL(PASSIVE_LEVEL);\par
00086     tracelast_func({\cf22 "Entering restore_context."});\par
00087     restore_context(&next->registers);\par
00088 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.h}
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../cpu.h"}\par
{\f2 #include "../../memory/memory.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEFAULT_TIMESLICE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_CS}\~ 0x08\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_DS}\~ 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_SS}\~ 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_CS}\~ 0x18\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_DS}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_SS}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INITIAL_RFLAGS}\~ 0x202\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_RFLAGS}\~ 0x246\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Yield}()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitScheduler} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Schedule} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} {\b cpu}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEFAULT_TIMESLICE\:scheduler.h}
{\xe \v scheduler.h\:DEFAULT_TIMESLICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEFAULT_TIMESLICE\~ 1}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b scheduler.h}.}\par
}
{\xe \v INITIAL_RFLAGS\:scheduler.h}
{\xe \v scheduler.h\:INITIAL_RFLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INITIAL_RFLAGS\~ 0x202}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b scheduler.h}.}\par
}
{\xe \v KERNEL_CS\:scheduler.h}
{\xe \v scheduler.h\:KERNEL_CS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_CS\~ 0x08}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b scheduler.h}.}\par
}
{\xe \v KERNEL_DS\:scheduler.h}
{\xe \v scheduler.h\:KERNEL_DS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_DS\~ 0x10}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b scheduler.h}.}\par
}
{\xe \v KERNEL_SS\:scheduler.h}
{\xe \v scheduler.h\:KERNEL_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_SS\~ 0x10}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b scheduler.h}.}\par
}
{\xe \v USER_CS\:scheduler.h}
{\xe \v scheduler.h\:USER_CS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_CS\~ 0x18}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b scheduler.h}.}\par
}
{\xe \v USER_DS\:scheduler.h}
{\xe \v scheduler.h\:USER_DS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_DS\~ 0x20}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b scheduler.h}.}\par
}
{\xe \v USER_RFLAGS\:scheduler.h}
{\xe \v scheduler.h\:USER_RFLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_RFLAGS\~ 0x246}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b scheduler.h}.}\par
}
{\xe \v USER_SS\:scheduler.h}
{\xe \v scheduler.h\:USER_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_SS\~ 0x20}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b scheduler.h}.}\par
}
{\xe \v Yield\:scheduler.h}
{\xe \v scheduler.h\:Yield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Yield()}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Schedule()\par
}
{
Definition at line {\b 33} of file {\b scheduler.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitScheduler\:scheduler.h}
{\xe \v scheduler.h\:InitScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitScheduler (void )}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b scheduler.c}.}\par
}
{\xe \v Schedule\:scheduler.h}
{\xe \v scheduler.h\:Schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Schedule (void )}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b scheduler.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cpu\:scheduler.h}
{\xe \v scheduler.h\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} cpu{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
scheduler.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/scheduler/scheduler.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Scheduler types and functions headers.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef SCHEDULER_H}\par
00007 {\cf21 #define SCHEDULER_H}\par
00008 \par
00009 {\cf21 #include "../cpu.h"}\par
00010 {\cf21 #include "../../memory/memory.h"}\par
00011 \par
00012 {\cf17 extern} CPU cpu;\par
00013 \par
00014 {\cf20 // Default timeslice for a new thread.}\par
00015 {\cf21 #define DEFAULT_TIMESLICE 1}\par
00016 \par
00017 {\cf21 #define KERNEL_CS       0x08    }{\cf20 // Entry 1: Kernel Code}\par
00018 {\cf21 #define KERNEL_DS       0x10    }{\cf20 // Entry 2: Kernel Data  }\par
00019 {\cf21 #define KERNEL_SS       0x10    }{\cf20 // Same as KERNEL_DS (data segment used for stack)}\par
00020 {\cf21 #define USER_CS         0x18    }{\cf20 // Entry 3: User Code (for future)}\par
00021 {\cf21 #define USER_DS         0x20    }{\cf20 // Entry 4: User Data (for future)}\par
00022 {\cf21 #define USER_SS         0x20    }{\cf20 // Same as USER_DS (for future)}\par
00023 {\cf21 #define INITIAL_RFLAGS  0x202}\par
00024 {\cf21 #define USER_RFLAGS     0x246 }{\cf20 // IF=1, IOPL=0, CPL=3}\par
00025 \par
00026 {\cf20 // Initialize scheduler: sets up idle thread and enables preemption}\par
00027 {\cf18 void} InitScheduler({\cf18 void});\par
00028 \par
00029 {\cf20 // Core schedule function; performs a context switch}\par
00030 {\cf18 void} Schedule({\cf18 void});\par
00031 \par
00032 {\cf20 // Voluntarily relinquish CPU -- Alias to Schedule()}\par
00033 {\cf21 #define Yield() Schedule()}\par
00034 \par
00035 {\cf21 #endif }{\cf20 // SCHEDULER_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/spinlock/spinlock.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/spinlock/spinlock.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/spinlock/spinlock.h}
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
spinlock.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/spinlock/spinlock.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/spinlock/spinlock.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Spinlock Types and Function Declarations.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_SPINLOCK_H}\par
00007 {\cf21 #define X86_SPINLOCK_H}\par
00008 \par
00009 {\cf20 // Supress intelliSense}\par
00010 {\cf21 #ifdef _MSC_VER}\par
00011 {\cf21 #undef atomic_flag_clear}\par
00012 {\cf21 #define atomic_flag_clear}\par
00013 {\cf21 #undef atomic_flag_test_and_set_explicit}\par
00014 {\cf21 #define atomic_flag_test_and_set_explicit}\par
00015 {\cf21 #undef atomic_flag_clear_explicit}\par
00016 {\cf21 #define atomic_flag_clear_explicit}\par
00017 {\cf21 #endif}\par
00018 \par
00019 {\cf17 static} {\cf17 inline} uint64_t save_and_cli({\cf18 void}) \{\par
00020     uint64_t flags;\par
00021     __asm__ {\cf17 volatile} (\par
00022         {\cf22 "pushfq\\n\\t"}\par
00023         {\cf22 "popq %0\\n\\t"}\par
00024         {\cf22 "cli"}\par
00025         : {\cf22 "=r"}(flags)\par
00026         :: {\cf22 "memory"}\par
00027         );\par
00028     {\cf19 return} flags;\par
00029 \}\par
00030 \par
00031 {\cf17 static} {\cf17 inline} {\cf18 void} restore_flags(uint64_t flags) \{\par
00032     __asm__ {\cf17 volatile} (\par
00033         {\cf22 "pushq %0\\n\\t"}\par
00034         {\cf22 "popfq"}\par
00035         :: {\cf22 "r"}(flags)\par
00036         : {\cf22 "memory"}, {\cf22 "cc"}\par
00037         );\par
00038 \}\par
00039 \par
00044 {\cf17 static} {\cf17 inline} {\cf18 void} spinlock_init(SPINLOCK* lock) \{\par
00045     {\cf19 if} (!lock) {\cf19 return};\par
00046     atomic_flag_clear(&lock->LOCKED);\par
00047 \}\par
00048 \par
00053 {\cf17 static} {\cf17 inline} {\cf18 void} MtAcquireSpinlock(SPINLOCK* lock, uint64_t* flags_out) \{\par
00054     tracelast_func({\cf22 "MtAcquireSpinlock"});\par
00055     {\cf19 if} (!lock) {\cf19 return};\par
00056     {\cf20 // spin until we grab the lock.}\par
00057     *flags_out = save_and_cli();\par
00058     {\cf19 while} (atomic_flag_test_and_set_explicit(&lock->LOCKED, memory_order_acquire)) \{\par
00059         {\cf20 //__asm__ volatile ("pause");}\par
00060         __builtin_ia32_pause();\par
00061     \}\par
00062 \}\par
00063 \par
00068 {\cf17 static} {\cf17 inline} {\cf18 void} MtReleaseSpinlock(SPINLOCK* lock, uint64_t flags) \{\par
00069     tracelast_func({\cf22 "MtReleaseSpinlock"});\par
00070     {\cf19 if} (!lock) {\cf19 return};\par
00071     atomic_flag_clear_explicit(&lock->LOCKED, memory_order_release);\par
00072     restore_flags(flags);\par
00073 \}\par
00074 \par
00075 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c}
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "thread.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_TID}\~ 4u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_TID}\~ 0xFFFFFFFCu\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALIGN_DELTA}\~ 4u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_FREE_POOL}\~ 1024u\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtCreateThread} ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b timeSliceTicks} TIMESLICE, bool kernelThread)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new thread with parameters. (if no parameters are supplied (NULL), it will be handled, so no worries) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} * {\b MtGetCurrentThread} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will return the current working thread. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} {\b cpu}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ALIGN_DELTA\:thread.c}
{\xe \v thread.c\:ALIGN_DELTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALIGN_DELTA\~ 4u}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b thread.c}.}\par
}
{\xe \v MAX_FREE_POOL\:thread.c}
{\xe \v thread.c\:MAX_FREE_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_FREE_POOL\~ 1024u}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b thread.c}.}\par
}
{\xe \v MAX_TID\:thread.c}
{\xe \v thread.c\:MAX_TID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_TID\~ 0xFFFFFFFCu}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b thread.c}.}\par
}
{\xe \v MIN_TID\:thread.c}
{\xe \v thread.c\:MIN_TID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_TID\~ 4u}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b thread.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MtCreateThread\:thread.c}
{\xe \v thread.c\:MtCreateThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtCreateThread ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b timeSliceTicks} TIMESLICE, bool kernelThread)}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new thread with parameters. (if no parameters are supplied (NULL), it will be handled, so no worries) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i entry} \cell }{The entry point address. (usually a function, I don't see any other use.)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parameters} \cell }{The pointer to the parameters (passed as a pointer, the function itself must convert it back to its original parameter variable)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i kernelThread} \cell }{Specificies if the thread should be a kernel one or not. (If not, it will setup a process, idk how I would implement it, when I'll get on it) TODO\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO implement user mode.\par
For when we context switch (this is why cfm is in stackTop), set the registers to all 0. (since the stack for the thread holds the registers when we context switch)\par
Here comes the actual part that separates between the normal and Ex version of creating the thread. - Remmber to use System V ABI as this is GCC.\par
}{
Definition at line {\b 84} of file {\b thread.c}.}\par
}
{\xe \v MtGetCurrentThread\:thread.c}
{\xe \v thread.c\:MtGetCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread} * MtGetCurrentThread (void )}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will return the current working thread. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to current {\b Thread} (struct)\par
}}}{
Definition at line {\b 156} of file {\b thread.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cpu\:thread.c}
{\xe \v thread.c\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} cpu{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
thread.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "thread.h"}\par
00002 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00003 {\cf21 #include "../../assert.h"}\par
00004 \par
00005 {\cf21 #define MIN_TID           4u}\par
00006 {\cf21 #define MAX_TID           0xFFFFFFFCu}\par
00007 {\cf21 #define ALIGN_DELTA       4u}\par
00008 {\cf21 #define MAX_FREE_POOL     1024u}\par
00009 \par
00011 {\cf20 // Call with freedTid == 0 ? allocate a new TID (returns 0 on failure)}\par
00012 {\cf20 // Call with freedTid  > 0 ? release that TID back into the pool (always returns 0)}\par
00014 {\cf17 static} uint32_t ManageTID(uint32_t freedTid)\par
00015 \{\par
00016     {\cf17 static} uint32_t nextTID = MIN_TID;\par
00017     {\cf17 static} uint32_t freePool[MAX_FREE_POOL];\par
00018     {\cf17 static} uint32_t freeCount = 0;\par
00019     uint32_t result = 0;\par
00020 \par
00021     {\cf19 if} (freedTid) \{\par
00022         {\cf20 // Release path: push into free pool if aligned & room}\par
00023         {\cf19 if} ((freedTid % ALIGN_DELTA) == 0 && freeCount < MAX_FREE_POOL) \{\par
00024             freePool[freeCount++] = freedTid;\par
00025         \}\par
00026         {\cf20 // else drop silently}\par
00027     \}\par
00028     {\cf19 else} \{\par
00029         {\cf20 // Allocate path:}\par
00030         {\cf19 if} (freeCount > 0) \{\par
00031             {\cf20 // Reuse most-recently freed}\par
00032             result = freePool[--freeCount];\par
00033         \}\par
00034         {\cf19 else} \{\par
00035             {\cf20 // Hand out next aligned TID}\par
00036             result = nextTID;\par
00037             nextTID += ALIGN_DELTA;\par
00038 \par
00039             {\cf20 // Wrap/overflow check}\par
00040             {\cf19 if} (nextTID < ALIGN_DELTA || result > MAX_TID) \{\par
00041                 {\cf20 // Exhausted all TIDs}\par
00042                 result = 0;\par
00043             \}\par
00044         \}\par
00045     \}\par
00046     {\cf19 return} result;\par
00047 \}\par
00048 \par
00049 \par
00050 {\cf20 // Clean exit for a thread\'97never returns!}\par
00051 {\cf17 static} {\cf18 void} ThreadExit(Thread* thread) \{\par
00052     tracelast_func({\cf22 "ThreadExit"});\par
00053 {\cf21 #ifdef DEBUG}\par
00054     gop_printf_forced(COLOR_RED, {\cf22 "Reached ThreadExit\\n"});\par
00055 {\cf21 #endif}\par
00056     {\cf20 // 1) mark as dead}\par
00057     thread->threadState = TERMINATED;\par
00058     thread->timeSlice = 0;\par
00059     ManageTID(thread->TID);\par
00060 \par
00061     {\cf20 // 2) Delete stack}\par
00062     MtFreeVirtualMemory(thread->startStackPtr);\par
00063     \par
00064     {\cf20 /* assertions */}\par
00065 {\cf21 #ifdef DEBUG}\par
00066     {\cf18 bool} valid = MtIsHeapAddressAllocated(thread->startStackPtr);\par
00067     assert((valid) == {\cf17 false}, {\cf22 "Thread's stack hasn't been freed correctly!"});\par
00068 {\cf21 #endif}\par
00069     Schedule();\par
00070 \par
00071     {\cf20 // should never get here}\par
00072     CTX_FRAME ctx;\par
00073     SAVE_CTX_FRAME(&ctx);\par
00074     MtBugcheck(&ctx, NULL, THREAD_EXIT_FAILURE, 0, {\cf17 false});\par
00075 \}\par
00076 \par
00077 {\cf17 static} {\cf18 void} ThreadWrapperEx(ThreadEntry thread_entry, THREAD_PARAMETER parameter, Thread* thread) \{\par
00078     {\cf20 // thread_entry(parameters) -> void func(void*)}\par
00079     thread_entry(parameter); {\cf20 // If thread entry takes no parameters, passing NULL is still fine.}\par
00081     ThreadExit(thread);\par
00082 \}\par
00083 \par
00084 {\cf18 void} MtCreateThread(ThreadEntry entry, THREAD_PARAMETER parameter, timeSliceTicks TIMESLICE, {\cf18 bool} kernelThread) \{\par
00085     {\cf19 if} (!kernelThread) \{\par
00087         {\cf19 return};\par
00088     \}\par
00089     IRQL oldIrql;\par
00090     MtRaiseIRQL(DISPATCH_LEVEL, &oldIrql);\par
00091     {\cf20 // First, allocate a new thread.}\par
00092     Thread* thread = MtAllocateVirtualMemory({\cf17 sizeof}(Thread), _Alignof(Thread));\par
00093     {\cf19 if} (!thread) \{\par
00094         CTX_FRAME ctx;\par
00095         SAVE_CTX_FRAME(&ctx);\par
00096         MtBugcheck(&ctx, NULL, HEAP_ALLOCATION_FAILED, 0, {\cf17 false});\par
00097     \}\par
00098 \par
00099     {\cf20 // Zero it.}\par
00100     kmemset(({\cf18 void}*)thread, 0, {\cf17 sizeof}(Thread));\par
00101 \par
00102     {\cf20 // Allocate a stackTop for the thread.}\par
00103     {\cf18 void}* stackTop = MtAllocateVirtualMemory(4096, 16);\par
00104     {\cf19 if} (!stackTop) \{\par
00105         CTX_FRAME ctx;\par
00106         SAVE_CTX_FRAME(&ctx);\par
00107         MtBugcheck(&ctx, NULL, HEAP_ALLOCATION_FAILED, 0, {\cf17 false});\par
00108     \}\par
00109     thread->startStackPtr = stackTop;\par
00111     uint8_t* sp = (uint8_t*)stackTop;\par
00112     sp -= {\cf17 sizeof}(CTX_FRAME);\par
00113     sp -= 64; {\cf20 // Extra space so we don't overwrite stuff while context switching.}\par
00114 \par
00115     CTX_FRAME* cfm = (CTX_FRAME*)(sp);\par
00116 \par
00117     kmemset(cfm, 0, {\cf17 sizeof} * cfm); {\cf20 // Start with 0 in all regs.}\par
00118 \par
00119     {\cf20 // Set our sig and timeslice.}\par
00120     thread->timeSlice = TIMESLICE;\par
00121     thread->origTimeSlice = TIMESLICE;\par
00122 \par
00124     cfm->rsp = (uint64_t)sp;\par
00125     cfm->rip = (uint64_t)ThreadWrapperEx;\par
00126     cfm->rdi = (uint64_t)entry; {\cf20 // first argument to ThreadWrapperEx (the entry point)}\par
00127     cfm->rsi = (uint64_t)parameter; {\cf20 // second arugment to ThreadWrapperEx (the parameter pointer)}\par
00128     cfm->rdx = (uint64_t)thread; {\cf20 // third argument to ThreadWrapperEx, our newly created Thread ptr.}\par
00129     \par
00130     uint32_t tid = ManageTID(0);\par
00131 \par
00132     {\cf19 if} (!tid) \{\par
00133         CTX_FRAME ctx;\par
00134         SAVE_CTX_FRAME(&ctx);\par
00135         uint32_t RIP;\par
00136         GET_RIP(RIP);\par
00137         BUGCHECK_ADDITIONALS addt = \{ 0 \};\par
00138         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "Creation of new TID resulted in an error <--> MtCreateThread"});\par
00139         addt.ptr = ({\cf18 void}*)(uintptr_t)RIP;\par
00140         MtBugcheckEx(&ctx, NULL, THREAD_ID_CREATION_FAILURE, &addt, {\cf17 true});\par
00141     \}\par
00142     \par
00143     {\cf20 // Set it's registers and others.}\par
00144     thread->registers = *cfm;\par
00145     thread->threadState = READY;\par
00146     thread->nextThread = NULL;\par
00147     thread->TID = tid;\par
00148 \par
00149     enqueue(&cpu.readyQueue, thread);\par
00150     {\cf20 // Lower IRQL.}\par
00151     MtLowerIRQL(oldIrql);\par
00152 \}\par
00153 \par
00154 {\cf17 extern} CPU cpu;\par
00155 \par
00156 Thread* MtGetCurrentThread({\cf18 void}) \{\par
00157     {\cf19 return} cpu.currentThread;\par
00158 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.h}
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../cpu.h"}\par
{\f2 #include "../../memory/memory.h"}\par
{\f2 #include "../scheduler/scheduler.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THREAD_DEFAULT_STACK_SIZE}\~ 4096\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b THREAD_PARAMETER}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These work the same as how windows does thread parameters, they just turn the parameter into 1 void* ptr, and the function that handles it must turn it into it's equivalent struct ptr. So essentially, you convert your struct ptr you want to call with the function into a void* ptr (so THREAD_PARAMETERS*), and then use that and the function you use the thread on must convert it back. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b ThreadEntry}) ({\b THREAD_PARAMETER})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtCreateThread} ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b timeSliceTicks} TIMESLICE, bool kernelThread)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new thread with parameters. (if no parameters are supplied (NULL), it will be handled, so no worries) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Thread} * {\b MtGetCurrentThread} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will return the current working thread. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v THREAD_DEFAULT_STACK_SIZE\:thread.h}
{\xe \v thread.h\:THREAD_DEFAULT_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THREAD_DEFAULT_STACK_SIZE\~ 4096}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b thread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v THREAD_PARAMETER\:thread.h}
{\xe \v thread.h\:THREAD_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b THREAD_PARAMETER}}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These work the same as how windows does thread parameters, they just turn the parameter into 1 void* ptr, and the function that handles it must turn it into it's equivalent struct ptr. So essentially, you convert your struct ptr you want to call with the function into a void* ptr (so THREAD_PARAMETERS*), and then use that and the function you use the thread on must convert it back. }}\par
{
Definition at line {\b 20} of file {\b thread.h}.}\par
}
{\xe \v ThreadEntry\:thread.h}
{\xe \v thread.h\:ThreadEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* ThreadEntry) ({\b THREAD_PARAMETER})}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b thread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MtCreateThread\:thread.h}
{\xe \v thread.h\:MtCreateThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtCreateThread ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b timeSliceTicks} TIMESLICE, bool kernelThread)}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a new thread with parameters. (if no parameters are supplied (NULL), it will be handled, so no worries) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i entry} \cell }{The entry point address. (usually a function, I don't see any other use.)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parameters} \cell }{The pointer to the parameters (passed as a pointer, the function itself must convert it back to its original parameter variable)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i kernelThread} \cell }{Specificies if the thread should be a kernel one or not. (If not, it will setup a process, idk how I would implement it, when I'll get on it) TODO\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO implement user mode.\par
For when we context switch (this is why cfm is in stackTop), set the registers to all 0. (since the stack for the thread holds the registers when we context switch)\par
Here comes the actual part that separates between the normal and Ex version of creating the thread. - Remmber to use System V ABI as this is GCC.\par
}{
Definition at line {\b 84} of file {\b thread.c}.}\par
}
{\xe \v MtGetCurrentThread\:thread.h}
{\xe \v thread.h\:MtGetCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Thread} * MtGetCurrentThread (void )}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will return the current working thread. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to current {\b Thread} (struct)\par
}}}{
Definition at line {\b 156} of file {\b thread.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
thread.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.h}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Threading Types and Functions for the Scheduler.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_THREAD_H}\par
00008 {\cf21 #define X86_THREAD_H}\par
00009 \par
00010 {\cf21 #include "../cpu.h"}\par
00011 {\cf21 #include "../../memory/memory.h"}\par
00012 {\cf21 #include "../scheduler/scheduler.h"}\par
00013 \par
00014 {\cf21 #define THREAD_DEFAULT_STACK_SIZE 4096}\par
00015 \par
00020 {\cf17 typedef} {\cf18 void}* THREAD_PARAMETER;\par
00021 {\cf17 typedef} void (*ThreadEntry)(THREAD_PARAMETER);\par
00022 \par
00023 \par
00024 {\cf20 // Explanation as to why passing NULL to a function that takes no params works:}\par
00025 {\cf20 // Since in System V ABI, the first parameter is passed in RDI.}\par
00026 {\cf20 // And so a function that takes a parametr will use RDI, and we always pass a parameter (even NULL, it is considered.)}\par
00027 {\cf20 // But what about a function that doesn't take parameters? (e.g void func(void) - It will stay be handled.}\par
00028 {\cf20 // Since a function that takes parameters GCC compiles with it reading from RDI, but since this function doesn't, it will NEVER read from RDI in the first place - so it will never even acknowledge the parameter.}\par
00029 {\cf20 // So, basically, the function didn't know the paramter was there, no corruption, nothing, it's completetly fine.}\par
00030 {\cf20 // (since we are telling the compiler to treat the function call as it had a parameter, so it will let us compile) - void func(void) - (void*)(int))func(NULL)}\par
00031 \par
00038 {\cf18 void} MtCreateThread(ThreadEntry entry, THREAD_PARAMETER parameter, timeSliceTicks TIMESLICE, {\cf18 bool} kernelThread);\par
00039 \par
00044 Thread* MtGetCurrentThread({\cf18 void});\par
00045 \par
00046 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/defs/stdarg_myos.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/defs/stdarg_myos.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/defs/stdarg_myos.h}
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b va_start}(ap,  last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b va_arg}(ap,  type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b va_end}(ap)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef __builtin_va_list {\b va_list}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v va_arg\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_arg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define va_arg( ap,  type)}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_va_arg(ap, type)\par
}
{
Definition at line {\b 12} of file {\b stdarg_myos.h}.}\par
}
{\xe \v va_end\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define va_end( ap)}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_va_end(ap)\par
}
{
Definition at line {\b 13} of file {\b stdarg_myos.h}.}\par
}
{\xe \v va_start\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define va_start( ap,  last)}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_va_start(ap, last)\par
}
{
Definition at line {\b 11} of file {\b stdarg_myos.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v va_list\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef __builtin_va_list {\b va_list}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b stdarg_myos.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
stdarg_myos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/defs/stdarg_myos.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/defs/stdarg_myos.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Variadic functions compiler helpers.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef __STDARG_H}\par
00007 {\cf21 #define __STDARG_H}\par
00008 {\cf21 #ifndef _MSC_VER}\par
00009 {\cf17 typedef} __builtin_va_list va_list;\par
00010 \par
00011 {\cf21 #define va_start(ap, last) __builtin_va_start(ap, last)}\par
00012 {\cf21 #define va_arg(ap, type)   __builtin_va_arg(ap, type)}\par
00013 {\cf21 #define va_end(ap)         __builtin_va_end(ap)}\par
00014 {\cf21 #else}\par
00015 {\cf21 #define va_arg}\par
00016 {\cf21 #endif}\par
00017 \par
00018 {\cf21 #endif}\par
00019 {\cf21 #pragma once}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ahci.h"}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _AHCI_PORT_CTX}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _AHCI_PORT_CTX} {\b AHCI_PORT_CTX}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_read_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, void *buf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single 512-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_write_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, const void *buf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single 512-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b ahci_get_block_device} (int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ahci_initialized} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v AHCI_PORT_CTX\:ahci.c}
{\xe \v ahci.c\:AHCI_PORT_CTX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _AHCI_PORT_CTX} {\b AHCI_PORT_CTX}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ahci_get_block_device\:ahci.c}
{\xe \v ahci.c\:ahci_get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * ahci_get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the {\b BLOCK_DEVICE} registration.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b BLOCK_DEVICE} struct pointer.\par
}}}{
Definition at line {\b 642} of file {\b ahci.c}.}\par
}
{\xe \v ahci_init\:ahci.c}
{\xe \v ahci.c\:ahci_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_init (void )}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the AHCI Driver.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based if it initialized correctly or not. (if failure = bugcheck)\par
}}}{
Definition at line {\b 288} of file {\b ahci.c}.}\par
}
{\xe \v ahci_read_sector\:ahci.c}
{\xe \v ahci.c\:ahci_read_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_read_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, void * buf)}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single 512-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Return buffer to place the data read.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession | buf pointer changes.\par
}}}{
Definition at line {\b 328} of file {\b ahci.c}.}\par
}
{\xe \v ahci_write_sector\:ahci.c}
{\xe \v ahci.c\:ahci_write_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_write_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, const void * buf)}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single 512-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{The buffer to write to the specified LBA.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession\par
}}}{
Definition at line {\b 551} of file {\b ahci.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ahci_initialized\:ahci.c}
{\xe \v ahci.c\:ahci_initialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ahci_initialized = false}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 286} of file {\b ahci.c}.}\par
}
{\xe \v boot_info_local\:ahci.c}
{\xe \v ahci.c\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b kernel.c}.}\par
}
{\xe \v gop_local\:ahci.c}
{\xe \v ahci.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ahci.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      AHCI Driver Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "ahci.h"}\par
00008 {\cf21 #include "../../trace.h"}\par
00009 {\cf21 #include "../../assert.h"}\par
00010 \par
00011 {\cf21 #ifdef REMINDER}\par
00012 {\cf17 _Static_assert}({\cf17 false}, {\cf22 "Reminder: AHCI, and other DMA stuff DEAL WITH PHYSICAL ADDRESSES ONLY! not virtual, so supply to them the translated addresses."});\par
00013 {\cf21 #endif}\par
00014 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00015 {\cf17 static} {\cf18 void} decode_serr(uint32_t serr) \{\par
00016     {\cf19 if} (serr == 0) \{\par
00017         gop_printf_forced(0xFFFFFF00, {\cf22 "SERR: No errors\\n"});\par
00018         {\cf19 return};\par
00019     \}\par
00020 \par
00021     gop_printf_forced(0xFFFF0000, {\cf22 "SERR: 0x%08x - Errors detected:\\n"}, serr);\par
00022 \par
00023     {\cf20 // ERR bits (0-15) - Recoverable and non-recoverable errors}\par
00024     {\cf19 if} (serr & (1 << 0))  gop_printf_forced(0xFFFFFF00, {\cf22 "  [0] ERR.I - Recovered Data Integrity Error\\n"});\par
00025     {\cf19 if} (serr & (1 << 1))  gop_printf_forced(0xFFFFFF00, {\cf22 "  [1] ERR.M - Recovered Communications Error\\n"});\par
00026     {\cf19 if} (serr & (1 << 8))  gop_printf_forced(0xFFFFFF00, {\cf22 "  [8] ERR.T - Transient Data Integrity Error\\n"});\par
00027     {\cf19 if} (serr & (1 << 9))  gop_printf_forced(0xFFFFFF00, {\cf22 "  [9] ERR.C - Persistent Communication/Data Integrity Error\\n"});\par
00028     {\cf19 if} (serr & (1 << 10)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [10] ERR.P - Protocol Error\\n"});\par
00029     {\cf19 if} (serr & (1 << 11)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [11] ERR.E - Internal Error\\n"});\par
00030 \par
00031     {\cf20 // DIAG bits (16-31) - Diagnostic errors}\par
00032     {\cf19 if} (serr & (1 << 16)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [16] DIAG.N - PhyRdy Change\\n"});\par
00033     {\cf19 if} (serr & (1 << 17)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [17] DIAG.I - Phy Internal Error\\n"});\par
00034     {\cf19 if} (serr & (1 << 18)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [18] DIAG.W - Comm Wake\\n"});\par
00035     {\cf19 if} (serr & (1 << 19)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [19] DIAG.B - 10B to 8B Decode Error\\n"});\par
00036     {\cf19 if} (serr & (1 << 20)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [20] DIAG.D - Disparity Error\\n"});\par
00037     {\cf19 if} (serr & (1 << 21)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [21] DIAG.C - CRC Error\\n"});\par
00038     {\cf19 if} (serr & (1 << 22)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [22] DIAG.H - Handshake Error\\n"});\par
00039     {\cf19 if} (serr & (1 << 23)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [23] DIAG.S - Link Sequence Error\\n"});\par
00040     {\cf19 if} (serr & (1 << 24)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [24] DIAG.T - Transport State Transition Error\\n"});\par
00041     {\cf19 if} (serr & (1 << 25)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [25] DIAG.F - Unknown FIS Type\\n"});\par
00042     {\cf19 if} (serr & (1 << 26)) gop_printf_forced(0xFFFFFF00, {\cf22 "  [26] DIAG.X - Exchanged\\n"});\par
00043 \}\par
00044 {\cf21 #endif}\par
00045 {\cf20 // Context per initialized port}\par
00046 {\cf17 typedef} {\cf17 struct }_AHCI_PORT_CTX \{\par
00047     HBA_PORT* port;             {\cf20 // MMIO base for this port}\par
00048     HBA_CMD_TBL* cmd_tbl;       {\cf20 // Command table memory}\par
00049     {\cf18 void}* clb;                  {\cf20 // Cmd list buffer}\par
00050     {\cf18 void}* fis;                  {\cf20 // FIS receive buffer}\par
00051     BLOCK_DEVICE bdev;          {\cf20 // Associated BLOCK_DEVICE interface}\par
00052 \} AHCI_PORT_CTX;\par
00053 \par
00054 {\cf17 static} HBA_MEM* hba_mem;\par
00055 {\cf17 static} AHCI_PORT_CTX ports[AHCI_MAX_PORTS];\par
00056 {\cf17 static} {\cf18 int} port_count;\par
00057 \par
00058 {\cf20 // Invalidate cache ranges of the CPU to ensure newest data is fetched from RAM.}\par
00059 {\cf17 static} {\cf17 inline} {\cf18 void} cache_flush_invalidate_range({\cf18 void}* addr, {\cf18 size_t} len) \{\par
00060     uintptr_t p = (uintptr_t)addr & ~(uintptr_t)63;\par
00061     uintptr_t end = (uintptr_t)addr + len;\par
00062     {\cf19 for} (; p < end; p += 64) \{\par
00063         __asm__ {\cf17 volatile}({\cf22 "clflush (%0)"} :: {\cf22 "r"}(({\cf18 void}*)p) : {\cf22 "memory"});\par
00064     \}\par
00065     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00066 \}\par
00067 \par
00068 {\cf17 static} {\cf17 inline} {\cf18 void} outl_port(uint16_t port, uint32_t val) \{\par
00069     __asm__ {\cf17 volatile}({\cf22 "outl %0, %1"} :: {\cf22 "a"}(val), {\cf22 "d"}(port));\par
00070 \}\par
00071 {\cf17 static} {\cf17 inline} uint32_t inl_port(uint16_t port) \{\par
00072     uint32_t val;\par
00073     __asm__ {\cf17 volatile}({\cf22 "inl %1, %0"} : {\cf22 "=a"}(val) : {\cf22 "d"}(port));\par
00074     {\cf19 return} val;\par
00075 \}\par
00076 {\cf17 static} uint32_t pci_cfg_read32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) \{\par
00077     uint32_t addr = (1u << 31) | ((uint32_t)bus << 16) | ((uint32_t)slot << 11) |\par
00078         ((uint32_t)func << 8) | (offset & 0xFC);\par
00079     outl_port(0xCF8, addr);\par
00080     {\cf19 return} inl_port(0xCFC);\par
00081 \}\par
00082 {\cf17 static} {\cf18 void} pci_cfg_write32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint32_t val) \{\par
00083     uint32_t addr = (1u << 31) | ((uint32_t)bus << 16) | ((uint32_t)slot << 11) |\par
00084         ((uint32_t)func << 8) | (offset & 0xFC);\par
00085     outl_port(0xCF8, addr);\par
00086     outl_port(0xCFC, val);\par
00087 \}\par
00088 \par
00089 {\cf20 // Scans PCI buses and enables Bus Master bit for first AHCI class device found.}\par
00090 {\cf20 // Call this at start of ahci_init() before enable_controller().}\par
00091 {\cf17 static} {\cf18 void} ensure_ahci_busmaster_enabled({\cf18 void}) \{\par
00092     {\cf19 for} (uint8_t bus = 0; bus < 8; ++bus) \{\par
00093         {\cf19 for} (uint8_t slot = 0; slot < 32; ++slot) \{\par
00094             {\cf19 for} (uint8_t func = 0; func < 8; ++func) \{\par
00095                 uint32_t d0 = pci_cfg_read32(bus, slot, func, 0x00);\par
00096                 {\cf19 if} ((d0 & 0xFFFF) == 0xFFFF) {\cf19 continue}; {\cf20 // no device}\par
00097                 uint32_t cl = pci_cfg_read32(bus, slot, func, 0x08);\par
00098                 uint8_t base_class = (cl >> 24) & 0xFF;\par
00099                 uint8_t sub_class = (cl >> 16) & 0xFF;\par
00100                 uint8_t prog_if = (cl >> 8) & 0xFF;\par
00101                 {\cf19 if} (base_class == 0x01 && sub_class == 0x06 && prog_if == 0x01) \{\par
00102 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00103                     uint32_t hdr = pci_cfg_read32(bus, slot, func, 0x00);\par
00104                     uint16_t vendor = hdr & 0xFFFF;\par
00105                     uint16_t device = (hdr >> 16) & 0xFFFF;\par
00106 {\cf21 #endif}\par
00107                     uint32_t cmd32 = pci_cfg_read32(bus, slot, func, 0x04);\par
00108                     uint16_t cmd = cmd32 & 0xFFFF;\par
00109 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00110                     gop_printf_forced(0xFFFFFF00, {\cf22 "AHCI PCI at %p:%p vendor=%p device=%p\\n"}, bus, slot, func, vendor, device);\par
00111                     gop_printf_forced(0xFFFFFF00, {\cf22 "PCI CMD before: %p\\n"}, cmd);\par
00112 {\cf21 #endif}\par
00113                     {\cf19 if} (!(cmd & (1 << 2))) \{\par
00114                         cmd |= (1 << 2); {\cf20 // set Bus Master}\par
00115                         pci_cfg_write32(bus, slot, func, 0x04, (cmd32 & 0xFFFF0000) | (uint32_t)cmd);\par
00116 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00117                         gop_printf_forced(0xFFFFFF00, {\cf22 "Enabled PCI Bus Master bit for AHCI\\n"});\par
00118 {\cf21 #endif}\par
00119                     \}\par
00120                     {\cf19 else} \{\par
00121 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00122                         gop_printf_forced(0xFFFFFF00, {\cf22 "PCI Bus Master already enabled\\n"});\par
00123 {\cf21 #endif}\par
00124                     \}\par
00125                     {\cf19 return};\par
00126                 \}\par
00127             \}\par
00128         \}\par
00129     \}\par
00130 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00131     gop_printf_forced(0xFFFF0000, {\cf22 "AHCI PCI device not found while scanning PCI bus\\n"});\par
00132 {\cf21 #endif}\par
00133 \}\par
00134 \par
00140 {\cf17 static} {\cf18 int} find_free_slot(uint32_t mask) \{\par
00141     tracelast_func({\cf22 "find_free_slot"});\par
00142     {\cf19 for} ({\cf18 int} i = 0; i < 32; i++) \{\par
00143         {\cf19 if} (!(mask & (1u << i))) \{\par
00144             {\cf19 return} i;\par
00145         \}\par
00146     \}\par
00147     {\cf19 return} -1;\par
00148 \}\par
00149 \par
00153 {\cf17 static} {\cf18 void} enable_controller({\cf18 void}) \{\par
00154     tracelast_func({\cf22 "enable_controller"});\par
00155     hba_mem->ghc |= (1u << 31); {\cf20 // AHCI Enable.}\par
00156     hba_mem->ghc |= (1u << 0); {\cf20 // Global Reset.}\par
00158     {\cf19 while} (hba_mem->ghc & (1u << 0));\par
00159 \}\par
00160 \par
00166 {\cf17 static} {\cf18 bool} init_one_port({\cf18 int} idx) \{\par
00167     HBA_PORT* p = (HBA_PORT*)((uint8_t*)hba_mem + 0x100 + idx * 0x80);\par
00168     uint32_t status = p->ssts;\par
00169     {\cf19 if} ((status & 0x0F) != 3) {\cf19 return} {\cf17 false}; {\cf20 // no device present}\par
00170 \par
00171     {\cf20 // Stop the port before configuration}\par
00172     p->cmd &= ~(1u << 0); {\cf20 // Clear ST (START)}\par
00173     p->cmd &= ~(1u << 4); {\cf20 // Clear PRE (FIS Receive Enable)}\par
00174 \par
00175     {\cf20 // Wait until port is idle}\par
00176     {\cf19 while} ((p->cmd & (1u << 15)) || (p->cmd & (1u << 14))) \{\par
00177         __pause();\par
00178     \}\par
00179 \par
00180     {\cf20 // Allocate and zero CLB (1 KiB)}\par
00181     {\cf18 void}* clb = MtAllocateVirtualMemoryEx(1024, 1024, PAGE_PRESENT | PAGE_RW | PAGE_PCD | PAGE_PWT);\par
00182     {\cf19 if} (!clb) {\cf19 return} {\cf17 false};\par
00183     kmemset(clb, 0, 1024);\par
00184     {\cf20 // pass the PHYSICAL address.}\par
00185     uintptr_t clb_phys = MtTranslateVirtualToPhysical(clb);\par
00186     assert(((uintptr_t)clb_phys & 0x3FF) == 0, {\cf22 "CLB must be 1KiB-aligned (1024 byte multiple)"});\par
00187 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00188     gop_printf(COLOR_BLUE, {\cf22 "In INIT_ONE_PORT, clb_phys: %p | virt: %p\\n"}, clb_phys, clb);\par
00189 {\cf21 #endif}\par
00190     p->clb = (uint32_t)(uintptr_t)clb_phys;\par
00191     p->clbu = (uint32_t)((uintptr_t)clb_phys >> 32);\par
00192 \par
00193     {\cf20 // Allocate and zero FIS receive buffer (256 B)}\par
00194     {\cf18 void}* fis_buf = MtAllocateVirtualMemoryEx(256, 256, PAGE_PRESENT | PAGE_RW | PAGE_PCD | PAGE_PWT);\par
00195     {\cf19 if} (!fis_buf) {\cf19 return} {\cf17 false};\par
00196     kmemset(fis_buf, 0, 256);\par
00197     {\cf20 // Again, pass the PHYSICAL.}\par
00198     uintptr_t fis_buf_phys = MtTranslateVirtualToPhysical(fis_buf);\par
00199 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00200     gop_printf(COLOR_BLUE, {\cf22 "In INIT_ONE_PORT, fis_buf_phys: %p | virt: %p\\n"}, fis_buf_phys, fis_buf);\par
00201 {\cf21 #endif}\par
00202     p->fb = (uint32_t)(uintptr_t)fis_buf_phys;\par
00203     p->fbu = (uint32_t)((uintptr_t)fis_buf_phys >> 32);\par
00204 \par
00205     {\cf20 // Allocate and zero Command Table buffers: 256 B \'D7 32 slots}\par
00206     {\cf18 size_t} tbl_size = 256 * 32;\par
00207     {\cf18 void}* cmd_tbl = MtAllocateVirtualMemoryEx(tbl_size, 256, PAGE_PRESENT | PAGE_RW | PAGE_PCD | PAGE_PWT);\par
00208     {\cf19 if} (!cmd_tbl) {\cf19 return} {\cf17 false};\par
00209     kmemset(cmd_tbl, 0, tbl_size);\par
00210     uintptr_t cmd_tbl_phys = MtTranslateVirtualToPhysical(cmd_tbl);\par
00211     assert(((uintptr_t)cmd_tbl_phys & 0xFF) == 0, {\cf22 "Command table block must be 256-byte aligned"});\par
00212 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00213     gop_printf(COLOR_BLUE, {\cf22 "In INIT_ONE_PORT, cmd_tbl_phys: %p | virt: %p\\n"}, cmd_tbl_phys, cmd_tbl);\par
00214 {\cf21 #endif}\par
00215 \par
00216     {\cf20 // Point each command header to its table}\par
00217     {\cf19 for} ({\cf18 int} slot = 0; slot < 32; slot++) \{\par
00218         {\cf20 // Header at clb + slot*32 bytes}\par
00219         HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)clb + slot * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00220         uintptr_t tbl_pa_phys = (uintptr_t)cmd_tbl_phys + slot * 256;\par
00221         hdr->ctba = (uint32_t)(tbl_pa_phys & 0xFFFFFFFF);\par
00222         hdr->ctbau = (uint32_t)(tbl_pa_phys >> 32);\par
00223         hba_cmd_hdr_set_prdtl(hdr, 1); {\cf20 // one PRDT entry}\par
00224     \}\par
00225 \par
00226     {\cf20 // Clear any old errors and start the port}\par
00227     p->serr = ~0U; {\cf20 // Clear all SERROR bits by writing 1 to them.}\par
00228     p->cmd |= (1u << 4); {\cf20 // Set FRE}\par
00229     p->cmd |= (1u << 0); {\cf20 // Set ST}\par
00230 \par
00231     {\cf20 // Add this assertion to ensure the port actually starts}\par
00232     assert((p->cmd & 1) != 0, {\cf22 "Port ST bit failed to set!"});\par
00233 \par
00234     {\cf20 // Save context}\par
00235     AHCI_PORT_CTX* ctx = &ports[port_count];\par
00236     ctx->port = p;\par
00237     ctx->clb = clb;\par
00238     ctx->fis = fis_buf;\par
00239     ctx->cmd_tbl = cmd_tbl;\par
00240     ctx->bdev.read_sector = ahci_read_sector;\par
00241     ctx->bdev.write_sector = ahci_write_sector;\par
00242     ctx->bdev.dev_data = ctx;\par
00243 \par
00244     {\cf20 /* CAP and slot counts */}\par
00245 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00246     uint32_t cap = (uint32_t)hba_mem->cap;\par
00247     uint32_t ncs = (cap >> 8) & 0x1Fu;\par
00248     assert(((ncs + 1) >= 1) && ((ncs + 1) <= 32), {\cf22 "CAP.NCS invalid (command slots out of range)"});\par
00249 \par
00250     {\cf18 bool} s64a = !!((cap >> 31) & 1u);\par
00251 \par
00252     {\cf20 /* Alignment checks */}\par
00253     assert(((uintptr_t)clb_phys & 0x3FF) == 0, {\cf22 "PxCLB must be 1KiB-aligned (1024 bytes)"});\par
00254     assert(((uintptr_t)fis_buf_phys & 0xFF) == 0, {\cf22 "PxFB (FIS) must be 256-byte aligned"});\par
00255     assert(((uintptr_t)cmd_tbl_phys & 0xFF) == 0, {\cf22 "Command table region must start at 256-byte boundary"});\par
00256 \par
00257     {\cf20 /* 64-bit addressing: if device doesn't advertise S64A, upper bits must be zero */}\par
00258     {\cf19 if} (!s64a) \{\par
00259         assert(((uintptr_t)clb_phys >> 32) == 0, {\cf22 "CLB high dword must be zero when CAP.S64A==0"});\par
00260         assert(((uintptr_t)cmd_tbl_phys >> 32) == 0, {\cf22 "CMD_TBL high dword must be zero when CAP.S64A==0"});\par
00261         assert(((uintptr_t)fis_buf_phys >> 32) == 0, {\cf22 "FIS high dword must be zero when CAP.S64A==0"});\par
00262     \}\par
00263 {\cf21 #endif}\par
00264     {\cf20 /* Per-header CTBA programmed correctly (for the number of slots the HBA advertises) */}\par
00265 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00266     {\cf19 for} ({\cf18 unsigned} sl = 0; sl <= ncs; ++sl) \{\par
00267         HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)clb + sl * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00268         uintptr_t expected = (uintptr_t)cmd_tbl_phys + sl * 256;\par
00269         assert(hdr->ctba == (uint32_t)(expected & 0xFFFFFFFFu), {\cf22 "Header CTBA low doesn't match expected CTBA"});\par
00270         {\cf19 if} (s64a) \{\par
00271             assert(hdr->ctbau == (uint32_t)(expected >> 32), {\cf22 "Header CTBAU mismatch (S64A advertised)"});\par
00272         \}\par
00273         {\cf19 else} \{\par
00274             assert(hdr->ctbau == 0, {\cf22 "Header CTBAU must be zero when S64A==0"});\par
00275         \}\par
00276     \}\par
00277 {\cf21 #endif}\par
00278 \par
00279     port_count++;\par
00280     {\cf19 return} {\cf17 true};\par
00281 \}\par
00282 \par
00283 {\cf17 extern} BOOT_INFO boot_info_local;\par
00284 {\cf17 extern} GOP_PARAMS gop_local;\par
00285 \par
00286 {\cf18 bool} ahci_initialized = {\cf17 false};\par
00287 \par
00288 MTSTATUS ahci_init({\cf18 void}) \{\par
00289     {\cf19 if} (ahci_initialized) \{ gop_printf(COLOR_RED, {\cf22 "AHCI Initialization got called again when alreaedy init.\\n"}); {\cf19 return} MT_SUCCESS; \}\par
00290     tracelast_func({\cf22 "ahci_init"});\par
00291     {\cf20 // Use BootInfo PCI BARs.}\par
00292     {\cf19 for} ({\cf18 size_t} i = 0; i < boot_info_local.AhciCount; i++) \{\par
00293         uint64_t base = boot_info_local.AhciBarBases[i];\par
00294         {\cf18 void}* virt = ({\cf18 void}*)(base + PHYS_MEM_OFFSET);\par
00295         map_page(virt, base, PAGE_PRESENT | PAGE_RW | PAGE_PCD | PAGE_PWT); {\cf20 // MMIO flags}\par
00296 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00297         gop_printf(COLOR_ORANGE, {\cf22 "Address of AHCI BAR %u (%p) is: %s\\n"}, i, virt, MtIsAddressValid(virt) ? {\cf22 "Valid"} : {\cf22 "Invalid"});\par
00298 {\cf21 #endif}\par
00299         {\cf20 // Now change the values in the struct}\par
00300         boot_info_local.AhciBarBases[i] = (uint64_t)virt;\par
00301     \}\par
00302 \par
00303     uint64_t bar = boot_info_local.AhciBarBases[0];\par
00304     hba_mem = (HBA_MEM*)(uintptr_t)bar;\par
00305 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00306     gop_printf(0xFF00FFFF, {\cf22 "About to touch AHCI %u at %p | It's %s\\n"},0, hba_mem, MtIsAddressValid(({\cf18 void}*)bar) ? {\cf22 "Valid"} : {\cf22 "Invalid"});\par
00307     {\cf20 //_cli(); __hlt();}\par
00308 {\cf21 #endif}\par
00309     ensure_ahci_busmaster_enabled();\par
00310     enable_controller();\par
00311     port_count = 0; {\cf20 // Start from 0.}\par
00312     uint32_t pi = hba_mem->pi;\par
00313 \par
00314     {\cf19 for} ({\cf18 int} idx = 0; idx < AHCI_MAX_PORTS; idx++) \{\par
00315         {\cf19 if} (pi & (1u << idx)) \{\par
00316             init_one_port(idx);\par
00317         \}\par
00318     \}\par
00319 \par
00320     {\cf20 // Register ALL block devices.}\par
00321     {\cf19 for} ({\cf18 int} i = 0; i < port_count; i++) \{\par
00322         register_block_device(&ports[i].bdev);\par
00323     \}\par
00324     ahci_initialized = {\cf17 true};\par
00325     {\cf19 return} port_count > 0 ? MT_SUCCESS : MT_AHCI_PORT_FAILURE; {\cf20 // If it could register a port, it will return true, if it couldn't, it will return false (bugcheck)}\par
00326 \}\par
00327 \par
00328 MTSTATUS ahci_read_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf18 void}* buf) \{\par
00329     tracelast_func({\cf22 "ahci_read_sector"});\par
00330     AHCI_PORT_CTX* ctx = (AHCI_PORT_CTX*)dev->dev_data;\par
00331     HBA_PORT* p = ctx->port;\par
00332     {\cf20 // Clear pending interrupt bits.}\par
00333     p->is = (uint32_t)-1;\par
00334     {\cf18 int} slot = find_free_slot(p->sact | p->ci);\par
00335     {\cf19 if} (slot < 0) {\cf19 return} MT_AHCI_PORT_FAILURE;\par
00336     uint32_t spin = 0;\par
00337     {\cf17 const} uint32_t TIMEOUT = 100000000;\par
00338     {\cf19 while} (p->ci & (1u << slot)) \{\par
00339         {\cf19 if} (++spin >= TIMEOUT) {\cf19 break};\par
00340     \}\par
00341 \par
00342 \par
00343     {\cf20 /* Command table for this slot (256 bytes per slot) */}\par
00344     HBA_CMD_TBL* cmd = (HBA_CMD_TBL*)((uint8_t*)ctx->cmd_tbl + slot * 256);\par
00345     kmemset(cmd, 0, 256);\par
00346 \par
00347 \par
00348     {\cf20 /* Command header in CLB for this slot */}\par
00349     HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)ctx->clb + slot * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00350     hba_cmd_hdr_set_cfl(hdr, ({\cf17 sizeof}(FIS_REG_H2D) + 3) / 4); {\cf20 /* CFIS length in DWORDs (20 bytes -> 5) */}\par
00351     hba_cmd_hdr_set_w(hdr, 0);       {\cf20 /* read */}\par
00352     hdr->prdbc = 0;   {\cf20 /* clear transferred byte count (DW1) */}\par
00353     hba_cmd_hdr_set_prdtl(hdr, 1);   {\cf20 /* one PRDT entry */}\par
00354 \par
00355 \par
00356     {\cf20 /* Build CFIS */}\par
00357     FIS_REG_H2D* fis = (FIS_REG_H2D*)(&cmd->cfis);\par
00358     kmemset(fis, 0, {\cf17 sizeof}(*fis));\par
00359     fis->fis_type = FIS_TYPE_REG_H2D;\par
00360     fis->c = 1;\par
00361     fis->command = 0x25; {\cf20 /* READ DMA EXT */}\par
00362     fis->device = 1 << 6;\par
00363     fis->lba0 = (uint8_t)(lba & 0xFF);\par
00364     fis->lba1 = (uint8_t)((lba >> 8) & 0xFF);\par
00365     fis->lba2 = (uint8_t)((lba >> 16) & 0xFF);\par
00366     fis->lba3 = (uint8_t)((lba >> 24) & 0xFF);\par
00367     fis->lba4 = 0;\par
00368     fis->lba5 = 0;\par
00369     fis->countl = 1;\par
00370     fis->counth = 0;\par
00371 \par
00372     {\cf20 /* PRDT (one entry) */}\par
00373     HBA_PRDT_ENTRY* prdt = &cmd->prdt_entry[0];\par
00374     uintptr_t buf_phys = MtTranslateVirtualToPhysical(buf);\par
00375 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00376 \par
00377     gop_printf(COLOR_BLUE, {\cf22 "In ahci_read_sector: buf_phys: %p | virt: %p\\n"}, ({\cf18 void}*)buf_phys, buf);\par
00378 \par
00379 {\cf21 #endif}\par
00380     uint32_t bytes = 512;\par
00381     prdt->dba = (uint32_t)(uintptr_t)buf_phys;\par
00382     prdt->dbau = (uint32_t)(((uintptr_t)buf_phys) >> 32);\par
00383     prdt->dbc = bytes - 1;\par
00384     prdt->i |= 1;\par
00385 \par
00386     {\cf20 /* Ensure controller sees CLB/CMD/FIS and data buffer in memory in correct order. */}\par
00387 \par
00388     {\cf20 /* Flush/invalidate command structures first, then the data buffer, then strong fences. */}\par
00389     cache_flush_invalidate_range(ctx->clb, 1024);            {\cf20 // CLB is 1 KiB}\par
00390     cache_flush_invalidate_range(cmd, 256);\par
00391     cache_flush_invalidate_range(ctx->fis, 256);             {\cf20 // FIS receive buffer}\par
00392     {\cf20 /* Buffer sanity */}\par
00393 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00394     assert(buf != NULL, {\cf22 "read buffer is NULL"});\par
00395     assert(MtIsAddressValid(buf), {\cf22 "read buffer virtual address invalid"});\par
00396     assert((buf_phys & 0x1) == 0, {\cf22 "Buffer not word-aligned."});\par
00397     assert(buf_phys != 0, {\cf22 "read buffer physical translation returned 0"});\par
00398     assert((buf_phys & 0x1FF) == 0, {\cf22 "read buffer physical address must be 512-byte aligned"});\par
00399     {\cf20 /* hdr / cmd table bounds sanity */}\par
00400     assert(((uintptr_t)hdr >= (uintptr_t)ctx->clb) && ((uintptr_t)hdr < ((uintptr_t)ctx->clb + 1024)),\par
00401         {\cf22 "HBA_CMD_HEADER pointer not inside CLB region"});\par
00402     uintptr_t cmd_tbl_region_start = (uintptr_t)ctx->cmd_tbl;\par
00403     uintptr_t cmd_tbl_region_end = cmd_tbl_region_start + (256 * 32);\par
00404     assert(((uintptr_t)cmd >= cmd_tbl_region_start) && ((uintptr_t)cmd < cmd_tbl_region_end),\par
00405         {\cf22 "Command table pointer out of allocated command-table region"});\par
00406     {\cf20 /* PRDT correctness: DBA/DBAU match the buffer physical address and dbc encodes bytes-1 and IOC set */}\par
00407     uintptr_t prdt_dba_full = (((uintptr_t)prdt->dbau) << 32) | (uintptr_t)prdt->dba;\par
00408     assert(prdt_dba_full == buf_phys, {\cf22 "PRDT DBA != buffer physical address"});\par
00409     uint32_t prdt_bytes = prdt->dbc & 0x003FFFFFu;  {\cf20 // low 22 bits = byte_count - 1}\par
00410     uint32_t prdt_ioc = (prdt->i & 0x1);\par
00411     assert(prdt_ioc == 1, {\cf22 "PRDT IOC (interrupt-on-completion) not set"});\par
00412     assert(prdt_bytes == (uint32_t)(bytes - 1), {\cf22 "PRDT dbc byte count not equal to bytes-1"});\par
00413     {\cf20 /* CFIS/header sanity */}\par
00414 {\cf21 #endif}\par
00415 {\cf21 #ifdef HBA_CMD_HDR_CFL_MASK}\par
00416     assert(hba_cmd_hdr_get_cfl(hdr) >= 2 && hba_cmd_hdr_get_cfl(hdr) <= 16, {\cf22 "CFIS length out of range"});\par
00417 \par
00418 {\cf21 #else}\par
00419 \par
00420     assert(((hdr->dw0 & 0x1F) >= 2) && ((hdr->dw0 & 0x1F) <= 16), {\cf22 "CFIS length out of range"});\par
00421 \par
00422 {\cf21 #endif}\par
00423     {\cf20 /* Flush/invalidate the data buffer as well (prepare CPU cache for DMA result) */}\par
00424     cache_flush_invalidate_range(buf, 512);\par
00425     {\cf20 /* Strong ordering so device definitely sees the command and PRDT */}\par
00426     __asm__ {\cf17 volatile}({\cf22 "sfence; mfence"} ::: {\cf22 "memory"});\par
00427 \par
00428     {\cf20 /* Clear pending interrupts for the port (read/write to acknowledge) - explicit read/write */}\par
00429     uint32_t port_is_before = p->is;\par
00430     p->is = port_is_before;\par
00431 \par
00432 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00433     {\cf20 // Validate the Command FIS:}\par
00434     gop_printf_forced(0xFFFFFF00, {\cf22 "Command FIS Validation:\\n"});\par
00435     gop_printf_forced(0xFFFFFF00, {\cf22 "  FIS Type: %p (should be 0x27)\\n"}, fis->fis_type);\par
00436     gop_printf_forced(0xFFFFFF00, {\cf22 "  C bit: %u (should be 1)\\n"}, fis->c);\par
00437     gop_printf_forced(0xFFFFFF00, {\cf22 "  Command: %p (READ DMA EXT)\\n"}, fis->command);\par
00438     gop_printf_forced(0xFFFFFF00, {\cf22 "  Device: %p (should be 0x40)\\n"}, fis->device);\par
00439     {\cf20 // Verify the complete FIS is exactly 20 bytes and properly terminated}\par
00440 \par
00441     uint8_t cfl = hba_cmd_hdr_get_cfl(hdr);\par
00442     gop_printf_forced(0xFFFFFF00, {\cf22 "  FIS size check: CFL=%u DWORDs = %u bytes (should be 20)\\n"},\par
00443         cfl, cfl * 4);\par
00444 {\cf21 #endif}\par
00445 \par
00446 \par
00447     {\cf20 /* Issue command */}\par
00448     p->ci = (1u << slot);\par
00449 \par
00450     {\cf20 /* Wait for completion with timeout */}\par
00451 \par
00452     spin = 0;\par
00453     {\cf19 while} (p->ci & (1u << slot)) \{\par
00454         {\cf19 if} (++spin >= TIMEOUT) {\cf19 break};\par
00455     \}\par
00456     {\cf19 if} (spin >= TIMEOUT) \{\par
00457 \par
00458 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00459 \par
00460         gop_printf_forced(0xFFFF0000, {\cf22 "AHCI read timeout\\n"});\par
00461 \par
00462         gop_printf_forced(0xFFFFFF00,\par
00463 \par
00464             {\cf22 "tfd=%p serr=%p is=%p\\n"},\par
00465 \par
00466             ({\cf18 void}*)(uintptr_t)p->tfd,\par
00467 \par
00468             ({\cf18 void}*)(uintptr_t)p->serr,\par
00469 \par
00470             ({\cf18 void}*)(uintptr_t)p->is);\par
00471 \par
00472         gop_printf_forced(0xFFFFFF00,\par
00473 \par
00474             {\cf22 "hdr.ctba=%p hdr.prdtl=%u hdr.prdbc=%u\\n"},\par
00475 \par
00476             ({\cf18 void}*)(uintptr_t)hdr->ctba,\par
00477 \par
00478             hba_cmd_hdr_get_prdtl(hdr),\par
00479 \par
00480             hdr->prdbc);\par
00481 \par
00482         gop_printf_forced(0xFFFFFF00,\par
00483 \par
00484             {\cf22 "ctx=%p ctx->cmd_tbl=%p ctx->clb=%p port=%p\\n"},\par
00485 \par
00486             ({\cf18 void}*)ctx,\par
00487 \par
00488             ({\cf18 void}*)ctx->cmd_tbl,\par
00489 \par
00490             ({\cf18 void}*)ctx->clb,\par
00491 \par
00492             ({\cf18 void}*)p);\par
00493 \par
00494 {\cf21 #endif}\par
00495         {\cf19 return} MT_AHCI_TIMEOUT;\par
00496 \par
00497     \}\par
00498 \par
00499     {\cf20 // IMPORTANT: Even if it didn't time out, check for errors from the device}\par
00500     {\cf20 // p->tfd bit 7 is BSY, bit 0 is ERR}\par
00501     {\cf19 if} (p->tfd & ((1 << 7) | (1 << 0))) \{\par
00502 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00503 \par
00504         gop_printf_forced(0xFFFF0000, {\cf22 "AHCI read error!\\n"});\par
00505 \par
00506         gop_printf_forced(0xFFFFFF00, {\cf22 "Port TFD: %p, SERR: %p\\n"}, ({\cf18 void}*)(uintptr_t)p->tfd, ({\cf18 void}*)(uintptr_t)p->serr);\par
00507 \par
00508 {\cf21 #endif}\par
00509         {\cf19 return} MT_AHCI_READ_FAILURE;\par
00510     \}\par
00511 \par
00512 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00513     {\cf20 /* Command issue cleared */}\par
00514     assert(((p->ci & (1u << slot)) == 0), {\cf22 "PxCI slot bit still set after completion"});\par
00515 \par
00516     {\cf20 /* Task file and error checks */}\par
00517     assert(((p->tfd & (1u << 0)) == 0), {\cf22 "PxTFD ERR bit set after transfer (device reported error)"});\par
00518     {\cf20 /* optional: ensure not BSY */}\par
00519     assert(((p->tfd & (1u << 7)) == 0), {\cf22 "PxTFD BSY still set after transfer"});\par
00520 \par
00521     assert((p->serr) == 0, {\cf22 "Serr isn't equal 0"});\par
00522     uint8_t status = (p->tfd >> 8) & 0xFF;  {\cf20 // ATA status register}\par
00523     assert((status & 0x01) == 0, {\cf22 "ERR Bit in status set"});\par
00524 {\cf21 #endif}\par
00525     {\cf20 /* Byte count reported by header (DW1) matches requested bytes (512) */}\par
00526     {\cf20 /* Read prdbc after we ensure device completed and after an mfence to be safe */}\par
00527     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00528     cache_flush_invalidate_range(hdr, {\cf17 sizeof}(HBA_CMD_HEADER));\par
00529     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00530 \par
00531     {\cf20 // Now read prdbc}\par
00532 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00533     uint32_t actual_bytes = hdr->prdbc;\par
00534     gop_printf_forced(0xFFFFFF00, {\cf22 "Expected: %u, Actual prdbc: %u\\n"}, bytes, actual_bytes);\par
00535     assert(hdr->prdbc == (uint32_t)bytes, {\cf22 "hdr.prdbc != bytes transferred"});\par
00536 \par
00537     {\cf20 /* Make sure CPU cache invalidation can see device writes (simple check: buf_phys non-zero and mapped) */}\par
00538     assert(MtIsAddressValid(buf), {\cf22 "buffer invalid after transfer (mapping vanished)"});\par
00539 {\cf21 #endif}\par
00540     {\cf20 // If we have gotten here, ahci read is successfull.}\par
00541     cache_flush_invalidate_range(buf, 512);\par
00542     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00543 \par
00544     {\cf20 /* Acknowledge/clear interrupts (read and write back) */}\par
00545     uint32_t port_is_after = p->is;\par
00546     p->is = port_is_after;\par
00547 \par
00548     {\cf19 return} MT_SUCCESS;\par
00549 \}\par
00550 \par
00551 MTSTATUS ahci_write_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf17 const} {\cf18 void}* buf) \{\par
00552     tracelast_func({\cf22 "ahci_write_sector"});\par
00553     AHCI_PORT_CTX* ctx = (AHCI_PORT_CTX*)dev->dev_data;\par
00554     HBA_PORT* p = ctx->port;\par
00555 \par
00556     {\cf18 int} slot = find_free_slot(p->sact | p->ci);\par
00557     {\cf19 if} (slot < 0) {\cf19 return} MT_AHCI_GENERAL_FAILURE;\par
00558 \par
00559     {\cf20 /* Command table for this slot */}\par
00560     HBA_CMD_TBL* cmd = (HBA_CMD_TBL*)((uint8_t*)ctx->cmd_tbl + slot * 256);\par
00561     kmemset(cmd, 0, 256);\par
00562 \par
00563     {\cf20 /* Command header */}\par
00564     HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)ctx->clb + slot * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00565     hba_cmd_hdr_set_cfl(hdr, ({\cf17 sizeof}(FIS_REG_H2D) + 3) / 4);\par
00566     hba_cmd_hdr_set_w(hdr, 1);       {\cf20 /* write */}\par
00567     hdr->prdbc = 0;\par
00568     hba_cmd_hdr_set_prdtl(hdr, 1);\par
00569 \par
00570     {\cf20 /* Build CFIS */}\par
00571     FIS_REG_H2D* fis = (FIS_REG_H2D*)(&cmd->cfis);\par
00572     kmemset(fis, 0, {\cf17 sizeof}(*fis));\par
00573     fis->fis_type = FIS_TYPE_REG_H2D;\par
00574     fis->c = 1;\par
00575     fis->command = 0x35; {\cf20 /* WRITE DMA EXT */}\par
00576     fis->device = 1 << 6;\par
00577     fis->lba0 = (uint8_t)(lba & 0xFF);\par
00578     fis->lba1 = (uint8_t)((lba >> 8) & 0xFF);\par
00579     fis->lba2 = (uint8_t)((lba >> 16) & 0xFF);\par
00580     fis->lba3 = (uint8_t)((lba >> 24) & 0xFF);\par
00581     fis->lba4 = 0;\par
00582     fis->lba5 = 0;\par
00583     fis->countl = 1;\par
00584     fis->counth = 0;\par
00585 \par
00586     {\cf20 /* PRDT */}\par
00587     HBA_PRDT_ENTRY* prdt = &cmd->prdt_entry[0];\par
00588     {\cf20 // this removes constness from buf, but it's fine since the translation DOES NOT write to the buffer, only makes translations.}\par
00589     uintptr_t buf_phys = MtTranslateVirtualToPhysical(({\cf18 void}*)buf);\par
00590 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00591     gop_printf(COLOR_BLUE, {\cf22 "In AHCI_WRITE_SECTOR, buf_phys: %p | buf: %p\\n"}, buf_phys, buf);\par
00592 {\cf21 #endif}\par
00593     uint32_t bytes = 512;\par
00594     prdt->dba = (uint32_t)(uintptr_t)buf_phys;\par
00595     prdt->dbau = (uint32_t)(((uintptr_t)buf_phys) >> 32);\par
00596     prdt->dbc = bytes - 1;\par
00597     prdt->i |= 1;\par
00598 \par
00599     cache_flush_invalidate_range(({\cf18 void}*)buf, 512);\par
00600     cache_flush_invalidate_range(({\cf18 void}*)buf, 512);\par
00601     cache_flush_invalidate_range(ctx->clb, 1024);            {\cf20 // CLB is 1 KiB}\par
00602     cache_flush_invalidate_range(cmd, 256);\par
00603     cache_flush_invalidate_range(ctx->fis, 256);             {\cf20 // FIS receive buffer}\par
00604     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00605 \par
00606     {\cf20 /* Clear pending interrupts */}\par
00607     p->is = p->is;\par
00608 \par
00609     {\cf20 /* Issue */}\par
00610     p->ci = (1u << slot);\par
00611 \par
00612     {\cf20 /* Wait */}\par
00613     uint32_t spin = 0;\par
00614     {\cf17 const} uint32_t TIMEOUT = 100000000;\par
00615     {\cf19 while} (p->ci & (1u << slot)) \{\par
00616         {\cf19 if} (++spin >= TIMEOUT) {\cf19 break};\par
00617     \}\par
00618 \par
00619     {\cf19 if} (spin >= TIMEOUT) \{\par
00620 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00621         gop_printf(COLOR_RED, {\cf22 "AHCI TIMEOUT ahci_read_sector\\n"});\par
00622 {\cf21 #endif}\par
00623         {\cf19 return} MT_AHCI_TIMEOUT;\par
00624     \}\par
00625 \par
00626     {\cf20 // IMPORTANT: Check for errors from the device}\par
00627     {\cf19 if} (p->tfd & ((1 << 7) | (1 << 0))) \{\par
00628 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00629         gop_printf_forced(0xFFFF0000, {\cf22 "AHCI write error!\\n"});\par
00630         gop_printf_forced(0xFFFFFF00, {\cf22 "Port TFD: %p, SERR: %p\\n"}, ({\cf18 void}*)(uintptr_t)p->tfd, ({\cf18 void}*)(uintptr_t)p->serr);\par
00631 {\cf21 #endif}\par
00632         {\cf19 return} MT_AHCI_WRITE_FAILURE;\par
00633     \}\par
00634 \par
00635     {\cf20 // clear int}\par
00636     p->is = p->is;\par
00637 \par
00638     {\cf19 return} MT_SUCCESS;\par
00639 \}\par
00640 \par
00641 \par
00642 BLOCK_DEVICE* ahci_get_block_device({\cf18 int} index) \{\par
00643     tracelast_func({\cf22 "ahci_get_block_device"});\par
00644     {\cf19 return} get_block_device(index);\par
00645 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include "../blk/block.h"}\par
{\f2 #include "../../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_MEM}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_PORT}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _FIS_REG_H2D}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_PRDT_ENTRY}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_CMD_TBL}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_CMD_HEADER}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_MAX_PORTS}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_CFL_MASK}\~ 0x0000001Fu\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_A_BIT}\~ (1u << 5)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_W_BIT}\~ (1u << 6)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_P_BIT}\~ (1u << 7)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_PRDTL_MASK}\~ 0xFFFF0000u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_DEV_BSY}\~ 0x80\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_DEV_DRQ}\~ 0x08\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_DEV_ERR}\~ 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_CMD_READ_DMA_EX}\~ 0x25\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_CMD_WRITE_DMA_EX}\~ 0x35\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_NULL}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_SATA}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_SEMB}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_PM}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_SATAPI}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PORT_IPM_ACTIVE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PORT_DET_PRESENT}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_ST}\~ 0x0001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_FRE}\~ 0x0010\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_FR}\~ 0x4000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_CR}\~ 0x8000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxIS_TFES}\~ (1 << 30)       /* TFES - Task File Error Status */\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FIS_TYPE} {\b FIS_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef volatile struct {\b _HBA_MEM} {\b HBA_MEM}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef volatile struct {\b _HBA_PORT} {\b HBA_PORT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _FIS_REG_H2D} {\b FIS_REG_H2D}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HBA_PRDT_ENTRY} {\b HBA_PRDT_ENTRY}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HBA_CMD_TBL} {\b HBA_CMD_TBL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HBA_CMD_HEADER} {\b HBA_CMD_HEADER}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FIS_TYPE} \{ {\b FIS_TYPE_REG_H2D} = 0x27
, {\b FIS_TYPE_REG_D2H} = 0x34
, {\b FIS_TYPE_DMA_ACT} = 0x39
, {\b FIS_TYPE_DMA_SETUP} = 0x41
, {\b FIS_TYPE_DATA} = 0x46
, {\b FIS_TYPE_BIST} = 0x58
, {\b FIS_TYPE_PIO_SETUP} = 0x5F
, {\b FIS_TYPE_DEV_BITS} = 0xA1
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_read_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, void *buf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single 512-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_write_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, const void *buf)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single 512-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b ahci_get_block_device} (int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AHCI_DEV_NULL\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_NULL\~ 0}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_PM\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_PM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_PM\~ 3}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_SATA\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_SATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_SATA\~ 1}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_SATAPI\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_SATAPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_SATAPI\~ 4}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_SEMB\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_SEMB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_SEMB\~ 2}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_MAX_PORTS\:ahci.h}
{\xe \v ahci.h\:AHCI_MAX_PORTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_MAX_PORTS\~ 32}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b ahci.h}.}\par
}
{\xe \v ATA_CMD_READ_DMA_EX\:ahci.h}
{\xe \v ahci.h\:ATA_CMD_READ_DMA_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_CMD_READ_DMA_EX\~ 0x25}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b ahci.h}.}\par
}
{\xe \v ATA_CMD_WRITE_DMA_EX\:ahci.h}
{\xe \v ahci.h\:ATA_CMD_WRITE_DMA_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_CMD_WRITE_DMA_EX\~ 0x35}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b ahci.h}.}\par
}
{\xe \v ATA_DEV_BSY\:ahci.h}
{\xe \v ahci.h\:ATA_DEV_BSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_DEV_BSY\~ 0x80}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b ahci.h}.}\par
}
{\xe \v ATA_DEV_DRQ\:ahci.h}
{\xe \v ahci.h\:ATA_DEV_DRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_DEV_DRQ\~ 0x08}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b ahci.h}.}\par
}
{\xe \v ATA_DEV_ERR\:ahci.h}
{\xe \v ahci.h\:ATA_DEV_ERR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_DEV_ERR\~ 0x01}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_A_BIT\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_A_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_A_BIT\~ (1u << 5)}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_CFL_MASK\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_CFL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_CFL_MASK\~ 0x0000001Fu}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_P_BIT\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_P_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_P_BIT\~ (1u << 7)}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_PRDTL_MASK\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_PRDTL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_PRDTL_MASK\~ 0xFFFF0000u}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_W_BIT\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_W_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_W_BIT\~ (1u << 6)}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PORT_DET_PRESENT\:ahci.h}
{\xe \v ahci.h\:HBA_PORT_DET_PRESENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PORT_DET_PRESENT\~ 3}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PORT_IPM_ACTIVE\:ahci.h}
{\xe \v ahci.h\:HBA_PORT_IPM_ACTIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PORT_IPM_ACTIVE\~ 1}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_CR\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_CR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_CR\~ 0x8000}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_FR\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_FR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_FR\~ 0x4000}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_FRE\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_FRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_FRE\~ 0x0010}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_ST\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_ST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_ST\~ 0x0001}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxIS_TFES\:ahci.h}
{\xe \v ahci.h\:HBA_PxIS_TFES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxIS_TFES\~ (1 << 30)       /* TFES - Task File Error Status */}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FIS_REG_H2D\:ahci.h}
{\xe \v ahci.h\:FIS_REG_H2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _FIS_REG_H2D} {\b FIS_REG_H2D}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }}\par
}
{\xe \v FIS_TYPE\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FIS_TYPE} {\b FIS_TYPE}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HBA_CMD_HEADER\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HBA_CMD_HEADER} {\b HBA_CMD_HEADER}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }}\par
}
{\xe \v HBA_CMD_TBL\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_TBL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HBA_CMD_TBL} {\b HBA_CMD_TBL}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }}\par
}
{\xe \v HBA_MEM\:ahci.h}
{\xe \v ahci.h\:HBA_MEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef volatile struct {\b _HBA_MEM} {\b HBA_MEM}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }}\par
}
{\xe \v HBA_PORT\:ahci.h}
{\xe \v ahci.h\:HBA_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef volatile struct {\b _HBA_PORT} {\b HBA_PORT}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }}\par
}
{\xe \v HBA_PRDT_ENTRY\:ahci.h}
{\xe \v ahci.h\:HBA_PRDT_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HBA_PRDT_ENTRY} {\b HBA_PRDT_ENTRY}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FIS_TYPE\:ahci.h}
{\xe \v ahci.h\:_FIS_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FIS_TYPE}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v FIS_TYPE_REG_H2D\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_REG_H2D}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_REG_H2D{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_REG_D2H\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_REG_D2H}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_REG_D2H{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DMA_ACT\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DMA_ACT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DMA_ACT{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DMA_SETUP\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DMA_SETUP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DMA_SETUP{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DATA\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DATA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DATA{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_BIST\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_BIST}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_BIST{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_PIO_SETUP\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_PIO_SETUP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_PIO_SETUP{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DEV_BITS\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DEV_BITS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DEV_BITS{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 19} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ahci_get_block_device\:ahci.h}
{\xe \v ahci.h\:ahci_get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * ahci_get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the {\b BLOCK_DEVICE} registration.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b BLOCK_DEVICE} struct pointer.\par
}}}{
Definition at line {\b 642} of file {\b ahci.c}.}\par
}
{\xe \v ahci_init\:ahci.h}
{\xe \v ahci.h\:ahci_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_init (void )}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the AHCI Driver.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based if it initialized correctly or not. (if failure = bugcheck)\par
}}}{
Definition at line {\b 288} of file {\b ahci.c}.}\par
}
{\xe \v ahci_read_sector\:ahci.h}
{\xe \v ahci.h\:ahci_read_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_read_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, void * buf)}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single 512-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Return buffer to place the data read.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession | buf pointer changes.\par
}}}{
Definition at line {\b 328} of file {\b ahci.c}.}\par
}
{\xe \v ahci_write_sector\:ahci.h}
{\xe \v ahci.h\:ahci_write_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_write_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, const void * buf)}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single 512-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{The buffer to write to the specified LBA.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession\par
}}}{
Definition at line {\b 551} of file {\b ahci.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ahci.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      AHCI Driver types and functions.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_DRIVER_AHCI_H}\par
00008 {\cf21 #define X86_DRIVER_AHCI_H}\par
00009 \par
00010 {\cf21 #include <stdint.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stddef.h>}\par
00013 {\cf21 #include "../blk/block.h"}\par
00014 {\cf21 #include "../../mtstatus.h"}\par
00015 \par
00016 {\cf20 // Maximum number of AHCI Ports supported}\par
00017 {\cf21 #define AHCI_MAX_PORTS 32}\par
00018 \par
00019 {\cf17 typedef} {\cf17 enum} _FIS_TYPE \{\par
00020     FIS_TYPE_REG_H2D = 0x27,    {\cf20 // Register FIS - host to device}\par
00021     FIS_TYPE_REG_D2H = 0x34,    {\cf20 // Register FIS - device to host}\par
00022     FIS_TYPE_DMA_ACT = 0x39,    {\cf20 // DMA activate FIS - device to host}\par
00023     FIS_TYPE_DMA_SETUP = 0x41,    {\cf20 // DMA setup FIS - bidirectional}\par
00024     FIS_TYPE_DATA = 0x46,  {\cf20 // Data FIS - bidirectional}\par
00025     FIS_TYPE_BIST = 0x58,  {\cf20 // BIST activate FIS - bidirectional}\par
00026     FIS_TYPE_PIO_SETUP = 0x5F,    {\cf20 // PIO setup FIS - device to host}\par
00027     FIS_TYPE_DEV_BITS = 0xA1,  {\cf20 // Set device bits FIS - device to host}\par
00028 \} FIS_TYPE;\par
00029 \par
00031 {\cf17 typedef} {\cf17 volatile} {\cf17 struct }_HBA_MEM \{\par
00032     uint32_t cap;        {\cf20 // 0x00: Host Capabilities.}\par
00033     uint32_t ghc;        {\cf20 // 0x04: Global host control}\par
00034     uint32_t is;      {\cf20 // 0x08: Interrupt Status}\par
00035     uint32_t pi;      {\cf20 // 0x0C: Ports implemented.}\par
00036     uint32_t vs;      {\cf20 // 0x10: Version}\par
00037     uint32_t ccc_ctl;    {\cf20 // 0x14: Command completion coalescing control}\par
00038     uint32_t ccc_pts;    {\cf20 // 0x18: Command completion coalescing ports.}\par
00039     uint32_t em_loc;  {\cf20 // 0x1C: Enclosure management location}\par
00040     uint32_t em_ctl;  {\cf20 // 0x20: Enclosure management control}\par
00041     uint32_t cap2;      {\cf20 // 0x24: Host capabilities EXTENDED.}\par
00042     uint32_t bohc;      {\cf20 // 0x28: BIOS/OS handoff control and status.}\par
00043     uint8_t  rsv[0xA0 - 0x2C];\par
00044     uint8_t  venor[0x100 - 0xA0];\par
00046 \} HBA_MEM;\par
00047 \par
00049 {\cf17 typedef} {\cf17 volatile} {\cf17 struct }_HBA_PORT \{\par
00050     uint32_t clb;        {\cf20 // 0x00: Command list base address lower 32 bits.}\par
00051     uint32_t clbu;      {\cf20 // 0x04: Command list base address higher 32 bits.}\par
00052     uint32_t fb;      {\cf20 // 0x08: FIS Base address lower 32 bits.}\par
00053     uint32_t fbu;        {\cf20 // 0x0C: FIS Base address higher 32 bits.}\par
00054     uint32_t is;      {\cf20 // 0x10: Interrupt Status.}\par
00055     uint32_t ie;      {\cf20 // 0x14: Interrupt Enable.}\par
00056     uint32_t cmd;        {\cf20 // 0x18: Command And Status.}\par
00057     uint32_t rsv0;      {\cf20 // 0x1C: RESERVED.}\par
00058     uint32_t tfd;        {\cf20 // 0x20: Task File Data.}\par
00059     uint32_t sig;        {\cf20 // 0x24: Signature.}\par
00060     uint32_t ssts;      {\cf20 // 0x28: Serial ATA Status.}\par
00061     uint32_t sctl;      {\cf20 // 0x2C: Serial ATA Control.}\par
00062     uint32_t serr;      {\cf20 // 0x30: Serial ATA Error.}\par
00063     uint32_t sact;      {\cf20 // 0x34: Serial ATA Active.}\par
00064     uint32_t ci;      {\cf20 // 0x38: Command Issue.}\par
00065     uint32_t sntf;      {\cf20 // 0x3C: Serial ATA notification.}\par
00066     uint32_t fbs;        {\cf20 // 0x40: FIS-Based switch control.}\par
00067     uint32_t rsv1[11];  {\cf20 // 0x44 - 0x6F: RESERVED.}\par
00068     uint32_t vendor[4]; {\cf20 // 0x70: Vendor Specific.}\par
00069 \} HBA_PORT;\par
00070 \par
00071 {\cf20 // Data structures for FIS and Command Tables }\par
00072 \par
00074 {\cf21 #pragma pack(push, 1)}\par
00075 {\cf17 typedef} {\cf17 struct }_FIS_REG_H2D \{\par
00076     uint8_t fis_type;\par
00077     uint8_t pmport : 4;\par
00078     uint8_t rsv0 : 3;\par
00079     uint8_t c : 1;       {\cf20 // 1: command, 0: control}\par
00080     uint8_t command;     {\cf20 // ATA command}\par
00081     uint8_t featurel;    {\cf20 // feature low}\par
00082     uint8_t lba0;        {\cf20 // LBA low byte}\par
00083     uint8_t lba1;        {\cf20 // LBA mid byte}\par
00084     uint8_t lba2;        {\cf20 // LBA high byte}\par
00085     uint8_t device;\par
00086     uint8_t lba3;        {\cf20 // LBA byte 3}\par
00087     uint8_t lba4;        {\cf20 // LBA byte 4}\par
00088     uint8_t lba5;        {\cf20 // LBA byte 5}\par
00089     uint8_t featureh;    {\cf20 // feature high}\par
00090     uint8_t countl;      {\cf20 // sector count low}\par
00091     uint8_t counth;      {\cf20 // sector count high}\par
00092     uint8_t icc;         {\cf20 // ISO command completion}\par
00093     uint8_t control;\par
00094     uint8_t rsv1[4];\par
00095 \} FIS_REG_H2D;\par
00096 \par
00098 {\cf17 typedef} {\cf17 struct }_HBA_PRDT_ENTRY \{\par
00099     uint32_t dba;        {\cf20 // Data base address}\par
00100     uint32_t dbau;      {\cf20 // Data base address upper 32 bits}\par
00101     uint32_t rsv0;      {\cf20 // Reserved}\par
00102 \par
00103     {\cf20 // DW3}\par
00104     uint32_t dbc : 22;       {\cf20 // Byte count, 4M max}\par
00105     uint32_t rsv1 : 9;      {\cf20 // Reserved}\par
00106     uint32_t i : 1;        {\cf20 // Interrupt on completionn}\par
00107 \} HBA_PRDT_ENTRY;\par
00108 \par
00110 {\cf17 typedef} {\cf17 struct }_HBA_CMD_TBL \{\par
00111     {\cf20 // 0x00}\par
00112     uint8_t  cfis[64];  {\cf20 // Command FIS}\par
00113 \par
00114     {\cf20 // 0x40}\par
00115     uint8_t  acmd[16];  {\cf20 // ATAPI command, 12 or 16 bytes}\par
00116 \par
00117     {\cf20 // 0x50}\par
00118     uint8_t  rsv[48];    {\cf20 // Reserved}\par
00119 \par
00120     {\cf20 // 0x80}\par
00121     HBA_PRDT_ENTRY    prdt_entry[1];    {\cf20 // Physical region descriptor table entries, 0 ~ 65535}\par
00122 \} HBA_CMD_TBL;\par
00123 {\cf21 #pragma pack(pop)}\par
00124 \par
00128 {\cf17 typedef} {\cf17 struct }_HBA_CMD_HEADER \{\par
00129     {\cf17 volatile} uint32_t dw0;     {\cf20 // control flags + PRDTL}\par
00130     {\cf17 volatile} uint32_t prdbc;   {\cf20 // physical region descriptor byte count transferred}\par
00131     uint32_t ctba;             {\cf20 // command table base address (lower)}\par
00132     uint32_t ctbau;            {\cf20 // command table base address upper}\par
00133     uint32_t rsv1[4];          {\cf20 // reserved}\par
00134 \} HBA_CMD_HEADER;\par
00135 {\cf21 #ifndef _MSC_VER}\par
00136 {\cf17 _Static_assert}({\cf17 sizeof}(HBA_CMD_HEADER) == 32, {\cf22 "SIZEOF HBA_CMD_HEADER ISNT 32 BYTES! -- Misalignment check."});\par
00137 {\cf17 _Static_assert}({\cf17 sizeof}(HBA_PRDT_ENTRY) == 16, {\cf22 "PRDT must be 16 bytes"});\par
00138 {\cf17 _Static_assert}(offsetof(HBA_CMD_TBL, prdt_entry) == 0x80, {\cf22 "PRDT must start at offset 0x80 in CMD_TBL"});\par
00139 {\cf17 _Static_assert}({\cf17 sizeof}(((HBA_CMD_TBL*)0)->cfis) == 64, {\cf22 "cfis must be 64 bytes"});\par
00140 {\cf21 #endif}\par
00141 \par
00142 {\cf20 // AHCI Driver API}\par
00143 \par
00144 {\cf20 // Bit masks / helpers for dw0}\par
00145 {\cf20 // Bit masks / helpers for dw0}\par
00146 {\cf21 #define HBA_CMD_HDR_CFL_MASK    0x0000001Fu}\par
00147 {\cf21 #define HBA_CMD_HDR_A_BIT       (1u << 5)}\par
00148 {\cf21 #define HBA_CMD_HDR_W_BIT       (1u << 6)}\par
00149 {\cf21 #define HBA_CMD_HDR_P_BIT       (1u << 7)}\par
00150 {\cf21 #define HBA_CMD_HDR_PRDTL_MASK  0xFFFF0000u}\par
00151 {\cf21 #define ATA_DEV_BSY 0x80 }{\cf20 // Busy}\par
00152 {\cf21 #define ATA_DEV_DRQ 0x08 }{\cf20 // Data Request}\par
00153 {\cf21 #define ATA_DEV_ERR 0x01 }{\cf20 // Error}\par
00154 \par
00155 {\cf21 #define ATA_CMD_READ_DMA_EX     0x25}\par
00156 {\cf21 #define ATA_CMD_WRITE_DMA_EX    0x35}\par
00157 \par
00158 {\cf21 #define AHCI_DEV_NULL 0}\par
00159 {\cf21 #define AHCI_DEV_SATA 1}\par
00160 {\cf21 #define AHCI_DEV_SEMB 2}\par
00161 {\cf21 #define AHCI_DEV_PM   3}\par
00162 {\cf21 #define AHCI_DEV_SATAPI 4}\par
00163 \par
00164 {\cf21 #define HBA_PORT_IPM_ACTIVE 1}\par
00165 {\cf21 #define HBA_PORT_DET_PRESENT 3}\par
00166 \par
00167 {\cf21 #define HBA_PxCMD_ST    0x0001}\par
00168 {\cf21 #define HBA_PxCMD_FRE   0x0010}\par
00169 {\cf21 #define HBA_PxCMD_FR    0x4000}\par
00170 {\cf21 #define HBA_PxCMD_CR    0x8000}\par
00171 {\cf21 #define HBA_PxIS_TFES   (1 << 30)       }{\cf20 /* TFES - Task File Error Status */}{\cf21 }\par
00172 \par
00173 {\cf17 static} {\cf17 inline} {\cf18 void} hba_cmd_hdr_set_cfl(HBA_CMD_HEADER* h, uint32_t cfl) \{\par
00174     h->dw0 = (h->dw0 & ~HBA_CMD_HDR_CFL_MASK) | ((cfl)&HBA_CMD_HDR_CFL_MASK);\par
00175 \}\par
00176 {\cf17 static} {\cf17 inline} uint32_t hba_cmd_hdr_get_cfl(HBA_CMD_HEADER* h) \{\par
00177     {\cf19 return} h->dw0 & HBA_CMD_HDR_CFL_MASK;\par
00178 \}\par
00179 \par
00180 {\cf17 static} {\cf17 inline} {\cf18 void} hba_cmd_hdr_set_w(HBA_CMD_HEADER* h, {\cf18 int} w) \{\par
00181     {\cf19 if} (w) h->dw0 |= HBA_CMD_HDR_W_BIT;\par
00182     {\cf19 else} h->dw0 &= ~HBA_CMD_HDR_W_BIT;\par
00183 \}\par
00184 {\cf17 static} {\cf17 inline} {\cf18 int} hba_cmd_hdr_get_w(HBA_CMD_HEADER* h) \{\par
00185     {\cf19 return} (h->dw0 & HBA_CMD_HDR_W_BIT) ? 1 : 0;\par
00186 \}\par
00187 \par
00188 {\cf17 static} {\cf17 inline} {\cf18 void} hba_cmd_hdr_set_prdtl(HBA_CMD_HEADER* h, uint32_t prdtl) \{\par
00189     h->dw0 = (h->dw0 & ~HBA_CMD_HDR_PRDTL_MASK) | (((prdtl) & 0xFFFFu) << 16);\par
00190 \}\par
00191 {\cf17 static} {\cf17 inline} uint32_t hba_cmd_hdr_get_prdtl(HBA_CMD_HEADER* h) \{\par
00192     {\cf19 return} (h->dw0 >> 16) & 0xFFFFu;\par
00193 \}\par
00194 \par
00195 {\cf20 /* Uncomment to see AHCI Debug Prints */}\par
00197 \par
00198 \par
00203 MTSTATUS ahci_init({\cf18 void});\par
00204 \par
00212 MTSTATUS ahci_read_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf18 void}* buf);\par
00213 \par
00221 MTSTATUS ahci_write_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf17 const} {\cf18 void}* buf);\par
00222 \par
00228 BLOCK_DEVICE* ahci_get_block_device({\cf18 int} index);\par
00229 \par
00230 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "block.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_BLK_DEV}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b register_block_device} ({\b BLOCK_DEVICE} *dev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b get_block_device} (int index)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_BLK_DEV\:block.c}
{\xe \v block.c\:MAX_BLK_DEV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_BLK_DEV\~ 32}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b block.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_block_device\:block.c}
{\xe \v block.c\:get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b block.c}.}\par
}
{\xe \v register_block_device\:block.c}
{\xe \v block.c\:register_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void register_block_device ({\b BLOCK_DEVICE} * dev)}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b block.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gop_local\:block.c}
{\xe \v block.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
block.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Block Device Abstraction Driver Implementation}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "block.h"}\par
00008 \par
00009 {\cf21 #define MAX_BLK_DEV 32 }{\cf20 // AHCI is a maximum of 32, anymore than that and we bugcheck.}\par
00010 \par
00011 {\cf17 static} BLOCK_DEVICE* devices[MAX_BLK_DEV];\par
00012 {\cf17 extern} GOP_PARAMS gop_local;\par
00013 {\cf17 static} {\cf18 int} device_count = 0;\par
00014 \par
00015 {\cf18 void} register_block_device(BLOCK_DEVICE* dev) \{\par
00016     tracelast_func({\cf22 "register_block_device"});\par
00017     {\cf20 // print the index we\'92re about to use and the device pointer}\par
00018 {\cf21 #ifdef DEBUG}\par
00019     gop_printf(0xFFFFFF00, {\cf22 "Registering block #%d at %x\\n"}, device_count, (uintptr_t)dev);\par
00020 {\cf21 #endif}\par
00021     {\cf19 if} (device_count < MAX_BLK_DEV) \{\par
00022         devices[device_count++] = dev;\par
00023     \}\par
00024     {\cf19 else} \{\par
00025         {\cf20 // too many!}\par
00026         CTX_FRAME ctx;\par
00027         SAVE_CTX_FRAME(&ctx);\par
00028         MtBugcheck(&ctx, NULL, BLOCK_DEVICE_LIMIT_REACHED, 0, {\cf17 false});\par
00029     \}\par
00030 \}\par
00031 \par
00032 \par
00033 BLOCK_DEVICE* get_block_device({\cf18 int} index) \{\par
00034     tracelast_func({\cf22 "get_block_device"});\par
00035     {\cf19 if} (index < 0 || index >= device_count) \{ {\cf19 return} NULL; \}\par
00036     {\cf19 return} devices[index];\par
00037 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
{\f2 #include "../../cpu/cpu.h"}\par
{\f2 #include "../../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BLOCK_DEVICE}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BLOCK_DEVICE} {\b BLOCK_DEVICE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b register_block_device} ({\b BLOCK_DEVICE} *dev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b get_block_device} (int index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BLOCK_DEVICE\:block.h}
{\xe \v block.h\:BLOCK_DEVICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BLOCK_DEVICE} {\b BLOCK_DEVICE}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_block_device\:block.h}
{\xe \v block.h\:get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b block.c}.}\par
}
{\xe \v register_block_device\:block.h}
{\xe \v block.h\:register_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void register_block_device ({\b BLOCK_DEVICE} * dev)}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b block.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
block.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // kernel/drivers/blk/block.h}\par
00002 {\cf21 #ifndef X86_KERNEL_DRIVER_BLK_BLOCK_H}\par
00003 {\cf21 #define X86_KERNEL_DRIVER_BLK_BLOCK_H}\par
00004 \par
00005 {\cf20 // Standard headers, required.}\par
00006 {\cf21 #include <stddef.h>}\par
00007 {\cf21 #include <stdbool.h>}\par
00008 {\cf21 #include <stdint.h>}\par
00009 {\cf21 #include "../../trace.h"}\par
00010 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00011 {\cf21 #include "../../cpu/cpu.h"}\par
00012 {\cf21 #include "../../mtstatus.h"}\par
00013 \par
00014 {\cf17 typedef} {\cf17 struct }_BLOCK_DEVICE \{\par
00015     MTSTATUS(*read_sector)({\cf17 struct }_BLOCK_DEVICE* dev,\par
00016         uint32_t lba,\par
00017         {\cf18 void}* buf);\par
00018     MTSTATUS(*write_sector)({\cf17 struct }_BLOCK_DEVICE* dev,\par
00019         uint32_t lba,\par
00020         {\cf17 const} {\cf18 void}* buf);\par
00021     {\cf18 void}* dev_data;\par
00022 \} BLOCK_DEVICE;\par
00023 \par
00024 {\cf20 /* Register a block device so `get_block_device()` can find it */}\par
00025 {\cf18 void} register_block_device(BLOCK_DEVICE* dev);\par
00026 \par
00027 {\cf20 /* Get the "n" registered device (0, 1, ...), or NULL if out of range. */}\par
00028 BLOCK_DEVICE* get_block_device({\cf18 int} index);\par
00029 \par
00030 {\cf21 #endif }{\cf20 // X86_KERNEL_DRIVER_BLK_BLOCK_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint8_t {\b font8x16} [256][16]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v font8x16\:font8x16.h}
{\xe \v font8x16.h\:font8x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const uint8_t font8x16[256][16]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
font8x16.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef FONT8X16_H}\par
00002 {\cf21 #define FONT8X16_H}\par
00003 {\cf21 #ifdef FONT8X16_IMPLEMENTATION}\par
00004 {\cf17 static} {\cf17 const} uint8_t font8x16[256][16] = \{\par
00005   \{ 0x00, 0x00, 0x00, 0x7E, 0x81, 0x99, 0xA5, 0xA1, 0xA5, 0x99, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+00}\par
00006   \{ 0x00, 0x00, 0x00, 0x7E, 0x81, 0xB9, 0xA5, 0xB9, 0xA9, 0xA5, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+01}\par
00007   \{ 0x00, 0x00, 0x3C, 0x43, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0xC2, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+02}\par
00008   \{ 0x00, 0x00, 0xFB, 0x55, 0x55, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+03}\par
00009   \{ 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+04}\par
00010   \{ 0x00, 0x00, 0x00, 0x00, 0x44, 0x38, 0x44, 0x44, 0x44, 0x38, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+05}\par
00011   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+06}\par
00012   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+07}\par
00013   \{ 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+08}\par
00014   \{ 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+09}\par
00015   \{ 0x00, 0x38, 0x04, 0x18, 0x04, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0A}\par
00016   \{ 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0B}\par
00017   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+0C}\par
00018   \{ 0x00, 0x10, 0x30, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0D}\par
00019   \{ 0x00, 0xE0, 0x10, 0x60, 0x12, 0xE4, 0x08, 0x10, 0x22, 0x46, 0x8A, 0x1E, 0x02, 0x02, 0x00, 0x00 \}, {\cf20 // U+0E}\par
00020   \{ 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0F}\par
00021   \{ 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+10}\par
00022   \{ 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+11}\par
00023   \{ 0x32, 0x4C, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+12}\par
00024   \{ 0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+13}\par
00025   \{ 0x00, 0x00, 0x7E, 0x92, 0x92, 0x92, 0x92, 0x72, 0x12, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+14}\par
00026   \{ 0x00, 0x38, 0x44, 0x40, 0x30, 0x48, 0x44, 0x44, 0x24, 0x18, 0x04, 0x44, 0x38, 0x00, 0x00, 0x00 \}, {\cf20 // U+15}\par
00027   \{ 0x10, 0x08, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+16}\par
00028   \{ 0x18, 0x24, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+17}\par
00029   \{ 0x00, 0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+18}\par
00030   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x54, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+19}\par
00031   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0xFE, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1A}\par
00032   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0xFE, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1B}\par
00033   \{ 0x24, 0x24, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1C}\par
00034   \{ 0x20, 0x10, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1D}\par
00035   \{ 0x08, 0x10, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1E}\par
00036   \{ 0x18, 0x24, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1F}\par
00037   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+20}\par
00038   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+21}\par
00039   \{ 0x00, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+22}\par
00040   \{ 0x00, 0x00, 0x24, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+23}\par
00041   \{ 0x00, 0x10, 0x10, 0x7C, 0x92, 0x90, 0x90, 0x7C, 0x12, 0x12, 0x92, 0x7C, 0x10, 0x10, 0x00, 0x00 \}, {\cf20 // U+24}\par
00042   \{ 0x00, 0x00, 0x64, 0x94, 0x68, 0x08, 0x10, 0x10, 0x20, 0x2C, 0x52, 0x4C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+25}\par
00043   \{ 0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0x30, 0x4A, 0x44, 0x44, 0x44, 0x3A, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+26}\par
00044   \{ 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+27}\par
00045   \{ 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+28}\par
00046   \{ 0x00, 0x00, 0x20, 0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+29}\par
00047   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x18, 0x7E, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2A}\par
00048   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2B}\par
00049   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00 \}, {\cf20 // U+2C}\par
00050   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2D}\par
00051   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2E}\par
00052   \{ 0x00, 0x00, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2F}\par
00053   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+30}\par
00054   \{ 0x00, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+31}\par
00055   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+32}\par
00056   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x1C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+33}\par
00057   \{ 0x00, 0x00, 0x02, 0x06, 0x0A, 0x12, 0x22, 0x42, 0x7E, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+34}\par
00058   \{ 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+35}\par
00059   \{ 0x00, 0x00, 0x1C, 0x20, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+36}\par
00060   \{ 0x00, 0x00, 0x7E, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+37}\par
00061   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+38}\par
00062   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+39}\par
00063   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3A}\par
00064   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00 \}, {\cf20 // U+3B}\par
00065   \{ 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3C}\par
00066   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3D}\par
00067   \{ 0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3E}\par
00068   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x04, 0x08, 0x08, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3F}\par
00069   \{ 0x00, 0x00, 0x7C, 0x82, 0x9E, 0xA2, 0xA2, 0xA2, 0xA6, 0x9A, 0x80, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+40}\par
00070   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+41}\par
00071   \{ 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+42}\par
00072   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+43}\par
00073   \{ 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+44}\par
00074   \{ 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+45}\par
00075   \{ 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+46}\par
00076   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+47}\par
00077   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+48}\par
00078   \{ 0x00, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+49}\par
00079   \{ 0x00, 0x00, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4A}\par
00080   \{ 0x00, 0x00, 0x42, 0x44, 0x48, 0x50, 0x60, 0x60, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4B}\par
00081   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4C}\par
00082   \{ 0x00, 0x00, 0x82, 0xC6, 0xAA, 0x92, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4D}\par
00083   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4E}\par
00084   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4F}\par
00085   \{ 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+50}\par
00086   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x4A, 0x3C, 0x02, 0x00, 0x00, 0x00 \}, {\cf20 // U+51}\par
00087   \{ 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+52}\par
00088   \{ 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+53}\par
00089   \{ 0x00, 0x00, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+54}\par
00090   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+55}\par
00091   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+56}\par
00092   \{ 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0x92, 0xAA, 0xC6, 0x82, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+57}\par
00093   \{ 0x00, 0x00, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x24, 0x24, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+58}\par
00094   \{ 0x00, 0x00, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+59}\par
00095   \{ 0x00, 0x00, 0x7E, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5A}\par
00096   \{ 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5B}\par
00097   \{ 0x00, 0x00, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5C}\par
00098   \{ 0x00, 0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5D}\par
00099   \{ 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5E}\par
00100   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00 \}, {\cf20 // U+5F}\par
00101   \{ 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+60}\par
00102   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+61}\par
00103   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+62}\par
00104   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+63}\par
00105   \{ 0x00, 0x00, 0x02, 0x02, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+64}\par
00106   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+65}\par
00107   \{ 0x00, 0x00, 0x0E, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+66}\par
00108   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+67}\par
00109   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+68}\par
00110   \{ 0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+69}\par
00111   \{ 0x00, 0x00, 0x04, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00 \}, {\cf20 // U+6A}\par
00112   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6B}\par
00113   \{ 0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6C}\par
00114   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6D}\par
00115   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6E}\par
00116   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6F}\par
00117   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00 \}, {\cf20 // U+70}\par
00118   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x02, 0x00 \}, {\cf20 // U+71}\par
00119   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+72}\par
00120   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+73}\par
00121   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+74}\par
00122   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+75}\par
00123   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+76}\par
00124   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x82, 0x92, 0x92, 0x92, 0x92, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+77}\par
00125   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+78}\par
00126   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+79}\par
00127   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7A}\par
00128   \{ 0x00, 0x00, 0x0C, 0x10, 0x10, 0x10, 0x20, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7B}\par
00129   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7C}\par
00130   \{ 0x00, 0x00, 0x30, 0x08, 0x08, 0x08, 0x04, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7D}\par
00131   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x92, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7E}\par
00132   \{ 0x44, 0x44, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7F}\par
00133   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+80}\par
00134   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+81}\par
00135   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+82}\par
00136   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+83}\par
00137   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+84}\par
00138   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+85}\par
00139   \{ 0x00, 0x00, 0x18, 0x24, 0x18, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+86}\par
00140   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+87}\par
00141   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+88}\par
00142   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+89}\par
00143   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8A}\par
00144   \{ 0x00, 0x00, 0x48, 0x48, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8B}\par
00145   \{ 0x00, 0x00, 0x30, 0x48, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8C}\par
00146   \{ 0x00, 0x00, 0x20, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8D}\par
00147   \{ 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8E}\par
00148   \{ 0x18, 0x24, 0x18, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8F}\par
00149   \{ 0x08, 0x10, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+90}\par
00150   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x12, 0x72, 0x9E, 0x90, 0x90, 0x6C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+91}\par
00151   \{ 0x00, 0x00, 0x7E, 0x90, 0x90, 0x90, 0xFC, 0x90, 0x90, 0x90, 0x90, 0x9E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+92}\par
00152   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+93}\par
00153   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+94}\par
00154   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+95}\par
00155   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+96}\par
00156   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+97}\par
00157   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+98}\par
00158   \{ 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+99}\par
00159   \{ 0x24, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9A}\par
00160   \{ 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x92, 0x90, 0x90, 0x90, 0x92, 0x7C, 0x10, 0x10, 0x00, 0x00 \}, {\cf20 // U+9B}\par
00161   \{ 0x00, 0x00, 0x18, 0x24, 0x20, 0x20, 0x78, 0x20, 0x20, 0x20, 0x22, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9C}\par
00162   \{ 0x00, 0x00, 0x82, 0x82, 0x44, 0x28, 0x10, 0x7C, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9D}\par
00163   \{ 0x00, 0x00, 0xF0, 0x88, 0x88, 0x88, 0xF4, 0x84, 0x8E, 0x84, 0x84, 0x82, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9E}\par
00164   \{ 0x00, 0x00, 0x0C, 0x12, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00 \}, {\cf20 // U+9F}\par
00165   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A0}\par
00166   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A1}\par
00167   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A2}\par
00168   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A3}\par
00169   \{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A4}\par
00170   \{ 0x32, 0x4C, 0x00, 0x42, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A5}\par
00171   \{ 0x00, 0x38, 0x04, 0x3C, 0x44, 0x3C, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A6}\par
00172   \{ 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A7}\par
00173   \{ 0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x20, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A8}\par
00174   \{ 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0xF2, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A9}\par
00175   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AA}\par
00176   \{ 0x00, 0x20, 0x60, 0x20, 0x22, 0x24, 0x08, 0x10, 0x20, 0x4C, 0x92, 0x04, 0x08, 0x1E, 0x00, 0x00 \}, {\cf20 // U+AB}\par
00177   \{ 0x00, 0x20, 0x60, 0x20, 0x22, 0x24, 0x08, 0x10, 0x22, 0x46, 0x8A, 0x1E, 0x02, 0x02, 0x00, 0x00 \}, {\cf20 // U+AC}\par
00178   \{ 0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AD}\par
00179   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x24, 0x48, 0x90, 0x48, 0x24, 0x12, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AE}\par
00180   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x48, 0x24, 0x12, 0x24, 0x48, 0x90, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AF}\par
00181   \{ 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22 \}, {\cf20 // U+B0}\par
00182   \{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 \}, {\cf20 // U+B1}\par
00183   \{ 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B2}\par
00184   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+B3}\par
00185   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+B4}\par
00186   \{ 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B5}\par
00187   \{ 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B6}\par
00188   \{ 0x32, 0x4C, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B7}\par
00189   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B8}\par
00190   \{ 0x10, 0x08, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B9}\par
00191   \{ 0x08, 0x10, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BA}\par
00192   \{ 0x18, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BB}\par
00193   \{ 0x08, 0x10, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BC}\par
00194   \{ 0x00, 0x00, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BD}\par
00195   \{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BE}\par
00196   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+BF}\par
00197   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C0}\par
00198   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C1}\par
00199   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+C2}\par
00200   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+C3}\par
00201   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C4}\par
00202   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+C5}\par
00203   \{ 0x00, 0x00, 0x28, 0x10, 0x28, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C6}\par
00204   \{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C7}\par
00205   \{ 0x00, 0x00, 0x00, 0x00, 0x02, 0x3C, 0x46, 0x4A, 0x52, 0x62, 0x42, 0xBC, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C8}\par
00206   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+C9}\par
00207   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00 \}, {\cf20 // U+CA}\par
00208   \{ 0x24, 0x18, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CB}\par
00209   \{ 0x00, 0x00, 0x24, 0x18, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+CC}\par
00210   \{ 0x10, 0x10, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CD}\par
00211   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CE}\par
00212   \{ 0x00, 0x00, 0x7E, 0x90, 0x90, 0x90, 0x9C, 0x90, 0x90, 0x90, 0x90, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CF}\par
00213   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x92, 0x92, 0x9E, 0x90, 0x90, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D0}\par
00214   \{ 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+D1}\par
00215   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+D2}\par
00216   \{ 0x24, 0x18, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D3}\par
00217   \{ 0x00, 0x00, 0x24, 0x18, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D4}\par
00218   \{ 0x44, 0x44, 0x00, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D5}\par
00219   \{ 0x24, 0x18, 0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D6}\par
00220   \{ 0x00, 0x00, 0x24, 0x18, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D7}\par
00221   \{ 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D8}\par
00222   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D9}\par
00223   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+DA}\par
00224   \{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF \}, {\cf20 // U+DB}\par
00225   \{ 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DC}\par
00226   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DD}\par
00227   \{ 0x00, 0x08, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DE}\par
00228   \{ 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DF}\par
00229   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00 \}, {\cf20 // U+E0}\par
00230   \{ 0x00, 0x00, 0x38, 0x44, 0x44, 0x48, 0x7C, 0x42, 0x42, 0x42, 0x62, 0x5C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E1}\par
00231   \{ 0x00, 0x12, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E2}\par
00232   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E3}\par
00233   \{ 0x00, 0x12, 0x12, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E4}\par
00234   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x48, 0x00, 0x00, 0x00 \}, {\cf20 // U+E5}\par
00235   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x46, 0x7A, 0x40, 0x40, 0x40, 0x00 \}, {\cf20 // U+E6}\par
00236   \{ 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E7}\par
00237   \{ 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E8}\par
00238   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x92, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E9}\par
00239   \{ 0x00, 0x00, 0x48, 0xA8, 0x50, 0x10, 0x20, 0x20, 0x40, 0x54, 0xAA, 0x94, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EA}\par
00240   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EB}\par
00241   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x92, 0x92, 0x92, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EC}\par
00242   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+ED}\par
00243   \{ 0x00, 0x00, 0x00, 0x1C, 0x22, 0x40, 0xF8, 0x40, 0xF8, 0x40, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EE}\par
00244   \{ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EF}\par
00245   \{ 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F0}\par
00246   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F1}\par
00247   \{ 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F2}\par
00248   \{ 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F3}\par
00249   \{ 0x00, 0x00, 0x00, 0x00, 0x02, 0x7E, 0x08, 0x10, 0x7E, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F4}\par
00250   \{ 0x00, 0x00, 0x96, 0x96, 0x96, 0xD0, 0xF0, 0xF0, 0xB0, 0x96, 0x90, 0x96, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F5}\par
00251   \{ 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x7C, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F6}\par
00252   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x4C, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F7}\par
00253   \{ 0x00, 0x18, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F8}\par
00254   \{ 0x00, 0x00, 0xFE, 0x10, 0x10, 0x1C, 0x70, 0x1C, 0x70, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F9}\par
00255   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FA}\par
00256   \{ 0x00, 0x00, 0x00, 0x1E, 0x20, 0x40, 0x40, 0x7E, 0x40, 0x40, 0x20, 0x1E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FB}\par
00257   \{ 0x00, 0x00, 0x38, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FC}\par
00258   \{ 0x00, 0x18, 0x24, 0x04, 0x08, 0x10, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FD}\par
00259   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FE}\par
00260   \{ 0x00, 0x00, 0x02, 0x04, 0x7C, 0x8A, 0x92, 0x92, 0xA2, 0x7C, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FF}\par
00261 \};\par
00262 {\cf21 #else}\par
00263 {\cf17 extern} {\cf17 const} uint8_t font8x16[256][16];\par
00264 {\cf21 #endif}\par
00265 \par
00266 {\cf21 #endif }{\cf20 // FONT8X16_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gop.h"}\par
{\f2 #include "font8x16.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FONT8X16_IMPLEMENTATION}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw_char} ({\b GOP_PARAMS} *gop, char c_, uint32_t x, uint32_t y, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw_string} ({\b GOP_PARAMS} *gop, const char *s, uint32_t x, uint32_t y, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_scroll} ({\b GOP_PARAMS} *gop)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_put_char} ({\b GOP_PARAMS} *gop, char c, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_puts} ({\b GOP_PARAMS} *gop, const char *s, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_print_dec} ({\b GOP_PARAMS} *gop, unsigned val, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_print_hex} ({\b GOP_PARAMS} *gop, uint64_t val, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_clear_screen} ({\b GOP_PARAMS} *gop, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrncat} (char *dest, const char *src, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b kstrlen} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrcpy} (char *dst, const char *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrtok} (char *str, const char *delim)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ksnprintf} (char *buf, size_t bufsize, const char *fmt,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
snprintf equivalent. \'96 Safe to run at ANY {\b IRQL}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kstrcmp} (const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_printf} (uint32_t color, const char *fmt,...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b gop_bold_enabled} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_x} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_y} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FONT8X16_IMPLEMENTATION\:gop.c}
{\xe \v gop.c\:FONT8X16_IMPLEMENTATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FONT8X16_IMPLEMENTATION}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b gop.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v draw_char\:gop.c}
{\xe \v gop.c\:draw_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void draw_char ({\b GOP_PARAMS} * gop, char c_, uint32_t x, uint32_t y, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b gop.c}.}\par
}
{\xe \v draw_string\:gop.c}
{\xe \v gop.c\:draw_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void draw_string ({\b GOP_PARAMS} * gop, const char * s, uint32_t x, uint32_t y, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b gop.c}.}\par
}
{\xe \v gop_clear_screen\:gop.c}
{\xe \v gop.c\:gop_clear_screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_clear_screen ({\b GOP_PARAMS} * gop, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b gop.c}.}\par
}
{\xe \v gop_print_dec\:gop.c}
{\xe \v gop.c\:gop_print_dec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_print_dec ({\b GOP_PARAMS} * gop, unsigned val, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b gop.c}.}\par
}
{\xe \v gop_print_hex\:gop.c}
{\xe \v gop.c\:gop_print_hex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_print_hex ({\b GOP_PARAMS} * gop, uint64_t val, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b gop.c}.}\par
}
{\xe \v gop_printf\:gop.c}
{\xe \v gop.c\:gop_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_printf (uint32_t color, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b gop.c}.}\par
}
{\xe \v gop_put_char\:gop.c}
{\xe \v gop.c\:gop_put_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_put_char ({\b GOP_PARAMS} * gop, char c, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b gop.c}.}\par
}
{\xe \v gop_puts\:gop.c}
{\xe \v gop.c\:gop_puts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_puts ({\b GOP_PARAMS} * gop, const char * s, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b gop.c}.}\par
}
{\xe \v gop_scroll\:gop.c}
{\xe \v gop.c\:gop_scroll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_scroll ({\b GOP_PARAMS} * gop)}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b gop.c}.}\par
}
{\xe \v ksnprintf\:gop.c}
{\xe \v gop.c\:ksnprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ksnprintf (char * buf, size_t bufsize, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
snprintf equivalent. \'96 Safe to run at ANY {\b IRQL}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Buffer to format.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufSize} \cell }{Size of the buffer.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fmt} \cell }{String and format.\cell }
{\row }
}
<return>Amount of bytes written. (excluding null terminator)</return> \par
}{
Definition at line {\b 323} of file {\b gop.c}.}\par
}
{\xe \v kstrcmp\:gop.c}
{\xe \v gop.c\:kstrcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kstrcmp (const char * s1, const char * s2)}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b gop.c}.}\par
}
{\xe \v kstrcpy\:gop.c}
{\xe \v gop.c\:kstrcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrcpy (char * dst, const char * src)}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b gop.c}.}\par
}
{\xe \v kstrlen\:gop.c}
{\xe \v gop.c\:kstrlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t kstrlen (const char * str)}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 262} of file {\b gop.c}.}\par
}
{\xe \v kstrncat\:gop.c}
{\xe \v gop.c\:kstrncat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrncat (char * dest, const char * src, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dest} \cell }{Destination buffer (must be mutable)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i src} \cell }{String to append\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{Total size of the destination buffer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to dest\par
}}}{
Definition at line {\b 234} of file {\b gop.c}.}\par
}
{\xe \v kstrtok\:gop.c}
{\xe \v gop.c\:kstrtok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrtok (char * str, const char * delim)}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 286} of file {\b gop.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cursor_x\:gop.c}
{\xe \v gop.c\:cursor_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_x = 0}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.c}.}\par
}
{\xe \v cursor_y\:gop.c}
{\xe \v gop.c\:cursor_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_y = 0}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.c}.}\par
}
{\xe \v gop_bold_enabled\:gop.c}
{\xe \v gop.c\:gop_bold_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool gop_bold_enabled = false}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b gop.c}.}\par
}
{\xe \v gop_local\:gop.c}
{\xe \v gop.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b gop.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gop.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     GOP Driver to draw onto screen Implementation (8\'D716 font)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "gop.h"}\par
00008 {\cf21 #define FONT8X16_IMPLEMENTATION}\par
00009 {\cf21 #include "font8x16.h"}\par
00010 \par
00011 {\cf18 bool} gop_bold_enabled = {\cf17 false}; {\cf20 // default}\par
00012 uint32_t cursor_x = 0, cursor_y = 0;\par
00013 {\cf17 extern} GOP_PARAMS gop_local;\par
00014 \par
00015 {\cf18 void} draw_char(GOP_PARAMS* gop, {\cf18 char} c_, uint32_t x, uint32_t y, uint32_t color) \{\par
00016     uint8_t c = (uint8_t)c_;\par
00017     {\cf19 if} (c > 0x7F) {\cf19 return};\par
00018 \par
00019     {\cf17 const} uint8_t* bitmap = font8x16[c];\par
00020     {\cf19 for} ({\cf18 int} row = 0; row < 16; row++) \{\par
00021         uint8_t bits = bitmap[row];\par
00022         {\cf19 for} ({\cf18 int} col = 0; col < 8; col++) \{\par
00023             {\cf20 // PSF bitmaps are MSB-first}\par
00024             {\cf19 if} (!(bits & (1 << (7 - col))))\par
00025                 {\cf19 continue};\par
00026 \par
00027             {\cf20 // scale each pixel up to FONT_SCALE\'D7FONT_SCALE}\par
00028             {\cf19 for} ({\cf18 int} dy = 0; dy < FONT_SCALE; dy++) \{\par
00029                 uint32_t py = y + row * FONT_SCALE + dy;\par
00030                 {\cf19 if} (py >= gop->Height) {\cf19 continue};\par
00031                 {\cf19 for} ({\cf18 int} dx = 0; dx < FONT_SCALE; dx++) \{\par
00032                     uint32_t px = x + col * FONT_SCALE + dx;\par
00033                     {\cf19 if} (px < gop->Width) \{\par
00034                         {\cf19 if} (gop_bold_enabled) \{\par
00035                             plot_pixel(gop, px, py, color);\par
00036                             plot_pixel(gop, px + 1, py, color);\par
00037                             plot_pixel(gop, px, py + 1, color);\par
00038                             plot_pixel(gop, px + 1, py + 1, color);\par
00039                         \}\par
00040                         {\cf19 else} \{\par
00041                             plot_pixel(gop, px, py, color);\par
00042                         \}\par
00043                     \}\par
00044                 \}\par
00045             \}\par
00046         \}\par
00047     \}\par
00048 \}\par
00049 \par
00050 {\cf18 void} draw_string(GOP_PARAMS* gop, {\cf17 const} {\cf18 char}* s, uint32_t x, uint32_t y, uint32_t color) \{\par
00051     {\cf19 while} (*s) \{\par
00052         draw_char(gop, *s, x, y, color);\par
00053         x += char_width();\par
00054         s++;\par
00055     \}\par
00056 \}\par
00057 \par
00058 {\cf18 void} gop_scroll(GOP_PARAMS* gop) \{\par
00059     uint32_t* fb = (uint32_t*)(uintptr_t)gop->FrameBufferBase;\par
00060     uint32_t  stride = gop->PixelsPerScanLine;\par
00061     uint32_t  h = gop->Height;\par
00062     uint32_t  w = gop->Width;\par
00063     uint32_t  lines = line_height();\par
00064 \par
00065     {\cf20 // scroll up}\par
00066     kmemcpy(&fb[0],\par
00067         &fb[lines * stride],\par
00068         (h - lines) * stride * {\cf17 sizeof} * fb);\par
00069 \par
00070     {\cf20 // clear bottom}\par
00071     {\cf19 for} (uint32_t yy = h - lines; yy < h; yy++)\par
00072         {\cf19 for} (uint32_t xx = 0; xx < w; xx++)\par
00073             fb[yy * stride + xx] = 0;\par
00074 \par
00075     cursor_y = (cursor_y >= lines) ? (cursor_y - lines) : 0;\par
00076 \}\par
00077 \par
00078 {\cf18 void} gop_put_char(GOP_PARAMS* gop, {\cf18 char} c, uint32_t color) \{\par
00079     {\cf19 if} (c == {\cf23 '\\b'}) \{\par
00080         {\cf20 // move cursor back one character (and clear it)}\par
00081         {\cf19 if} (cursor_x >= char_width()) \{\par
00082             cursor_x -= char_width();\par
00083         \}\par
00084         {\cf19 else} \{\par
00085             {\cf20 // if at start of line, wrap to end of previous line}\par
00086             {\cf19 if} (cursor_y >= line_height()) \{\par
00087                 cursor_y -= line_height();\par
00088                 cursor_x = gop->Width - char_width();\par
00089             \}\par
00090         \}\par
00091         {\cf20 // clear the old glyph cell:}\par
00092         {\cf19 for} (uint32_t yy = cursor_y; yy < cursor_y + line_height(); yy++) \{\par
00093             {\cf19 for} (uint32_t xx = cursor_x; xx < cursor_x + char_width(); xx++) \{\par
00094                 plot_pixel(gop, xx, yy, color);\par
00095             \}\par
00096         \}\par
00097         {\cf19 return};\par
00098     \}\par
00099     {\cf19 if} (c == {\cf23 '\\n'}) \{\par
00100         cursor_x = 0;\par
00101         cursor_y += line_height();\par
00102         {\cf19 if} (cursor_y + line_height() > gop->Height) gop_scroll(gop);\par
00103         {\cf19 return};\par
00104     \}\par
00105     {\cf19 if} (c == {\cf23 '\\r'}) \{\par
00106         cursor_x = 0;\par
00107         {\cf19 return};\par
00108     \}\par
00109 \par
00110     draw_char(gop, c, cursor_x, cursor_y, color);\par
00111     cursor_x += char_width();\par
00112     {\cf19 if} (cursor_x + char_width() > gop->Width) \{\par
00113         cursor_x = 0;\par
00114         cursor_y += line_height();\par
00115         {\cf19 if} (cursor_y + line_height() > gop->Height) gop_scroll(gop);\par
00116     \}\par
00117 \}\par
00118 \par
00119 {\cf18 void} gop_puts(GOP_PARAMS* gop, {\cf17 const} {\cf18 char}* s, uint32_t color) \{\par
00120     {\cf19 while} (*s) \{\par
00121         gop_put_char(gop, *s++, color);\par
00122     \}\par
00123 \}\par
00124 \par
00125 {\cf17 static} {\cf18 void} sprint_dec({\cf18 char}* buf, {\cf18 unsigned} v) \{\par
00126     {\cf18 char}* p = buf;\par
00127     {\cf19 if} (v == 0) \{ *p++ = {\cf23 '0'}; \}\par
00128     {\cf19 else} \{\par
00129         {\cf18 char} tmp[16]; {\cf18 int} i = 0;\par
00130         {\cf19 while} (v) \{\par
00131             tmp[i++] = {\cf23 '0'} + (v % 10);\par
00132             v /= 10;\par
00133         \}\par
00134         {\cf19 while} (i--) *p++ = tmp[i];\par
00135     \}\par
00136     *p = {\cf23 '\\0'};\par
00137 \}\par
00138 \par
00139 {\cf18 void} gop_print_dec(GOP_PARAMS* gop, {\cf18 unsigned} val, uint32_t color) \{\par
00140     {\cf18 char} buf[16];\par
00141     sprint_dec(buf, val);\par
00142     gop_puts(gop, buf, color);\par
00143 \}\par
00144 \par
00145 {\cf18 void} gop_print_hex(GOP_PARAMS* gop, uint64_t val, uint32_t color) \{\par
00146     {\cf18 char} buf[19] = {\cf22 "0x0000000000000000"}; {\cf20 // 64 bit addressing}\par
00147     {\cf19 for} ({\cf18 int} i = 0; i < 16; i++) \{\par
00148         {\cf18 unsigned} nib = (val >> ((15 - i) * 4)) & 0xF;\par
00149         buf[2 + i] = (nib < 10 ? {\cf23 '0'} + nib : {\cf23 'a'} + nib - 10);\par
00150     \}\par
00151     buf[18] = {\cf23 '\\0'}; {\cf20 // null terminator}\par
00152     gop_puts(gop, buf, color);\par
00153 \}\par
00154 \par
00155 {\cf17 extern} GOP_PARAMS gop_local;\par
00156 \par
00157 {\cf18 void} gop_clear_screen(GOP_PARAMS* gop, uint32_t color) \{\par
00158     {\cf19 for} (uint32_t y = 0; y < gop->Height; y++)\par
00159         {\cf19 for} (uint32_t x = 0; x < gop->Width; x++)\par
00160             plot_pixel(gop, x, y, color);\par
00161 \}\par
00162 \par
00163 {\cf17 static} {\cf17 inline} {\cf18 void} buf_put_char({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, {\cf18 char} c) \{\par
00164     {\cf19 if} (*written + 1 < size) \{\par
00165         buf[*written] = c;\par
00166     \}\par
00167     (*written)++;\par
00168 \}\par
00169 \par
00170 {\cf17 static} {\cf18 void} buf_puts({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, {\cf17 const} {\cf18 char}* s) \{\par
00171     {\cf19 while} (*s) \{\par
00172         buf_put_char(buf, size, written, *s++);\par
00173     \}\par
00174 \}\par
00175 \par
00176 {\cf17 static} {\cf18 void} buf_print_dec({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, {\cf18 int} value) \{\par
00177     {\cf18 char} tmp[12]; {\cf20 // enough for -2^31 and NUL}\par
00178     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00179     {\cf18 bool} neg = (value < 0);\par
00180     {\cf18 unsigned} u = neg ? -(unsigned)value : (unsigned)value;\par
00181     *t = {\cf23 '\\0'};\par
00182     {\cf19 if} (u == 0) \{\par
00183         *--t = {\cf23 '0'};\par
00184     \}\par
00185     {\cf19 else} \{\par
00186         {\cf19 while} (u) \{\par
00187             *--t = {\cf23 '0'} + (u % 10);\par
00188             u /= 10;\par
00189         \}\par
00190     \}\par
00191     {\cf19 if} (neg) \{\par
00192         *--t = {\cf23 '-'};\par
00193     \}\par
00194     buf_puts(buf, size, written, t);\par
00195 \}\par
00196 \par
00197 {\cf17 static} {\cf18 void} buf_print_hex({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, {\cf18 unsigned} value) \{\par
00198     {\cf18 char} tmp[9]; {\cf20 // 8 digits + NUL}\par
00199     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00200     {\cf17 const} {\cf18 char}* hex = {\cf22 "0123456789abcdef"};\par
00201     *t = {\cf23 '\\0'};\par
00202     {\cf19 if} (value == 0) \{\par
00203         *--t = {\cf23 '0'};\par
00204     \}\par
00205     {\cf19 else} \{\par
00206         {\cf19 while} (value) \{\par
00207             *--t = hex[value & 0xF];\par
00208             value >>= 4;\par
00209         \}\par
00210     \}\par
00211     buf_puts(buf, size, written, t);\par
00212 \}\par
00213 \par
00214 {\cf20 //-----------------------------------------------------------------------------}\par
00215 {\cf20 // Helper: simple strchr for delimiter scanning}\par
00216 {\cf20 //-----------------------------------------------------------------------------}\par
00217 {\cf17 static} {\cf18 char}* strchr({\cf17 const} {\cf18 char}* s, {\cf18 int} c) \{\par
00218     {\cf19 while} (*s) \{\par
00219         {\cf19 if} (*s == ({\cf18 char})c) \{\par
00220             {\cf19 return} ({\cf18 char}*)s;\par
00221         \}\par
00222         s++;\par
00223     \}\par
00224     {\cf19 return} NULL;\par
00225 \}\par
00226 \par
00234 {\cf18 char}* kstrncat({\cf18 char}* dest, {\cf17 const} {\cf18 char}* src, {\cf18 size_t} max_len) \{\par
00235     {\cf19 if} (!dest || !src || max_len == 0) {\cf19 return} dest;\par
00236 \par
00237     {\cf20 // Move dest_ptr to the end of the current string}\par
00238     {\cf18 size_t} dest_len = 0;\par
00239     {\cf19 while} (dest_len < max_len && dest[dest_len] != {\cf23 '\\0'}) \{\par
00240         dest_len++;\par
00241     \}\par
00242 \par
00243     {\cf19 if} (dest_len == max_len) \{\par
00244         {\cf20 // dest is already full, cannot append}\par
00245         {\cf19 return} dest;\par
00246     \}\par
00247 \par
00248     {\cf18 size_t} i = 0;\par
00249     {\cf19 while} (dest_len + i < max_len - 1 && src[i] != {\cf23 '\\0'}) \{\par
00250         dest[dest_len + i] = src[i];\par
00251         i++;\par
00252     \}\par
00253 \par
00254     {\cf20 // Null-terminate}\par
00255     dest[dest_len + i] = {\cf23 '\\0'};\par
00256     {\cf19 return} dest;\par
00257 \}\par
00258 \par
00259 {\cf20 //-----------------------------------------------------------------------------}\par
00260 {\cf20 // kstrlen: Return length of string (excluding null terminator).}\par
00261 {\cf20 //-----------------------------------------------------------------------------}\par
00262 {\cf18 size_t} kstrlen({\cf17 const} {\cf18 char}* str) \{\par
00263     {\cf18 size_t} len = 0;\par
00264     {\cf19 while} (str && str[len] != {\cf23 '\\0'}) \{\par
00265         len++;\par
00266     \}\par
00267     {\cf19 return} len;\par
00268 \}\par
00269 \par
00270 {\cf20 //-----------------------------------------------------------------------------}\par
00271 {\cf20 // kstrcpy: Copy string from src to dst. Assumes dst is large enough.}\par
00272 {\cf20 //-----------------------------------------------------------------------------}\par
00273 {\cf18 char}* kstrcpy({\cf18 char}* dst, {\cf17 const} {\cf18 char}* src) \{\par
00274     {\cf18 char}* ret = dst;\par
00275     {\cf19 while} ((*dst++ = *src++)) \{\par
00276         {\cf20 // copy until null terminator}\par
00277     \}\par
00278     {\cf19 return} ret;\par
00279 \}\par
00280 \par
00281 {\cf20 //-----------------------------------------------------------------------------}\par
00282 {\cf20 // kstrtok: Tokenize string with delimiters.}\par
00283 {\cf20 // Works like strtok, but without libc.}\par
00284 {\cf20 // Keeps static state across calls unless str != NULL.}\par
00285 {\cf20 //-----------------------------------------------------------------------------}\par
00286 {\cf18 char}* kstrtok({\cf18 char}* str, {\cf17 const} {\cf18 char}* delim) \{\par
00287     {\cf17 static} {\cf18 char}* saved = NULL;\par
00288 \par
00289     {\cf19 if} (str != NULL) \{\par
00290         saved = str;\par
00291     \}\par
00292     {\cf19 if} (saved == NULL) \{\par
00293         {\cf19 return} NULL;\par
00294     \}\par
00295 \par
00296     {\cf20 // Skip leading delimiters}\par
00297     {\cf18 char}* token_start = saved;\par
00298     {\cf19 while} (*token_start && strchr(delim, *token_start)) \{\par
00299         token_start++;\par
00300     \}\par
00301     {\cf19 if} (*token_start == {\cf23 '\\0'}) \{\par
00302         saved = NULL;\par
00303         {\cf19 return} NULL;\par
00304     \}\par
00305 \par
00306     {\cf20 // Find end of token}\par
00307     {\cf18 char}* token_end = token_start;\par
00308     {\cf19 while} (*token_end && !strchr(delim, *token_end)) \{\par
00309         token_end++;\par
00310     \}\par
00311 \par
00312     {\cf19 if} (*token_end) \{\par
00313         *token_end = {\cf23 '\\0'};\par
00314         saved = token_end + 1;\par
00315     \}\par
00316     {\cf19 else} \{\par
00317         saved = NULL;\par
00318     \}\par
00319 \par
00320     {\cf19 return} token_start;\par
00321 \}\par
00322 \par
00323 {\cf18 int} ksnprintf({\cf18 char}* buf, {\cf18 size_t} bufsize, {\cf17 const} {\cf18 char}* fmt, ...) \{\par
00324     {\cf18 size_t} written = 0;\par
00325     va_list ap;\par
00326     va_start(ap, fmt);\par
00327 \par
00328     {\cf19 for} ({\cf17 const} {\cf18 char}* p = fmt; *p; p++) \{\par
00329         {\cf19 if} (*p == {\cf23 '%'} && p[1]) \{\par
00330             p++;\par
00331             {\cf19 switch} (*p) \{\par
00332             {\cf19 case} {\cf23 'd'}:\par
00333                 buf_print_dec(buf, bufsize, &written, va_arg(ap, int32_t));\par
00334                 {\cf19 break};      \par
00335             {\cf19 case} {\cf23 'u'}:       \par
00336                 buf_print_dec(buf, bufsize, &written, va_arg(ap, uint32_t));\par
00337                 {\cf19 break};   \par
00338             {\cf19 case} {\cf23 'x'}:    \par
00339                 buf_print_hex(buf, bufsize, &written, va_arg(ap, uint32_t));\par
00340                 {\cf19 break};      \par
00341             {\cf19 case} {\cf23 'p'}:       \par
00342                 buf_print_hex(buf, bufsize, &written, ({\cf18 unsigned})(uintptr_t)va_arg(ap, {\cf18 void}*));\par
00343                 {\cf19 break};\par
00344             {\cf19 case} {\cf23 'c'}:\par
00345                 buf_put_char(buf, bufsize, &written, ({\cf18 char})va_arg(ap, {\cf18 int}));\par
00346                 {\cf19 break};\par
00347             {\cf19 case} {\cf23 's'}: \{\par
00348                 {\cf17 const} {\cf18 char}* s = va_arg(ap, {\cf17 const} {\cf18 char}*);\par
00349                 buf_puts(buf, bufsize, &written, s ? s : {\cf22 "(null)"});\par
00350                 {\cf19 break};\par
00351             \}\par
00352             {\cf19 case} {\cf23 '%'}:\par
00353                 buf_put_char(buf, bufsize, &written, {\cf23 '%'});\par
00354                 {\cf19 break};\par
00355             {\cf19 default}:\par
00356                 buf_put_char(buf, bufsize, &written, {\cf23 '%'});\par
00357                 buf_put_char(buf, bufsize, &written, *p);\par
00358             \}\par
00359         \}\par
00360         {\cf19 else} \{\par
00361             buf_put_char(buf, bufsize, &written, *p);\par
00362         \}\par
00363     \}\par
00364 \par
00365     va_end(ap);\par
00366     {\cf19 if} (bufsize > 0) \{\par
00367         buf[written < bufsize ? written : bufsize - 1] = {\cf23 '\\0'};\par
00368     \}\par
00369 \par
00370     {\cf19 return} ({\cf18 int})written;\par
00371 \}\par
00372 \par
00373 {\cf17 static} {\cf17 inline} {\cf18 bool} interrupts_enabled({\cf18 void}) \{\par
00374     {\cf18 unsigned} {\cf18 long} flags;\par
00375     __asm__ __volatile__({\cf22 "pushfq; popq %0"} : {\cf22 "=r"}(flags));\par
00376     {\cf19 return} (flags & (1UL << 9)) != 0; {\cf20 // IF is bit 9}\par
00377 \}\par
00378 \par
00379 {\cf17 static} {\cf18 void} gop_print_binary(GOP_PARAMS* gop, uint64_t val, uint32_t color) \{\par
00380     {\cf18 char} buf[65]; {\cf20 // 64 bits + null terminator}\par
00381     {\cf19 for} ({\cf18 int} i = 0; i < 64; i++) \{\par
00382         {\cf20 // fill buffer from MSB to LSB}\par
00383         buf[i] = (val & (1ULL << (63 - i))) ? {\cf23 '1'} : {\cf22 '0'};\par
00384     \}\par
00385     buf[64] = {\cf23 '\\0'};\par
00386     gop_puts(gop, buf, color);\par
00387 \}\par
00388 \par
00389 {\cf18 int} kstrcmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2) \{\par
00390     {\cf19 while} (*s1 && *s2) \{\par
00391         {\cf19 if} (*s1 != *s2) {\cf19 return} ({\cf18 int})(({\cf18 unsigned} char)*s1 - ({\cf18 unsigned} char)*s2);\par
00392         s1++;\par
00393         s2++;\par
00394     \}\par
00395     {\cf19 return} ({\cf18 int})(({\cf18 unsigned} char)*s1 - ({\cf18 unsigned} char)*s2);\par
00396 \}\par
00397 \par
00398 {\cf18 void} gop_printf(uint32_t color, {\cf17 const} {\cf18 char}* fmt, ...) \{\par
00399     {\cf18 bool} prev_if = interrupts_enabled();\par
00400     __cli();\par
00401     GOP_PARAMS* gop = &gop_local;\par
00402     tracelast_func({\cf22 "gop_printf"});\par
00403     va_list ap;\par
00404     va_start(ap, fmt);\par
00405     {\cf19 for} ({\cf17 const} {\cf18 char}* p = fmt; *p; p++) \{\par
00406         {\cf19 if} (*p == {\cf23 '*'} && p[1] == {\cf23 '*'}) \{\par
00407             gop_bold_enabled = !gop_bold_enabled;  {\cf20 // Toggle bold}\par
00408             p++; {\cf20 // skip the second '*'}\par
00409             {\cf19 continue};\par
00410         \}\par
00411         {\cf19 if} (*p == {\cf23 '%'} && p[1]) \{\par
00412             {\cf19 switch} (*++p) \{\par
00413             {\cf19 case} {\cf23 'd'}: gop_print_dec(gop, va_arg(ap, int64_t), color); {\cf19 break};\par
00414             {\cf19 case} {\cf23 'u'}: gop_print_dec(gop, va_arg(ap, uint64_t), color); {\cf19 break};\par
00415             {\cf19 case} {\cf23 'x'}: gop_print_hex(gop, va_arg(ap, uint64_t), color); {\cf19 break};\par
00416             {\cf19 case} {\cf23 'p'}: gop_print_hex(gop, (uint64_t)(uintptr_t)va_arg(ap, {\cf18 void}*), color); {\cf19 break};\par
00417             {\cf19 case} {\cf23 'c'}: gop_put_char(gop, ({\cf18 char})va_arg(ap, uint64_t), color); {\cf19 break};\par
00418             {\cf19 case} {\cf23 'b'}: gop_print_binary(gop, ({\cf18 char})va_arg(ap, uint64_t), color); {\cf19 break};\par
00419             {\cf19 case} {\cf23 's'}: \{\par
00420                 {\cf17 const} {\cf18 char}* str = va_arg(ap, {\cf17 const} {\cf18 char}*);\par
00421                 {\cf19 if} (str) gop_puts(gop, str, color);\par
00422             \} {\cf19 break};\par
00423             {\cf19 case} {\cf23 '%'}: gop_put_char(gop, {\cf23 '%'}, color); {\cf19 break};\par
00424             {\cf19 default}:\par
00425                 gop_put_char(gop, {\cf23 '%'}, color);\par
00426                 gop_put_char(gop, *p, color);\par
00427             \}\par
00428         \}\par
00429         {\cf19 else} \{\par
00430             gop_put_char(gop, *p, color);\par
00431         \}\par
00432     \}\par
00433     va_end(ap);\par
00434    {\cf19 if} (prev_if) __sti();\par
00435 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../defs/stdarg_myos.h"}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "../../memory/memory.h"}\par
{\f2 #include "../../memory/allocator/uefi_memory.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_RED}\~ 0xFFFF0000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors definitions for easier access. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_GREEN}\~ 0xFF00FF00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_BLUE}\~ 0xFF0000FF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_WHITE}\~ 0xFFFFFFFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_BLACK}\~ 0xFF000000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_YELLOW}\~ 0xFFFFFF00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_CYAN}\~ 0xFF00FFFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_MAGENTA}\~ 0xFFFF00FF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_GRAY}\~ 0xFF808080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_DARK_GRAY}\~ 0xFF404040\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_LIGHT_GRAY}\~ 0xFFD3D3D3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_ORANGE}\~ 0xFFFFA500\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_BROWN}\~ 0xFFA52A2A\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_PURPLE}\~ 0xFF800080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_PINK}\~ 0xFFFFC0CB\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_LIME}\~ 0xFF32CD32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_NAVY}\~ 0xFF000080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_TEAL}\~ 0xFF008080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_OLIVE}\~ 0xFF808000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FONT_SCALE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gop_printf_forced}(color,  fmt, ...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw_char} ({\b GOP_PARAMS} *gop, char c, uint32_t x, uint32_t y, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw_string} ({\b GOP_PARAMS} *gop, const char *s, uint32_t x, uint32_t y, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_printf} (uint32_t color, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_put_char} ({\b GOP_PARAMS} *gop, char c, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_puts} ({\b GOP_PARAMS} *gop, const char *s, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_scroll} ({\b GOP_PARAMS} *gop)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_clear_screen} ({\b GOP_PARAMS} *gop, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_print_dec} ({\b GOP_PARAMS} *gop, unsigned val, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_print_hex} ({\b GOP_PARAMS} *gop, uint64_t val, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ksnprintf} (char *buf, size_t bufsize, const char *fmt,...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
snprintf equivalent. \'96 Safe to run at ANY {\b IRQL}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kstrcmp} (const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b kstrlen} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrcpy} (char *dst, const char *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrtok} (char *str, const char *delim)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrncat} (char *dest, const char *src, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v COLOR_BLACK\:gop.h}
{\xe \v gop.h\:COLOR_BLACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_BLACK\~ 0xFF000000}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b gop.h}.}\par
}
{\xe \v COLOR_BLUE\:gop.h}
{\xe \v gop.h\:COLOR_BLUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_BLUE\~ 0xFF0000FF}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b gop.h}.}\par
}
{\xe \v COLOR_BROWN\:gop.h}
{\xe \v gop.h\:COLOR_BROWN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_BROWN\~ 0xFFA52A2A}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b gop.h}.}\par
}
{\xe \v COLOR_CYAN\:gop.h}
{\xe \v gop.h\:COLOR_CYAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_CYAN\~ 0xFF00FFFF}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b gop.h}.}\par
}
{\xe \v COLOR_DARK_GRAY\:gop.h}
{\xe \v gop.h\:COLOR_DARK_GRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_DARK_GRAY\~ 0xFF404040}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b gop.h}.}\par
}
{\xe \v COLOR_GRAY\:gop.h}
{\xe \v gop.h\:COLOR_GRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_GRAY\~ 0xFF808080}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b gop.h}.}\par
}
{\xe \v COLOR_GREEN\:gop.h}
{\xe \v gop.h\:COLOR_GREEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_GREEN\~ 0xFF00FF00}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.h}.}\par
}
{\xe \v COLOR_LIGHT_GRAY\:gop.h}
{\xe \v gop.h\:COLOR_LIGHT_GRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_LIGHT_GRAY\~ 0xFFD3D3D3}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b gop.h}.}\par
}
{\xe \v COLOR_LIME\:gop.h}
{\xe \v gop.h\:COLOR_LIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_LIME\~ 0xFF32CD32}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b gop.h}.}\par
}
{\xe \v COLOR_MAGENTA\:gop.h}
{\xe \v gop.h\:COLOR_MAGENTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_MAGENTA\~ 0xFFFF00FF}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b gop.h}.}\par
}
{\xe \v COLOR_NAVY\:gop.h}
{\xe \v gop.h\:COLOR_NAVY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_NAVY\~ 0xFF000080}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b gop.h}.}\par
}
{\xe \v COLOR_OLIVE\:gop.h}
{\xe \v gop.h\:COLOR_OLIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_OLIVE\~ 0xFF808000}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b gop.h}.}\par
}
{\xe \v COLOR_ORANGE\:gop.h}
{\xe \v gop.h\:COLOR_ORANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_ORANGE\~ 0xFFFFA500}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b gop.h}.}\par
}
{\xe \v COLOR_PINK\:gop.h}
{\xe \v gop.h\:COLOR_PINK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_PINK\~ 0xFFFFC0CB}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b gop.h}.}\par
}
{\xe \v COLOR_PURPLE\:gop.h}
{\xe \v gop.h\:COLOR_PURPLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_PURPLE\~ 0xFF800080}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b gop.h}.}\par
}
{\xe \v COLOR_RED\:gop.h}
{\xe \v gop.h\:COLOR_RED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_RED\~ 0xFFFF0000}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors definitions for easier access. }}\par
{
Definition at line {\b 11} of file {\b gop.h}.}\par
}
{\xe \v COLOR_TEAL\:gop.h}
{\xe \v gop.h\:COLOR_TEAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_TEAL\~ 0xFF008080}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b gop.h}.}\par
}
{\xe \v COLOR_WHITE\:gop.h}
{\xe \v gop.h\:COLOR_WHITE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_WHITE\~ 0xFFFFFFFF}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b gop.h}.}\par
}
{\xe \v COLOR_YELLOW\:gop.h}
{\xe \v gop.h\:COLOR_YELLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_YELLOW\~ 0xFFFFFF00}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b gop.h}.}\par
}
{\xe \v FONT_SCALE\:gop.h}
{\xe \v gop.h\:FONT_SCALE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FONT_SCALE\~ 1}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b gop.h}.}\par
}
{\xe \v gop_printf_forced\:gop.h}
{\xe \v gop.h\:gop_printf_forced}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gop_printf_forced( color,  fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gop_printf(color, fmt, ##__VA_ARGS__)\par
}
{
Definition at line {\b 57} of file {\b gop.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v draw_char\:gop.h}
{\xe \v gop.h\:draw_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void draw_char ({\b GOP_PARAMS} * gop, char c, uint32_t x, uint32_t y, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b gop.c}.}\par
}
{\xe \v draw_string\:gop.h}
{\xe \v gop.h\:draw_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void draw_string ({\b GOP_PARAMS} * gop, const char * s, uint32_t x, uint32_t y, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b gop.c}.}\par
}
{\xe \v gop_clear_screen\:gop.h}
{\xe \v gop.h\:gop_clear_screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_clear_screen ({\b GOP_PARAMS} * gop, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b gop.c}.}\par
}
{\xe \v gop_print_dec\:gop.h}
{\xe \v gop.h\:gop_print_dec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_print_dec ({\b GOP_PARAMS} * gop, unsigned val, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b gop.c}.}\par
}
{\xe \v gop_print_hex\:gop.h}
{\xe \v gop.h\:gop_print_hex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_print_hex ({\b GOP_PARAMS} * gop, uint64_t val, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b gop.c}.}\par
}
{\xe \v gop_printf\:gop.h}
{\xe \v gop.h\:gop_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_printf (uint32_t color, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b gop.c}.}\par
}
{\xe \v gop_put_char\:gop.h}
{\xe \v gop.h\:gop_put_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_put_char ({\b GOP_PARAMS} * gop, char c, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b gop.c}.}\par
}
{\xe \v gop_puts\:gop.h}
{\xe \v gop.h\:gop_puts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_puts ({\b GOP_PARAMS} * gop, const char * s, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b gop.c}.}\par
}
{\xe \v gop_scroll\:gop.h}
{\xe \v gop.h\:gop_scroll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_scroll ({\b GOP_PARAMS} * gop)}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b gop.c}.}\par
}
{\xe \v ksnprintf\:gop.h}
{\xe \v gop.h\:ksnprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ksnprintf (char * buf, size_t bufsize, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
snprintf equivalent. \'96 Safe to run at ANY {\b IRQL}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Buffer to format.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufSize} \cell }{Size of the buffer.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fmt} \cell }{String and format.\cell }
{\row }
}
<return>Amount of bytes written. (excluding null terminator)</return> \par
}{
Definition at line {\b 323} of file {\b gop.c}.}\par
}
{\xe \v kstrcmp\:gop.h}
{\xe \v gop.h\:kstrcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kstrcmp (const char * s1, const char * s2)}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b gop.c}.}\par
}
{\xe \v kstrcpy\:gop.h}
{\xe \v gop.h\:kstrcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrcpy (char * dst, const char * src)}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b gop.c}.}\par
}
{\xe \v kstrlen\:gop.h}
{\xe \v gop.h\:kstrlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t kstrlen (const char * str)}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 262} of file {\b gop.c}.}\par
}
{\xe \v kstrncat\:gop.h}
{\xe \v gop.h\:kstrncat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrncat (char * dest, const char * src, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dest} \cell }{Destination buffer (must be mutable)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i src} \cell }{String to append\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{Total size of the destination buffer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to dest\par
}}}{
Definition at line {\b 234} of file {\b gop.c}.}\par
}
{\xe \v kstrtok\:gop.h}
{\xe \v gop.h\:kstrtok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrtok (char * str, const char * delim)}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 286} of file {\b gop.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gop.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     GOP Driver to draw onto screen (long-mode framebuffer)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_GOP_DRIVER_H}\par
00008 {\cf21 #define X86_GOP_DRIVER_H}\par
00009 \par
00011 {\cf21 #define COLOR_RED        0xFFFF0000}\par
00012 {\cf21 #define COLOR_GREEN      0xFF00FF00}\par
00013 {\cf21 #define COLOR_BLUE       0xFF0000FF}\par
00014 {\cf21 #define COLOR_WHITE      0xFFFFFFFF}\par
00015 {\cf21 #define COLOR_BLACK      0xFF000000}\par
00016 {\cf21 #define COLOR_YELLOW     0xFFFFFF00}\par
00017 {\cf21 #define COLOR_CYAN       0xFF00FFFF}\par
00018 {\cf21 #define COLOR_MAGENTA    0xFFFF00FF}\par
00019 {\cf21 #define COLOR_GRAY       0xFF808080}\par
00020 {\cf21 #define COLOR_DARK_GRAY  0xFF404040}\par
00021 {\cf21 #define COLOR_LIGHT_GRAY 0xFFD3D3D3}\par
00022 {\cf21 #define COLOR_ORANGE     0xFFFFA500}\par
00023 {\cf21 #define COLOR_BROWN      0xFFA52A2A}\par
00024 {\cf21 #define COLOR_PURPLE     0xFF800080}\par
00025 {\cf21 #define COLOR_PINK       0xFFFFC0CB}\par
00026 {\cf21 #define COLOR_LIME       0xFF32CD32}\par
00027 {\cf21 #define COLOR_NAVY       0xFF000080}\par
00028 {\cf21 #define COLOR_TEAL       0xFF008080}\par
00029 {\cf21 #define COLOR_OLIVE      0xFF808000}\par
00030 \par
00031  {\cf20 // Standard headers, required.}\par
00032 {\cf21 #include <stddef.h>}\par
00033 {\cf21 #include <stdbool.h>}\par
00034 {\cf21 #include <stdint.h>}\par
00035 {\cf21 #include "../../defs/stdarg_myos.h"}\par
00036 {\cf21 #include "../../trace.h"}\par
00037 {\cf21 #include "../../memory/memory.h"}\par
00038 {\cf21 #include "../../memory/allocator/uefi_memory.h"}\par
00039 \par
00040  {\cf20 // integer font scale (1 = native 8\'D716, 2 = 16\'D732, etc)}\par
00041 {\cf21 #define FONT_SCALE 1}\par
00042 \par
00043 {\cf17 static} {\cf17 inline} {\cf18 void} plot_pixel(GOP_PARAMS* gop, uint32_t x, uint32_t y, uint32_t color) \{\par
00044     uint32_t* fb = (uint32_t*)(uintptr_t)gop->FrameBufferBase;\par
00045     uint32_t  stride = gop->PixelsPerScanLine;\par
00046     fb[y * stride + x] = color;\par
00047 \}\par
00048 \par
00049 {\cf17 static} {\cf17 inline} uint32_t char_width({\cf18 void}) \{ {\cf19 return}  8 * FONT_SCALE; \}\par
00050 {\cf17 static} {\cf17 inline} uint32_t line_height({\cf18 void}) \{ {\cf19 return} 16 * FONT_SCALE; \}\par
00051 \par
00052 {\cf18 void} draw_char(GOP_PARAMS* gop, {\cf18 char} c, uint32_t x, uint32_t y, uint32_t color);\par
00053 {\cf18 void} draw_string(GOP_PARAMS* gop, {\cf17 const} {\cf18 char}* s, uint32_t x, uint32_t y, uint32_t color);\par
00054 \par
00055 {\cf18 void} gop_printf(uint32_t color, {\cf17 const} {\cf18 char}* fmt, ...);\par
00056 \par
00057 {\cf21 #define gop_printf_forced(color, fmt, ...) gop_printf(color, fmt, ##__VA_ARGS__)}\par
00058 \par
00059 {\cf18 void} gop_put_char(GOP_PARAMS* gop, {\cf18 char} c, uint32_t color);\par
00060 {\cf18 void} gop_puts(GOP_PARAMS* gop, {\cf17 const} {\cf18 char}* s, uint32_t color);\par
00061 {\cf18 void} gop_scroll(GOP_PARAMS* gop);\par
00062 {\cf18 void} gop_clear_screen(GOP_PARAMS* gop, uint32_t color);\par
00063 {\cf18 void} gop_print_dec(GOP_PARAMS* gop, {\cf18 unsigned} val, uint32_t color);\par
00064 {\cf18 void} gop_print_hex(GOP_PARAMS* gop, uint64_t val, uint32_t color);\par
00065 \par
00073 {\cf18 int} ksnprintf({\cf18 char}* buf, {\cf18 size_t} bufsize, {\cf17 const} {\cf18 char}* fmt, ...);\par
00074 \par
00075 {\cf20 // Compare two null-terminated strings.}\par
00076 {\cf20 // Returns 0 if equal, <0 if s1 < s2, >0 if s1 > s2.}\par
00077 {\cf18 int} kstrcmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2);\par
00078 \par
00079 {\cf18 size_t} kstrlen({\cf17 const} {\cf18 char}* str);\par
00080 {\cf18 char}* kstrcpy({\cf18 char}* dst, {\cf17 const} {\cf18 char}* src);\par
00081 {\cf18 char}* kstrtok({\cf18 char}* str, {\cf17 const} {\cf18 char}* delim);\par
00082 \par
00090 {\cf18 char}* kstrncat({\cf18 char}* dest, {\cf17 const} {\cf18 char}* src, {\cf18 size_t} max_len);\par
00091 \par
00092 {\cf21 #endif }{\cf20 // X86_GOP_DRIVER_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "fat32.h"}\par
{\f2 #include "../../drivers/blk/block.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../time.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LFN_ENTRY_BUFFER}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRITE_MODE_APPEND_EXISTING}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRITE_MODE_CREATE_OR_REPLACE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_LFN_ENTRIES}\~ 20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_LFN_LEN}\~ 260\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BPB_SECTOR_START}\~ 2048\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_init} (int disk_index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fat32_list_root} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_read_file} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_create_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_write_file} (const char *path, const void *data, uint32_t size, uint32_t mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_list_directory} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fat32_directory_is_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_file} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BPB_SECTOR_START\:fat32.c}
{\xe \v fat32.c\:BPB_SECTOR_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BPB_SECTOR_START\~ 2048}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 528} of file {\b fat32.c}.}\par
}
{\xe \v MAX_LFN_ENTRIES\:fat32.c}
{\xe \v fat32.c\:MAX_LFN_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_LFN_ENTRIES\~ 20}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b fat32.c}.}\par
}
{\xe \v MAX_LFN_LEN\:fat32.c}
{\xe \v fat32.c\:MAX_LFN_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_LFN_LEN\~ 260}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b fat32.c}.}\par
}
{\xe \v WRITE_MODE_APPEND_EXISTING\:fat32.c}
{\xe \v fat32.c\:WRITE_MODE_APPEND_EXISTING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRITE_MODE_APPEND_EXISTING\~ 0}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b fat32.c}.}\par
}
{\xe \v WRITE_MODE_CREATE_OR_REPLACE\:fat32.c}
{\xe \v fat32.c\:WRITE_MODE_CREATE_OR_REPLACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRITE_MODE_CREATE_OR_REPLACE\~ 1}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fat32_create_directory\:fat32.c}
{\xe \v fat32.c\:fat32_create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_create_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 836} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_directory\:fat32.c}
{\xe \v fat32.c\:fat32_delete_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1761} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_file\:fat32.c}
{\xe \v fat32.c\:fat32_delete_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_file (const char * path)}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1794} of file {\b fat32.c}.}\par
}
{\xe \v fat32_directory_is_empty\:fat32.c}
{\xe \v fat32.c\:fat32_directory_is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool fat32_directory_is_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 1499} of file {\b fat32.c}.}\par
}
{\xe \v fat32_init\:fat32.c}
{\xe \v fat32.c\:fat32_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_init (int disk_index)}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 531} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_directory\:fat32.c}
{\xe \v fat32.c\:fat32_list_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_list_directory (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1414} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_root\:fat32.c}
{\xe \v fat32.c\:fat32_list_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fat32_list_root (void )}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 557} of file {\b fat32.c}.}\par
}
{\xe \v fat32_read_file\:fat32.c}
{\xe \v fat32.c\:fat32_read_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_read_file (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 709} of file {\b fat32.c}.}\par
}
{\xe \v fat32_write_file\:fat32.c}
{\xe \v fat32.c\:fat32_write_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_write_file (const char * path, const void * data, uint32_t size, uint32_t file_modification_mode)}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_modification_mode} \cell }{Whether to APPEND or REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1001} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gop_local\:fat32.c}
{\xe \v fat32.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fat32.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     FAT32 FileSystem Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "fat32.h"}\par
00008 {\cf21 #include "../../drivers/blk/block.h"}\par
00009 {\cf21 #include "../../assert.h"}\par
00010 {\cf21 #include "../../time.h"}\par
00011 \par
00012 {\cf21 #define WRITE_MODE_APPEND_EXISTING 0}\par
00013 {\cf21 #define WRITE_MODE_CREATE_OR_REPLACE 1}\par
00014 \par
00015 {\cf17 static} FAT32_BPB bpb;\par
00016 {\cf17 static} FAT32_FSINFO fs;\par
00017 {\cf17 static} BLOCK_DEVICE* disk;\par
00018 {\cf17 extern} GOP_PARAMS gop_local;\par
00019 \par
00020 \par
00021 {\cf21 #define MAX_LFN_ENTRIES 20       }{\cf20 // Allows up to 260 chars (20*13)}\par
00022 {\cf21 #define MAX_LFN_LEN 260}\par
00023 \par
00024 {\cf17 typedef} {\cf17 struct }\{\par
00025     uint16_t name_chars[13];     {\cf20 // UTF-16 characters from one LFN entry}\par
00026 \} LFN_ENTRY_BUFFER;\par
00027 \par
00028 {\cf20 // Read sector into the buffer.}\par
00029 {\cf17 static} MTSTATUS read_sector(uint32_t lba, {\cf18 void}* buf) \{\par
00030     tracelast_func({\cf22 "read_sector - fat32"});\par
00031     {\cf19 return} disk->read_sector(disk, lba, buf);\par
00032 \}\par
00033 \par
00034 {\cf20 // Write to sector from buffer}\par
00035 {\cf17 static} MTSTATUS write_sector(uint32_t lba, {\cf17 const} {\cf18 void}* buf) \{\par
00036     tracelast_func({\cf22 "write_sector - fat32"});\par
00037     {\cf19 return} disk->write_sector(disk, lba, buf);\par
00038 \}\par
00039 \par
00040 {\cf20 // Compute checksum of 8.3 name (from specification)}\par
00041 {\cf17 static} uint8_t lfn_checksum({\cf17 const} uint8_t short_name[11]) \{\par
00042     uint8_t sum = 0;\par
00043     {\cf19 for} ({\cf18 int} i = 0; i < 11; i++) \{\par
00044         sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + short_name[i];\par
00045     \}\par
00046     {\cf19 return} sum;\par
00047 \}\par
00048 \par
00049 {\cf20 // Convert to uppercase.}\par
00050 {\cf17 static} {\cf17 inline} {\cf18 int} toupper({\cf18 int} c) \{\par
00051     tracelast_func({\cf22 "toupper - fat32"});\par
00052     {\cf19 if} (c >= {\cf23 'a'} && c <= {\cf23 'z'}) \{\par
00053         {\cf19 return} c - ({\cf23 'a'} - {\cf23 'A'}); {\cf20 // Convert lowercase to uppercase}\par
00054     \}\par
00055     {\cf19 return} c; {\cf20 // Return unchanged if not lowercase letter}\par
00056 \}\par
00057 \par
00058 {\cf20 // Compare short name}\par
00059 {\cf17 static} {\cf18 bool} cmp_name({\cf17 const} {\cf18 char}* str_1, {\cf17 const} {\cf18 char}* str_2) \{\par
00060     tracelast_func({\cf22 "cmp_name - fat32"});\par
00061     {\cf18 char} t[12] = \{ 0 \};\par
00062     {\cf19 for} ({\cf18 int} i = 0; i < 11; i++) \{ t[i] = str_1[i]; \}\par
00063     {\cf19 for} ({\cf18 int} i = 0; i < 11; i++) \{\par
00064         {\cf19 if} (toupper(t[i]) != toupper(str_2[i])) \{\par
00065             {\cf19 return} {\cf17 false};\par
00066         \}\par
00067     \}\par
00068     {\cf19 return} {\cf17 true};\par
00069 \}\par
00070 \par
00071 \par
00072 {\cf20 // Helper: convert "NAME.EXT" or "NAMEEXT" to 11-byte FAT short-name (uppercased, space-padded).}\par
00073 {\cf17 static} {\cf18 void} format_short_name({\cf17 const} {\cf18 char}* input, {\cf18 char} out[11]) \{\par
00074     {\cf20 // Fill with spaces}\par
00075     {\cf19 for} ({\cf18 int} i = 0; i < 11; ++i) out[i] = {\cf23 ' '};\par
00076     {\cf20 // Copy name (up to 8 chars)}\par
00077     {\cf18 int} ni = 0;\par
00078     {\cf17 const} {\cf18 unsigned} {\cf18 char}* p = ({\cf17 const} {\cf18 unsigned} {\cf18 char}*)input;\par
00079     {\cf19 while} (*p && *p != {\cf23 '.'} && ni < 8) \{\par
00080         out[ni++] = (char)toupper(*p++);\par
00081     \}\par
00082     {\cf20 // If '.' found, copy extension (up to 3)}\par
00083     {\cf19 if} (*p == {\cf23 '.'}) \{\par
00084         ++p;\par
00085         {\cf18 int} ei = 0;\par
00086         {\cf19 while} (*p && ei < 3) \{\par
00087             out[8 + ei++] = (char)toupper(*p++);\par
00088         \}\par
00089     \}\par
00090 \}\par
00091 \par
00099 {\cf17 static} FAT32_DIR_ENTRY* read_lfn(FAT32_DIR_ENTRY* cur, uint32_t remaining, {\cf18 char}* out_name, uint32_t* out_consumed) \{\par
00100     {\cf19 if} (!cur || remaining == 0) {\cf19 return} NULL;\par
00101     *out_consumed = 0;\par
00102 \par
00103     {\cf20 // Collect LFN pointers (they appear immediately before the 8.3 entry).}\par
00104     FAT32_DIR_ENTRY* lfn_list[MAX_LFN_ENTRIES];\par
00105     uint32_t lfn_count = 0;\par
00106     uint32_t i = 0;\par
00107 \par
00108     {\cf20 // Walk forward while entries are LFN (0x0F). Stop when we hit a non-LFN or end.}\par
00109     {\cf19 while} (i < remaining && ((uint8_t)cur[i].name[0] != 0x00) && (cur[i].attr == ATTR_LONG_NAME)) \{\par
00110         {\cf19 if} (lfn_count < MAX_LFN_ENTRIES) lfn_list[lfn_count++] = &cur[i];\par
00111         i++;\par
00112     \}\par
00113 \par
00114     {\cf20 // i now points to the candidate 8.3 entry (must exist and not be end marker).}\par
00115     {\cf19 if} (i >= remaining) {\cf19 return} NULL;\par
00116     FAT32_DIR_ENTRY* short_entry = &cur[i];\par
00117     {\cf19 if} ((uint8_t)short_entry->name[0] == 0x00 || (uint8_t)short_entry->name[0] == 0xE5) \{\par
00118         {\cf20 // no valid 8.3 here}\par
00119         {\cf19 return} NULL;\par
00120     \}\par
00121 \par
00122     {\cf20 // If no LFN entries collected, just copy short name into out_name and return short_entry.}\par
00123     {\cf19 if} (lfn_count == 0) \{\par
00124         {\cf20 // Convert 11-byte SFN to human readable name "NAME.EXT"}\par
00125         {\cf17 const} {\cf18 unsigned} {\cf18 char}* s = ({\cf17 const} {\cf18 unsigned} {\cf18 char}*)short_entry->name;\par
00126         {\cf18 int} pos = 0;\par
00127 \par
00128         {\cf20 // name part (0..7)}\par
00129         {\cf19 for} ({\cf18 int} n = 0; n < 8; ++n) \{\par
00130             {\cf19 if} (s[n] == {\cf23 ' '}) {\cf19 break};\par
00131             {\cf19 if} (pos < ({\cf18 int})MAX_LFN_LEN - 1) out_name[pos++] = s[n];\par
00132         \}\par
00133 \par
00134         {\cf20 // extension (8..10)}\par
00135         {\cf18 bool} has_ext = {\cf17 false};\par
00136         {\cf19 for} ({\cf18 int} n = 8; n < 11; ++n) {\cf19 if} (s[n] != {\cf23 ' '}) \{ has_ext = {\cf17 true}; {\cf19 break}; \}\par
00137         {\cf19 if} (has_ext) \{\par
00138             {\cf19 if} (pos < ({\cf18 int})MAX_LFN_LEN - 1) out_name[pos++] = {\cf23 '.'};\par
00139             {\cf19 for} ({\cf18 int} n = 8; n < 11; ++n) \{\par
00140                 {\cf19 if} (s[n] == {\cf23 ' '}) {\cf19 break};\par
00141                 {\cf19 if} (pos < ({\cf18 int})MAX_LFN_LEN - 1) out_name[pos++] = s[n];\par
00142             \}\par
00143         \}\par
00144 \par
00145         out_name[pos] = {\cf23 '\\0'};\par
00146         *out_consumed = 1;\par
00147         {\cf19 return} short_entry;\par
00148     \}\par
00149 \par
00150     {\cf20 // Validate checksum of short name against each LFN entry's checksum field (offset 13)}\par
00151     uint8_t cs = lfn_checksum((uint8_t*)short_entry->name);\par
00152     {\cf19 for} (uint32_t j = 0; j < lfn_count; ++j) \{\par
00153         uint8_t entry_checksum = *((uint8_t*)lfn_list[j] + 13);\par
00154         {\cf19 if} (entry_checksum != cs) {\cf19 return} NULL; {\cf20 // mismatch -> invalid chain}\par
00155     \}\par
00156 \par
00157     {\cf20 // Reconstruct name: iterate lfn_list in reverse (last chunk -> first chunk)}\par
00158     uint32_t pos = 0;\par
00159     {\cf19 for} ({\cf18 int} j = ({\cf18 int})lfn_count - 1; j >= 0; --j) \{\par
00160         uint8_t* ebytes = (uint8_t*)lfn_list[j];\par
00161 \par
00162         {\cf20 // Name1 at offset 1, 5 UTF-16 chars}\par
00163         uint16_t* name1 = (uint16_t*)(ebytes + 1);\par
00164         {\cf19 for} ({\cf18 int} c = 0; c < 5; ++c) \{\par
00165             uint16_t ch = name1[c];\par
00166             {\cf19 if} (ch == 0x0000) \{ out_name[pos] = {\cf23 '\\0'}; {\cf19 goto} done; \}\par
00167             {\cf19 if} (ch <= 0x7F) out_name[pos++] = (char)ch; {\cf19 else} out_name[pos++] = {\cf23 '?'};\par
00168             {\cf19 if} (pos >= MAX_LFN_LEN - 1) {\cf19 goto} done;\par
00169         \}\par
00170 \par
00171         {\cf20 // Name2 at offset 14, 6 UTF-16 chars}\par
00172         uint16_t* name2 = (uint16_t*)(ebytes + 14);\par
00173         {\cf19 for} ({\cf18 int} c = 0; c < 6; ++c) \{\par
00174             uint16_t ch = name2[c];\par
00175             {\cf19 if} (ch == 0x0000) \{ out_name[pos] = {\cf23 '\\0'}; {\cf19 goto} done; \}\par
00176             {\cf19 if} (ch <= 0x7F) out_name[pos++] = (char)ch; {\cf19 else} out_name[pos++] = {\cf23 '?'};\par
00177             {\cf19 if} (pos >= MAX_LFN_LEN - 1) {\cf19 goto} done;\par
00178         \}\par
00179 \par
00180         {\cf20 // Name3 at offset 28, 2 UTF-16 chars}\par
00181         uint16_t* name3 = (uint16_t*)(ebytes + 28);\par
00182         {\cf19 for} ({\cf18 int} c = 0; c < 2; ++c) \{\par
00183             uint16_t ch = name3[c];\par
00184             {\cf19 if} (ch == 0x0000) \{ out_name[pos] = {\cf23 '\\0'}; {\cf19 goto} done; \}\par
00185             {\cf19 if} (ch <= 0x7F) out_name[pos++] = (char)ch; {\cf19 else} out_name[pos++] = {\cf23 '?'};\par
00186             {\cf19 if} (pos >= MAX_LFN_LEN - 1) {\cf19 goto} done;\par
00187         \}\par
00188     \}\par
00189 \par
00190 done:\par
00191     out_name[pos] = {\cf23 '\\0'};\par
00192     {\cf20 // consumed entries = number of LFN entries + the 8.3 entry}\par
00193     *out_consumed = (uint32_t)lfn_count + 1;\par
00194     {\cf19 return} short_entry;\par
00195 \}\par
00196 \par
00197 {\cf20 // Read the FAT for the given cluster, to inspect data about this specific cluster, like which sectors are free, used, what's the next sector, and which sector are EOF (end of file = 0x0FFFFFFF)}\par
00198 {\cf17 static} uint32_t fat32_read_fat(uint32_t cluster) \{\par
00199     tracelast_func({\cf22 "fat32_read_fat"});\par
00200     MTSTATUS status;\par
00201     uint32_t fat_offset = cluster * 4;\par
00202     uint32_t fat_sector = fs.fat_start + (fat_offset / fs.bytes_per_sector);\par
00203     uint32_t ent_offset = fat_offset % fs.bytes_per_sector;\par
00204 \par
00205     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
00206     {\cf19 if} (!buf) {\cf19 return} 0x0FFFFFFF; {\cf20 // treat as EOF on allocation failure}\par
00207     status = read_sector(fat_sector, buf);\par
00208     {\cf19 if} (MT_FAILURE(status)) \{\par
00209         tracelast_func({\cf22 "Couldn't read sector."});\par
00210         MtFreeVirtualMemory(buf);\par
00211         {\cf19 return} 0x0FFFFFFF;\par
00212     \}\par
00213 \par
00214     uint32_t val = *(uint32_t*)((uint8_t*)buf + ent_offset);\par
00215     val &= 0x0FFFFFFF;\par
00216     MtFreeVirtualMemory(buf);\par
00217     {\cf19 return} val;\par
00218 \}\par
00219 \par
00220 {\cf17 static} uint32_t first_sector_of_cluster(uint32_t cluster) \{\par
00221     tracelast_func({\cf22 "first_sector_of_cluster"});\par
00222     {\cf19 return} fs.first_data_sector + (cluster - 2) * fs.sectors_per_cluster;\par
00223 \}\par
00224 \par
00225 \par
00226 {\cf17 static} {\cf18 bool} fat32_write_fat(uint32_t cluster, uint32_t value) \{\par
00227     uint32_t fat_offset = cluster * 4;\par
00228     uint32_t fat_sector_base = fs.fat_start; {\cf20 // first FAT start}\par
00229     uint32_t ent_offset = fat_offset % fs.bytes_per_sector;\par
00230     uint32_t sec_index = fat_offset / fs.bytes_per_sector;\par
00231 \par
00232     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
00233     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
00234     MTSTATUS status;\par
00235     {\cf18 bool} ok = {\cf17 true};\par
00236     {\cf19 for} (uint32_t fat_i = 0; fat_i < bpb.num_fats; ++fat_i) \{\par
00237         uint32_t fat_sector = fat_sector_base + fat_i * fs.sectors_per_fat + sec_index;\par
00238         status = read_sector(fat_sector, buf);\par
00239         {\cf19 if} (MT_FAILURE(status)) \{ ok = {\cf17 false}; {\cf19 break}; \}\par
00240 \par
00241         uint32_t* fat_entry = (uint32_t*)((uint8_t*)buf + ent_offset);\par
00242         *fat_entry = (*fat_entry & 0xF0000000) | (value & 0x0FFFFFFF);\par
00243         status = write_sector(fat_sector, buf);\par
00244         {\cf19 if} (MT_FAILURE(status)) \{ ok = {\cf17 false}; {\cf19 break}; \}\par
00245     \}\par
00246 \par
00247     MtFreeVirtualMemory(buf);\par
00248     {\cf19 return} ok;\par
00249 \}\par
00250 \par
00251 \par
00252 {\cf17 static} {\cf17 inline} uint32_t get_dir_cluster(FAT32_DIR_ENTRY* entry) \{\par
00253     {\cf19 return} ((uint32_t)entry->fst_clus_hi << 16) | entry->fst_clus_lo;\par
00254 \}\par
00255 \par
00256 {\cf20 // Free a cluster chain starting at start_cluster (set each entry to FREE)}\par
00257 {\cf17 static} {\cf18 bool} fat32_free_cluster_chain(uint32_t start_cluster) \{\par
00258     tracelast_func({\cf22 "fat32_free_cluster_chain"});\par
00259     {\cf19 if} (start_cluster < 2 || start_cluster >= FAT32_EOC_MIN) {\cf19 return} {\cf17 false};\par
00260 \par
00261     uint32_t cur = start_cluster;\par
00262     {\cf19 while} (cur < FAT32_EOC_MIN) \{\par
00263         uint32_t next = fat32_read_fat(cur);\par
00264         {\cf20 // mark current as free}\par
00265         {\cf19 if} (!fat32_write_fat(cur, FAT32_FREE_CLUSTER)) {\cf19 return} {\cf17 false};\par
00266         {\cf20 // protect against pathological loops}\par
00267         {\cf19 if} (next == cur) {\cf19 break};\par
00268         cur = next;\par
00269     \}\par
00270     {\cf19 return} {\cf17 true};\par
00271 \}\par
00272 \par
00273 \par
00274 {\cf17 static} uint32_t fat32_find_free_cluster({\cf18 void}) \{\par
00275     tracelast_func({\cf22 "fat32_find_free_cluster"});\par
00276     {\cf20 // Start searching from cluster 2 (the first usable cluster)}\par
00277     {\cf20 // In a more advanced implementation, we would use the FSInfo sector to find a hint. But even then that hint can be misleading (read osdev on FAT)}\par
00278     uint32_t total_clusters = (bpb.total_sectors_32 - fs.first_data_sector) / fs.sectors_per_cluster;\par
00279     {\cf19 for} (uint32_t i = 2; i < total_clusters; i++) \{\par
00280         {\cf19 if} (fat32_read_fat(i) == FAT32_FREE_CLUSTER) \{\par
00281             {\cf19 return} i;\par
00282         \}\par
00283     \}\par
00284     {\cf19 return} 0; {\cf20 // no free clusters found..}\par
00285 \}\par
00286 \par
00287 {\cf17 static} {\cf18 bool} zero_cluster(uint32_t cluster) \{\par
00288     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
00289     {\cf18 bool} success = {\cf17 true};\par
00290     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
00291     kmemset(buf, 0, 512);\par
00292     MTSTATUS status;\par
00293     uint32_t sector = first_sector_of_cluster(cluster);\par
00294     {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; i++) \{\par
00295         status = write_sector(sector + i, buf);\par
00296         {\cf19 if} (MT_FAILURE(status)) \{\par
00297             success = {\cf17 false};\par
00298             {\cf19 break};\par
00299         \}\par
00300     \}\par
00301 \par
00302     MtFreeVirtualMemory(buf);\par
00303     {\cf19 return} success;\par
00304 \}\par
00305 \par
00306 {\cf20 // Simple, strict compare: dir_name is on-disk 11 bytes, short_name is formatted 11 bytes}\par
00307 {\cf17 static} {\cf18 bool} cmp_short_name({\cf17 const} {\cf18 char}* dir_name, {\cf17 const} {\cf18 char} short_name[11]) \{\par
00308     {\cf19 for} ({\cf18 int} i = 0; i < 11; ++i) \{\par
00309         {\cf19 if} (({\cf18 unsigned} {\cf18 char})dir_name[i] != ({\cf18 unsigned} {\cf18 char})short_name[i]) {\cf19 return} {\cf17 false};\par
00310     \}\par
00311     {\cf19 return} {\cf17 true};\par
00312 \}\par
00313 \par
00314 {\cf20 // ASCII case-insensitive compare}\par
00315 {\cf17 static} {\cf17 inline} {\cf18 bool} ci_equal({\cf17 const} {\cf18 char}* a, {\cf17 const} {\cf18 char}* b) \{\par
00316     {\cf18 size_t} la = kstrlen(a);\par
00317     {\cf18 size_t} lb = kstrlen(b);\par
00318     {\cf19 if} (la != lb) {\cf19 return} {\cf17 false};\par
00319     {\cf19 for} ({\cf18 size_t} i = 0; i < la; ++i) \{\par
00320         {\cf19 if} (({\cf18 char})toupper(({\cf18 int})a[i]) != ({\cf18 char})toupper(({\cf18 int})b[i])) {\cf19 return} {\cf17 false};\par
00321     \}\par
00322     {\cf19 return} {\cf17 true};\par
00323 \}\par
00324 \par
00332 {\cf17 static} {\cf18 bool} fat32_find_entry({\cf17 const} {\cf18 char}* path, FAT32_DIR_ENTRY* out_entry, uint32_t* out_parent_cluster) \{\par
00333     {\cf18 char} path_copy[260];\par
00334     kstrcpy(path_copy, path); {\cf20 // Use a mutable copy}\par
00335     MTSTATUS status;\par
00336     uint32_t current_cluster = fs.root_cluster;\par
00337     uint32_t parent_cluster_of_last_found = fs.root_cluster;\par
00338 \par
00339     {\cf20 // Handle the root path "/" separately.}\par
00340     {\cf19 if} (kstrcmp(path_copy, {\cf22 "/"}) == 0 || path_copy[0] == {\cf23 '\\0'}) \{\par
00341         {\cf19 if} (out_entry) \{\par
00342             kmemset(out_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00343             out_entry->attr = ATTR_DIRECTORY;\par
00344             out_entry->fst_clus_lo = (uint16_t)(fs.root_cluster & 0xFFFF);\par
00345             out_entry->fst_clus_hi = (uint16_t)(fs.root_cluster >> 16);\par
00346         \}\par
00347         {\cf19 if} (out_parent_cluster) *out_parent_cluster = fs.root_cluster; {\cf20 // Root's parent is itself}\par
00348         {\cf19 return} {\cf17 true};\par
00349     \}\par
00350 \par
00351     FAT32_DIR_ENTRY last_found_entry;\par
00352     kmemset(&last_found_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00353     {\cf18 bool} any_token_found = {\cf17 false};\par
00354 \par
00355     {\cf18 char}* token = kstrtok(path_copy, {\cf22 "/"});\par
00356 \par
00357     {\cf19 while} (token != NULL) \{\par
00358         {\cf18 bool} found_this_token = {\cf17 false};\par
00359         parent_cluster_of_last_found = current_cluster;\par
00360 \par
00361         {\cf18 void}* sector_buf = MtAllocateVirtualMemory(512, 512);\par
00362         {\cf19 if} (!sector_buf) {\cf19 return} {\cf17 false};\par
00363 \par
00364         {\cf20 // Search the current directory (current_cluster) for the token}\par
00365         {\cf19 do} \{\par
00366             uint32_t sector = first_sector_of_cluster(current_cluster);\par
00367             {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; i++) \{\par
00368                 status = read_sector(sector + i, sector_buf);\par
00369                 {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} {\cf17 false}; \}\par
00370 \par
00371                 FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)sector_buf;\par
00372                 uint32_t num_entries = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
00373 \par
00374                 {\cf19 for} (uint32_t j = 0; j < num_entries; ) \{\par
00375                     {\cf19 if} (entries[j].name[0] == END_OF_DIRECTORY) {\cf19 goto} next_cluster_search;\par
00376                     {\cf19 if} ((uint8_t)entries[j].name[0] == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
00377 \par
00378                     {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
00379                     uint32_t consumed = 0;\par
00380                     FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], num_entries - j, lfn_buf, &consumed);\par
00381 \par
00382                     {\cf19 if} (sfn) \{\par
00383                         {\cf18 bool} match = {\cf17 false};\par
00384 \par
00385                         {\cf20 // 1) exact LFN match}\par
00386                         {\cf19 if} (kstrcmp(lfn_buf, token) == 0) match = {\cf17 true};\par
00387 \par
00388                         {\cf20 // 2) case-insensitive LFN match}\par
00389                         {\cf19 if} (!match) \{\par
00390                             {\cf18 size_t} la = kstrlen(lfn_buf);\par
00391                             {\cf18 size_t} lb = kstrlen(token);\par
00392                             {\cf19 if} (la == lb) \{\par
00393                                 {\cf18 bool} eq = {\cf17 true};\par
00394                                 {\cf19 for} ({\cf18 size_t} z = 0; z < la; ++z) \{\par
00395                                     {\cf18 char} ca = lfn_buf[z];\par
00396                                     {\cf18 char} cb = token[z];\par
00397                                     {\cf19 if} (ca >= {\cf23 'a'} && ca <= {\cf23 'z'}) ca -= ({\cf23 'a'} - {\cf23 'A'});\par
00398                                     {\cf19 if} (cb >= {\cf23 'a'} && cb <= {\cf23 'z'}) cb -= ({\cf23 'a'} - {\cf23 'A'});\par
00399                                     {\cf19 if} (ca != cb) \{ eq = {\cf17 false}; {\cf19 break}; \}\par
00400                                 \}\par
00401                                 {\cf19 if} (eq) match = {\cf17 true};\par
00402                             \}\par
00403                         \}\par
00404 \par
00405                         {\cf20 // 3) SFN compare (format token to 11-byte SFN and compare bytes)}\par
00406                         {\cf19 if} (!match) \{\par
00407                             {\cf18 char} token_sfn[11];\par
00408                             format_short_name(token, token_sfn);\par
00409                             {\cf19 if} (cmp_short_name(sfn->name, token_sfn)) match = {\cf17 true};\par
00410                         \}\par
00411 \par
00412                         {\cf19 if} (match) \{\par
00413                             kmemcpy(&last_found_entry, sfn, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00414                             found_this_token = {\cf17 true};\par
00415                             current_cluster = (sfn->fst_clus_hi << 16) | sfn->fst_clus_lo;\par
00416                             {\cf19 goto} token_found_and_continue;\par
00417                         \}\par
00418                     \}\par
00419 \par
00420                     j += (consumed > 0) ? consumed : 1;\par
00421                 \}\par
00422             \}\par
00423         next_cluster_search:\par
00424             current_cluster = fat32_read_fat(current_cluster);\par
00425         \} {\cf19 while} (current_cluster < FAT32_EOC_MIN);\par
00426 \par
00427     token_found_and_continue:\par
00428         {\cf20 // free sector_buf}\par
00429         MtFreeVirtualMemory(sector_buf);\par
00430         {\cf19 if} (!found_this_token) \{\par
00431             {\cf19 return} {\cf17 false}; {\cf20 // Path component not found, so the whole path is invalid.}\par
00432         \}\par
00433 \par
00434         any_token_found = {\cf17 true};\par
00435 \par
00436         {\cf20 // Get the next part of the path}\par
00437         token = kstrtok(NULL, {\cf22 "/"});\par
00438 \par
00439         {\cf20 // If we found a component, but it's not a directory and there's more path to parse, it's an error.}\par
00440         {\cf19 if} (token != NULL && !(last_found_entry.attr & ATTR_DIRECTORY)) \{\par
00441             {\cf19 return} {\cf17 false};\par
00442         \}\par
00443     \}\par
00444 \par
00445     {\cf19 if} (any_token_found) \{\par
00446         {\cf19 if} (out_entry) kmemcpy(out_entry, &last_found_entry, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00447         {\cf19 if} (out_parent_cluster) *out_parent_cluster = parent_cluster_of_last_found;\par
00448         {\cf19 return} {\cf17 true};\par
00449     \}\par
00450 \par
00451     {\cf19 return} {\cf17 false}; {\cf20 // Should not be reached if path is not root, but good for safety.}\par
00452 \}\par
00453 \par
00454 {\cf17 static} {\cf18 bool} fat32_extend_directory(uint32_t dir_cluster) \{\par
00455     uint32_t new_cluster = fat32_find_free_cluster();\par
00456     {\cf19 if} (new_cluster == 0) {\cf19 return} {\cf17 false};\par
00457 \par
00458     {\cf20 // Zero out the new cluster}\par
00459     {\cf19 if} (!zero_cluster(new_cluster)) \{\par
00460         fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER); {\cf20 // Free it back}\par
00461         {\cf19 return} {\cf17 false};\par
00462     \}\par
00463 \par
00464     fat32_write_fat(new_cluster, FAT32_EOC_MAX); {\cf20 // Mark as new end of chain}\par
00465 \par
00466     {\cf20 // Find the last cluster in the original chain and link it to the new one}\par
00467     uint32_t current = dir_cluster;\par
00468     uint32_t next = 0;\par
00469     {\cf19 while} ((next = fat32_read_fat(current)) < FAT32_EOC_MIN) \{\par
00470         current = next;\par
00471     \}\par
00472 \par
00473     {\cf19 return} fat32_write_fat(current, new_cluster);\par
00474 \}\par
00475 \par
00476 {\cf17 static} {\cf18 bool} fat32_find_free_dir_slots(uint32_t dir_cluster, uint32_t count, uint32_t* out_sector, uint32_t* out_entry_index) \{\par
00477     uint32_t current_cluster = dir_cluster;\par
00478     {\cf18 void}* sector_buf = MtAllocateVirtualMemory(512, 512);\par
00479     {\cf19 if} (!sector_buf) {\cf19 return} {\cf17 false};\par
00480     MTSTATUS status;\par
00481     {\cf19 do} \{\par
00482         uint32_t sector_lba = first_sector_of_cluster(current_cluster);\par
00483         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; i++) \{\par
00484             status = read_sector(sector_lba + i, sector_buf);\par
00485             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} {\cf17 false}; \}\par
00486 \par
00487             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)sector_buf;\par
00488             uint32_t num_entries = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
00489 \par
00490             uint32_t consecutive_free = 0;\par
00491             {\cf19 for} (uint32_t j = 0; j < num_entries; j++) \{\par
00492                 uint8_t first_byte = (uint8_t)entries[j].name[0];\par
00493                 {\cf19 if} (first_byte == END_OF_DIRECTORY || first_byte == DELETED_DIR_ENTRY) \{\par
00494                     consecutive_free++;\par
00495                     {\cf19 if} (consecutive_free == count) \{\par
00496                         *out_sector = sector_lba + i;\par
00497                         *out_entry_index = j - (count - 1);\par
00498                         MtFreeVirtualMemory(sector_buf);\par
00499                         {\cf19 return} {\cf17 true};\par
00500                     \}\par
00501                 \}\par
00502                 {\cf19 else} \{\par
00503                     consecutive_free = 0;\par
00504                 \}\par
00505             \}\par
00506         \}\par
00507 \par
00508         uint32_t next_cluster = fat32_read_fat(current_cluster);\par
00509         {\cf19 if} (next_cluster >= FAT32_EOC_MIN) \{\par
00510             {\cf20 // End of chain, no space found, try to extend}\par
00511             {\cf19 if} (fat32_extend_directory(dir_cluster)) \{\par
00512                 {\cf20 // After extending, restart the search. A more optimized way exists,}\par
00513                 {\cf20 // but this is safer and simpler to implement.}\par
00514                 {\cf19 return} fat32_find_free_dir_slots(dir_cluster, count, out_sector, out_entry_index);\par
00515             \}\par
00516             {\cf19 else} \{\par
00517                 MtFreeVirtualMemory(sector_buf);\par
00518                 {\cf19 return} {\cf17 false}; {\cf20 // Cannot extend directory}\par
00519             \}\par
00520         \}\par
00521         current_cluster = next_cluster;\par
00522     \} {\cf19 while} ({\cf17 true});\par
00523 \par
00524     MtFreeVirtualMemory(sector_buf);\par
00525     {\cf19 return} {\cf17 false};\par
00526 \}\par
00527 \par
00528 {\cf21 #define BPB_SECTOR_START 2048}\par
00529 \par
00530 {\cf20 // Read BPB (Bios Parameter Block) and initialize.}\par
00531 MTSTATUS fat32_init({\cf18 int} disk_index) \{\par
00532     tracelast_func({\cf22 "fat32_init"});\par
00533     MTSTATUS status;\par
00534     disk = get_block_device(disk_index);\par
00535     {\cf19 if} (!disk) \{ {\cf19 return} MT_GENERAL_FAILURE; \}\par
00536 \par
00537     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
00538     {\cf19 if} (!buf) {\cf19 return} MT_NO_MEMORY;\par
00539     status = read_sector(BPB_SECTOR_START, buf);\par
00540     {\cf19 if} (MT_FAILURE(status)) \{ {\cf19 return} status; \} {\cf20 // First sector contains the BPB for FAT.}\par
00541     kmemcpy(&bpb, buf, {\cf17 sizeof}(bpb)); {\cf20 // So copy that first sector into our local BPB structure.}\par
00542 \par
00543     {\cf20 // Then initialize it.}\par
00544     fs.bytes_per_sector = bpb.bytes_per_sector;\par
00545     fs.sectors_per_cluster = bpb.sectors_per_cluster;\par
00546     fs.reserved_sector_count = bpb.reserved_sector_count;\par
00547     fs.sectors_per_fat = bpb.fat_size_32;\par
00548     fs.root_cluster = bpb.root_cluster;\par
00549 \par
00550     fs.fat_start = BPB_SECTOR_START + bpb.reserved_sector_count; {\cf20 // technically also reserved_sector_count of fs. holds it as well.}\par
00551     fs.first_data_sector = fs.fat_start + bpb.num_fats * fs.sectors_per_fat;\par
00552     MtFreeVirtualMemory(buf);\par
00553     {\cf19 return} MT_SUCCESS;\par
00554 \}\par
00555 \par
00556 {\cf20 // Walk cluster chain and read directory entries.}\par
00557 {\cf18 void} fat32_list_root({\cf18 void}) \{\par
00558     tracelast_func({\cf22 "fat32_list_root"});\par
00559     uint32_t cluster = fs.root_cluster;\par
00560 \par
00561     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
00562     {\cf19 if} (!buf) {\cf19 return};\par
00563 \par
00564     {\cf20 // Temp buffer to accumulate LFN entries (and eventually the 8.3 entry).}\par
00565     FAT32_DIR_ENTRY temp_entries[MAX_LFN_ENTRIES + 1];\par
00566     uint32_t lfn_accum = 0;\par
00567     MTSTATUS status;\par
00568     {\cf19 do} \{\par
00569         uint32_t sector = first_sector_of_cluster(cluster);\par
00570         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; ++i) \{\par
00571             status = read_sector(sector + i, buf);\par
00572             {\cf19 if} (MT_FAILURE(status)) {\cf19 return};\par
00573 \par
00574             FAT32_DIR_ENTRY* dir = (FAT32_DIR_ENTRY*)buf;\par
00575             uint32_t entries = fs.bytes_per_sector / {\cf17 sizeof}(*dir);\par
00576             \par
00577             {\cf19 for} (uint32_t j = 0; j < entries; ++j, ++dir) \{\par
00578                 uint8_t first = (uint8_t)dir->name[0];\par
00579 \par
00580                 {\cf20 // End of directory: stop everything}\par
00581                 {\cf19 if} (first == 0x00) \{\par
00582                     MtFreeVirtualMemory(buf);\par
00583                     {\cf19 return};\par
00584                 \}\par
00585 \par
00586                 {\cf20 // Deleted entry: if we were accumulating an LFN chain, drop it.}\par
00587                 {\cf19 if} (first == 0xE5) \{\par
00588                     lfn_accum = 0;\par
00589                     {\cf19 continue};\par
00590                 \}\par
00591 \par
00592                 {\cf20 // If it's an LFN entry, copy it into the temp accumulator (preserve order read-on-disk)}\par
00593                 {\cf19 if} (dir->attr == ATTR_LONG_NAME) \{\par
00594                     {\cf19 if} (lfn_accum < MAX_LFN_ENTRIES) \{\par
00595                         kmemcpy(&temp_entries[lfn_accum], dir, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00596                         lfn_accum++;\par
00597                     \}\par
00598                     {\cf19 else} \{\par
00599                         {\cf20 // too many parts: drop accumulator to avoid overflow}\par
00600                         lfn_accum = 0;\par
00601                     \}\par
00602                     {\cf19 continue};\par
00603                 \}\par
00604                 {\cf20 // Non-LFN entry: this is the 8.3 entry that ends any preceding LFN chain (if present).}\par
00605                 {\cf20 // If we have accumulated LFN entries, build a contiguous array: [LFN...][8.3]}\par
00606                 {\cf18 char} bufferLfn[MAX_LFN_LEN];\par
00607                 uint32_t consumed = 0;\par
00608                 FAT32_DIR_ENTRY* real = NULL;\par
00609 \par
00610                 {\cf19 if} (lfn_accum > 0) \{\par
00611                     {\cf20 // copy the 8.3 entry as the last element}\par
00612                     kmemcpy(&temp_entries[lfn_accum], dir, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00613                     {\cf20 // call read_lfn on our temp buffer (which starts with LFN entries)}\par
00614                     real = read_lfn(temp_entries, lfn_accum + 1, bufferLfn, &consumed);\par
00615                     {\cf20 // reset accumulator regardless (we've handled or attempted to)}\par
00616                     lfn_accum = 0;\par
00617                 \}\par
00618                 {\cf19 else} \{\par
00619                     {\cf20 // No accumulated LFN entries: handle short-name-only entry}\par
00620                     {\cf20 // We can call read_lfn directly on the sector buffer at current position}\par
00621                     uint32_t remaining = entries - j;\par
00622                     real = read_lfn(&dir[0], remaining, bufferLfn, &consumed);\par
00623                     {\cf20 // note: consumed will be at least 1 if successful}\par
00624                 \}\par
00625 \par
00626                 {\cf20 // If read_lfn returned a real 8.3 entry (it should), print the name}\par
00627                 {\cf19 if} (real) \{\par
00628                     gop_printf(0xFF00FFFF, {\cf22 "Found: %s\\n"}, bufferLfn);\par
00629                 \}\par
00630                 {\cf19 else} \{\par
00631                     {\cf20 // Fallback: if read_lfn failed for some reason, print raw 8.3 as a last resort}\par
00632                     {\cf18 char} fallback[12];\par
00633                     {\cf19 for} ({\cf18 int} k = 0; k < 11; ++k) fallback[k] = dir->name[k];\par
00634                     fallback[11] = {\cf23 '\\0'};\par
00635                     gop_printf(0xFF00FFFF, {\cf22 "Found (raw): %s\\n"}, fallback);\par
00636                 \}\par
00637 \par
00638                 {\cf20 // continue to next entry (we already advanced j by loop)}\par
00639             \} {\cf20 // for each dir entry in sector}\par
00640         \} {\cf20 // for each sector in cluster}\par
00641 \par
00642         cluster = fat32_read_fat(cluster);\par
00643     \} {\cf19 while} (cluster < 0x0FFFFFF8);\par
00644 \}\par
00645 \par
00646 {\cf20 // Helper to detect if a filename has a slash in it (/), and so the filename is in a directory}\par
00647 {\cf17 static} {\cf18 bool} is_filename_in_dir({\cf17 const} {\cf18 char}* filename) \{\par
00648     {\cf19 if} (!filename) {\cf19 return} {\cf17 false};\par
00649 \par
00650     {\cf19 while} (*filename) \{\par
00651         {\cf19 if} (*filename == {\cf23 '/'}) {\cf19 return} {\cf17 true};\par
00652         filename++;\par
00653     \}\par
00654 \par
00655     {\cf19 return} {\cf17 false};\par
00656 \}\par
00657 \par
00658 {\cf17 static} uint32_t extract_dir_cluster({\cf17 const} {\cf18 char}* filename) \{\par
00659     tracelast_func({\cf22 "extract_dir_cluster - fat32"});\par
00660 \par
00661     {\cf19 if} (!filename || filename[0] == {\cf23 '\\0'}) {\cf19 return} fs.root_cluster;\par
00662 \par
00663     {\cf20 // Make a mutable copy}\par
00664     {\cf18 char} path_copy[260];\par
00665     kstrcpy(path_copy, filename);\par
00666 \par
00667     {\cf20 // Remove trailing slashes (keep a single leading '/' if path is "/")}\par
00668     {\cf18 int} len = (int)kstrlen(path_copy);\par
00669     {\cf19 while} (len > 1 && path_copy[len - 1] == {\cf23 '/'}) \{\par
00670         path_copy[len - 1] = {\cf23 '\\0'};\par
00671         len--;\par
00672     \}\par
00673 \par
00674     {\cf20 // Find last slash}\par
00675     {\cf18 int} last_slash = -1;\par
00676     {\cf19 for} ({\cf18 int} i = len - 1; i >= 0; --i) \{\par
00677         {\cf19 if} (path_copy[i] == {\cf23 '/'}) \{ last_slash = i; {\cf19 break}; \}\par
00678     \}\par
00679 \par
00680     {\cf20 // No slash -> file is in root}\par
00681     {\cf19 if} (last_slash == -1) \{\par
00682         {\cf19 return} fs.root_cluster;\par
00683     \}\par
00684 \par
00685     {\cf20 // Parent path is "/" if last_slash == 0, otherwise substring [0..last_slash-1]}\par
00686     {\cf18 char} parent[260];\par
00687     {\cf19 if} (last_slash == 0) \{\par
00688         parent[0] = {\cf23 '/'};\par
00689         parent[1] = {\cf23 '\\0'};\par
00690     \}\par
00691     {\cf19 else} \{\par
00692         {\cf20 // copy up to last_slash}\par
00693         {\cf19 for} ({\cf18 int} i = 0; i < last_slash; ++i) parent[i] = path_copy[i];\par
00694         parent[last_slash] = {\cf23 '\\0'};\par
00695     \}\par
00696 \par
00697     {\cf20 // Resolve the parent path to a directory entry}\par
00698     FAT32_DIR_ENTRY parent_entry;\par
00699     {\cf19 if} (!fat32_find_entry(parent, &parent_entry, NULL)) {\cf19 return} 0;\par
00700 \par
00701     {\cf20 // Ensure it's a directory}\par
00702     {\cf19 if} (!(parent_entry.attr & ATTR_DIRECTORY)) {\cf19 return} 0;\par
00703 \par
00704     uint32_t cluster = ((uint32_t)parent_entry.fst_clus_hi << 16) | parent_entry.fst_clus_lo;\par
00705     {\cf19 if} (cluster == 0) cluster = fs.root_cluster; {\cf20 // safety fallback}\par
00706     {\cf19 return} cluster;\par
00707 \}\par
00708 \par
00709 MTSTATUS fat32_read_file({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out) \{\par
00710     tracelast_func({\cf22 "fat32_read_file"});\par
00711     MTSTATUS status;\par
00712     {\cf20 // We still need a temporary buffer for reading sectors}\par
00713     {\cf18 void}* sblk = MtAllocateVirtualMemory(512, 512);\par
00714     {\cf19 if} (!sblk) {\cf19 return} MT_NO_MEMORY;\par
00715 \par
00716     {\cf20 // Get the cluster of the directory filename points to (e.g "tmp/folder/myfile.txt", we need the "folder" cluster.)}\par
00717     uint32_t cluster = 0;\par
00718 \par
00719     {\cf19 if} (is_filename_in_dir(filename)) \{\par
00720         cluster = extract_dir_cluster(filename);\par
00721         {\cf19 if} (!cluster) \{\par
00722             MtFreeVirtualMemory(sblk);\par
00723             {\cf19 return} MT_FAT32_INVALID_CLUSTER;\par
00724         \}\par
00725     \}\par
00726     {\cf19 else} \{\par
00727         cluster = fs.root_cluster;\par
00728     \}\par
00729 \par
00730     {\cf19 do} \{\par
00731         uint32_t sector = first_sector_of_cluster(cluster);\par
00732         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; ++i) \{\par
00733             status = read_sector(sector + i, sblk);\par
00734             {\cf19 if} (MT_FAILURE(status)) \{\par
00735                 {\cf20 // Free sblk before returning}\par
00736                 MtFreeVirtualMemory(sblk);\par
00737                 {\cf19 return} status;\par
00738             \}\par
00739 \par
00740             FAT32_DIR_ENTRY* dir_entries = (FAT32_DIR_ENTRY*)sblk;\par
00741             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
00742 \par
00743             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
00744                 FAT32_DIR_ENTRY* current_entry = &dir_entries[j];\par
00745 \par
00746                 {\cf19 if} (current_entry->name[0] == END_OF_DIRECTORY) \{\par
00747                     {\cf20 // Free sblk}\par
00748                     MtFreeVirtualMemory(sblk);\par
00749                     {\cf19 return} MT_FAT32_FILE_NOT_FOUND; {\cf20 // End of directory, file not found}\par
00750                 \}\par
00751                 {\cf19 if} ((uint8_t)current_entry->name[0] == DELETED_DIR_ENTRY) \{\par
00752                     j++;\par
00753                     {\cf19 continue};\par
00754                 \}\par
00755 \par
00756                 {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
00757                 uint32_t consumed_entries = 0;\par
00758                 FAT32_DIR_ENTRY* sfn_entry = read_lfn(current_entry, entries_per_sector - j, lfn_buf, &consumed_entries);\par
00759 \par
00760                 {\cf19 if} (sfn_entry) \{\par
00761                     {\cf20 // Check if either the long or short filename matches}\par
00762                     {\cf19 if} (kstrcmp(filename, lfn_buf) == 0) \{\par
00763                         {\cf19 goto} file_found;\par
00764                     \}\par
00765 \par
00766                     {\cf18 char} shortname_formatted[11];\par
00767                     format_short_name(filename, shortname_formatted);\par
00768                     {\cf19 if} (cmp_short_name(sfn_entry->name, shortname_formatted)) \{\par
00769                         {\cf19 goto} file_found;\par
00770                     \}\par
00771 \par
00772                     j += consumed_entries; {\cf20 // Skip past all LFN entries and the SFN entry}\par
00773                     {\cf19 continue};\par
00774 \par
00775                 file_found:\par
00776                     \{\par
00777                         uint32_t file_size = sfn_entry->file_size;\par
00778                         {\cf19 if} (file_size_out) \{\par
00779                             *file_size_out = file_size;\par
00780                         \}\par
00781 \par
00782                         {\cf20 // Now allocate the final buffer for the file content}\par
00783                         {\cf18 void}* file_buffer = MtAllocateVirtualMemory(file_size, 4096);\par
00784                         {\cf19 if} (!file_buffer) \{\par
00785                             {\cf20 // Free sblk}\par
00786                             MtFreeVirtualMemory(sblk);\par
00787                             {\cf19 return} MT_NO_MEMORY;\par
00788                         \}\par
00789 \par
00790                         uint32_t file_cluster = (uint32_t)((sfn_entry->fst_clus_hi << 16) | sfn_entry->fst_clus_lo);\par
00791                         uint32_t remaining_bytes = file_size;\par
00792                         uint8_t* dst = (uint8_t*)file_buffer;\par
00793 \par
00794                         {\cf19 while} (file_cluster < FAT32_EOC_MIN && remaining_bytes > 0) \{\par
00795                             uint32_t current_sector = first_sector_of_cluster(file_cluster);\par
00796                             {\cf19 for} (uint32_t sc = 0; sc < fs.sectors_per_cluster && remaining_bytes > 0; ++sc) \{\par
00797                                 status = read_sector(current_sector + sc, sblk);\par
00798                                 {\cf19 if} (MT_FAILURE(status)) \{\par
00799                                     {\cf20 // Free both buffers}\par
00800                                     MtFreeVirtualMemory(file_buffer);\par
00801                                     MtFreeVirtualMemory(sblk);\par
00802                                     {\cf19 return} status;\par
00803                                 \}\par
00804 \par
00805                                 uint32_t bytes_to_copy = fs.bytes_per_sector;\par
00806                                 {\cf19 if} (bytes_to_copy > remaining_bytes) \{\par
00807                                     bytes_to_copy = remaining_bytes;\par
00808                                 \}\par
00809 \par
00810                                 kmemcpy(dst, sblk, bytes_to_copy);\par
00811                                 dst += bytes_to_copy;\par
00812                                 remaining_bytes -= bytes_to_copy;\par
00813                             \}\par
00814                             file_cluster = fat32_read_fat(file_cluster);\par
00815                         \}\par
00816 \par
00817                         {\cf20 // Free the temporary sector buffer and return the file buffer}\par
00818                         MtFreeVirtualMemory(sblk);\par
00819                         *buffer_out = file_buffer;\par
00820                         {\cf19 return} MT_SUCCESS;\par
00821                     \}\par
00822                 \}\par
00823                 {\cf19 else} \{\par
00824                     j++; {\cf20 // Move to the next entry if read_lfn fails}\par
00825                 \}\par
00826             \}\par
00827         \}\par
00828         cluster = fat32_read_fat(cluster);\par
00829     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
00830 \par
00831     {\cf20 // Free sblk}\par
00832     MtFreeVirtualMemory(sblk);\par
00833     {\cf19 return} MT_FAT32_FILE_NOT_FOUND; {\cf20 // File not found after searching the entire directory}\par
00834 \}\par
00835 \par
00836 MTSTATUS fat32_create_directory({\cf17 const} {\cf18 char}* path) \{\par
00837     tracelast_func({\cf22 "fat32_create_directory_full"});\par
00838     {\cf20 // 1. Check if an entry already exists at this path}\par
00839     {\cf19 if} (fat32_find_entry(path, NULL, NULL)) \{\par
00840 {\cf21 #ifdef DEBUG}\par
00841         gop_printf(0xFFFF0000, {\cf22 "Error: Path '%s' already exists.\\n"}, path);\par
00842 {\cf21 #endif}\par
00843         {\cf19 return} MT_FAT32_DIRECTORY_ALREADY_EXISTS;\par
00844     \}\par
00845     MTSTATUS status;\par
00846     {\cf20 // 2. Separate parent path and new directory name}\par
00847     {\cf18 char} path_copy[260];\par
00848     kstrcpy(path_copy, path);\par
00849     {\cf18 char}* new_dir_name = NULL;\par
00850     {\cf18 char}* parent_path = {\cf22 "/"};\par
00851     {\cf18 int} last_slash = -1;\par
00852     {\cf19 for} ({\cf18 int} i = 0; path_copy[i] != {\cf23 '\\0'}; i++) \{\par
00853         {\cf19 if} (path_copy[i] == {\cf23 '/'}) last_slash = i;\par
00854     \}\par
00855     {\cf19 if} (last_slash != -1) \{\par
00856         new_dir_name = &path_copy[last_slash + 1];\par
00857         {\cf19 if} (last_slash > 0) \{\par
00858             path_copy[last_slash] = {\cf23 '\\0'};\par
00859             parent_path = path_copy;\par
00860         \}\par
00861     \}\par
00862     {\cf19 else} \{\par
00863         new_dir_name = path_copy;\par
00864     \}\par
00865 \par
00866     {\cf20 // 3. Find the parent directory cluster}\par
00867     FAT32_DIR_ENTRY parent_entry;\par
00868     uint32_t parent_cluster;\par
00869     {\cf19 if} (!fat32_find_entry(parent_path, &parent_entry, NULL)) \{\par
00870 {\cf21 #ifdef DEBUG}\par
00871         gop_printf(0xFFFF0000, {\cf22 "Error: Parent path '%s' not found.\\n"}, parent_path);\par
00872 {\cf21 #endif}\par
00873         {\cf19 return} MT_FAT32_PARENT_PATH_NOT_FOUND;\par
00874     \}\par
00875     {\cf19 if} (!(parent_entry.attr & ATTR_DIRECTORY)) \{\par
00876 {\cf21 #ifdef DEBUG}\par
00877         gop_printf(0xFFFF0000, {\cf22 "Error: Parent path is not a directory.\\n"}, parent_path);\par
00878 {\cf21 #endif}\par
00879         {\cf19 return} MT_FAT32_PARENT_PATH_NOT_DIR;\par
00880     \}\par
00881     parent_cluster = (parent_entry.fst_clus_hi << 16) | parent_entry.fst_clus_lo;\par
00882 \par
00883     {\cf20 // 4. Allocate a new cluster for this directory's contents}\par
00884     uint32_t new_cluster = fat32_find_free_cluster();\par
00885     {\cf19 if} (new_cluster == 0) {\cf19 return} MT_FAT32_CLUSTERS_FULL;\par
00886 \par
00887     fat32_write_fat(new_cluster, FAT32_EOC_MAX);\par
00888     zero_cluster(new_cluster);\par
00889 \par
00890     {\cf20 // 5. Create '.' and '..' entries in the new cluster}\par
00891     {\cf18 void}* sector_buf = MtAllocateVirtualMemory(512, 512);\par
00892     {\cf19 if} (!sector_buf) \{ {\cf20 /* handle error */} {\cf19 return} MT_MEMORY_LIMIT; \}\par
00893     kmemset(sector_buf, 0, 512);\par
00894     FAT32_DIR_ENTRY* dot_entries = (FAT32_DIR_ENTRY*)sector_buf;\par
00895 \par
00896     kmemcpy(dot_entries[0].name, {\cf22 ".          "}, 11);\par
00897     dot_entries[0].attr = ATTR_DIRECTORY;\par
00898     dot_entries[0].fst_clus_lo = (uint16_t)new_cluster;\par
00899     dot_entries[0].fst_clus_hi = (uint16_t)(new_cluster >> 16);\par
00900 \par
00901     kmemcpy(dot_entries[1].name, {\cf22 "..         "}, 11);\par
00902     dot_entries[1].attr = ATTR_DIRECTORY;\par
00903     dot_entries[1].fst_clus_lo = (uint16_t)parent_cluster;\par
00904     dot_entries[1].fst_clus_hi = (uint16_t)(parent_cluster >> 16);\par
00905 \par
00906     write_sector(first_sector_of_cluster(new_cluster), sector_buf);\par
00907 \par
00908     {\cf20 // 6. Create the entry in the parent directory}\par
00909     {\cf20 // For simplicity, we'll use a simple SFN. A full implementation needs `fat32_generate_sfn`.}\par
00910     {\cf18 char} sfn[11];\par
00911     format_short_name(new_dir_name, sfn); {\cf20 // Using your existing simple formatter}\par
00912 \par
00913     uint32_t entry_sector, entry_index;\par
00914     {\cf19 if} (!fat32_find_free_dir_slots(parent_cluster, 1, &entry_sector, &entry_index)) \{\par
00915         {\cf20 // free sector_buf, free cluster...}\par
00916         MtFreeVirtualMemory(sector_buf);\par
00917         fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER);\par
00918         {\cf19 return} MT_FAT32_DIR_FULL;\par
00919     \}\par
00920 \par
00921     {\cf20 // Read the target sector, modify it, write it back}\par
00922     status = read_sector(entry_sector, sector_buf);\par
00923     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} status; \}\par
00924 \par
00925     FAT32_DIR_ENTRY* new_entry = &((FAT32_DIR_ENTRY*)sector_buf)[entry_index];\par
00926     kmemset(new_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00927     kmemcpy(new_entry->name, sfn, 11);\par
00928     new_entry->attr = ATTR_DIRECTORY;\par
00929     new_entry->fst_clus_lo = (uint16_t)new_cluster;\par
00930     new_entry->fst_clus_hi = (uint16_t)(new_cluster >> 16);\par
00931 \par
00932     status = write_sector(entry_sector, sector_buf);\par
00933 \par
00934     {\cf20 // free sector_buf}\par
00935     MtFreeVirtualMemory(sector_buf);\par
00936     {\cf19 return} status;\par
00937 \}\par
00938 \par
00939 {\cf17 static} uint32_t fat32_create_lfn_entries(FAT32_DIR_ENTRY* entry_buffer, {\cf17 const} {\cf18 char}* long_name, uint8_t sfn_checksum) \{\par
00940     uint32_t len = kstrlen(long_name);\par
00941     uint32_t num_lfn_entries = (len + 12) / 13;\par
00942 \par
00943     {\cf20 // Fill LFN entries backwards}\par
00944     {\cf19 for} (uint32_t i = 0; i < num_lfn_entries; i++) \{\par
00945         FAT32_DIR_ENTRY* lfn = &entry_buffer[i];\par
00946         uint32_t lfn_seq = (num_lfn_entries - i);\par
00947         {\cf19 if} (i == 0) lfn_seq |= 0x40; {\cf20 // Last LFN entry marker}\par
00948 \par
00949         lfn->attr = ATTR_LONG_NAME;\par
00950         lfn->nt_res = 0;\par
00951         lfn->crt_time_tenth = sfn_checksum; {\cf20 // This field holds the checksum}\par
00952         lfn->fst_clus_lo = 0;\par
00953 \par
00954         {\cf20 // This is the sequence and type field in disguise}\par
00955         *(uint8_t*)(&lfn->name[0]) = lfn_seq;\par
00956 \par
00957         {\cf20 // Character positions for LFN entry}\par
00958         {\cf20 // pointers into the entry (UTF-16 wide chars)}\par
00959         uint8_t* ebytes = (uint8_t*)lfn;\par
00960         uint16_t* name1_map = (uint16_t*)(ebytes + 1);   {\cf20 // 5 chars}\par
00961         uint16_t* name2_map = (uint16_t*)(ebytes + 14);  {\cf20 // 6 chars}\par
00962         uint16_t* name3_map = (uint16_t*)(ebytes + 28);  {\cf20 // 2 chars}\par
00963 \par
00964         {\cf20 // Populate with UTF-16 characters}\par
00965         uint32_t char_idx = (num_lfn_entries - 1 - i) * 13;\par
00966         {\cf19 for} ({\cf18 int} k = 0; k < 13; k++) \{\par
00967             uint16_t uchar = 0xFFFF; {\cf20 // Fill with 0xFFFF}\par
00968             {\cf19 if} (char_idx < len) \{\par
00969                 uchar = long_name[char_idx];\par
00970             \}\par
00971             {\cf19 else} {\cf19 if} (char_idx == len) \{\par
00972                 uchar = 0x0000; {\cf20 // Null terminator}\par
00973             \}\par
00974 \par
00975             {\cf19 if} (k < 5)       ((uint16_t*)name1_map)[k] = uchar;\par
00976             {\cf19 else} {\cf19 if} (k < 11) ((uint16_t*)name2_map)[k - 5] = uchar;\par
00977             {\cf19 else}             ((uint16_t*)name3_map)[k - 11] = uchar;\par
00978 \par
00979             char_idx++;\par
00980         \}\par
00981     \}\par
00982     {\cf19 return} num_lfn_entries;\par
00983 \}\par
00984 \par
00985 {\cf17 static} TIME_ENTRY convertFat32ToRealtime(uint16_t fat32Time, uint16_t fat32Date) \{\par
00986     TIME_ENTRY time;\par
00987     uint8_t h, m, s;\par
00988     uint8_t mon, day;\par
00989     uint16_t y;\par
00990     fat32_decode_date(fat32Date, &y, &mon, &day);\par
00991     fat32_decode_time(fat32Time, &h, &m, &s);\par
00992     time.hour = h;\par
00993     time.minute = m;\par
00994     time.second = s;\par
00995     time.month = mon;\par
00996     time.day = day;\par
00997     time.year = y;\par
00998     {\cf19 return} time;\par
00999 \}\par
01000 \par
01001 MTSTATUS fat32_write_file({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, uint32_t mode) \{\par
01002     tracelast_func({\cf22 "fat32_write_file_full"});\par
01003     {\cf20 // Safety check.}\par
01004     {\cf19 if} (mode != WRITE_MODE_CREATE_OR_REPLACE && mode != WRITE_MODE_APPEND_EXISTING) \{\par
01005         {\cf19 return} MT_FAT32_INVALID_WRITE_MODE;\par
01006     \}\par
01007     MTSTATUS status;\par
01008     uint32_t first_cluster = 0;\par
01009     {\cf20 // parse parent + filename.}\par
01010     {\cf18 char} path_copy[260];\par
01011     kstrcpy(path_copy, path);\par
01012     {\cf18 char}* filename = NULL;\par
01013     {\cf18 char}* parent_path = {\cf22 "/"};\par
01014     {\cf18 int} last_slash = -1;\par
01015     {\cf19 for} ({\cf18 int} i = 0; path_copy[i] != {\cf23 '\\0'}; i++) \{ {\cf19 if} (path_copy[i] == {\cf23 '/'}) last_slash = i; \}\par
01016     {\cf19 if} (last_slash != -1) \{\par
01017         filename = &path_copy[last_slash + 1];\par
01018         {\cf19 if} (last_slash > 0) \{ path_copy[last_slash] = {\cf23 '\\0'}; parent_path = path_copy; \}\par
01019     \}\par
01020     {\cf19 else} \{ filename = path_copy; \}\par
01021 \par
01022     {\cf20 // Step 3: Find parent directory cluster}\par
01023     FAT32_DIR_ENTRY parent_entry;\par
01024     {\cf19 if} (!fat32_find_entry(parent_path, &parent_entry, NULL) || !(parent_entry.attr & ATTR_DIRECTORY)) \{ {\cf19 return} MT_FAT32_CLUSTER_NOT_FOUND; \}\par
01025     uint32_t parent_cluster = (parent_entry.fst_clus_hi << 16) | parent_entry.fst_clus_lo;\par
01026 \par
01027     {\cf20 // locate existing entry if any}\par
01028     FAT32_DIR_ENTRY existing_entry;\par
01029     {\cf18 bool} exists = fat32_find_entry(path, &existing_entry, NULL);\par
01030 \par
01031     {\cf20 // Helper: locate on-disk sector + index for the entry (so we can update SFN/LFN in-place)}\par
01032     uint32_t located_sector = 0;\par
01033     uint32_t located_index = 0;\par
01034     uint32_t located_consumed = 0;\par
01035     {\cf18 bool} located = {\cf17 false};\par
01036 \par
01037     \{\par
01038         {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
01039         {\cf19 if} (!buf) {\cf19 return} MT_NO_MEMORY;\par
01040         uint32_t cluster = parent_cluster;\par
01041         {\cf19 do} \{\par
01042             uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01043             {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01044                 status = read_sector(sector_lba + s, buf);\par
01045                 {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} status; \}\par
01046                 FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01047                 uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01048 \par
01049                 {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01050                     uint8_t first = (uint8_t)entries[j].name[0];\par
01051                     {\cf19 if} (first == END_OF_DIRECTORY) \{ MtFreeVirtualMemory(buf); {\cf19 goto} locate_done; \}\par
01052                     {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01053 \par
01054                     {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
01055                     uint32_t consumed = 0;\par
01056                     FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_buf, &consumed);\par
01057                     {\cf19 if} (sfn) \{\par
01058                         {\cf18 bool} match = {\cf17 false};\par
01059                         {\cf20 // exact LFN}\par
01060                         {\cf19 if} (kstrcmp(lfn_buf, filename) == 0) match = {\cf17 true};\par
01061                         {\cf20 // case-insensitive LFN}\par
01062                         {\cf19 if} (!match && ci_equal(lfn_buf, filename)) match = {\cf17 true};\par
01063                         {\cf20 // SFN compare}\par
01064                         {\cf19 if} (!match) \{\par
01065                             {\cf18 char} token_sfn[11];\par
01066                             format_short_name(filename, token_sfn);\par
01067                             {\cf19 if} (cmp_short_name(sfn->name, token_sfn)) match = {\cf17 true};\par
01068                         \}\par
01069                         {\cf19 if} (match) \{\par
01070                             located_sector = sector_lba + s;\par
01071                             located_index = j;\par
01072                             located_consumed = consumed;\par
01073                             located = {\cf17 true};\par
01074                             MtFreeVirtualMemory(buf);\par
01075                             {\cf19 goto} locate_done;\par
01076                         \}\par
01077                         j += consumed;\par
01078                         {\cf19 continue};\par
01079                     \}\par
01080                     {\cf19 else} \{\par
01081                         j++;\par
01082                     \}\par
01083                 \}\par
01084             \}\par
01085             cluster = fat32_read_fat(cluster);\par
01086         \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01087         MtFreeVirtualMemory(buf);\par
01088     \}\par
01089 locate_done:\par
01090 \par
01091     {\cf20 // 4) Allocate clusters for file data }\par
01092     {\cf19 if} (exists) first_cluster = (existing_entry.fst_clus_hi << 16) | existing_entry.fst_clus_lo;\par
01093 \par
01094     {\cf20 // Behavior:}\par
01095     {\cf20 // - CREATE_OR_OVERWRITE: if file exists -> free its clusters; treat as new file}\par
01096     {\cf20 // - APPEND: if file exists -> append to its chain; otherwise behave like create}\par
01097     {\cf19 if} (mode == WRITE_MODE_CREATE_OR_REPLACE) \{\par
01098         {\cf20 // If exists, free existing cluster chain and reset first_cluster}\par
01099         {\cf19 if} (exists && first_cluster >= 2) \{\par
01100             {\cf19 if} (!fat32_free_cluster_chain(first_cluster)) \{\par
01101                 {\cf19 return} MT_FAT32_INVALID_CLUSTER;\par
01102             \}\par
01103         \}\par
01104         first_cluster = 0;\par
01105     \}\par
01106     {\cf20 // For append, we'll compute writing start later.}\par
01107 \par
01108     {\cf20 /* Step 5: Write data to the allocated clusters */}\par
01109     {\cf20 // If size > 0 allocate clusters and write data. Handle append partial-last-cluster case.}\par
01110     {\cf19 if} (size > 0) \{\par
01111         uint32_t cluster_size = fs.sectors_per_cluster * fs.bytes_per_sector;\par
01112         uint32_t clusters_needed = 0;\par
01113         uint32_t prev_cluster = 0;\par
01114         uint32_t last_cluster = 0;\par
01115         uint32_t append_offset = 0;\par
01116 \par
01117         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists && first_cluster != 0) \{\par
01118             {\cf20 // find last cluster of existing file and offset}\par
01119             uint32_t cur = first_cluster;\par
01120             uint32_t next = cur;\par
01121             uint32_t file_size = existing_entry.file_size;\par
01122             {\cf19 if} (file_size == 0) \{\par
01123                 last_cluster = 0;\par
01124                 append_offset = 0;\par
01125             \}\par
01126             {\cf19 else} \{\par
01127                 {\cf20 // reach last cluster}\par
01128                 {\cf19 while} (cur < FAT32_EOC_MIN) \{\par
01129                     next = fat32_read_fat(cur);\par
01130                     {\cf19 if} (next >= FAT32_EOC_MIN) \{ last_cluster = cur; {\cf19 break}; \}\par
01131                     cur = next;\par
01132                 \}\par
01133                 append_offset = existing_entry.file_size % cluster_size;\par
01134             \}\par
01135         \}\par
01136 \par
01137         {\cf20 // compute clusters needed (account for partial last cluster when appending)}\par
01138         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists && append_offset > 0) \{\par
01139             uint32_t bytes_fit = cluster_size - append_offset;\par
01140             {\cf19 if} (size <= bytes_fit) clusters_needed = 0;\par
01141             {\cf19 else} clusters_needed = (size - bytes_fit + cluster_size - 1) / cluster_size;\par
01142         \}\par
01143         {\cf19 else} \{\par
01144             clusters_needed = (size + cluster_size - 1) / cluster_size;\par
01145             {\cf20 // if appending into empty file that had no clusters, clusters_needed is as above}\par
01146         \}\par
01147 \par
01148         {\cf20 // allocate required clusters}\par
01149         uint32_t first_new = 0;\par
01150         prev_cluster = 0;\par
01151         {\cf19 for} (uint32_t i = 0; i < clusters_needed; ++i) \{\par
01152             uint32_t nc = fat32_find_free_cluster();\par
01153             {\cf19 if} (nc == 0) \{\par
01154                 {\cf20 // cleanup on failure}\par
01155                 {\cf19 if} (first_new) fat32_free_cluster_chain(first_new);\par
01156                 {\cf19 return} MT_FAT32_CLUSTERS_FULL;\par
01157             \}\par
01158             {\cf19 if} (!zero_cluster(nc)) \{\par
01159                 {\cf20 // free and abort}\par
01160                 fat32_write_fat(nc, FAT32_FREE_CLUSTER);\par
01161                 {\cf19 if} (first_new) fat32_free_cluster_chain(first_new);\par
01162                 {\cf19 return} MT_FAT32_CLUSTER_GENERAL_FAILURE;\par
01163             \}\par
01164             {\cf19 if} (first_new == 0) first_new = nc;\par
01165             {\cf19 if} (prev_cluster != 0) \{\par
01166                 {\cf19 if} (!fat32_write_fat(prev_cluster, nc)) \{\par
01167                     {\cf20 // cleanup}\par
01168                     {\cf19 if} (first_new) fat32_free_cluster_chain(first_new);\par
01169                     {\cf19 return} MT_FAT32_CLUSTER_GENERAL_FAILURE;\par
01170                 \}\par
01171             \}\par
01172             prev_cluster = nc;\par
01173         \}\par
01174         {\cf19 if} (prev_cluster != 0) fat32_write_fat(prev_cluster, FAT32_EOC_MAX);\par
01175 \par
01176         {\cf20 // Link newly allocated clusters into file chain}\par
01177         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists) \{\par
01178             {\cf19 if} (first_new != 0) \{\par
01179                 {\cf19 if} (last_cluster == 0) \{\par
01180                     {\cf20 // file had no cluster, new allocation becomes first}\par
01181                     first_cluster = first_new;\par
01182                 \}\par
01183                 {\cf19 else} \{\par
01184                     {\cf20 // link last_cluster -> first_new}\par
01185                     {\cf19 if} (!fat32_write_fat(last_cluster, first_new)) \{\par
01186                         {\cf19 if} (first_new) fat32_free_cluster_chain(first_new);\par
01187                         {\cf19 return} MT_FAT32_CLUSTER_GENERAL_FAILURE;\par
01188                     \}\par
01189                 \}\par
01190             \}\par
01191             {\cf20 // else nothing newly allocated, file continues as-is}\par
01192         \}\par
01193         {\cf19 else} \{\par
01194             {\cf20 // create/overwrite or new file -> new chain starts at first_new}\par
01195             {\cf19 if} (first_new != 0) first_cluster = first_new;\par
01196         \}\par
01197 \par
01198         {\cf20 // Now write bytes to cluster chain}\par
01199         {\cf18 void}* sector_buf = MtAllocateVirtualMemory(512, 512);\par
01200         {\cf19 if} (!sector_buf) \{\par
01201             {\cf20 // cleanup allocated clusters on error}\par
01202             {\cf19 if} (mode != WRITE_MODE_APPEND_EXISTING || !exists) \{\par
01203                 {\cf19 if} (first_cluster) fat32_free_cluster_chain(first_cluster);\par
01204             \}\par
01205             {\cf19 return} MT_NO_MEMORY;\par
01206         \}\par
01207 \par
01208         {\cf17 const} uint8_t* src = ({\cf17 const} uint8_t*)data;\par
01209         uint32_t bytes_left = size;\par
01210 \par
01211         {\cf20 // If appending into an existing partial last cluster, fill its tail first}\par
01212         uint32_t cur_cluster = 0;\par
01213         uint32_t write_cluster = 0;\par
01214         uint32_t write_offset = 0;\par
01215 \par
01216         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists && append_offset > 0) \{\par
01217             write_cluster = last_cluster;\par
01218             write_offset = append_offset;\par
01219         \}\par
01220         {\cf19 else} \{\par
01221             write_cluster = first_cluster;\par
01222             write_offset = 0;\par
01223         \}\par
01224 \par
01225         {\cf20 // If write_cluster == 0 here (shouldn't happen when size>0) treat as error}\par
01226         {\cf19 if} (write_cluster == 0) \{\par
01227             {\cf20 // may happen for append when file had no clusters but we didn't allocate - but in that case we did allocate above.}\par
01228             MtFreeVirtualMemory(sector_buf);\par
01229             {\cf19 return} MT_FAT32_CLUSTER_GENERAL_FAILURE;\par
01230         \}\par
01231 \par
01232         {\cf20 // loop writing clusters one by one}\par
01233         cur_cluster = write_cluster;\par
01234         {\cf19 while} (bytes_left > 0 && cur_cluster < FAT32_EOC_MIN) \{\par
01235             uint32_t sector_lba = first_sector_of_cluster(cur_cluster);\par
01236             {\cf20 // write sectors in cluster}\par
01237             {\cf19 for} (uint32_t sc = 0; sc < fs.sectors_per_cluster && bytes_left > 0; ++sc) \{\par
01238                 {\cf20 // if starting in the middle of cluster, handle first sector specially}\par
01239                 {\cf19 if} (sc == 0 && write_offset > 0) \{\par
01240                     {\cf20 // read sector, patch from write_offset, write back}\par
01241                     status = read_sector(sector_lba + sc, sector_buf);\par
01242                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} status; \}\par
01243                     uint32_t off_in_sector = write_offset % fs.bytes_per_sector;\par
01244                     uint32_t to_copy = fs.bytes_per_sector - off_in_sector;\par
01245                     {\cf19 if} (to_copy > bytes_left) to_copy = bytes_left;\par
01246 \par
01247                     {\cf20 // Copy new data}\par
01248                     kmemcpy((uint8_t*)sector_buf + off_in_sector, src, to_copy);\par
01249 \par
01250                     {\cf20 // Zero out remaining bytes in the sector}\par
01251                     {\cf19 if} (to_copy < fs.bytes_per_sector - off_in_sector)\par
01252                         kmemset((uint8_t*)sector_buf + off_in_sector + to_copy, 0,\par
01253                             fs.bytes_per_sector - off_in_sector - to_copy);\par
01254 \par
01255                     {\cf20 // Patch the sector.}\par
01256                     status = write_sector(sector_lba + sc, sector_buf);\par
01257                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} status; \}\par
01258 \par
01259                     src += to_copy;\par
01260                     bytes_left -= to_copy;\par
01261                     write_offset = 0;\par
01262                     {\cf19 continue};\par
01263                 \}\par
01264 \par
01265                 {\cf20 // normal full-sector write}\par
01266                 uint32_t to_write = (bytes_left > fs.bytes_per_sector) ? fs.bytes_per_sector : bytes_left;\par
01267                 {\cf19 if} (to_write < fs.bytes_per_sector) \{\par
01268                     {\cf20 // partial sector: read-modify-write to preserve rest}\par
01269                     status = read_sector(sector_lba + sc, sector_buf);\par
01270                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} status; \}\par
01271                     kmemcpy(sector_buf, src, to_write);\par
01272                     kmemset((uint8_t*)sector_buf + to_write, 0, fs.bytes_per_sector - to_write);\par
01273                     status = write_sector(sector_lba + sc, sector_buf);\par
01274                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} status; \}\par
01275                 \}\par
01276                 {\cf19 else} \{\par
01277                     {\cf20 // full sector}\par
01278                     kmemcpy(sector_buf, src, fs.bytes_per_sector);\par
01279                     status = write_sector(sector_lba + sc, sector_buf);\par
01280                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(sector_buf); {\cf19 return} status; \}\par
01281                 \}\par
01282                 src += to_write;\par
01283                 bytes_left -= to_write;\par
01284             \}\par
01285             {\cf20 // advance to next cluster in chain}\par
01286             uint32_t next = fat32_read_fat(cur_cluster);\par
01287             {\cf19 if} (bytes_left == 0) {\cf19 break};\par
01288             {\cf19 if} (next >= FAT32_EOC_MIN) \{\par
01289                 {\cf20 // Shouldn't happen because we allocated enough clusters, but guard anyway}\par
01290                 MtFreeVirtualMemory(sector_buf);\par
01291                 {\cf19 return} MT_FAT32_CLUSTERS_FULL;\par
01292             \}\par
01293             cur_cluster = next;\par
01294         \}\par
01295 \par
01296         MtFreeVirtualMemory(sector_buf);\par
01297     \}\par
01298 \par
01299     {\cf20 // Step 6: Create and write directory entries (LFN + SFN)}\par
01300     {\cf20 // When file already existed -> update its SFN entry in-place (file_size + fst_clus)}\par
01301     {\cf20 // When file didn't exist -> create new LFN+SFN entries (as original impl)}\par
01302     {\cf18 char} sfn[11];\par
01303     format_short_name(filename, sfn); {\cf20 // Again, using simple SFN for now}\par
01304     uint8_t checksum = lfn_checksum((uint8_t*)sfn);\par
01305 \par
01306     uint32_t lfn_count = (kstrlen(filename) + 12) / 13;\par
01307     uint32_t total_entries = lfn_count + 1;\par
01308     FAT32_DIR_ENTRY entry_buf[total_entries];\par
01309 \par
01310     fat32_create_lfn_entries(entry_buf, filename, checksum);\par
01311 \par
01312     {\cf20 // Create the SFN entry at the end of the buffer}\par
01313     FAT32_DIR_ENTRY* sfn_entry = &entry_buf[lfn_count];\par
01314     kmemset(sfn_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01315     kmemcpy(sfn_entry->name, sfn, 11);\par
01316     sfn_entry->attr = 0; {\cf20 // Not a directory, archive bit can be set.}\par
01317     {\cf20 // set file size & first_cluster (first_cluster may be zero for size==0)}\par
01318     uint32_t final_size = size;\par
01319     {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists) final_size = existing_entry.file_size + size;\par
01320     sfn_entry->file_size = final_size;\par
01321     sfn_entry->fst_clus_lo = (uint16_t)first_cluster;\par
01322     sfn_entry->fst_clus_hi = (uint16_t)(first_cluster >> 16);\par
01323     TIME_ENTRY currTime = get_time();\par
01324     uint16_t fat32date = fat32_encode_date(currTime.year, currTime.month, currTime.day);\par
01325     uint16_t fat32time = fat32_encode_time(currTime.hour, currTime.minute, currTime.second);\par
01326     sfn_entry->wrt_date = fat32date;\par
01327     sfn_entry->wrt_time = fat32time;\par
01328     sfn_entry->crt_date = fat32date;\par
01329     sfn_entry->crt_time = fat32time;\par
01330     sfn_entry->lst_acc_date = fat32date;\par
01331 \par
01332     {\cf19 if} (exists && located) \{\par
01333         {\cf20 // Update existing on-disk SFN+LFN in-place: overwrite SFN fields + file_size + fst_clus (but preserve other fields).}\par
01334         {\cf18 void}* write_buf = MtAllocateVirtualMemory(512, 512);\par
01335         {\cf19 if} (!write_buf) {\cf19 return} MT_NO_MEMORY;\par
01336         status = read_sector(located_sector, write_buf);\par
01337         {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(write_buf); {\cf19 return} status; \}\par
01338 \par
01339         FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)write_buf;\par
01340         {\cf20 // The located_index is the start (LFN or SFN). We assumed read_lfn returned consumed entries for that start.}\par
01341         {\cf20 // If the located entry was an LFN chain, the SFN is at located_index + (located_consumed - 1)}\par
01342         uint32_t sfn_pos = located_index + (located_consumed ? (located_consumed - 1) : 0);\par
01343         {\cf20 // Update SFN's cluster and filesize}\par
01344         entries[sfn_pos].fst_clus_lo = (uint16_t)first_cluster;\par
01345         entries[sfn_pos].fst_clus_hi = (uint16_t)(first_cluster >> 16);\par
01346         entries[sfn_pos].file_size = final_size;\par
01347         fat32date = fat32_encode_date(currTime.year, currTime.month, currTime.day);\par
01348         fat32time = fat32_encode_time(currTime.hour, currTime.minute, currTime.second);\par
01349         entries[sfn_pos].wrt_date = fat32date;\par
01350         entries[sfn_pos].wrt_time = fat32time;\par
01351         entries[sfn_pos].crt_date = fat32date;\par
01352         entries[sfn_pos].crt_time = fat32time;\par
01353         entries[sfn_pos].lst_acc_date = fat32date;\par
01354 \par
01355         {\cf20 // If original file had no LFN and we're writing a long-name (lfn_count>0), we cannot expand in-place safely.}\par
01356         {\cf20 // In that case we fallback to find free slots and write a new LFN+SFN pair and mark old entries deleted.}\par
01357         {\cf18 bool} can_update_inplace = (lfn_count == 0) || (located_consumed == total_entries);\par
01358         {\cf19 if} (!can_update_inplace) \{\par
01359             {\cf20 // mark old consumed entries deleted (0xE5), then write new entries in free slots}\par
01360             {\cf19 for} (uint32_t k = 0; k < located_consumed; ++k) \{\par
01361                 ((uint8_t*)entries[located_index + k].name)[0] = DELETED_DIR_ENTRY;\par
01362             \}\par
01363             status = write_sector(located_sector, write_buf);\par
01364             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(write_buf); {\cf19 return} status; \}\par
01365             MtFreeVirtualMemory(write_buf);\par
01366 \par
01367             {\cf20 // find new free slots and write new entries (reuse original creation path)}\par
01368             uint32_t entry_sector, entry_index;\par
01369             {\cf19 if} (!fat32_find_free_dir_slots(parent_cluster, total_entries, &entry_sector, &entry_index)) \{\par
01370                 {\cf20 // cleanup clusters if we've allocated them}\par
01371                 {\cf19 return} MT_FAT32_DIR_FULL;\par
01372             \}\par
01373             {\cf18 void}* write_buf2 = MtAllocateVirtualMemory(512, 512);\par
01374             {\cf19 if} (!write_buf2) \{ {\cf19 return} MT_NO_MEMORY; \}\par
01375             status = read_sector(entry_sector, write_buf2);\par
01376             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(write_buf2); {\cf19 return} status; \}\par
01377             kmemcpy(&((FAT32_DIR_ENTRY*)write_buf2)[entry_index], entry_buf, total_entries * {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01378             status = write_sector(entry_sector, write_buf2);\par
01379             MtFreeVirtualMemory(write_buf2);\par
01380             {\cf19 return} status;\par
01381         \}\par
01382         {\cf19 else} \{\par
01383             {\cf20 // safe to update in-place: write sector}\par
01384             status = write_sector(located_sector, write_buf);\par
01385             MtFreeVirtualMemory(write_buf);\par
01386             {\cf19 return} status;\par
01387         \}\par
01388     \}\par
01389     {\cf19 else} \{\par
01390         {\cf20 // File did not exist: find space and write the entries (original flow)}\par
01391         uint32_t entry_sector, entry_index;\par
01392         {\cf19 if} (!fat32_find_free_dir_slots(parent_cluster, total_entries, &entry_sector, &entry_index)) \{\par
01393             {\cf20 // If we allocated new clusters earlier, free them (best effort)}\par
01394             {\cf19 if} (first_cluster) fat32_free_cluster_chain(first_cluster);\par
01395             {\cf19 return} MT_FAT32_DIR_FULL;\par
01396         \}\par
01397 \par
01398         {\cf18 void}* write_buf = MtAllocateVirtualMemory(512, 512);\par
01399         {\cf19 if} (!write_buf) {\cf19 return} MT_NO_MEMORY;\par
01400         status = read_sector(entry_sector, write_buf);\par
01401         {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(write_buf); {\cf19 return} status; \}\par
01402         kmemcpy(&((FAT32_DIR_ENTRY*)write_buf)[entry_index], entry_buf, total_entries * {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01403         status = write_sector(entry_sector, write_buf);\par
01404 \par
01405         {\cf20 // free write_buf}\par
01406         MtFreeVirtualMemory(write_buf);\par
01407         {\cf19 return} status;\par
01408     \}\par
01409 \par
01410     {\cf20 // Should not reach here}\par
01411     {\cf19 return} MT_GENERAL_FAILURE;\par
01412 \}\par
01413 \par
01414 MTSTATUS fat32_list_directory({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len) \{\par
01415     tracelast_func({\cf22 "fat32_list_directory"});\par
01416     MTSTATUS status;\par
01417     {\cf20 // 1. Find the directory entry for the given path to get its starting cluster.}\par
01418     FAT32_DIR_ENTRY dir_entry;\par
01419     {\cf19 if} (!fat32_find_entry(path, &dir_entry, NULL) || !(dir_entry.attr & ATTR_DIRECTORY)) \{\par
01420         gop_printf(0xFFFF0000, {\cf22 "Error: Directory not found or path is not a directory: %s\\n"}, path);\par
01421         {\cf19 return} MT_FAT32_DIRECTORY_NOT_FOUND;\par
01422     \}\par
01423 \par
01424     uint32_t cluster = (uint32_t)((dir_entry.fst_clus_hi << 16) | dir_entry.fst_clus_lo);\par
01425     {\cf19 if} (cluster == 0) \{ {\cf20 // Root directory special case on some FAT16/12, but for FAT32 it should be root_cluster.}\par
01426         cluster = fs.root_cluster;\par
01427     \}\par
01428 \par
01429     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
01430     {\cf19 if} (!buf) {\cf19 return} MT_NO_MEMORY;\par
01431 \par
01432     {\cf19 if} (max_len > 0) listings[0] = {\cf23 '\\0'};\par
01433     {\cf18 size_t} used = 0;\par
01434 \par
01435     {\cf19 do} \{\par
01436         uint32_t sector = first_sector_of_cluster(cluster);\par
01437         {\cf18 bool} end_of_dir = {\cf17 false};\par
01438 \par
01439         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; ++i) \{\par
01440             status = read_sector(sector + i, buf);\par
01441             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} status; \}\par
01442 \par
01443             FAT32_DIR_ENTRY* dir = (FAT32_DIR_ENTRY*)buf;\par
01444             uint32_t entries = fs.bytes_per_sector / {\cf17 sizeof}(*dir);\par
01445 \par
01446             {\cf19 for} (uint32_t j = 0; j < entries; ) \{\par
01447                 FAT32_DIR_ENTRY* current_entry = &dir[j];\par
01448 \par
01449                 {\cf19 if} (current_entry->name[0] == END_OF_DIRECTORY) \{\par
01450                     end_of_dir = {\cf17 true};\par
01451                     {\cf19 break}; {\cf20 // stop scanning entries in this sector -> will break outer loops below}\par
01452                 \}\par
01453 \par
01454                 {\cf19 if} ((uint8_t)current_entry->name[0] == DELETED_DIR_ENTRY ||\par
01455                     (current_entry->name[0] == {\cf23 '.'} && (current_entry->name[1] == {\cf23 '\\0'} || current_entry->name[1] == {\cf23 '.'}))) \{\par
01456                     j++;\par
01457                     {\cf19 continue};\par
01458                 \}\par
01459 \par
01460                 {\cf18 char} lfn_name[MAX_LFN_LEN];\par
01461                 uint32_t consumed = 0;\par
01462                 FAT32_DIR_ENTRY* sfn_entry = read_lfn(current_entry, entries - j, lfn_name, &consumed);\par
01463                 {\cf18 char} line_buf[256];\par
01464                 {\cf19 if} (sfn_entry) \{\par
01465                     {\cf19 if} (sfn_entry->attr & ATTR_DIRECTORY) \{\par
01466                         ksnprintf(line_buf, {\cf17 sizeof}(line_buf), {\cf22 "<DIR>  %s\\n"}, lfn_name);\par
01467                     \}\par
01468                     {\cf19 else} \{\par
01469                         ksnprintf(line_buf, {\cf17 sizeof}(line_buf), {\cf22 "%s   (%u bytes)\\n"}, lfn_name, sfn_entry->file_size);\par
01470                     \}\par
01471                     {\cf20 // safe append: compute remaining and append up to remaining-1}\par
01472                     {\cf18 size_t} avail = (used < max_len) ? (max_len - used) : 0;\par
01473                     {\cf19 if} (avail > 1) \{\par
01474                         {\cf20 // write directly into listings+used}\par
01475                         ksnprintf(listings + used, avail, {\cf22 "%s"}, line_buf);\par
01476                         used = kstrlen(listings);\par
01477                     \}\par
01478                     j += consumed;\par
01479                 \}\par
01480                 {\cf19 else} \{\par
01481                     j++;\par
01482                 \}\par
01483             \}\par
01484 \par
01485             {\cf19 if} (end_of_dir) {\cf19 break};\par
01486         \}\par
01487 \par
01488         {\cf19 if} (end_of_dir) {\cf19 break};\par
01489 \par
01490         cluster = fat32_read_fat(cluster);\par
01491     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01492 \par
01493     MtFreeVirtualMemory(buf);\par
01494     {\cf19 return} MT_SUCCESS;\par
01495 \}\par
01496 \par
01497 {\cf20 // Check that a directory cluster contains only '.' and '..' (and deleted entries).}\par
01498 {\cf20 // Returns true if empty ,false if non-empty or error.}\par
01499 {\cf18 bool} fat32_directory_is_empty({\cf17 const} {\cf18 char}* path) \{\par
01500     tracelast_func({\cf22 "fat32_directory_is_empty"});\par
01501 \par
01502     FAT32_DIR_ENTRY entry;\par
01503     uint32_t parent_cluster = 0;\par
01504     fat32_find_entry(path, &entry, &parent_cluster);\par
01505 \par
01506     uint32_t dir_cluster = get_dir_cluster(&entry);\par
01507     {\cf19 if} (dir_cluster == 0) {\cf19 return} {\cf17 false};\par
01508 \par
01509     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
01510     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
01511 \par
01512     uint32_t cluster = dir_cluster;\par
01513     MTSTATUS status;\par
01514     {\cf19 do} \{\par
01515         uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01516         {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01517             status = read_sector(sector_lba + s, buf);\par
01518             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 false}; \}\par
01519 \par
01520             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01521             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01522 \par
01523             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01524                 uint8_t first = (uint8_t)entries[j].name[0];\par
01525 \par
01526                 {\cf19 if} (first == END_OF_DIRECTORY) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 true}; \} {\cf20 // no more entries}\par
01527                 {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01528 \par
01529                 {\cf20 // Build full name (LFN or SFN)}\par
01530                 {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
01531                 uint32_t consumed = 0;\par
01532                 FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_buf, &consumed);\par
01533                 {\cf19 if} (!sfn) \{ j++; {\cf19 continue}; \}\par
01534 \par
01535                 {\cf20 // skip '.' and '..'}\par
01536                 {\cf19 if} (({\cf18 unsigned} {\cf18 char})sfn->name[0] == {\cf23 '.'}) \{\par
01537                     j += consumed;\par
01538                     {\cf19 continue};\par
01539                 \}\par
01540 \par
01541                 {\cf20 // There is a non-deleted entry that is not '.'/'..' -> directory not empty}\par
01542                 MtFreeVirtualMemory(buf);\par
01543                 {\cf19 return} {\cf17 false};\par
01544             \}\par
01545         \}\par
01546         cluster = fat32_read_fat(cluster);\par
01547     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01548 \par
01549     MtFreeVirtualMemory(buf);\par
01550     {\cf19 return} {\cf17 true};\par
01551 \}\par
01552 \par
01553 {\cf20 // Mark the SFN and all preceding LFN entries for `filename` in parent_cluster as deleted.}\par
01554 {\cf20 // `path` is the full path. parent_cluster is cluster of parent directory.}\par
01555 {\cf20 // Returns true on success (sector written), false otherwise.}\par
01556 {\cf17 static} {\cf18 bool} mark_entry_and_lfns_deleted({\cf17 const} {\cf18 char}* path, uint32_t parent_cluster) \{\par
01557     tracelast_func({\cf22 "mark_entry_and_lfns_deleted"});\par
01558     {\cf20 // extract filename (last component)}\par
01559     {\cf18 char} path_copy[260];\par
01560     kstrcpy(path_copy, path);\par
01561     {\cf18 int} len = (int)kstrlen(path_copy);\par
01562     {\cf20 // strip trailing slashes}\par
01563     {\cf19 while} (len > 1 && path_copy[len - 1] == {\cf23 '/'}) \{ path_copy[--len] = {\cf23 '\\0'}; \}\par
01564 \par
01565     {\cf18 int} last_slash = -1;\par
01566     {\cf19 for} ({\cf18 int} i = len - 1; i >= 0; --i) \{\par
01567         {\cf19 if} (path_copy[i] == {\cf23 '/'}) \{ last_slash = i; {\cf19 break}; \}\par
01568     \}\par
01569 \par
01570     {\cf17 const} {\cf18 char}* filename = (last_slash == -1) ? path_copy : &path_copy[last_slash + 1];\par
01571 \par
01572     {\cf20 // Prepare SFN format for short-name comparison}\par
01573     {\cf18 char} sfn_formatted[11];\par
01574     format_short_name(filename, sfn_formatted);\par
01575 \par
01576     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
01577     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
01578 \par
01579     uint32_t cluster = parent_cluster;\par
01580     MTSTATUS status;\par
01581     {\cf19 do} \{\par
01582         uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01583         {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01584             status = read_sector(sector_lba + s, buf);\par
01585             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 false}; \}\par
01586 \par
01587             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01588             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01589 \par
01590             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01591                 uint8_t first = (uint8_t)entries[j].name[0];\par
01592 \par
01593                 {\cf19 if} (first == END_OF_DIRECTORY) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 false}; \} {\cf20 // not found in parent}\par
01594                 {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01595 \par
01596                 {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
01597                 uint32_t consumed = 0;\par
01598                 FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_buf, &consumed);\par
01599 \par
01600                 {\cf19 if} (sfn) \{\par
01601                     {\cf20 // Match by LFN (exact), LFN (case-insensitive), or SFN bytes}\par
01602                     {\cf18 bool} match = {\cf17 false};\par
01603 \par
01604                     {\cf20 // 1) exact LFN match}\par
01605                     {\cf19 if} (kstrcmp(lfn_buf, filename) == 0) \{\par
01606                         match = {\cf17 true};\par
01607                     \}\par
01608 \par
01609                     {\cf20 // 2) case-insensitive LFN match}\par
01610                     {\cf19 if} (!match && ci_equal(lfn_buf, filename)) \{\par
01611                         match = {\cf17 true};\par
01612                     \}\par
01613 \par
01614                     {\cf20 // 3) SFN byte-wise compare (token formatted)}\par
01615                     {\cf19 if} (!match && cmp_short_name(sfn->name, sfn_formatted)) \{\par
01616                         match = {\cf17 true};\par
01617                     \}\par
01618 \par
01619                     {\cf19 if} (match) \{\par
01620                         {\cf20 // Mark all consumed entries (LFN...SFN) as deleted (0xE5)}\par
01621                         {\cf19 for} (uint32_t k = 0; k < consumed; ++k) \{\par
01622                             ((uint8_t*)entries[j + k].name)[0] = DELETED_DIR_ENTRY;\par
01623                         \}\par
01624 \par
01625                         {\cf20 // Write sector back to disk}\par
01626                         {\cf18 bool} ok = write_sector(sector_lba + s, buf);\par
01627                         MtFreeVirtualMemory(buf);\par
01628                         {\cf19 return} ok;\par
01629                     \}\par
01630 \par
01631                     j += consumed;\par
01632                     {\cf19 continue};\par
01633                 \}\par
01634                 {\cf19 else} \{\par
01635                     {\cf20 // read_lfn failed (corrupted LFN chain?), skip this entry}\par
01636                     j++;\par
01637                 \}\par
01638             \}\par
01639         \}\par
01640         cluster = fat32_read_fat(cluster);\par
01641     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01642 \par
01643     MtFreeVirtualMemory(buf);\par
01644     {\cf19 return} {\cf17 false}; {\cf20 // not found}\par
01645 \}\par
01646 \par
01647 \par
01648 {\cf20 // Recursively delete directory contents and free the directory's cluster chain.}\par
01649 {\cf20 // This function deletes all children (files & subdirs) found inside dir_cluster,}\par
01650 {\cf20 // marks their directory entries as DELETED on disk, and finally frees dir_cluster itself.}\par
01651 {\cf20 // Returns true on success, false on any error.}\par
01652 {\cf17 static} {\cf18 bool} fat32_rm_rf_dir(uint32_t dir_cluster) \{\par
01653     tracelast_func({\cf22 "fat32_rm_rf_dir"});\par
01654 \par
01655     {\cf19 if} (dir_cluster == 0 || dir_cluster == fs.root_cluster) {\cf19 return} {\cf17 false}; {\cf20 // never delete root here}\par
01656 \par
01657     {\cf18 void}* buf = MtAllocateVirtualMemory(512, 512);\par
01658     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
01659 \par
01660     uint32_t cluster = dir_cluster;\par
01661     {\cf20 // Iterate cluster chain}\par
01662     MTSTATUS status;\par
01663     {\cf19 while} (cluster < FAT32_EOC_MIN) \{\par
01664         uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01665 \par
01666         {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01667             status = read_sector(sector_lba + s, buf);\par
01668             {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 false}; \}\par
01669 \par
01670             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01671             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01672 \par
01673             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01674                 uint8_t first = (uint8_t)entries[j].name[0];\par
01675 \par
01676                 {\cf20 // End of directory: nothing after this in this directory}\par
01677                 {\cf19 if} (first == END_OF_DIRECTORY) \{\par
01678                     {\cf20 // we can stop scanning this directory entirely}\par
01679                     {\cf20 // free buffer and break out to free cluster chain}\par
01680                     MtFreeVirtualMemory(buf);\par
01681                     {\cf19 goto} free_and_return;\par
01682                 \}\par
01683 \par
01684                 {\cf20 // Deleted entry: skip}\par
01685                 {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01686 \par
01687                 {\cf20 // Attempt to read LFN + SFN at this position}\par
01688                 {\cf18 char} lfn_name[MAX_LFN_LEN];\par
01689                 uint32_t consumed = 0;\par
01690                 FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_name, &consumed);\par
01691 \par
01692                 {\cf19 if} (!sfn) \{\par
01693                     {\cf20 // corrupted chain or not an entry we can parse: skip single entry}\par
01694                     j++;\par
01695                     {\cf19 continue};\par
01696                 \}\par
01697 \par
01698                 {\cf20 // Skip '.' and '..' entries}\par
01699                 {\cf19 if} (({\cf18 unsigned} {\cf18 char})sfn->name[0] == {\cf23 '.'}) \{\par
01700                     j += consumed;\par
01701                     {\cf19 continue};\par
01702                 \}\par
01703 \par
01704                 {\cf20 // If directory -> recurse}\par
01705                 {\cf19 if} (sfn->attr & ATTR_DIRECTORY) \{\par
01706                     uint32_t child_cluster = get_dir_cluster(sfn);\par
01707                     {\cf19 if} (child_cluster != 0 && child_cluster != 1 && child_cluster != dir_cluster) \{\par
01708                         {\cf20 // Recursively delete child directory contents and free its clusters.}\par
01709                         {\cf19 if} (!fat32_rm_rf_dir(child_cluster)) \{\par
01710                             {\cf20 // recursion failed \'97 return false}\par
01711                             MtFreeVirtualMemory(buf);\par
01712                             {\cf19 return} {\cf17 false};\par
01713                         \}\par
01714                         {\cf20 // At this point child's clusters are freed by the recursive call.}\par
01715                     \}\par
01716                     {\cf20 // After child deleted, mark child's LFN+SFN entries as deleted in this parent sector}\par
01717                     {\cf19 for} (uint32_t k = 0; k < consumed; ++k) \{\par
01718                         ((uint8_t*)entries[j + k].name)[0] = DELETED_DIR_ENTRY;\par
01719                     \}\par
01720                     {\cf20 // write this sector back}\par
01721                     status = write_sector(sector_lba + s, buf);\par
01722                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 false}; \}\par
01723                     {\cf20 // advance past consumed entries}\par
01724                     j += consumed;\par
01725                     {\cf19 continue};\par
01726                 \}\par
01727                 {\cf19 else} \{\par
01728                     {\cf20 // It's a file: free its cluster chain (if any) then mark entries deleted}\par
01729                     uint32_t file_cluster = get_dir_cluster(sfn);\par
01730                     {\cf19 if} (file_cluster >= 2) \{\par
01731                         {\cf19 if} (!fat32_free_cluster_chain(file_cluster)) \{\par
01732                             MtFreeVirtualMemory(buf);\par
01733                             {\cf19 return} {\cf17 false};\par
01734                         \}\par
01735                     \}\par
01736                     {\cf20 // mark the LFN+SFN entries as deleted}\par
01737                     {\cf19 for} (uint32_t k = 0; k < consumed; ++k) \{\par
01738                         ((uint8_t*)entries[j + k].name)[0] = DELETED_DIR_ENTRY;\par
01739                     \}\par
01740                     {\cf20 // write sector back}\par
01741                     status = write_sector(sector_lba + s, buf);\par
01742                     {\cf19 if} (MT_FAILURE(status)) \{ MtFreeVirtualMemory(buf); {\cf19 return} {\cf17 false}; \}\par
01743                     j += consumed;\par
01744                     {\cf19 continue};\par
01745                 \}\par
01746             \} {\cf20 // for each entry in sector}\par
01747         \} {\cf20 // for each sector in cluster}\par
01748 \par
01749         cluster = fat32_read_fat(cluster);\par
01750     \} {\cf20 // while cluster chain}\par
01751 \par
01752 free_and_return:\par
01753     {\cf20 // Free this directory's own cluster chain (we deleted contents)}\par
01754     {\cf19 if} (!fat32_free_cluster_chain(dir_cluster)) \{\par
01755         {\cf20 // if freeing fails, we still consider it an error}\par
01756         {\cf19 return} {\cf17 false};\par
01757     \}\par
01758     {\cf19 return} {\cf17 true};\par
01759 \}\par
01760 \par
01761 MTSTATUS fat32_delete_directory({\cf17 const} {\cf18 char}* path) \{\par
01762     tracelast_func({\cf22 "fat32_delete_directory"});\par
01763 \par
01764     {\cf20 // Find entry & its parent cluster}\par
01765     FAT32_DIR_ENTRY entry;\par
01766     uint32_t parent_cluster;\par
01767     {\cf19 if} (!fat32_find_entry(path, &entry, &parent_cluster)) {\cf19 return} MT_FAT32_DIRECTORY_NOT_FOUND;\par
01768 \par
01769     {\cf20 // Must be a directory}\par
01770     {\cf19 if} (!(entry.attr & ATTR_DIRECTORY)) {\cf19 return} MT_FAT32_INVALID_FILENAME;\par
01771 \par
01772     uint32_t dir_cluster = get_dir_cluster(&entry);\par
01773     {\cf19 if} (dir_cluster == 0) dir_cluster = fs.root_cluster;\par
01774 \par
01775     {\cf20 // Don't allow removing root via this function}\par
01776     {\cf19 if} (dir_cluster == fs.root_cluster) {\cf19 return} MT_GENERAL_FAILURE;\par
01777 \par
01778     {\cf20 // Recursively delete children and free the directory's clusters.}\par
01779     {\cf19 if} (!fat32_rm_rf_dir(dir_cluster)) {\cf19 return} MT_GENERAL_FAILURE;\par
01780 \par
01781     {\cf20 // Now mark this directory's entry (LFN+SFN) in parent as deleted.}\par
01782     {\cf19 if} (!mark_entry_and_lfns_deleted(path, parent_cluster)) {\cf19 return} MT_GENERAL_FAILURE;\par
01783 \par
01784     {\cf19 return} MT_SUCCESS;\par
01785 \}\par
01786 \par
01787 {\cf17 static} {\cf17 inline} {\cf18 bool} is_file(FAT32_DIR_ENTRY* entry) \{\par
01788     uint8_t attr = entry->attr;\par
01789     {\cf19 if} ((attr & ATTR_LONG_NAME) == ATTR_LONG_NAME) {\cf19 return} {\cf17 false}; {\cf20 // skip LFN}\par
01790     {\cf19 if} (attr & ATTR_DIRECTORY) {\cf19 return} {\cf17 false}; {\cf20 // skip directories}\par
01791     {\cf19 return} {\cf17 true}; {\cf20 // it's a regular file}\par
01792 \}\par
01793 \par
01794 MTSTATUS fat32_delete_file({\cf17 const} {\cf18 char}* path) \{\par
01795     tracelast_func({\cf22 "fat32_delete_file"});\par
01796 \par
01797     {\cf20 // Find the file entry and its parent cluster}\par
01798     FAT32_DIR_ENTRY entry;\par
01799     uint32_t parent_cluster;\par
01800     {\cf19 if} (!fat32_find_entry(path, &entry, &parent_cluster)) \{\par
01801         {\cf19 return} MT_FAT32_DIRECTORY_NOT_FOUND; {\cf20 // File not found}\par
01802     \}\par
01803 \par
01804     {\cf20 // Must be a file (not a directory)}\par
01805     {\cf19 if} (!is_file(&entry)) \{\par
01806         {\cf19 return} MT_FAT32_INVALID_FILENAME; {\cf20 // Not a file}\par
01807     \}\par
01808 \par
01809     {\cf20 // Get the file's first cluster}\par
01810     uint32_t file_cluster = get_dir_cluster(&entry);\par
01811 \par
01812     {\cf20 // Free the file's cluster chain (if it has any clusters allocated)}\par
01813     {\cf19 if} (file_cluster >= 2 && file_cluster < FAT32_EOC_MIN) \{\par
01814         {\cf19 if} (!fat32_free_cluster_chain(file_cluster)) \{\par
01815             {\cf19 return} MT_GENERAL_FAILURE; {\cf20 // Failed to free cluster chain}\par
01816         \}\par
01817     \}\par
01818 \par
01819     {\cf20 // Mark the file's directory entry (LFN + SFN) as deleted in the parent directory}\par
01820     {\cf19 if} (!mark_entry_and_lfns_deleted(path, parent_cluster)) \{\par
01821         {\cf19 return} MT_GENERAL_FAILURE; {\cf20 // Failed to mark directory entries as deleted}\par
01822     \}\par
01823 \par
01824     {\cf19 return} MT_SUCCESS; {\cf20 // Success}\par
01825 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "../../drivers/gop/gop.h"}\par
{\f2 #include "../../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _FAT32_FSINFO}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b END_OF_DIRECTORY}\~ 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DELETED_DIR_ENTRY}\~ 0xE5\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_FAT_MASK}\~ 0x0FFFFFFFU\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_FREE_CLUSTER}\~ 0x00000000U\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_BAD_CLUSTER}\~ 0x0FFFFFF7U\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_EOC_MIN}\~ 0x0FFFFFF8U /* inclusive */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_EOC_MAX}\~ 0x0FFFFFFFU /* inclusive */\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _FAT32_FSINFO} {\b FAT32_FSINFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FAT32_ATTRIBUTES} {\b FAT32_ATTRIBUTES}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FAT32_ATTRIBUTES} \{ {\b ATTR_READ_ONLY} = 0x01
, {\b ATTR_HIDDEN} = 0x02
, {\b ATTR_SYSTEM} = 0x04
, {\b ATTR_VOLUME_ID} = 0x08
, {\b ATTR_DIRECTORY} = 0x10
, {\b ATTR_ARCHIVE} = 0x20
, {\b ATTR_LONG_NAME} = 0x0F
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __attribute__} ((packed)) _FAT32_BPB\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_init} (int disk_index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fat32_list_root} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_read_file} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_create_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_write_file} (const char *path, const void *data, uint32_t size, uint32_t file_modification_mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_list_directory} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_file} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fat32_directory_is_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FAT32_BPB}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FAT32_DIR_ENTRY}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DELETED_DIR_ENTRY\:fat32.h}
{\xe \v fat32.h\:DELETED_DIR_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DELETED_DIR_ENTRY\~ 0xE5}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b fat32.h}.}\par
}
{\xe \v END_OF_DIRECTORY\:fat32.h}
{\xe \v fat32.h\:END_OF_DIRECTORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define END_OF_DIRECTORY\~ 0x00}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_BAD_CLUSTER\:fat32.h}
{\xe \v fat32.h\:FAT32_BAD_CLUSTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_BAD_CLUSTER\~ 0x0FFFFFF7U}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_EOC_MAX\:fat32.h}
{\xe \v fat32.h\:FAT32_EOC_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_EOC_MAX\~ 0x0FFFFFFFU /* inclusive */}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_EOC_MIN\:fat32.h}
{\xe \v fat32.h\:FAT32_EOC_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_EOC_MIN\~ 0x0FFFFFF8U /* inclusive */}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_FAT_MASK\:fat32.h}
{\xe \v fat32.h\:FAT32_FAT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_FAT_MASK\~ 0x0FFFFFFFU}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_FREE_CLUSTER\:fat32.h}
{\xe \v fat32.h\:FAT32_FREE_CLUSTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_FREE_CLUSTER\~ 0x00000000U}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FAT32_ATTRIBUTES\:fat32.h}
{\xe \v fat32.h\:FAT32_ATTRIBUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FAT32_ATTRIBUTES} {\b FAT32_ATTRIBUTES}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FAT32_FSINFO\:fat32.h}
{\xe \v fat32.h\:FAT32_FSINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _FAT32_FSINFO} {\b FAT32_FSINFO}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FAT32_ATTRIBUTES\:fat32.h}
{\xe \v fat32.h\:_FAT32_ATTRIBUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FAT32_ATTRIBUTES}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ATTR_READ_ONLY\:fat32.h}
{\xe \v fat32.h\:ATTR_READ_ONLY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_READ_ONLY{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
\cell }{\cell }{\row }
{\xe \v ATTR_HIDDEN\:fat32.h}
{\xe \v fat32.h\:ATTR_HIDDEN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_HIDDEN{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
\cell }{\cell }{\row }
{\xe \v ATTR_SYSTEM\:fat32.h}
{\xe \v fat32.h\:ATTR_SYSTEM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_SYSTEM{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
\cell }{\cell }{\row }
{\xe \v ATTR_VOLUME_ID\:fat32.h}
{\xe \v fat32.h\:ATTR_VOLUME_ID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_VOLUME_ID{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
\cell }{\cell }{\row }
{\xe \v ATTR_DIRECTORY\:fat32.h}
{\xe \v fat32.h\:ATTR_DIRECTORY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_DIRECTORY{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
\cell }{\cell }{\row }
{\xe \v ATTR_ARCHIVE\:fat32.h}
{\xe \v fat32.h\:ATTR_ARCHIVE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_ARCHIVE{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
\cell }{\cell }{\row }
{\xe \v ATTR_LONG_NAME\:fat32.h}
{\xe \v fat32.h\:ATTR_LONG_NAME}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_LONG_NAME{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 99} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:fat32.h}
{\xe \v fat32.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b fat32.h}.}\par
}
{\xe \v fat32_create_directory\:fat32.h}
{\xe \v fat32.h\:fat32_create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_create_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 836} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_directory\:fat32.h}
{\xe \v fat32.h\:fat32_delete_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1761} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_file\:fat32.h}
{\xe \v fat32.h\:fat32_delete_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_file (const char * path)}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1794} of file {\b fat32.c}.}\par
}
{\xe \v fat32_directory_is_empty\:fat32.h}
{\xe \v fat32.h\:fat32_directory_is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool fat32_directory_is_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 1499} of file {\b fat32.c}.}\par
}
{\xe \v fat32_init\:fat32.h}
{\xe \v fat32.h\:fat32_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_init (int disk_index)}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 531} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_directory\:fat32.h}
{\xe \v fat32.h\:fat32_list_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_list_directory (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1414} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_root\:fat32.h}
{\xe \v fat32.h\:fat32_list_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fat32_list_root (void )}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 557} of file {\b fat32.c}.}\par
}
{\xe \v fat32_read_file\:fat32.h}
{\xe \v fat32.h\:fat32_read_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_read_file (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 709} of file {\b fat32.c}.}\par
}
{\xe \v fat32_write_file\:fat32.h}
{\xe \v fat32.h\:fat32_write_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_write_file (const char * path, const void * data, uint32_t size, uint32_t file_modification_mode)}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_modification_mode} \cell }{Whether to APPEND or REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1001} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v FAT32_BPB\:fat32.h}
{\xe \v fat32.h\:FAT32_BPB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FAT32_BPB}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_DIR_ENTRY\:fat32.h}
{\xe \v fat32.h\:FAT32_DIR_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FAT32_DIR_ENTRY}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b fat32.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fat32.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     FAT32 FileSystem Headers.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_KERNEL_FILESYSTEM_FAT32_HEADER}\par
00008 {\cf21 #define X86_KERNEL_FILESYSTEM_FAT32_HEADER}\par
00009  {\cf20 // Standard headers, required.}\par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stdint.h>}\par
00013 {\cf21 #include "../../trace.h"}\par
00014 {\cf21 #include "../../drivers/gop/gop.h"}\par
00015 {\cf21 #include "../../mtstatus.h"}\par
00016 \par
00017 {\cf21 #define END_OF_DIRECTORY 0x00}\par
00018 {\cf21 #define DELETED_DIR_ENTRY 0xE5}\par
00019 \par
00020 \par
00021 {\cf21 #define FAT32_FAT_MASK        0x0FFFFFFFU}\par
00022 {\cf21 #define FAT32_FREE_CLUSTER    0x00000000U}\par
00023 {\cf21 #define FAT32_BAD_CLUSTER     0x0FFFFFF7U}\par
00024 {\cf21 #define FAT32_EOC_MIN         0x0FFFFFF8U }{\cf20 /* inclusive */}{\cf21 }\par
00025 {\cf21 #define FAT32_EOC_MAX         0x0FFFFFFFU }{\cf20 /* inclusive */}{\cf21 }\par
00026 \par
00027 \par
00028 \par
00029 {\cf21 #ifdef _MSC_VER}\par
00030 {\cf21 #pragma pack(push, 1)}\par
00031 {\cf17 typedef} {\cf17 struct }_FAT32_BPB \{\par
00032 {\cf21 #else}\par
00033 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _FAT32_BPB \{\par
00034 {\cf21 #endif}\par
00035     uint8_t jump[3];\par
00036     uint8_t oem[8];\par
00037     uint16_t bytes_per_sector;\par
00038     uint8_t sectors_per_cluster;\par
00039     uint16_t reserved_sector_count;\par
00040     uint8_t num_fats;\par
00041     uint16_t root_entry_count;\par
00042     uint16_t total_sectors_16;\par
00043     uint8_t media;\par
00044     uint16_t fat_size_16;\par
00045     uint16_t sectors_per_track;\par
00046     uint16_t num_heads;\par
00047     uint32_t hidden_sectors;\par
00048     uint32_t total_sectors_32;\par
00049     uint32_t fat_size_32;\par
00050     uint16_t ext_flags;\par
00051     uint16_t fs_version;\par
00052     uint32_t root_cluster;\par
00053     uint16_t fs_info_sector;\par
00054     uint16_t backup_root_sector;\par
00055 \} FAT32_BPB;\par
00056 {\cf21 #ifdef _MSC_VER}\par
00057 {\cf21 #pragma pack(pop)}\par
00058 {\cf21 #endif}\par
00059 \par
00060 {\cf21 #ifdef _MSC_VER}\par
00061 {\cf21 #pragma pack(push, 1)}\par
00062 {\cf17 typedef} {\cf17 struct }_FAT32_DIR_ENTRY \{\par
00063 {\cf21 #else}\par
00064 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _FAT32_DIR_ENTRY \{\par
00065 {\cf21 #endif}\par
00066     {\cf18 char} name[11];\par
00067     uint8_t attr;\par
00068     uint8_t nt_res;\par
00069     uint8_t crt_time_tenth;\par
00070     uint16_t crt_time;\par
00071     uint16_t crt_date;\par
00072     uint16_t lst_acc_date;\par
00073     uint16_t fst_clus_hi;\par
00074     uint16_t wrt_time;\par
00075     uint16_t wrt_date;\par
00076     uint16_t fst_clus_lo;\par
00077     uint32_t file_size;\par
00078 \} FAT32_DIR_ENTRY;\par
00079 {\cf21 #ifdef _MSC_VER}\par
00080 {\cf21 #pragma pack(pop)}\par
00081 {\cf21 #endif}\par
00082 \par
00083 {\cf17 typedef} {\cf17 struct }_FAT32_FSINFO \{\par
00084     uint32_t first_data_sector;\par
00085     uint32_t root_cluster;\par
00086     uint32_t sectors_per_fat;\par
00087     uint32_t bytes_per_sector;\par
00088     uint32_t sectors_per_cluster;\par
00089     uint32_t fat_start;\par
00090     uint16_t reserved_sector_count;\par
00091 \} FAT32_FSINFO;\par
00092 \par
00093 {\cf20 // Initialize a FAT32 FileSystem on a given block device.}\par
00094 MTSTATUS fat32_init({\cf18 int} disk_index);\par
00095 \par
00096 {\cf20 // List files in root dir}\par
00097 {\cf18 void} fat32_list_root({\cf18 void});\par
00098 \par
00099 {\cf17 typedef} {\cf17 enum} _FAT32_ATTRIBUTES \{\par
00100     ATTR_READ_ONLY = 0x01,  {\cf20 // File is read-only}\par
00101     ATTR_HIDDEN = 0x02,  {\cf20 // File is hidden}\par
00102     ATTR_SYSTEM = 0x04,  {\cf20 // System file}\par
00103     ATTR_VOLUME_ID = 0x08,  {\cf20 // Volume label}\par
00104     ATTR_DIRECTORY = 0x10,  {\cf20 // Entry is a directory}\par
00105     ATTR_ARCHIVE = 0x20,  {\cf20 // File should be archived}\par
00106     {\cf20 // Special combination values}\par
00107     ATTR_LONG_NAME = 0x0F,  {\cf20 // Long File Name entry (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID)}\par
00108 \} FAT32_ATTRIBUTES;\par
00109 \par
00110 {\cf17 static} {\cf17 inline} uint16_t fat32_encode_date(uint16_t year, uint8_t month, uint8_t day) \{\par
00111     {\cf20 // FAT date: YYYYYYYMMMMDDDDD (since 1980)}\par
00112     {\cf19 return} ((year - 1980) << 9) | (month << 5) | (day);\par
00113 \}\par
00114 \par
00115 {\cf17 static} {\cf17 inline} uint16_t fat32_encode_time(uint8_t hour, uint8_t min, uint8_t sec) \{\par
00116     {\cf20 // FAT time: HHHHHMMMMMMSSSSS (seconds / 2)}\par
00117     {\cf19 return} (hour << 11) | (min << 5) | (sec / 2);\par
00118 \}\par
00119 \par
00120 {\cf17 static} {\cf17 inline} {\cf18 void} fat32_decode_date(uint16_t date, uint16_t* year, uint8_t* month, uint8_t* day) \{\par
00121     *year = 1980 + ((date >> 9) & 0x7F); {\cf20 // 7 bits for year}\par
00122     *month = (date >> 5) & 0x0F;          {\cf20 // 4 bits for month}\par
00123     *day = date & 0x1F;                 {\cf20 // 5 bits for day}\par
00124 \}\par
00125 \par
00126 {\cf17 static} {\cf17 inline} {\cf18 void} fat32_decode_time(uint16_t time, uint8_t* hour, uint8_t* min, uint8_t* sec) \{\par
00127     *hour = (time >> 11) & 0x1F;          {\cf20 // 5 bits for hours}\par
00128     *min = (time >> 5) & 0x3F;           {\cf20 // 6 bits for minutes}\par
00129     *sec = (time & 0x1F) * 2;            {\cf20 // 5 bits for seconds (2-second resolution)}\par
00130 \}\par
00131 \par
00139 MTSTATUS fat32_read_file({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out);\par
00140 \par
00146 MTSTATUS fat32_create_directory({\cf17 const} {\cf18 char}* path);\par
00147 \par
00156 MTSTATUS fat32_write_file({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, uint32_t file_modification_mode);\par
00157 \par
00165 MTSTATUS fat32_list_directory({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len);\par
00166 \par
00172 MTSTATUS fat32_delete_directory({\cf17 const} {\cf18 char}* path);\par
00173 \par
00179 MTSTATUS fat32_delete_file({\cf17 const} {\cf18 char}* path);\par
00180 \par
00186 {\cf18 bool} fat32_directory_is_empty({\cf17 const} {\cf18 char}* path);\par
00187 \par
00188 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "vfs.h"}\par
{\f2 #include "../../drivers/ahci/ahci.h"}\par
{\f2 #include "../fat32/fat32.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MOUNTED_FS}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MOUNTS}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAIN_FS_DEVICE}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct MOUNTED_FS {\b MOUNTED_FS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_read} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_write} (const char *path, const void *data, uint32_t size, {\b FS_WRITE_MODES} write_mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_delete} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_listdir} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_mkdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_rmdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vfs_is_dir_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vfs_listrootdir} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FS_DRIVER} {\b fat32_driver}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAIN_FS_DEVICE\:vfs.c}
{\xe \v vfs.c\:MAIN_FS_DEVICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAIN_FS_DEVICE\~ 0}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b vfs.c}.}\par
}
{\xe \v MAX_MOUNTS\:vfs.c}
{\xe \v vfs.c\:MAX_MOUNTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MOUNTS\~ 4}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v MOUNTED_FS\:vfs.c}
{\xe \v vfs.c\:MOUNTED_FS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct MOUNTED_FS MOUNTED_FS}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vfs_delete\:vfs.c}
{\xe \v vfs.c\:vfs_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_delete (const char * path)}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 94} of file {\b vfs.c}.}\par
}
{\xe \v vfs_init\:vfs.c}
{\xe \v vfs.c\:vfs_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_init (void )}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 41} of file {\b vfs.c}.}\par
}
{\xe \v vfs_is_dir_empty\:vfs.c}
{\xe \v vfs.c\:vfs_is_dir_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool vfs_is_dir_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 122} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listdir\:vfs.c}
{\xe \v vfs.c\:vfs_listdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_listdir (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 101} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listrootdir\:vfs.c}
{\xe \v vfs.c\:vfs_listrootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vfs_listrootdir (void )}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }}\par
{
Definition at line {\b 129} of file {\b vfs.c}.}\par
}
{\xe \v vfs_mkdir\:vfs.c}
{\xe \v vfs.c\:vfs_mkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_mkdir (const char * path)}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 108} of file {\b vfs.c}.}\par
}
{\xe \v vfs_read\:vfs.c}
{\xe \v vfs.c\:vfs_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_read (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 80} of file {\b vfs.c}.}\par
}
{\xe \v vfs_rmdir\:vfs.c}
{\xe \v vfs.c\:vfs_rmdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_rmdir (const char * path)}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 115} of file {\b vfs.c}.}\par
}
{\xe \v vfs_write\:vfs.c}
{\xe \v vfs.c\:vfs_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_write (const char * path, const void * data, uint32_t size, {\b FS_WRITE_MODES} write_mode)}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i write_mode} \cell }{Whether to APPEND or CREATE/REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 87} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v fat32_driver\:vfs.c}
{\xe \v vfs.c\:fat32_driver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FS_DRIVER} fat32_driver}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .init = fat32_fs_init,\par
    .read = fat32_read_file,\par
    .write = fat32_write_file,\par
    .delete = fat32_delete_file,\par
    .listdir = fat32_list_directory,\par
    .mkdir = fat32_create_directory,\par
    .rmdir = fat32_delete_directory,\par
    .is_dir_empty = fat32_directory_is_empty,\par
    .listrootdir = fat32_list_root,\par
\}\par
}
{
Definition at line {\b 29} of file {\b vfs.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vfs.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Virtual File System (VFS) Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "vfs.h"}\par
00008 \par
00009 {\cf21 #include "../../drivers/ahci/ahci.h"}\par
00010 {\cf21 #include "../fat32/fat32.h"}\par
00011 \par
00012 {\cf17 typedef} {\cf17 struct }MOUNTED_FS \{\par
00013     FS_DRIVER* driver;\par
00014     uint8_t device_id;\par
00015     {\cf17 const} {\cf18 char}* mount_point;  {\cf20 // e.g., "/", "/ext2"}\par
00016 \} MOUNTED_FS;\par
00017 \par
00018 {\cf21 #define MAX_MOUNTS 4}\par
00019 {\cf17 static} MOUNTED_FS mounted_fs[MAX_MOUNTS];\par
00020 {\cf17 static} uint8_t mount_count = 0;\par
00021 \par
00022 {\cf21 #define MAIN_FS_DEVICE 0}\par
00023 \par
00024 {\cf20 // Adapter for VFS FS_DRIVER}\par
00025 {\cf17 static} MTSTATUS fat32_fs_init(uint8_t device_id) \{\par
00026     {\cf19 return} fat32_init(device_id);\par
00027 \}\par
00028 \par
00029 FS_DRIVER fat32_driver = \{\par
00030     .init = fat32_fs_init,\par
00031     .read = fat32_read_file,\par
00032     .write = fat32_write_file,\par
00033     .delete = fat32_delete_file,\par
00034     .listdir = fat32_list_directory,\par
00035     .mkdir = fat32_create_directory,\par
00036     .rmdir = fat32_delete_directory,\par
00037     .is_dir_empty = fat32_directory_is_empty,\par
00038     .listrootdir = fat32_list_root,\par
00039 \};\par
00040 \par
00041 MTSTATUS vfs_init({\cf18 void}) \{\par
00042     {\cf20 // First initialize other FS Related stuff (FAT32, AHCI, etc..)}\par
00043     MTSTATUS status = ahci_init();\par
00044     {\cf19 if} (MT_FAILURE(status)) {\cf19 return} status;\par
00045 \par
00046     {\cf20 // Mount FAT32 on MAIN_FS_DEVICE}\par
00047     status = fat32_driver.init(MAIN_FS_DEVICE);\par
00048     {\cf19 if} (MT_FAILURE(status)) {\cf19 return} status;\par
00049 \par
00050     mounted_fs[mount_count++] = (MOUNTED_FS)\{ .driver = &fat32_driver, .device_id = MAIN_FS_DEVICE, .mount_point = {\cf22 "/"} \};\par
00051 \par
00052     {\cf19 return} MT_SUCCESS;\par
00053 \}\par
00054 \par
00055 {\cf17 static} MOUNTED_FS* vfs_find_fs_for_path({\cf17 const} {\cf18 char}* path) \{\par
00056     {\cf19 if} (!path) {\cf19 return} NULL;\par
00057     {\cf19 for} (uint8_t i = 0; i < mount_count; i++) \{\par
00058         {\cf17 const} {\cf18 char}* mount = mounted_fs[i].mount_point;\par
00059         {\cf20 // root mount should match anything}\par
00060         {\cf19 if} (mount[0] == {\cf23 '/'} && mount[1] == {\cf23 '\\0'}) {\cf19 return} &mounted_fs[i];\par
00061 \par
00062         {\cf20 // compute mount_len}\par
00063         {\cf18 size_t} mount_len = 0;\par
00064         {\cf19 while} (mount[mount_len]) mount_len++;\par
00065 \par
00066         {\cf20 // path must be at least mount_len}\par
00067         {\cf18 size_t} path_len = 0;\par
00068         {\cf19 while} (path[path_len]) path_len++;\par
00069         {\cf19 if} (path_len < mount_len) {\cf19 continue};\par
00070 \par
00071         {\cf18 bool} match = {\cf17 true};\par
00072         {\cf19 for} ({\cf18 size_t} j = 0; j < mount_len; j++) \{\par
00073             {\cf19 if} (path[j] != mount[j]) \{ match = {\cf17 false}; {\cf19 break}; \}\par
00074         \}\par
00075         {\cf19 if} (match) {\cf19 return} &mounted_fs[i];\par
00076     \}\par
00077     {\cf19 return} NULL;\par
00078 \}\par
00079 \par
00080 MTSTATUS vfs_read({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out) \{\par
00081     MOUNTED_FS* fs = vfs_find_fs_for_path(filename);\par
00082     {\cf19 if} (!fs || !fs->driver || !fs->driver->read) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00083 \par
00084     {\cf19 return} fs->driver->read(filename, file_size_out, buffer_out);\par
00085 \}\par
00086 \par
00087 MTSTATUS vfs_write({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, FS_WRITE_MODES write_mode) \{\par
00088     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00089     {\cf19 if} (!fs || !fs->driver || !fs->driver->write) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00090 \par
00091     {\cf19 return} fs->driver->write(path, data, size, (uint32_t)write_mode);\par
00092 \}\par
00093 \par
00094 MTSTATUS vfs_delete({\cf17 const} {\cf18 char}* path) \{\par
00095     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00096     {\cf19 if} (!fs || !fs->driver || !fs->driver->delete) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00097 \par
00098     {\cf19 return} fs->driver->delete(path);\par
00099 \}\par
00100 \par
00101 MTSTATUS vfs_listdir({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len) \{\par
00102     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00103     {\cf19 if} (!fs || !fs->driver || !fs->driver->listdir) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00104 \par
00105     {\cf19 return} fs->driver->listdir(path, listings, max_len);\par
00106 \}\par
00107 \par
00108 MTSTATUS vfs_mkdir({\cf17 const} {\cf18 char}* path) \{\par
00109     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00110     {\cf19 if} (!fs || !fs->driver || !fs->driver->mkdir) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00111 \par
00112     {\cf19 return} fs->driver->mkdir(path);\par
00113 \}\par
00114 \par
00115 MTSTATUS vfs_rmdir({\cf17 const} {\cf18 char}* path) \{\par
00116     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00117     {\cf19 if} (!fs || !fs->driver || !fs->driver->rmdir) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00118 \par
00119     {\cf19 return} fs->driver->rmdir(path);\par
00120 \}\par
00121 \par
00122 {\cf18 bool} vfs_is_dir_empty({\cf17 const} {\cf18 char}* path) \{\par
00123     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00124     {\cf19 if} (!fs || !fs->driver || !fs->driver->is_dir_empty) {\cf19 return} {\cf17 false};\par
00125 \par
00126     {\cf19 return} fs->driver->is_dir_empty(path);\par
00127 \}\par
00128 \par
00129 {\cf18 void} vfs_listrootdir({\cf18 void}) \{\par
00130     MOUNTED_FS* fs = vfs_find_fs_for_path({\cf22 "/"});\par
00131     {\cf19 if} (!fs || !fs->driver || !fs->driver->listrootdir) {\cf19 return};\par
00132 \par
00133     fs->driver->listrootdir();\par
00134     {\cf19 return};\par
00135 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../fat32/fat32.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b FS_DRIVER}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FS_WRITE_MODES} {\b FS_WRITE_MODES}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct FS_DRIVER {\b FS_DRIVER}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FS_WRITE_MODES} \{ {\b WRITE_MODE_APPEND_EXISTING}
, {\b WRITE_MODE_CREATE_OR_REPLACE}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_read} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_write} (const char *path, const void *data, uint32_t size, {\b FS_WRITE_MODES} write_mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_delete} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_listdir} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_mkdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_rmdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vfs_is_dir_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vfs_listrootdir} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FS_DRIVER\:vfs.h}
{\xe \v vfs.h\:FS_DRIVER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct FS_DRIVER FS_DRIVER}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FS_WRITE_MODES\:vfs.h}
{\xe \v vfs.h\:FS_WRITE_MODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FS_WRITE_MODES} {\b FS_WRITE_MODES}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FS_WRITE_MODES\:vfs.h}
{\xe \v vfs.h\:_FS_WRITE_MODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FS_WRITE_MODES}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v WRITE_MODE_APPEND_EXISTING\:vfs.h}
{\xe \v vfs.h\:WRITE_MODE_APPEND_EXISTING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid WRITE_MODE_APPEND_EXISTING{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
\cell }{\cell }{\row }
{\xe \v WRITE_MODE_CREATE_OR_REPLACE\:vfs.h}
{\xe \v vfs.h\:WRITE_MODE_CREATE_OR_REPLACE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid WRITE_MODE_CREATE_OR_REPLACE{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 13} of file {\b vfs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vfs_delete\:vfs.h}
{\xe \v vfs.h\:vfs_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_delete (const char * path)}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 94} of file {\b vfs.c}.}\par
}
{\xe \v vfs_init\:vfs.h}
{\xe \v vfs.h\:vfs_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_init (void )}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 41} of file {\b vfs.c}.}\par
}
{\xe \v vfs_is_dir_empty\:vfs.h}
{\xe \v vfs.h\:vfs_is_dir_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool vfs_is_dir_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 122} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listdir\:vfs.h}
{\xe \v vfs.h\:vfs_listdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_listdir (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 101} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listrootdir\:vfs.h}
{\xe \v vfs.h\:vfs_listrootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vfs_listrootdir (void )}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }}\par
{
Definition at line {\b 129} of file {\b vfs.c}.}\par
}
{\xe \v vfs_mkdir\:vfs.h}
{\xe \v vfs.h\:vfs_mkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_mkdir (const char * path)}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 108} of file {\b vfs.c}.}\par
}
{\xe \v vfs_read\:vfs.h}
{\xe \v vfs.h\:vfs_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_read (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 80} of file {\b vfs.c}.}\par
}
{\xe \v vfs_rmdir\:vfs.h}
{\xe \v vfs.h\:vfs_rmdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_rmdir (const char * path)}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 115} of file {\b vfs.c}.}\par
}
{\xe \v vfs_write\:vfs.h}
{\xe \v vfs.h\:vfs_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_write (const char * path, const void * data, uint32_t size, {\b FS_WRITE_MODES} write_mode)}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i write_mode} \cell }{Whether to APPEND or CREATE/REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 87} of file {\b vfs.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vfs.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Virtual File System (VFS) Header Functions & Structures.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_VFS_H}\par
00008 {\cf21 #define X86_VFS_H}\par
00009 \par
00010 {\cf20 // Include the FAT32 Header.}\par
00011 {\cf21 #include "../fat32/fat32.h"}\par
00012 \par
00013 {\cf17 typedef} {\cf17 enum} _FS_WRITE_MODES \{\par
00014     WRITE_MODE_APPEND_EXISTING,\par
00015     WRITE_MODE_CREATE_OR_REPLACE,\par
00016 \} FS_WRITE_MODES;\par
00017 \par
00018 {\cf17 typedef} {\cf17 struct }FS_DRIVER \{\par
00019     MTSTATUS(*init)(uint8_t device_id);\par
00020     MTSTATUS(*read)({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out);\par
00021     MTSTATUS(*write)({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, uint32_t mode);\par
00022     MTSTATUS(*{\cf17 delete})({\cf17 const} {\cf18 char}* path);\par
00023     MTSTATUS(*mkdir)({\cf17 const} {\cf18 char}* path);\par
00024     MTSTATUS(*rmdir)({\cf17 const} {\cf18 char}* path);\par
00025     bool(*is_dir_empty)({\cf17 const} {\cf18 char}* path);\par
00026     MTSTATUS(*listdir)({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len);\par
00027     void(*listrootdir)(void);\par
00028 \} FS_DRIVER;\par
00029 \par
00034 MTSTATUS vfs_init({\cf18 void});\par
00035 \par
00043 MTSTATUS vfs_read({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out);\par
00044 \par
00053 MTSTATUS vfs_write({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, FS_WRITE_MODES write_mode);\par
00054 \par
00060 MTSTATUS vfs_delete({\cf17 const} {\cf18 char}* path);\par
00061 \par
00069 MTSTATUS vfs_listdir({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len);\par
00070 \par
00076 MTSTATUS vfs_mkdir({\cf17 const} {\cf18 char}* path);\par
00077 \par
00083 MTSTATUS vfs_rmdir({\cf17 const} {\cf18 char}* path);\par
00084 \par
00090 {\cf18 bool} vfs_is_dir_empty({\cf17 const} {\cf18 char}* path);\par
00091 \par
00095 {\cf18 void} vfs_listrootdir({\cf18 void});\par
00096 \par
00097 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.c}
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "handlers.h"}\par
{\f2 #include "scancodes.h"}\par
{\f2 #include "../idt.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_keyboard} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b keyboard_handler} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_timer} (unsigned long int frequency)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b timer_handler} (bool schedulerEnabled)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_handler} (bool schedulerEnabled)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pagefault_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doublefault_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dividebyzero_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debugsinglestep_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nmi_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b breakpoint_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b overflow_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b boundscheck_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidopcode_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nocoprocessor_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coprocessor_segment_overrun_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidtss_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b segment_selector_not_present_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stack_segment_overrun_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpf_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fpu_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b alignment_check_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b severe_machine_check_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b shift_pressed} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ctrl_pressed} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b caps_lock_on} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b extended_scancode} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b schedule_pending}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alignment_check_handler\:handlers.c}
{\xe \v handlers.c\:alignment_check_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void alignment_check_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b handlers.c}.}\par
}
{\xe \v boundscheck_handler\:handlers.c}
{\xe \v handlers.c\:boundscheck_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void boundscheck_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b handlers.c}.}\par
}
{\xe \v breakpoint_handler\:handlers.c}
{\xe \v handlers.c\:breakpoint_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void breakpoint_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b handlers.c}.}\par
}
{\xe \v coprocessor_segment_overrun_handler\:handlers.c}
{\xe \v handlers.c\:coprocessor_segment_overrun_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void coprocessor_segment_overrun_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b handlers.c}.}\par
}
{\xe \v debugsinglestep_handler\:handlers.c}
{\xe \v handlers.c\:debugsinglestep_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debugsinglestep_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b handlers.c}.}\par
}
{\xe \v dividebyzero_handler\:handlers.c}
{\xe \v handlers.c\:dividebyzero_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dividebyzero_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b handlers.c}.}\par
}
{\xe \v doublefault_handler\:handlers.c}
{\xe \v handlers.c\:doublefault_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doublefault_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b handlers.c}.}\par
}
{\xe \v fpu_handler\:handlers.c}
{\xe \v handlers.c\:fpu_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fpu_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 272} of file {\b handlers.c}.}\par
}
{\xe \v gpf_handler\:handlers.c}
{\xe \v handlers.c\:gpf_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpf_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 267} of file {\b handlers.c}.}\par
}
{\xe \v init_keyboard\:handlers.c}
{\xe \v handlers.c\:init_keyboard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_keyboard (void )}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b handlers.c}.}\par
}
{\xe \v init_timer\:handlers.c}
{\xe \v handlers.c\:init_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_timer (unsigned long int frequency)}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b handlers.c}.}\par
}
{\xe \v invalidopcode_handler\:handlers.c}
{\xe \v handlers.c\:invalidopcode_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidopcode_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 235} of file {\b handlers.c}.}\par
}
{\xe \v invalidtss_handler\:handlers.c}
{\xe \v handlers.c\:invalidtss_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidtss_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b handlers.c}.}\par
}
{\xe \v keyboard_handler\:handlers.c}
{\xe \v handlers.c\:keyboard_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void keyboard_handler (void )}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b handlers.c}.}\par
}
{\xe \v lapic_eoi\:handlers.c}
{\xe \v handlers.c\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b apic.c}.}\par
}
{\xe \v lapic_handler\:handlers.c}
{\xe \v handlers.c\:lapic_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_handler (bool schedulerEnabled)}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b handlers.c}.}\par
}
{\xe \v nmi_handler\:handlers.c}
{\xe \v handlers.c\:nmi_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nmi_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b handlers.c}.}\par
}
{\xe \v nocoprocessor_handler\:handlers.c}
{\xe \v handlers.c\:nocoprocessor_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nocoprocessor_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b handlers.c}.}\par
}
{\xe \v overflow_handler\:handlers.c}
{\xe \v handlers.c\:overflow_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void overflow_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 224} of file {\b handlers.c}.}\par
}
{\xe \v pagefault_handler\:handlers.c}
{\xe \v handlers.c\:pagefault_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pagefault_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b handlers.c}.}\par
}
{\xe \v segment_selector_not_present_handler\:handlers.c}
{\xe \v handlers.c\:segment_selector_not_present_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void segment_selector_not_present_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 255} of file {\b handlers.c}.}\par
}
{\xe \v severe_machine_check_handler\:handlers.c}
{\xe \v handlers.c\:severe_machine_check_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void severe_machine_check_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 289} of file {\b handlers.c}.}\par
}
{\xe \v stack_segment_overrun_handler\:handlers.c}
{\xe \v handlers.c\:stack_segment_overrun_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void stack_segment_overrun_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b handlers.c}.}\par
}
{\xe \v timer_handler\:handlers.c}
{\xe \v handlers.c\:timer_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void timer_handler (bool schedulerEnabled)}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DO NOT SET schedule_needed TO TRUE HERE, IT WILL BE SET IN ScheduleDPC!!\par
}{
Definition at line {\b 145} of file {\b handlers.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v caps_lock_on\:handlers.c}
{\xe \v handlers.c\:caps_lock_on}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool caps_lock_on = false}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b handlers.c}.}\par
}
{\xe \v ctrl_pressed\:handlers.c}
{\xe \v handlers.c\:ctrl_pressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ctrl_pressed = false}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b handlers.c}.}\par
}
{\xe \v cursor_x\:handlers.c}
{\xe \v handlers.c\:cursor_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_x{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.c}.}\par
}
{\xe \v cursor_y\:handlers.c}
{\xe \v handlers.c\:cursor_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_y{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b gop.c}.}\par
}
{\xe \v extended_scancode\:handlers.c}
{\xe \v handlers.c\:extended_scancode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool extended_scancode = false}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b handlers.c}.}\par
}
{\xe \v gop_local\:handlers.c}
{\xe \v handlers.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
{\xe \v schedule_pending\:handlers.c}
{\xe \v handlers.c\:schedule_pending}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool schedule_pending{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b dpc.c}.}\par
}
{\xe \v shift_pressed\:handlers.c}
{\xe \v handlers.c\:shift_pressed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool shift_pressed = false}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b handlers.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
handlers.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.c}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Implementation of handler functions for interrupts.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "handlers.h"}\par
00008 {\cf21 #include "scancodes.h"}\par
00009 {\cf21 #include "../idt.h"}\par
00010 \par
00011 {\cf20 // NOTE TO SELF: DO NOT PUT TRACELAST_FUNC HERE, THESE ARE INTERRUPT/EXCEPTION HANDLERS!}\par
00012 \par
00013 \par
00014 {\cf17 extern} uint32_t cursor_x;\par
00015 {\cf17 extern} uint32_t cursor_y;\par
00016 \par
00017 {\cf18 bool} shift_pressed = {\cf17 false};\par
00018 {\cf18 bool} ctrl_pressed = {\cf17 false};\par
00019 {\cf18 bool} caps_lock_on = {\cf17 false};\par
00020 {\cf18 bool} extended_scancode = {\cf17 false};\par
00021 \par
00022 {\cf18 void} init_keyboard() \{\par
00023     shift_pressed = {\cf17 false};\par
00024     ctrl_pressed = {\cf17 false};\par
00025     caps_lock_on = {\cf17 false};\par
00026     extended_scancode = {\cf17 false};\par
00027 \}\par
00028 \par
00029 {\cf17 extern} GOP_PARAMS gop_local;\par
00030 \par
00031 {\cf18 void} keyboard_handler() \{\par
00032     {\cf20 // Read the scan port from the status port.}\par
00033     {\cf18 unsigned} {\cf18 char} scancode = __inbyte(KEYBOARD_DATA_PORT);\par
00034 \par
00035     {\cf20 // Extended scancode recognition.}\par
00036     {\cf19 if} (scancode == 0xE0) \{\par
00037         extended_scancode = {\cf17 true};\par
00038         __outbyte(0x20, PIC_EOI); {\cf20 //ack}\par
00039         {\cf19 return};\par
00040     \}\par
00041 \par
00042     {\cf19 if} (extended_scancode) \{\par
00043         {\cf20 // second byte of extended scancode.}\par
00044         {\cf19 switch} (scancode) \{\par
00045         {\cf19 case} KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_UP:\par
00046             cursor_y--; {\cf20 // reveresd, even though it's - on the y scale, it goes up on screen.}\par
00047             extended_scancode = {\cf17 false};\par
00048             __outbyte(0x20, PIC_EOI); {\cf20 //ack}\par
00049             {\cf19 return};\par
00050         {\cf19 case} KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_DOWN:\par
00051             cursor_y++;\par
00052             extended_scancode = {\cf17 false};\par
00053             __outbyte(0x20, PIC_EOI);\par
00054             {\cf19 return};\par
00055         {\cf19 case} KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_RIGHT:\par
00056             cursor_x++;\par
00057             extended_scancode = {\cf17 false};\par
00058             __outbyte(0x20, PIC_EOI);\par
00059             {\cf19 return};\par
00060         {\cf19 case} KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_LEFT:\par
00061             cursor_x--;\par
00062             extended_scancode = {\cf17 false};\par
00063             __outbyte(0x20, PIC_EOI);\par
00064             {\cf19 return};\par
00065         \}\par
00066     \}\par
00067 \par
00068     {\cf20 // Check if it's a key press, bit 7 of the inbyte.}\par
00069     {\cf20 // 0x80 in binary is 1000 0000 -> BIT 7 AND -> if 1 - press, if 0 release.}\par
00070     {\cf19 if} (!(scancode & 0x80)) \{\par
00071         {\cf20 // Conver scan code to ASCII to see if it's even a printable character.}\par
00072         {\cf19 if} ((scancode < {\cf17 sizeof}(scancode_to_ascii) && scancode_to_ascii[scancode]) || (scancode < {\cf17 sizeof}(scancode_to_ascii_shift) && scancode_to_ascii_shift[scancode])) \{\par
00073             {\cf18 char} key = scancode_to_ascii[scancode];\par
00074             {\cf18 char} keyShift = scancode_to_ascii_shift[scancode];\par
00075             {\cf18 char} str[2] = \{ key, {\cf23 '\\0'} \}; {\cf20 // default string (key) + null terminator.}\par
00076             {\cf18 char} strShift[2] = \{ keyShift, {\cf23 '\\0'} \};\par
00077             {\cf19 switch} (key) \{\par
00078             {\cf19 case} {\cf23 '\\n'}: {\cf20 // newline char}\par
00079                 gop_printf_forced(1, {\cf22 "\\n"});\par
00080                 {\cf19 break};\par
00081             {\cf19 case} {\cf23 '\\b'}: {\cf20 // backspace}\par
00082                 gop_printf_forced(1, {\cf22 "\\b \\b"});\par
00083                 {\cf19 break};\par
00084             {\cf19 case} {\cf23 '\\t'}: {\cf20 // TAB}\par
00085                 gop_printf_forced(1, {\cf22 "    "});\par
00086                 {\cf19 break};\par
00087             {\cf19 default}:\par
00088                 {\cf19 if} (shift_pressed || caps_lock_on) \{\par
00089                     gop_printf_forced(0xFFFFFFFE, strShift); {\cf20 // basically underflow to max 32bit val.}\par
00090                 \}\par
00091                 {\cf19 else} \{\par
00092                     gop_printf_forced(0xFFFFFFFE, str); {\cf20 // basically underflow to max 32bit val.}\par
00093                 \}\par
00094                 {\cf19 break};\par
00095             \}\par
00096         \}\par
00097         {\cf19 switch} (scancode) \{\par
00098         {\cf19 case} KEYBOARD_SCANCODE_PRESSED_LEFT_SHIFT:\par
00099             shift_pressed = {\cf17 true};\par
00100             {\cf19 break};\par
00101         {\cf19 case} KEYBOARD_SCANCODE_PRESSED_CAPS_LOCK:\par
00102             caps_lock_on = !caps_lock_on;\par
00103         \}\par
00104 \par
00105     \}\par
00106     {\cf19 else} \{\par
00107         {\cf20 // It's a release, bit 7 is 0.}\par
00108         {\cf19 switch} (scancode) \{\par
00109         {\cf19 case} KEYBOARD_SCANCODE_RELEASE_LEFT_SHIFT:\par
00110             shift_pressed = {\cf17 false};\par
00111             {\cf19 break};\par
00112         \}\par
00113 \par
00114     \}\par
00115     {\cf20 // Send End Of Interrupt (EOI) to the PIC.}\par
00116     __outbyte(0x20, PIC_EOI); {\cf20 // Only sent to master since this is a master interrupt.}\par
00117 \}\par
00118 \par
00119 {\cf18 void} init_timer({\cf18 unsigned} {\cf18 long} {\cf18 int} frequency) \{\par
00120     {\cf18 unsigned} {\cf18 long} {\cf18 int} divisor = 1193180 / frequency;\par
00121 \par
00122     {\cf20 // Send the command byte}\par
00123     __outbyte(0x43, 0x36);  {\cf20 // Channel 0, lobyte/hibyte, mode 3 (square wave)}\par
00124 \par
00125     {\cf20 // Send the frequency divisor}\par
00126     __outbyte(0x40, ({\cf18 unsigned} {\cf18 char})(divisor & 0xFF));       {\cf20 // Low byte}\par
00127     __outbyte(0x40, ({\cf18 unsigned} {\cf18 char})((divisor >> 8) & 0xFF)); {\cf20 // High byte}\par
00128 \}\par
00129 \par
00130 \par
00131 {\cf20 // REVISE THAT SCHEDULEDPC WILL ALSO SEND CTX.}\par
00132 \par
00133 {\cf17 static} DPC scheduleDpc = \{\par
00134     .Next = NULL,\par
00135     .callback = ScheduleDPC,\par
00136     .callbackWithCtx = NULL,\par
00137     .ctx = NULL,\par
00138     .Kind = DPC_SCHEDULE,\par
00139     .hasCtx = {\cf17 false},\par
00140     .priority = HIGH_PRIORITY\par
00141 \};\par
00142 \par
00143 {\cf17 extern} {\cf17 volatile} {\cf18 bool} schedule_pending;\par
00144 \par
00145 {\cf18 void} timer_handler({\cf18 bool} schedulerEnabled) \{\par
00146     {\cf19 if} (!schedule_pending) \{\par
00147         {\cf19 if} (schedulerEnabled) \{\par
00148             {\cf19 if} (cpu.currentThread) \{\par
00149                 {\cf19 if} (cpu.currentThread->timeSlice-- <= 0) \{\par
00150                     cpu.currentThread->timeSlice = cpu.currentThread->origTimeSlice;\par
00151                     tracelast_func({\cf22 "Queuing DPC in timer_handler"});\par
00152                     MtQueueDPC(&scheduleDpc);\par
00154                 \}\par
00155                 {\cf19 else} \{\par
00156                     tracelast_func({\cf22 "Did not queue DPC in timer handler. Reason: Thread's timeslice isn't over."});\par
00157                 \}\par
00158             \}\par
00159             {\cf19 else} \{\par
00160                 tracelast_func({\cf22 "Did not queue DPC in timer handler. Reason: Thread is NULL (no current thread)"});\par
00161             \}\par
00162         \}\par
00163         {\cf19 else} \{\par
00164             tracelast_func({\cf22 "Did not queue DPC in timer handler. Reason: Scheduler isn't enabled.."});\par
00165         \}\par
00166     \}\par
00167     {\cf19 else} \{\par
00168         tracelast_func({\cf22 "Did not queue DPC in timer handler. Reason: Schedule DPC is already pending.."});\par
00169     \}\par
00170 \}\par
00171 \par
00172 {\cf17 extern} {\cf18 void} lapic_eoi({\cf18 void});\par
00173 \par
00174 {\cf18 void} lapic_handler({\cf18 bool} schedulerEnabled) \{\par
00175     lapic_eoi();\par
00176     timer_handler(schedulerEnabled);\par
00177 \}\par
00178 \par
00179 {\cf18 void} pagefault_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00180     uint64_t fault_addr;\par
00181     {\cf20 // cr2 holds the faulty address that caused the page fault.}\par
00182     \par
00183     __asm__ __volatile__ (\par
00184     {\cf22 "movq %%cr2, %0"}\par
00185     : {\cf22 "=r"}(fault_addr)\par
00186     );\par
00187     MtBugcheck(ctx, intfr, PAGE_FAULT, fault_addr, {\cf17 true});\par
00188     \par
00189     {\cf20 // __hlt(); -> When an HLT instruction is called when the CPU is in interrupt mode, (interrupts are already disabled to let this interrupt go through), iretd never executes, and so the CPU Is just stuck in place. Only an NMI or SMI can wake the processor back up}\par
00190     {\cf20 // NMI - Non Maskable Interrupt, happens when a watchdog timer expires, system bus errors, (or memory parity errors, that rarily occur in modern systems -- unless a gamma ray strikes through).}\par
00191     {\cf20 // SMI - A System Managment Interrupt is a special kind of an interurpt that also masks over CLI (even when interrupts are already disabled, like NMI), that is used for thermal throttling of the CPU, power management, or hardware emulation.}\par
00192 \}\par
00193 \par
00194 {\cf18 void} doublefault_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00195     {\cf20 // We reached a double fault, an exception within an exception handler.}\par
00196     {\cf20 // To not reach a triple fault, we will bugcheck the system (similar to a windows bugcheck - BSOD)}\par
00197     MtBugcheck(ctx, intfr, DOUBLE_FAULT, 0, {\cf17 false});\par
00198 \}\par
00199 \par
00200 {\cf18 void} dividebyzero_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00201     {\cf20 // handle diving by zero.}\par
00202     MtBugcheck(ctx, intfr, DIVIDE_BY_ZERO, 0, {\cf17 false});\par
00203 \}\par
00204 \par
00205 {\cf18 void} debugsinglestep_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00206     UNREFERENCED_PARAMETER(ctx);\par
00207     UNREFERENCED_PARAMETER(intfr);\par
00208     gop_printf_forced(0xFFFF0000, {\cf22 "\\nERROR: Debugging is not currently supported, halting.\\n"});\par
00209     __hlt();\par
00210 \}\par
00211 \par
00212 {\cf18 void} nmi_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00213     {\cf20 // severe problem, bugchecking.}\par
00214     MtBugcheck(ctx, intfr, NON_MASKABLE_INTERRUPT,0, {\cf17 false});\par
00215 \}\par
00216 \par
00217 {\cf18 void} breakpoint_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00218     UNREFERENCED_PARAMETER(ctx);\par
00219     UNREFERENCED_PARAMETER(intfr);\par
00220     gop_printf_forced(0xFFFF0000, {\cf22 "\\nERROR: Debugging is not currently supported, halting.\\n"});\par
00221     __hlt();\par
00222 \}\par
00223 \par
00224 {\cf18 void} overflow_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00225     {\cf20 // almost never happens on modern systems (compilers dont generate the INTO instruction anymore, unless manual assembly is placed)}\par
00226     {\cf20 // just bugcheck}\par
00227     MtBugcheck(ctx, intfr, OVERFLOW, 0, {\cf17 false});\par
00228 \}\par
00229 \par
00230 {\cf18 void} boundscheck_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00231     {\cf20 // bugcheck too, this is kernel mode.}\par
00232     MtBugcheck(ctx, intfr, BOUNDS_CHECK, 0, {\cf17 false});\par
00233 \}\par
00234 \par
00235 {\cf18 void} invalidopcode_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00236     MtBugcheck(ctx, intfr, INVALID_OPCODE, 0, {\cf17 false});\par
00237 \}\par
00238 \par
00239 {\cf18 void} nocoprocessor_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00240     {\cf20 // rarely triggered, if a floating point chip is not integrated, or is not attached, bugcheck.}\par
00241     MtBugcheck(ctx, intfr, NO_COPROCESSOR, 0, {\cf17 false});\par
00242 \}\par
00243 \par
00244 {\cf18 void} coprocessor_segment_overrun_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00245     {\cf20 // quite literally impossible in protected or long mode, since CPU's don't generate this exception on these modes, but if they did, bugcheck, severe code.}\par
00246     MtBugcheck(ctx, intfr, COPROCESSOR_SEGMENT_OVERRUN, 0, {\cf17 false});\par
00247 \}\par
00248 \par
00249 {\cf18 void} invalidtss_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00250     {\cf20 // a tss is when the CPU hardware switches (usually does not happen, since OS'es implement switching in software, like process timer context switch, all in software)}\par
00251     {\cf20 // if it did happen though, we bugcheck.}\par
00252     MtBugcheck(ctx, intfr, INVALID_TSS, 0, {\cf17 false});\par
00253 \}\par
00254 \par
00255 {\cf18 void} segment_selector_not_present_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00256     {\cf20 // this happens when the CPU loads a segment that points to a valid descriptor, that is marked as "not present" (that the present bit is 0), which means it's swapped out to disk.}\par
00257     {\cf20 // we don't have disk paging right now, we don't even have a current user mode or stable memory for now, so we just bugcheck.}\par
00258     MtBugcheck(ctx, intfr, SEGMENT_SELECTOR_NOTPRESENT, 0, {\cf17 false});\par
00259 \}\par
00260 \par
00261 {\cf18 void} stack_segment_overrun_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00262     {\cf20 // this happens when the stack pointer (esp, rsp, sp on 16 bit) moves OUTSIDE the bounds of the current stack segment, this is different from a stack overflow at the software level, this is a hardware level exception.}\par
00263     {\cf20 // segment limits on protected mode usually gets switched off, so if this happens just bugcheck.}\par
00264     MtBugcheck(ctx, intfr, STACK_SEGMENT_OVERRUN, 0, {\cf17 false});\par
00265 \}\par
00266 \par
00267 {\cf18 void} gpf_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00268     {\cf20 // important exception, view error code and bugcheck with it}\par
00269     MtBugcheck(ctx, intfr, GENERAL_PROTECTION_FAULT, 0, {\cf17 false});\par
00270 \}\par
00271 \par
00272 {\cf18 void} fpu_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00273     UNREFERENCED_PARAMETER(ctx);\par
00274     UNREFERENCED_PARAMETER(intfr);;\par
00275     {\cf20 // this occurs when a floating point operation has an error, (even division by zero floating point will get here), or underflow/overflow}\par
00276     gop_printf_forced(0xFFFF0000, {\cf22 "Error: Floating Point error, have you done a correct calculation?\\n"});\par
00277 \}\par
00278 \par
00279 {\cf18 void} alignment_check_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00280     {\cf20 // 3 conditions must be met in-order for this to even reach.}\par
00281     {\cf20 // CR0.AM (Alignment Mask) must be set to 1.}\par
00282     {\cf20 // EFLAGS.AC (Alignment Check) must be set to 1.}\par
00283     {\cf20 // CPL (user mode or kernel mode) must be set to 3. (user mode only)}\par
00284     {\cf20 // If all are 1 and a stack alignment occurs (when doing char* ptr = kmalloc(64, 16); then writing like this *((uint32_t*)ptr) = 0xdeadbeef; // It's an unaligned write, writing more than there is.}\par
00285     {\cf20 // for now, bugcheck.}\par
00286     MtBugcheck(ctx, intfr, ALIGNMENT_CHECK, 0, {\cf17 false});\par
00287 \}\par
00288 \par
00289 {\cf18 void} severe_machine_check_handler(CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00290     {\cf20 // creepy.}\par
00291     {\cf20 // This happens when the machine has a SEVERE problem, memory faults, CPU internal fault, all of that, the cpu registers this.}\par
00292     {\cf20 // obviously bugcheck.}\par
00293     MtBugcheck(ctx, intfr, SEVERE_MACHINE_CHECK, 0, {\cf17 false});\par
00294 \}\par
00295 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.h}
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../cpu/cpu.h"}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_DATA_PORT}\~ 0x60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_STATUS_PORT}\~ 0x64\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_keyboard} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b keyboard_handler} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_timer} (unsigned long int frequency)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b timer_handler} (bool schedulerEnabled)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pagefault_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b doublefault_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dividebyzero_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b debugsinglestep_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nmi_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b breakpoint_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b overflow_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b boundscheck_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidopcode_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nocoprocessor_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b coprocessor_segment_overrun_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidtss_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b segment_selector_not_present_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stack_segment_overrun_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gpf_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fpu_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b alignment_check_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b severe_machine_check_handler} ({\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_handler} (bool schedulerEnabled)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v KEYBOARD_DATA_PORT\:handlers.h}
{\xe \v handlers.h\:KEYBOARD_DATA_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_DATA_PORT\~ 0x60}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b handlers.h}.}\par
}
{\xe \v KEYBOARD_STATUS_PORT\:handlers.h}
{\xe \v handlers.h\:KEYBOARD_STATUS_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_STATUS_PORT\~ 0x64}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b handlers.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alignment_check_handler\:handlers.h}
{\xe \v handlers.h\:alignment_check_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void alignment_check_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b handlers.c}.}\par
}
{\xe \v boundscheck_handler\:handlers.h}
{\xe \v handlers.h\:boundscheck_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void boundscheck_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b handlers.c}.}\par
}
{\xe \v breakpoint_handler\:handlers.h}
{\xe \v handlers.h\:breakpoint_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void breakpoint_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 217} of file {\b handlers.c}.}\par
}
{\xe \v coprocessor_segment_overrun_handler\:handlers.h}
{\xe \v handlers.h\:coprocessor_segment_overrun_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void coprocessor_segment_overrun_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b handlers.c}.}\par
}
{\xe \v debugsinglestep_handler\:handlers.h}
{\xe \v handlers.h\:debugsinglestep_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void debugsinglestep_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b handlers.c}.}\par
}
{\xe \v dividebyzero_handler\:handlers.h}
{\xe \v handlers.h\:dividebyzero_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dividebyzero_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b handlers.c}.}\par
}
{\xe \v doublefault_handler\:handlers.h}
{\xe \v handlers.h\:doublefault_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void doublefault_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b handlers.c}.}\par
}
{\xe \v fpu_handler\:handlers.h}
{\xe \v handlers.h\:fpu_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fpu_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 272} of file {\b handlers.c}.}\par
}
{\xe \v gpf_handler\:handlers.h}
{\xe \v handlers.h\:gpf_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gpf_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 267} of file {\b handlers.c}.}\par
}
{\xe \v init_keyboard\:handlers.h}
{\xe \v handlers.h\:init_keyboard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_keyboard (void )}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b handlers.c}.}\par
}
{\xe \v init_timer\:handlers.h}
{\xe \v handlers.h\:init_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_timer (unsigned long int frequency)}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b handlers.c}.}\par
}
{\xe \v invalidopcode_handler\:handlers.h}
{\xe \v handlers.h\:invalidopcode_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidopcode_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 235} of file {\b handlers.c}.}\par
}
{\xe \v invalidtss_handler\:handlers.h}
{\xe \v handlers.h\:invalidtss_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void invalidtss_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b handlers.c}.}\par
}
{\xe \v keyboard_handler\:handlers.h}
{\xe \v handlers.h\:keyboard_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void keyboard_handler (void )}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b handlers.c}.}\par
}
{\xe \v lapic_handler\:handlers.h}
{\xe \v handlers.h\:lapic_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_handler (bool schedulerEnabled)}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b handlers.c}.}\par
}
{\xe \v nmi_handler\:handlers.h}
{\xe \v handlers.h\:nmi_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nmi_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b handlers.c}.}\par
}
{\xe \v nocoprocessor_handler\:handlers.h}
{\xe \v handlers.h\:nocoprocessor_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nocoprocessor_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b handlers.c}.}\par
}
{\xe \v overflow_handler\:handlers.h}
{\xe \v handlers.h\:overflow_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void overflow_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 224} of file {\b handlers.c}.}\par
}
{\xe \v pagefault_handler\:handlers.h}
{\xe \v handlers.h\:pagefault_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pagefault_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b handlers.c}.}\par
}
{\xe \v segment_selector_not_present_handler\:handlers.h}
{\xe \v handlers.h\:segment_selector_not_present_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void segment_selector_not_present_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 255} of file {\b handlers.c}.}\par
}
{\xe \v severe_machine_check_handler\:handlers.h}
{\xe \v handlers.h\:severe_machine_check_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void severe_machine_check_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 289} of file {\b handlers.c}.}\par
}
{\xe \v stack_segment_overrun_handler\:handlers.h}
{\xe \v handlers.h\:stack_segment_overrun_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void stack_segment_overrun_handler ({\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b handlers.c}.}\par
}
{\xe \v timer_handler\:handlers.h}
{\xe \v handlers.h\:timer_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void timer_handler (bool schedulerEnabled)}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DO NOT SET schedule_needed TO TRUE HERE, IT WILL BE SET IN ScheduleDPC!!\par
}{
Definition at line {\b 145} of file {\b handlers.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
handlers.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/handlers.h}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     ISR Handlers - Handle Interrupts based on number and do something.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_HANDLER_FUNCTIONS_H}\par
00007 {\cf21 #define X86_HANDLER_FUNCTIONS_H}\par
00008  {\cf20 // Standard headers, required.}\par
00009 {\cf21 #include <stddef.h>}\par
00010 {\cf21 #include <stdbool.h>}\par
00011 {\cf21 #include <stdint.h>}\par
00012 {\cf21 #include "../../cpu/cpu.h"}\par
00013 {\cf21 #include "../../trace.h"}\par
00014 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00015 \par
00016 {\cf20 // Obtained from https://wiki.osdev.org/Interrupts}\par
00017 {\cf21 #define KEYBOARD_DATA_PORT 0x60}\par
00018 {\cf21 #define KEYBOARD_STATUS_PORT 0x64}\par
00019 \par
00020 {\cf20 // IRQs}\par
00021 \par
00022 {\cf20 // Initialize keyboard left shift and left control to 0.}\par
00023 {\cf18 void} init_keyboard({\cf18 void});\par
00024 {\cf20 // Handle keyboard interruptions.}\par
00025 {\cf18 void} keyboard_handler({\cf18 void});\par
00026 {\cf20 // Initiate timer with a specified frequency.}\par
00027 {\cf18 void} init_timer({\cf18 unsigned} {\cf18 long} {\cf18 int} frequency);\par
00028 {\cf20 // Handle Timer Interruptions.}\par
00029 {\cf18 void} timer_handler({\cf18 bool} schedulerEnabled);\par
00030 \par
00031 {\cf20 // Exceptions:}\par
00032 \par
00033 \par
00034 {\cf20 // Handle Page Faults.}\par
00035 {\cf18 void} pagefault_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00036 {\cf20 // Handle Double Fault - Bugcheck.}\par
00037 {\cf18 void} doublefault_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00038 {\cf20 // Handle Division By Zero.}\par
00039 {\cf18 void} dividebyzero_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00040 \par
00041 {\cf20 // New added.}\par
00042 \par
00043 {\cf20 // Handle debugger single step exception.}\par
00044 {\cf18 void} debugsinglestep_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00045 {\cf20 // Handle Non Maskable Interrupt exception.}\par
00046 {\cf18 void} nmi_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00047 {\cf20 // Handle breakpoint exception.}\par
00048 {\cf18 void} breakpoint_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00049 {\cf20 // Handle overflow exception.}\par
00050 {\cf18 void} overflow_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00051 {\cf20 // Handle bounds check exception.}\par
00052 {\cf18 void} boundscheck_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00053 {\cf20 // Handle invalid opcode exception.}\par
00054 {\cf18 void} invalidopcode_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00055 {\cf20 // Handle no coprocessor exception.}\par
00056 {\cf18 void} nocoprocessor_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00057 {\cf20 // Handle coprocessor segment overrun exception.}\par
00058 {\cf18 void} coprocessor_segment_overrun_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00059 {\cf20 // Handle Invalid TSS Exception.}\par
00060 {\cf18 void} invalidtss_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00061 {\cf20 // Handle segment selector not present exception.}\par
00062 {\cf18 void} segment_selector_not_present_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00063 {\cf20 // Handle stack segment overrun exception.}\par
00064 {\cf18 void} stack_segment_overrun_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00065 {\cf20 // Handle GPF Exception. -- important exception, we use the registers and error code for it.}\par
00066 {\cf18 void} gpf_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00067 {\cf20 // Handle floating point error exception.}\par
00068 {\cf18 void} fpu_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00069 {\cf20 // Handle alignment check exception.}\par
00070 {\cf18 void} alignment_check_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00071 {\cf20 // Handle severe machine check exception.}\par
00072 {\cf18 void} severe_machine_check_handler(CTX_FRAME* ctx, INT_FRAME* intfr);\par
00073 \par
00074 {\cf18 void} lapic_handler({\cf18 bool} schedulerEnabled);\par
00075 {\cf21 #endif}\par
00076 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/scancodes.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/scancodes.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/scancodes.h}
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_3}\~ 0x04\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_7}\~ 0x08\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_MINUS}\~ 0x0C\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_Q}\~ 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_T}\~ 0x14\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_O}\~ 0x18\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_ENTER}\~ 0x1C\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_D}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_J}\~ 0x24\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_SINGLEQUOTE}\~ 0x28\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_Z}\~ 0x2C\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_B}\~ 0x30\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_LEFT_SHIFT}\~ 0x2A\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_DOT}\~ 0x34\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_LEFT_ALT}\~ 0x38\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_LEFT_CONTROL}\~ 0x1D\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_PRESSED_CAPS_LOCK}\~ 0x3A\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_UP}\~ 0x48\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_LEFT}\~ 0x4B\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_DOWN}\~ 0x50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_RIGHT}\~ 0x4D\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_RELEASE_LEFT_CONTROL}\~ 0x9D\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_RELEASE_LEFT_SHIFT}\~ 0xAA\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KEYBOARD_SCANCODE_RELEASE_CAPS_LOCK}\~ 0xBB\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b scancode_to_ascii} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b scancode_to_ascii_shift} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_DOWN\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_DOWN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_DOWN\~ 0x50}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_LEFT\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_LEFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_LEFT\~ 0x4B}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_RIGHT\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_RIGHT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_RIGHT\~ 0x4D}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_UP\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_UP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_UP\~ 0x48}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_3\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_3\~ 0x04}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_7\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_7\~ 0x08}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_B\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_B\~ 0x30}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_CAPS_LOCK\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_CAPS_LOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_CAPS_LOCK\~ 0x3A}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_D\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_D\~ 0x20}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_DOT\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_DOT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_DOT\~ 0x34}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_ENTER\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_ENTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_ENTER\~ 0x1C}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_J\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_J}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_J\~ 0x24}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_LEFT_ALT\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_LEFT_ALT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_LEFT_ALT\~ 0x38}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_LEFT_CONTROL\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_LEFT_CONTROL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_LEFT_CONTROL\~ 0x1D}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_LEFT_SHIFT\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_LEFT_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_LEFT_SHIFT\~ 0x2A}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_MINUS\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_MINUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_MINUS\~ 0x0C}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_O\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_O}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_O\~ 0x18}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_Q\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_Q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_Q\~ 0x10}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_SINGLEQUOTE\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_SINGLEQUOTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_SINGLEQUOTE\~ 0x28}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_T\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_T\~ 0x14}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_PRESSED_Z\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_PRESSED_Z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_PRESSED_Z\~ 0x2C}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_RELEASE_CAPS_LOCK\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_RELEASE_CAPS_LOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_RELEASE_CAPS_LOCK\~ 0xBB}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_RELEASE_LEFT_CONTROL\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_RELEASE_LEFT_CONTROL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_RELEASE_LEFT_CONTROL\~ 0x9D}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b scancodes.h}.}\par
}
{\xe \v KEYBOARD_SCANCODE_RELEASE_LEFT_SHIFT\:scancodes.h}
{\xe \v scancodes.h\:KEYBOARD_SCANCODE_RELEASE_LEFT_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KEYBOARD_SCANCODE_RELEASE_LEFT_SHIFT\~ 0xAA}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b scancodes.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v scancode_to_ascii\:scancodes.h}
{\xe \v scancodes.h\:scancode_to_ascii}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char scancode_to_ascii[]}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    0,  27, {\cf23 '1'}, {\cf23 '2'}, {\cf23 '3'}, {\cf23 '4'}, {\cf23 '5'}, {\cf23 '6'}, {\cf23 '7'}, {\cf23 '8'}, {\cf23 '9'}, {\cf23 '0'}, {\cf23 '-'}, {\cf23 '='}, {\cf23 '\\b'},\par
    {\cf23 '\\t'}, {\cf23 'q'}, {\cf23 'w'}, {\cf23 'e'}, {\cf23 'r'}, {\cf23 't'}, {\cf23 'y'}, {\cf23 'u'}, {\cf23 'i'}, {\cf23 'o'}, {\cf23 'p'}, {\cf23 '['}, {\cf23 ']'}, {\cf23 '\\n'},\par
    0, {\cf23 'a'}, {\cf23 's'}, {\cf23 'd'}, {\cf23 'f'}, {\cf23 'g'}, {\cf23 'h'}, {\cf23 'j'}, {\cf23 'k'}, {\cf23 'l'}, {\cf23 ';'}, {\cf23 '\\''}, {\cf23 '`'},\par
    0, {\cf23 '\\\\'}, {\cf23 'z'}, {\cf23 'x'}, {\cf23 'c'}, {\cf23 'v'}, {\cf23 'b'}, {\cf23 'n'}, {\cf23 'm'}, {\cf23 ','}, {\cf23 '.'}, {\cf23 '/'}, 0,\par
    {\cf23 '*'}, 0, {\cf23 ' '}\par
\}\par
}
{
Definition at line {\b 41} of file {\b scancodes.h}.}\par
}
{\xe \v scancode_to_ascii_shift\:scancodes.h}
{\xe \v scancodes.h\:scancode_to_ascii_shift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char scancode_to_ascii_shift[]}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    0,  27, {\cf23 '!'}, {\cf23 '@'}, {\cf23 '#'}, {\cf23 '$'}, {\cf23 '%'}, {\cf23 '^'}, {\cf23 '&'}, {\cf23 '*'}, {\cf23 '('}, {\cf23 ')'}, {\cf23 '_'}, {\cf23 '+'}, {\cf23 '\\b'},\par
    {\cf23 '\\t'}, {\cf23 'Q'}, {\cf23 'W'}, {\cf23 'E'}, {\cf23 'R'}, {\cf23 'T'}, {\cf23 'Y'}, {\cf23 'U'}, {\cf23 'I'}, {\cf23 'O'}, {\cf23 'P'}, {\cf23 '\{'}, {\cf23 '\}'}, {\cf23 '\\n'},\par
    0, {\cf23 'A'}, {\cf23 'S'}, {\cf23 'D'}, {\cf23 'F'}, {\cf23 'G'}, {\cf23 'H'}, {\cf23 'J'}, {\cf23 'K'}, {\cf23 'L'}, {\cf23 ':'}, {\cf23 '"'}, {\cf23 '~'},\par
    0, {\cf23 '|'}, {\cf23 'Z'}, {\cf23 'X'}, {\cf23 'C'}, {\cf23 'V'}, {\cf23 'B'}, {\cf23 'N'}, {\cf23 'M'}, {\cf23 '<'}, {\cf23 '>'}, {\cf23 '?'}, 0,\par
    {\cf23 '*'}, 0, {\cf23 ' '}\par
\}\par
}
{
Definition at line {\b 49} of file {\b scancodes.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
scancodes.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/scancodes.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/handlers/scancodes.h}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Keyboard Scancodes Definitions.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_KEYBOARD_SCANCODES}\par
00007 {\cf21 #define X86_KEYBOARD_SCANCODES}\par
00008 \par
00009 {\cf20 // taken from here - https://wiki.osdev.org/PS/2_Keyboard}\par
00010 \par
00011 {\cf20 // press}\par
00012 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_3 0x04}\par
00013 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_7 0x08}\par
00014 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_MINUS 0x0C}\par
00015 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_Q 0x10}\par
00016 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_T 0x14}\par
00017 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_O 0x18}\par
00018 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_ENTER 0x1C}\par
00019 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_D 0x20}\par
00020 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_J 0x24}\par
00021 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_SINGLEQUOTE 0x28}\par
00022 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_Z 0x2C}\par
00023 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_B 0x30}\par
00024 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_LEFT_SHIFT 0x2A}\par
00025 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_DOT 0x34}\par
00026 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_LEFT_ALT 0x38}\par
00027 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_LEFT_CONTROL 0x1D}\par
00028 {\cf21 #define KEYBOARD_SCANCODE_PRESSED_CAPS_LOCK 0x3A}\par
00029 \par
00030 {\cf20 // extended press}\par
00031 {\cf21 #define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_UP 0x48}\par
00032 {\cf21 #define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_LEFT 0x4B}\par
00033 {\cf21 #define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_DOWN 0x50}\par
00034 {\cf21 #define KEYBOARD_SCANCODE_EXTENDED_PRESSED_CURSOR_RIGHT 0x4D}\par
00035 \par
00036 {\cf20 // release}\par
00037 {\cf21 #define KEYBOARD_SCANCODE_RELEASE_LEFT_CONTROL 0x9D}\par
00038 {\cf21 #define KEYBOARD_SCANCODE_RELEASE_LEFT_SHIFT 0xAA}\par
00039 {\cf21 #define KEYBOARD_SCANCODE_RELEASE_CAPS_LOCK 0xBB}\par
00040 \par
00041 {\cf18 char} scancode_to_ascii[] = \{\par
00042     0,  27, {\cf23 '1'}, {\cf23 '2'}, {\cf23 '3'}, {\cf23 '4'}, {\cf23 '5'}, {\cf23 '6'}, {\cf23 '7'}, {\cf23 '8'}, {\cf23 '9'}, {\cf23 '0'}, {\cf23 '-'}, {\cf23 '='}, {\cf23 '\\b'},\par
00043     {\cf23 '\\t'}, {\cf23 'q'}, {\cf23 'w'}, {\cf23 'e'}, {\cf23 'r'}, {\cf23 't'}, {\cf23 'y'}, {\cf23 'u'}, {\cf23 'i'}, {\cf23 'o'}, {\cf23 'p'}, {\cf23 '['}, {\cf23 ']'}, {\cf23 '\\n'},\par
00044     0, {\cf23 'a'}, {\cf23 's'}, {\cf23 'd'}, {\cf23 'f'}, {\cf23 'g'}, {\cf23 'h'}, {\cf23 'j'}, {\cf23 'k'}, {\cf23 'l'}, {\cf23 ';'}, {\cf23 '\\''}, {\cf23 '`'},\par
00045     0, {\cf23 '\\\\'}, {\cf23 'z'}, {\cf23 'x'}, {\cf23 'c'}, {\cf23 'v'}, {\cf23 'b'}, {\cf23 'n'}, {\cf23 'm'}, {\cf23 ','}, {\cf23 '.'}, {\cf23 '/'}, 0,\par
00046     {\cf23 '*'}, 0, {\cf23 ' '}\par
00047 \};\par
00048 \par
00049 {\cf18 char} scancode_to_ascii_shift[] = \{\par
00050     0,  27, {\cf23 '!'}, {\cf23 '@'}, {\cf23 '#'}, {\cf23 '$'}, {\cf23 '%'}, {\cf23 '^'}, {\cf23 '&'}, {\cf23 '*'}, {\cf23 '('}, {\cf23 ')'}, {\cf23 '_'}, {\cf23 '+'}, {\cf23 '\\b'},\par
00051     {\cf23 '\\t'}, {\cf23 'Q'}, {\cf23 'W'}, {\cf23 'E'}, {\cf23 'R'}, {\cf23 'T'}, {\cf23 'Y'}, {\cf23 'U'}, {\cf23 'I'}, {\cf23 'O'}, {\cf23 'P'}, {\cf23 '\{'}, {\cf23 '\}'}, {\cf23 '\\n'},\par
00052     0, {\cf23 'A'}, {\cf23 'S'}, {\cf23 'D'}, {\cf23 'F'}, {\cf23 'G'}, {\cf23 'H'}, {\cf23 'J'}, {\cf23 'K'}, {\cf23 'L'}, {\cf23 ':'}, {\cf23 '"'}, {\cf23 '~'},\par
00053     0, {\cf23 '|'}, {\cf23 'Z'}, {\cf23 'X'}, {\cf23 'C'}, {\cf23 'V'}, {\cf23 'B'}, {\cf23 'N'}, {\cf23 'M'}, {\cf23 '<'}, {\cf23 '>'}, {\cf23 '?'}, 0,\par
00054     {\cf23 '*'}, 0, {\cf23 ' '}\par
00055 \};\par
00056 \par
00057 \par
00058 {\cf20 // yeah im tired, this is enough for now.}\par
00059 \par
00060 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.c}
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "idt.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_TIMER_VECTOR}\~ 0xEF\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_idt_gate} (int n, unsigned long int handler)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b install_idt} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_ENTRY64} {\b IDT} [{\b IDT_ENTRIES}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_PTR} {\b PIDT}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LAPIC_TIMER_VECTOR\:idt.c}
{\xe \v idt.c\:LAPIC_TIMER_VECTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_TIMER_VECTOR\~ 0xEF}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v install_idt\:idt.c}
{\xe \v idt.c\:install_idt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void install_idt (void )}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b idt.c}.}\par
}
{\xe \v set_idt_gate\:idt.c}
{\xe \v idt.c\:set_idt_gate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_idt_gate (int n, unsigned long int handler)}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functions \par
}{
Definition at line {\b 12} of file {\b idt.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v IDT\:idt.c}
{\xe \v idt.c\:IDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_ENTRY64} IDT[{\b IDT_ENTRIES}]}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b idt.c}.}\par
}
{\xe \v PIDT\:idt.c}
{\xe \v idt.c\:PIDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_PTR} PIDT}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b idt.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
idt.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.c}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     IMPLEMENTATION To SETUP IDT Entries.}\par
00005 {\cf20  */}\par
00006 {\cf21 #include "idt.h"}\par
00007 \par
00008 IDT_ENTRY64 IDT[IDT_ENTRIES];\par
00009 IDT_PTR  PIDT;\par
00010 \par
00011 {\cf20 /* Set one gate. */}\par
00012 {\cf18 void} set_idt_gate({\cf18 int} n, {\cf18 unsigned} {\cf18 long} {\cf18 int} handler) \{\par
00013     tracelast_func({\cf22 "set_idt_gate"});\par
00014     IDT[n].offset_low = handler & 0xFFFF;\par
00015     IDT[n].selector = 0x08;   {\cf20 // code segment selector}\par
00016     IDT[n].ist = 0;           {\cf20 // right now it's zero, I don't use IST.}\par
00017     IDT[n].type_attr = 0x8E;  {\cf20 // interrupt gate, present, ring 0}\par
00018     IDT[n].offset_mid = (handler >> 16) & 0xFFFF;\par
00019     IDT[n].offset_high = (handler >> 32) & 0xFFFFFFFF;\par
00020     IDT[n].zero = 0;\par
00021 \}\par
00022 \par
00023 {\cf20 /* Populate IDT: exceptions, IRQ, and then finally load it. */}\par
00024 {\cf18 void} install_idt() \{\par
00025     tracelast_func({\cf22 "install_idt"});\par
00026     {\cf20 /* REMAP the PIC so IRQs start at vector 0x20 */}\par
00027     __outbyte(0x20, 0x11); {\cf20 // initialize master PIC}\par
00028     __outbyte(0xA0, 0x11); {\cf20 // initialize slave PIC}\par
00029     __outbyte(0x21, 0x20); {\cf20 // master PIC vector offset 0x20.}\par
00030     __outbyte(0xA1, 0x28); {\cf20 // slave PIC vector offset 0x28}\par
00031     __outbyte(0x21, 0x04);\par
00032     __outbyte(0xA1, 0x02);\par
00033     __outbyte(0x21, 0x01);\par
00034     __outbyte(0xA1, 0x01);\par
00035     __outbyte(0x21, 0x0);\par
00036     __outbyte(0xA1, 0x0);\par
00037 \par
00038     {\cf20 /* Fill IDT Entries for CPU Exceptions (0-31) */} {\cf20 /* For clarifications, all of the ISR and IRQ externals live in isr_stub (where it defines the functions and gets linked together, via the global keyword) and isr_common_stub (where it does the routine), where they are linked together via the linker (externs) */}\par
00039     {\cf17 extern} {\cf18 void} isr0({\cf18 void}); {\cf17 extern} {\cf18 void} isr1({\cf18 void}); {\cf17 extern} {\cf18 void} isr2({\cf18 void}); {\cf17 extern} {\cf18 void} isr3({\cf18 void}); {\cf17 extern} {\cf18 void} isr4({\cf18 void}); {\cf17 extern} {\cf18 void} isr5({\cf18 void}); {\cf17 extern} {\cf18 void} isr6({\cf18 void}); {\cf17 extern} {\cf18 void} isr7({\cf18 void}); {\cf17 extern} {\cf18 void} isr8({\cf18 void}); {\cf17 extern} {\cf18 void} isr9({\cf18 void}); {\cf17 extern} {\cf18 void} isr10({\cf18 void}); {\cf17 extern} {\cf18 void} isr11({\cf18 void}); {\cf17 extern} {\cf18 void} isr12({\cf18 void}); {\cf17 extern} {\cf18 void} isr13({\cf18 void}); {\cf17 extern} {\cf18 void} isr14({\cf18 void}); {\cf17 extern} {\cf18 void} isr15({\cf18 void}); {\cf17 extern} {\cf18 void} isr16({\cf18 void}); {\cf17 extern} {\cf18 void} isr17({\cf18 void}); {\cf17 extern} {\cf18 void} isr18({\cf18 void}); {\cf17 extern} {\cf18 void} isr19({\cf18 void}); {\cf17 extern} {\cf18 void} isr20({\cf18 void}); {\cf17 extern} {\cf18 void} isr21({\cf18 void}); {\cf17 extern} {\cf18 void} isr22({\cf18 void}); {\cf17 extern} {\cf18 void} isr23({\cf18 void}); {\cf17 extern} {\cf18 void} isr24({\cf18 void}); {\cf17 extern} {\cf18 void} isr25({\cf18 void}); {\cf17 extern} {\cf18 void} isr26({\cf18 void}); {\cf17 extern} {\cf18 void} isr27({\cf18 void}); {\cf17 extern} {\cf18 void} isr28({\cf18 void}); {\cf17 extern} {\cf18 void} isr29({\cf18 void}); {\cf17 extern} {\cf18 void} isr30({\cf18 void}); {\cf17 extern} {\cf18 void} isr31({\cf18 void});\par
00040     {\cf20 /* I forgo t to set n in the set_idt_gate, they were all zeros and I didn't understand why I got IRQ of like 50 thousand and error code of 4 billion. (i copy pasted each line instead of typing manually) */}\par
00041     set_idt_gate(0, ({\cf18 unsigned} {\cf18 long})isr0);\par
00042     set_idt_gate(1, ({\cf18 unsigned} {\cf18 long})isr1);\par
00043     set_idt_gate(2, ({\cf18 unsigned} {\cf18 long})isr2);\par
00044     set_idt_gate(3, ({\cf18 unsigned} {\cf18 long})isr3);\par
00045     set_idt_gate(4, ({\cf18 unsigned} {\cf18 long})isr4);\par
00046     set_idt_gate(5, ({\cf18 unsigned} {\cf18 long})isr5);\par
00047     set_idt_gate(6, ({\cf18 unsigned} {\cf18 long})isr6);\par
00048     set_idt_gate(7, ({\cf18 unsigned} {\cf18 long})isr7);\par
00049     set_idt_gate(8, ({\cf18 unsigned} {\cf18 long})isr8);\par
00050     set_idt_gate(9, ({\cf18 unsigned} {\cf18 long})isr9);\par
00051     set_idt_gate(10, ({\cf18 unsigned} {\cf18 long})isr10);\par
00052     set_idt_gate(11, ({\cf18 unsigned} {\cf18 long})isr11);\par
00053     set_idt_gate(12, ({\cf18 unsigned} {\cf18 long})isr12);\par
00054     set_idt_gate(13, ({\cf18 unsigned} {\cf18 long})isr13);\par
00055     set_idt_gate(14, ({\cf18 unsigned} {\cf18 long})isr14);\par
00056     set_idt_gate(15, ({\cf18 unsigned} {\cf18 long})isr15);\par
00057     set_idt_gate(16, ({\cf18 unsigned} {\cf18 long})isr16);\par
00058     set_idt_gate(17, ({\cf18 unsigned} {\cf18 long})isr17);\par
00059     set_idt_gate(18, ({\cf18 unsigned} {\cf18 long})isr18);\par
00060     set_idt_gate(19, ({\cf18 unsigned} {\cf18 long})isr19);\par
00061     set_idt_gate(20, ({\cf18 unsigned} {\cf18 long})isr20);\par
00062     set_idt_gate(21, ({\cf18 unsigned} {\cf18 long})isr21);\par
00063     set_idt_gate(22, ({\cf18 unsigned} {\cf18 long})isr22);\par
00064     set_idt_gate(23, ({\cf18 unsigned} {\cf18 long})isr23);\par
00065     set_idt_gate(24, ({\cf18 unsigned} {\cf18 long})isr24);\par
00066     set_idt_gate(25, ({\cf18 unsigned} {\cf18 long})isr25);\par
00067     set_idt_gate(26, ({\cf18 unsigned} {\cf18 long})isr26);\par
00068     set_idt_gate(27, ({\cf18 unsigned} {\cf18 long})isr27);\par
00069     set_idt_gate(28, ({\cf18 unsigned} {\cf18 long})isr28);\par
00070     set_idt_gate(29, ({\cf18 unsigned} {\cf18 long})isr29);\par
00071     set_idt_gate(30, ({\cf18 unsigned} {\cf18 long})isr30);\par
00072     set_idt_gate(31, ({\cf18 unsigned} {\cf18 long})isr31);\par
00073 \par
00074     {\cf20 /* Fill IDT Gates for IRQs (32-47) */}\par
00075     {\cf17 extern} {\cf18 void} irq0({\cf18 void}); {\cf17 extern} {\cf18 void} irq1({\cf18 void}); {\cf17 extern} {\cf18 void} irq2({\cf18 void}); {\cf17 extern} {\cf18 void} irq3({\cf18 void}); {\cf17 extern} {\cf18 void} irq4({\cf18 void}); {\cf17 extern} {\cf18 void} irq5({\cf18 void}); {\cf17 extern} {\cf18 void} irq6({\cf18 void}); {\cf17 extern} {\cf18 void} irq7({\cf18 void}); {\cf17 extern} {\cf18 void} irq8({\cf18 void}); {\cf17 extern} {\cf18 void} irq9({\cf18 void}); {\cf17 extern} {\cf18 void} irq10({\cf18 void}); {\cf17 extern} {\cf18 void} irq11({\cf18 void}); {\cf17 extern} {\cf18 void} irq12({\cf18 void}); {\cf17 extern} {\cf18 void} irq13({\cf18 void}); {\cf17 extern} {\cf18 void} irq14({\cf18 void}); {\cf17 extern} {\cf18 void} irq15({\cf18 void});\par
00076     set_idt_gate(32, ({\cf18 unsigned} {\cf18 long})irq0);\par
00077     set_idt_gate(33, ({\cf18 unsigned} {\cf18 long})irq1);\par
00078     set_idt_gate(34, ({\cf18 unsigned} {\cf18 long})irq2);\par
00079     set_idt_gate(35, ({\cf18 unsigned} {\cf18 long})irq3);\par
00080     set_idt_gate(36, ({\cf18 unsigned} {\cf18 long})irq4);\par
00081     set_idt_gate(37, ({\cf18 unsigned} {\cf18 long})irq5);\par
00082     set_idt_gate(38, ({\cf18 unsigned} {\cf18 long})irq6);\par
00083     set_idt_gate(39, ({\cf18 unsigned} {\cf18 long})irq7);\par
00084     set_idt_gate(40, ({\cf18 unsigned} {\cf18 long})irq8);\par
00085     set_idt_gate(41, ({\cf18 unsigned} {\cf18 long})irq9);\par
00086     set_idt_gate(42, ({\cf18 unsigned} {\cf18 long})irq10);\par
00087     set_idt_gate(43, ({\cf18 unsigned} {\cf18 long})irq11);\par
00088     set_idt_gate(44, ({\cf18 unsigned} {\cf18 long})irq12);\par
00089     set_idt_gate(45, ({\cf18 unsigned} {\cf18 long})irq13);\par
00090     set_idt_gate(46, ({\cf18 unsigned} {\cf18 long})irq14);\par
00091     set_idt_gate(47, ({\cf18 unsigned} {\cf18 long})irq15);\par
00092 {\cf21 #define LAPIC_TIMER_VECTOR 0xEF}\par
00093     {\cf20 /* For LAPIC */}\par
00094     {\cf17 extern} {\cf18 void} isr239({\cf18 void}); {\cf20 // LAPIC ISR.}\par
00095     set_idt_gate(LAPIC_TIMER_VECTOR, ({\cf18 unsigned} {\cf18 long})isr239);\par
00096 \par
00097     {\cf20 /* Finally, Load IDT. */}\par
00098     PIDT.limit = {\cf17 sizeof}(IDT_ENTRY64) * IDT_ENTRIES - 1; {\cf20 // Max limit is the amount of IDT_ENTRIES structs (0-255)}\par
00099     PIDT.base = ({\cf18 unsigned} long)&IDT;\par
00100     __lidt(&PIDT);\par
00101 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.h}
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../cpu/cpu.h"}\par
{\f2 #include "../trace.h"}\par
{\f2 #include "handlers/handlers.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IDT_PTR}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IDT_ENTRY_64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC1_COMMAND_MASTER}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC1_DATA_MASTER}\~ 0x21\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC2_COMMAND_SLAVE}\~ 0xA0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC2_DATA_SLAVE}\~ 0xA1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC_EOI}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IDT_ENTRIES}\~ 256\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _CPU_EXCEPTIONS} {\b CPU_EXCEPTIONS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _INTERRUPT_LIST} {\b INTERRUPT_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PIC_IRQ_LINE} {\b PIC_IRQ_LINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IDT_PTR} {\b IDT_PTR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IDT_ENTRY_64} {\b IDT_ENTRY64}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _CPU_EXCEPTIONS} \{ {\b EXCEPTION_DIVIDE_BY_ZERO}
, {\b EXCEPTION_SINGLE_STEP}
, {\b EXCEPTION_NON_MASKABLE_INTERRUPT}
, {\b EXCEPTION_BREAKPOINT}
, {\b EXCEPTION_OVERFLOW}
, {\b EXCEPTION_BOUNDS_CHECK}
, {\b EXCEPTION_INVALID_OPCODE}
, {\b EXCEPTION_NO_COPROCESSOR}
, {\b EXCEPTION_DOUBLE_FAULT}
, {\b EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN}
, {\b EXCEPTION_INVALID_TSS}
, {\b EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT}
, {\b EXCEPTION_STACK_SEGMENT_OVERRUN}
, {\b EXCEPTION_GENERAL_PROTECTION_FAULT}
, {\b EXCEPTION_PAGE_FAULT}
, {\b EXCEPTION_RESERVED}
, {\b EXCEPTION_FLOATING_POINT_ERROR}
, {\b EXCEPTION_ALIGNMENT_CHECK}
, {\b EXCEPTION_SEVERE_MACHINE_CHECK}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _INTERRUPT_LIST} \{ {\b TIMER_INTERRUPT} = 32
, {\b KEYBOARD_INTERRUPT} = 33
, {\b ATA_INTERRUPT} = 46
, {\b LAPIC_INTERRUPT} = 0xEF
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PIC_IRQ_LINE} \{ {\b IRQ0_TIMER} = 0
, {\b IRQ1_KEYBOARD} = 1
, {\b IRQ2_CASCADE} = 2
, {\b IRQ3_SERIAL2} = 3
, {\b IRQ4_SERIAL1} = 4
, {\b IRQ5_LPT2} = 5
, {\b IRQ6_FLOPPY} = 6
, {\b IRQ7_LPT1} = 7
, {\b IRQ8_CMOS} = 8
, {\b IRQ9_FREE} = 9
, {\b IRQ10_FREE} = 10
, {\b IRQ11_FREE} = 11
, {\b IRQ12_MOUSE} = 12
, {\b IRQ13_FPU} = 13
, {\b IRQ14_PRIMARY_ATA} = 14
, {\b IRQ15_SECONDARY_ATA} = 15
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_idt_gate} (int n, unsigned long int handler)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b install_idt} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_interrupts} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b isr_handler64} (int vec_num, {\b CTX_FRAME} *ctx, {\b INT_FRAME} *intfr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IDT_ENTRIES\:idt.h}
{\xe \v idt.h\:IDT_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IDT_ENTRIES\~ 256}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b idt.h}.}\par
}
{\xe \v PIC1_COMMAND_MASTER\:idt.h}
{\xe \v idt.h\:PIC1_COMMAND_MASTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC1_COMMAND_MASTER\~ 0x20}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b idt.h}.}\par
}
{\xe \v PIC1_DATA_MASTER\:idt.h}
{\xe \v idt.h\:PIC1_DATA_MASTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC1_DATA_MASTER\~ 0x21}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b idt.h}.}\par
}
{\xe \v PIC2_COMMAND_SLAVE\:idt.h}
{\xe \v idt.h\:PIC2_COMMAND_SLAVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC2_COMMAND_SLAVE\~ 0xA0}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b idt.h}.}\par
}
{\xe \v PIC2_DATA_SLAVE\:idt.h}
{\xe \v idt.h\:PIC2_DATA_SLAVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC2_DATA_SLAVE\~ 0xA1}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b idt.h}.}\par
}
{\xe \v PIC_EOI\:idt.h}
{\xe \v idt.h\:PIC_EOI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC_EOI\~ 0x20}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b idt.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CPU_EXCEPTIONS\:idt.h}
{\xe \v idt.h\:CPU_EXCEPTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _CPU_EXCEPTIONS} {\b CPU_EXCEPTIONS}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception Definitions \par
}}
{\xe \v IDT_ENTRY64\:idt.h}
{\xe \v idt.h\:IDT_ENTRY64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IDT_ENTRY_64} {\b IDT_ENTRY64}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IDT_PTR\:idt.h}
{\xe \v idt.h\:IDT_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IDT_PTR} {\b IDT_PTR}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERRUPT_LIST\:idt.h}
{\xe \v idt.h\:INTERRUPT_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _INTERRUPT_LIST} {\b INTERRUPT_LIST}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interrupt Definitions \par
}}
{\xe \v PIC_IRQ_LINE\:idt.h}
{\xe \v idt.h\:PIC_IRQ_LINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PIC_IRQ_LINE} {\b PIC_IRQ_LINE}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PIC IRQ Lines \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _CPU_EXCEPTIONS\:idt.h}
{\xe \v idt.h\:_CPU_EXCEPTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _CPU_EXCEPTIONS}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception Definitions \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v EXCEPTION_DIVIDE_BY_ZERO\:idt.h}
{\xe \v idt.h\:EXCEPTION_DIVIDE_BY_ZERO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_DIVIDE_BY_ZERO{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_SINGLE_STEP\:idt.h}
{\xe \v idt.h\:EXCEPTION_SINGLE_STEP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_SINGLE_STEP{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_NON_MASKABLE_INTERRUPT\:idt.h}
{\xe \v idt.h\:EXCEPTION_NON_MASKABLE_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_NON_MASKABLE_INTERRUPT{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_BREAKPOINT\:idt.h}
{\xe \v idt.h\:EXCEPTION_BREAKPOINT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_BREAKPOINT{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_OVERFLOW\:idt.h}
{\xe \v idt.h\:EXCEPTION_OVERFLOW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_OVERFLOW{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_BOUNDS_CHECK\:idt.h}
{\xe \v idt.h\:EXCEPTION_BOUNDS_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_BOUNDS_CHECK{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_INVALID_OPCODE\:idt.h}
{\xe \v idt.h\:EXCEPTION_INVALID_OPCODE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_INVALID_OPCODE{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_NO_COPROCESSOR\:idt.h}
{\xe \v idt.h\:EXCEPTION_NO_COPROCESSOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_NO_COPROCESSOR{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_DOUBLE_FAULT\:idt.h}
{\xe \v idt.h\:EXCEPTION_DOUBLE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_DOUBLE_FAULT{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN\:idt.h}
{\xe \v idt.h\:EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_INVALID_TSS\:idt.h}
{\xe \v idt.h\:EXCEPTION_INVALID_TSS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_INVALID_TSS{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT\:idt.h}
{\xe \v idt.h\:EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_STACK_SEGMENT_OVERRUN\:idt.h}
{\xe \v idt.h\:EXCEPTION_STACK_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_STACK_SEGMENT_OVERRUN{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_GENERAL_PROTECTION_FAULT\:idt.h}
{\xe \v idt.h\:EXCEPTION_GENERAL_PROTECTION_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_GENERAL_PROTECTION_FAULT{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_PAGE_FAULT\:idt.h}
{\xe \v idt.h\:EXCEPTION_PAGE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_PAGE_FAULT{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_RESERVED\:idt.h}
{\xe \v idt.h\:EXCEPTION_RESERVED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_RESERVED{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_FLOATING_POINT_ERROR\:idt.h}
{\xe \v idt.h\:EXCEPTION_FLOATING_POINT_ERROR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_FLOATING_POINT_ERROR{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_ALIGNMENT_CHECK\:idt.h}
{\xe \v idt.h\:EXCEPTION_ALIGNMENT_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_ALIGNMENT_CHECK{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_SEVERE_MACHINE_CHECK\:idt.h}
{\xe \v idt.h\:EXCEPTION_SEVERE_MACHINE_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_SEVERE_MACHINE_CHECK{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 26} of file {\b idt.h}.}\par
}
{\xe \v _INTERRUPT_LIST\:idt.h}
{\xe \v idt.h\:_INTERRUPT_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _INTERRUPT_LIST}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interrupt Definitions \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v TIMER_INTERRUPT\:idt.h}
{\xe \v idt.h\:TIMER_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid TIMER_INTERRUPT{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
\cell }{\cell }{\row }
{\xe \v KEYBOARD_INTERRUPT\:idt.h}
{\xe \v idt.h\:KEYBOARD_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid KEYBOARD_INTERRUPT{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
\cell }{\cell }{\row }
{\xe \v ATA_INTERRUPT\:idt.h}
{\xe \v idt.h\:ATA_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATA_INTERRUPT{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
\cell }{\cell }{\row }
{\xe \v LAPIC_INTERRUPT\:idt.h}
{\xe \v idt.h\:LAPIC_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_INTERRUPT{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 49} of file {\b idt.h}.}\par
}
{\xe \v _PIC_IRQ_LINE\:idt.h}
{\xe \v idt.h\:_PIC_IRQ_LINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PIC_IRQ_LINE}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PIC IRQ Lines \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v IRQ0_TIMER\:idt.h}
{\xe \v idt.h\:IRQ0_TIMER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ0_TIMER{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
\cell }{\cell }{\row }
{\xe \v IRQ1_KEYBOARD\:idt.h}
{\xe \v idt.h\:IRQ1_KEYBOARD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ1_KEYBOARD{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
\cell }{\cell }{\row }
{\xe \v IRQ2_CASCADE\:idt.h}
{\xe \v idt.h\:IRQ2_CASCADE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ2_CASCADE{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
\cell }{\cell }{\row }
{\xe \v IRQ3_SERIAL2\:idt.h}
{\xe \v idt.h\:IRQ3_SERIAL2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ3_SERIAL2{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
\cell }{\cell }{\row }
{\xe \v IRQ4_SERIAL1\:idt.h}
{\xe \v idt.h\:IRQ4_SERIAL1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ4_SERIAL1{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
\cell }{\cell }{\row }
{\xe \v IRQ5_LPT2\:idt.h}
{\xe \v idt.h\:IRQ5_LPT2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ5_LPT2{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
\cell }{\cell }{\row }
{\xe \v IRQ6_FLOPPY\:idt.h}
{\xe \v idt.h\:IRQ6_FLOPPY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ6_FLOPPY{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
\cell }{\cell }{\row }
{\xe \v IRQ7_LPT1\:idt.h}
{\xe \v idt.h\:IRQ7_LPT1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ7_LPT1{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
\cell }{\cell }{\row }
{\xe \v IRQ8_CMOS\:idt.h}
{\xe \v idt.h\:IRQ8_CMOS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ8_CMOS{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
\cell }{\cell }{\row }
{\xe \v IRQ9_FREE\:idt.h}
{\xe \v idt.h\:IRQ9_FREE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ9_FREE{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
\cell }{\cell }{\row }
{\xe \v IRQ10_FREE\:idt.h}
{\xe \v idt.h\:IRQ10_FREE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ10_FREE{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
\cell }{\cell }{\row }
{\xe \v IRQ11_FREE\:idt.h}
{\xe \v idt.h\:IRQ11_FREE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ11_FREE{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
\cell }{\cell }{\row }
{\xe \v IRQ12_MOUSE\:idt.h}
{\xe \v idt.h\:IRQ12_MOUSE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ12_MOUSE{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
\cell }{\cell }{\row }
{\xe \v IRQ13_FPU\:idt.h}
{\xe \v idt.h\:IRQ13_FPU}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ13_FPU{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
\cell }{\cell }{\row }
{\xe \v IRQ14_PRIMARY_ATA\:idt.h}
{\xe \v idt.h\:IRQ14_PRIMARY_ATA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ14_PRIMARY_ATA{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
\cell }{\cell }{\row }
{\xe \v IRQ15_SECONDARY_ATA\:idt.h}
{\xe \v idt.h\:IRQ15_SECONDARY_ATA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQ15_SECONDARY_ATA{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 57} of file {\b idt.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_interrupts\:idt.h}
{\xe \v idt.h\:init_interrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_interrupts (void )}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b isr.c}.}\par
}
{\xe \v install_idt\:idt.h}
{\xe \v idt.h\:install_idt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void install_idt (void )}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b idt.c}.}\par
}
{\xe \v isr_handler64\:idt.h}
{\xe \v idt.h\:isr_handler64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void isr_handler64 (int vec_num, {\b CTX_FRAME} * ctx, {\b INT_FRAME} * intfr)}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v set_idt_gate\:idt.h}
{\xe \v idt.h\:set_idt_gate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_idt_gate (int n, unsigned long int handler)}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Functions \par
}{
Definition at line {\b 12} of file {\b idt.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
idt.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/idt.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Interrupt Structure and functions declaration.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_IDT_H}\par
00007 {\cf21 #define X86_IDT_H}\par
00008 \par
00009 {\cf20 // Standard headers, required.}\par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stdint.h>}\par
00013 {\cf21 #include "../cpu/cpu.h"}\par
00014 {\cf21 #include "../trace.h"}\par
00015 {\cf21 #include "handlers/handlers.h"}\par
00016 \par
00017 {\cf21 #define PIC1_COMMAND_MASTER 0x20}\par
00018 {\cf21 #define PIC1_DATA_MASTER    0x21}\par
00019 {\cf21 #define PIC2_COMMAND_SLAVE  0xA0}\par
00020 {\cf21 #define PIC2_DATA_SLAVE     0xA1}\par
00021 \par
00022 {\cf21 #define PIC_EOI            0x20}\par
00023 {\cf21 #define IDT_ENTRIES        256}\par
00024 \par
00026 {\cf17 typedef} {\cf17 enum} _CPU_EXCEPTIONS \{\par
00027     EXCEPTION_DIVIDE_BY_ZERO,\par
00028     EXCEPTION_SINGLE_STEP,\par
00029     EXCEPTION_NON_MASKABLE_INTERRUPT,\par
00030     EXCEPTION_BREAKPOINT,\par
00031     EXCEPTION_OVERFLOW,\par
00032     EXCEPTION_BOUNDS_CHECK,\par
00033     EXCEPTION_INVALID_OPCODE,\par
00034     EXCEPTION_NO_COPROCESSOR,\par
00035     EXCEPTION_DOUBLE_FAULT,\par
00036     EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN,\par
00037     EXCEPTION_INVALID_TSS,\par
00038     EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT,\par
00039     EXCEPTION_STACK_SEGMENT_OVERRUN,\par
00040     EXCEPTION_GENERAL_PROTECTION_FAULT,\par
00041     EXCEPTION_PAGE_FAULT,\par
00042     EXCEPTION_RESERVED,\par
00043     EXCEPTION_FLOATING_POINT_ERROR,\par
00044     EXCEPTION_ALIGNMENT_CHECK,\par
00045     EXCEPTION_SEVERE_MACHINE_CHECK,\par
00046 \} CPU_EXCEPTIONS;\par
00047 \par
00049 {\cf17 typedef} {\cf17 enum} _INTERRUPT_LIST \{\par
00050     TIMER_INTERRUPT = 32,\par
00051     KEYBOARD_INTERRUPT = 33,\par
00052     ATA_INTERRUPT = 46,\par
00053     LAPIC_INTERRUPT = 0xEF,\par
00054 \} INTERRUPT_LIST;\par
00055 \par
00057 {\cf17 typedef} {\cf17 enum} _PIC_IRQ_LINE \{\par
00058     IRQ0_TIMER = 0,\par
00059     IRQ1_KEYBOARD = 1,\par
00060     IRQ2_CASCADE = 2,\par
00061     IRQ3_SERIAL2 = 3,\par
00062     IRQ4_SERIAL1 = 4,\par
00063     IRQ5_LPT2 = 5,\par
00064     IRQ6_FLOPPY = 6,\par
00065     IRQ7_LPT1 = 7,\par
00066     IRQ8_CMOS = 8,\par
00067     IRQ9_FREE = 9,\par
00068     IRQ10_FREE = 10,\par
00069     IRQ11_FREE = 11,\par
00070     IRQ12_MOUSE = 12,\par
00071     IRQ13_FPU = 13,\par
00072     IRQ14_PRIMARY_ATA = 14,\par
00073     IRQ15_SECONDARY_ATA = 15,\par
00074 \} PIC_IRQ_LINE;\par
00075 \par
00076 {\cf21 #pragma pack(push, 1)}\par
00077 {\cf17 typedef} {\cf17 struct }_IDT_PTR \{\par
00078     uint16_t limit;\par
00079     uint64_t base;\par
00080 \} IDT_PTR;\par
00081 \par
00082 {\cf17 typedef} {\cf17 struct }_IDT_ENTRY_64 \{\par
00083     uint16_t offset_low;\par
00084     uint16_t selector;\par
00085     uint8_t  ist;\par
00086     uint8_t  type_attr;\par
00087     uint16_t offset_mid;\par
00088     uint32_t offset_high;\par
00089     uint32_t zero;\par
00090 \} IDT_ENTRY64;\par
00091 {\cf21 #pragma pack(pop)}\par
00092  \par
00094 {\cf18 void} set_idt_gate({\cf18 int} n, {\cf18 unsigned} {\cf18 long} {\cf18 int} handler);\par
00095 {\cf18 void} install_idt({\cf18 void});\par
00096 {\cf18 void} init_interrupts({\cf18 void});\par
00097 {\cf18 void} isr_handler64({\cf18 int} vec_num, CTX_FRAME* ctx, INT_FRAME* intfr);\par
00098 \par
00102 {\cf17 static} {\cf17 inline} {\cf18 void} mask_irq(PIC_IRQ_LINE irq_line) \{\par
00103     uint16_t port;\par
00104     uint8_t mask;\par
00105     {\cf19 if} (irq_line < 8) \{\par
00106         port = PIC1_DATA_MASTER;\par
00107     \}\par
00108     {\cf19 else} \{\par
00109         port = PIC2_DATA_SLAVE;\par
00110         irq_line -= 8;\par
00111     \}\par
00112     mask = __inbyte(port);\par
00113     mask |= (1 << irq_line);\par
00114     __outbyte(port, mask);\par
00115 \}\par
00116 \par
00117 {\cf17 static} {\cf17 inline} {\cf18 void} unmask_irq(PIC_IRQ_LINE irq_line) \{\par
00118     uint16_t port;\par
00119     uint8_t mask;\par
00120     {\cf19 if} (irq_line < 8) \{\par
00121         port = PIC1_DATA_MASTER;\par
00122     \}\par
00123     {\cf19 else} \{\par
00124         port = PIC2_DATA_SLAVE;\par
00125         irq_line -= 8;\par
00126     \}\par
00127     mask = __inbyte(port);\par
00128     mask &= ~(1 << irq_line);\par
00129     __outbyte(port, mask);\par
00130 \}\par
00131 \par
00132 {\cf21 #endif }{\cf20 /* X86_IDT_H */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/isr.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/isr.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/isr.c}
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "idt.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((used))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_interrupts} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const bool {\b has_error_code} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:isr.c}
{\xe \v isr.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((used) )}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b isr.c}.}\par
}
{\xe \v init_interrupts\:isr.c}
{\xe \v isr.c\:init_interrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_interrupts (void )}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b isr.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gop_local\:isr.c}
{\xe \v isr.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
{\xe \v has_error_code\:isr.c}
{\xe \v isr.c\:has_error_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const bool has_error_code[]}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, \par
    {\cf17 true},  {\cf17 false}, {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 false}, \par
    {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, \par
    {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}  \par
\}\par
}
{
Definition at line {\b 12} of file {\b isr.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
isr.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/isr.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/interrupts/isr.c}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     IMPLEMENTATION To SETUP ISR Handler.}\par
00005 {\cf20  * EXPLANATION: An ISR is what handles the interrupts that gets sent from the CPU (after interrupt is sent to ISR itself), it will do stuff based if it's an exception, or a normal interrupt.}\par
00006 {\cf20  */}\par
00007 \par
00008 {\cf21 #include "idt.h"}\par
00009 \par
00010 {\cf17 extern} GOP_PARAMS gop_local;\par
00011 \par
00012 {\cf17 const} {\cf18 bool} has_error_code[] = \{\par
00013     {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf20 // 0-7}\par
00014     {\cf17 true},  {\cf17 false}, {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 false}, {\cf20 // 8-15}\par
00015     {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf20 // 16-23}\par
00016     {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}  {\cf20 // 24-31}\par
00017 \};\par
00018 \par
00019 {\cf21 #ifndef _MSC_VER}\par
00020 __attribute__((used))\par
00021 {\cf21 #endif}\par
00022 {\cf18 void} isr_handler64({\cf18 int} vec_num, CTX_FRAME* ctx, INT_FRAME* intfr) \{\par
00023     {\cf18 char} buf[256];\par
00024     ksnprintf(buf, {\cf17 sizeof}(buf), {\cf22 "INTERRUPT: %d"}, vec_num);\par
00025     tracelast_func(buf);\par
00026     IRQL oldIrql;\par
00027     \par
00028     {\cf20 // Save if the scheduler was enabled or not before raising to >= DISPATCH_LEVEL (because in dispatch_level the scheduler gets disabled to disable pre-emption)}\par
00029     {\cf18 bool} schedulerEnabled = cpu.schedulerEnabled;\par
00030 \par
00031     ctx->rip = intfr->rip;\par
00032     ctx->rsp = intfr->rsp;\par
00033     intfr->vector = vec_num;\par
00034 \par
00035     {\cf19 switch} (vec_num) \{\par
00036     {\cf19 case} EXCEPTION_DIVIDE_BY_ZERO:\par
00037         dividebyzero_handler(ctx, intfr);\par
00038         {\cf19 break};\par
00039     {\cf19 case} EXCEPTION_SINGLE_STEP:\par
00040         debugsinglestep_handler(ctx, intfr);\par
00041         {\cf19 break};\par
00042     {\cf19 case} EXCEPTION_NON_MASKABLE_INTERRUPT:\par
00043         _MtSetIRQL(HIGH_LEVEL); {\cf20 // Non Maskable Interrupt - basically when the CPU encounters a hardware fault, cannot be masked, very alarming.}\par
00044         nmi_handler(ctx, intfr);\par
00045         {\cf19 break};\par
00046     {\cf19 case} EXCEPTION_BREAKPOINT:\par
00047         breakpoint_handler(ctx, intfr);\par
00048         {\cf19 break};\par
00049     {\cf19 case} EXCEPTION_OVERFLOW:\par
00050         overflow_handler(ctx, intfr);\par
00051         {\cf19 break};\par
00052     {\cf19 case} EXCEPTION_BOUNDS_CHECK:\par
00053         boundscheck_handler(ctx, intfr);\par
00054         {\cf19 break};\par
00055     {\cf19 case} EXCEPTION_INVALID_OPCODE:\par
00056         invalidopcode_handler(ctx, intfr);\par
00057         {\cf19 break};\par
00058     {\cf19 case} EXCEPTION_NO_COPROCESSOR:\par
00059         nocoprocessor_handler(ctx, intfr);\par
00060         {\cf19 break};\par
00061     {\cf19 case} EXCEPTION_DOUBLE_FAULT:\par
00062         _MtSetIRQL(HIGH_LEVEL);\par
00063         doublefault_handler(ctx, intfr);\par
00064         {\cf19 break};\par
00065     {\cf19 case} EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN:\par
00066         coprocessor_segment_overrun_handler(ctx, intfr);\par
00067         {\cf19 break};\par
00068     {\cf19 case} EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT:\par
00069         segment_selector_not_present_handler(ctx, intfr);\par
00070         {\cf19 break};\par
00071     {\cf19 case} EXCEPTION_INVALID_TSS:\par
00072         invalidtss_handler(ctx, intfr);\par
00073         {\cf19 break};\par
00074     {\cf19 case} EXCEPTION_GENERAL_PROTECTION_FAULT:\par
00075         gpf_handler(ctx, intfr);\par
00076         {\cf19 break};\par
00077     {\cf19 case} EXCEPTION_PAGE_FAULT:\par
00078         pagefault_handler(ctx, intfr);\par
00079         {\cf19 break};\par
00080     {\cf19 case} EXCEPTION_RESERVED:\par
00081         {\cf20 // reserved, do not use.}\par
00082         {\cf19 break};\par
00083     {\cf19 case} EXCEPTION_FLOATING_POINT_ERROR:\par
00084         fpu_handler(ctx, intfr);\par
00085         {\cf19 break};\par
00086     {\cf19 case} EXCEPTION_ALIGNMENT_CHECK:\par
00087         alignment_check_handler(ctx, intfr);\par
00088         {\cf19 break};\par
00089     {\cf19 case} EXCEPTION_SEVERE_MACHINE_CHECK:\par
00090         _MtSetIRQL(HIGH_LEVEL); {\cf20 // machine check, like NMI, high irql.}\par
00091         severe_machine_check_handler(ctx, intfr);\par
00092         {\cf19 break};\par
00093     {\cf19 case} KEYBOARD_INTERRUPT:\par
00094         MtRaiseIRQL(DIRQL_KEYBOARD, &oldIrql);\par
00095         keyboard_handler();\par
00096         MtLowerIRQL(oldIrql);\par
00097         {\cf19 break};\par
00098     {\cf19 case} LAPIC_INTERRUPT:\par
00099         MtRaiseIRQL(DIRQL_TIMER, &oldIrql);\par
00100         lapic_handler(schedulerEnabled);\par
00101         MtLowerIRQL(oldIrql);\par
00102         {\cf19 break};\par
00103     {\cf19 default}:\par
00104         gop_printf(0xFFFF0000, {\cf22 "Interrupt Exception: "});\par
00105         gop_printf(0xFFFFFFFF, {\cf22 "%d\\r\\n"}, vec_num);\par
00106         {\cf19 break};\par
00107     \}\par
00108 \}\par
00109 \par
00110 {\cf18 void} init_interrupts() \{\par
00111     install_idt();\par
00112     _MtSetIRQL(PASSIVE_LEVEL);\par
00113 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/atomic.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/atomic.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/atomic.h}
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
atomic.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/atomic.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/atomic.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Atomic Functions for the kernel.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef ATOMIC_H}\par
00007 {\cf21 #define ATOMIC_H}\par
00008 \par
00009 {\cf21 #include <stdint.h>}\par
00010 \par
00011 {\cf20 // atomic.h}\par
00012 {\cf20 // Pure GCC/C11 inline-asm implementations of Windows-like Interlocked functions}\par
00013 \par
00020 {\cf17 static} {\cf17 inline} int32_t InterlockedExchange32({\cf17 volatile} int32_t* target, int32_t value)\par
00021 \{\par
00022     __asm__ {\cf17 volatile}(\par
00023         {\cf22 "xchg %0, %1"}\par
00024         : {\cf22 "+r"}(value), {\cf22 "+m"}(*target)\par
00025         :\par
00026         : {\cf22 "memory"}\par
00027         );\par
00028     {\cf19 return} value;\par
00029 \}\par
00030 \par
00037 {\cf17 static} {\cf17 inline} int64_t InterlockedExchange64({\cf17 volatile} int64_t* target, int64_t value)\par
00038 \{\par
00039     __asm__ {\cf17 volatile}(\par
00040         {\cf22 "xchg %0, %1"}\par
00041         : {\cf22 "+r"}(value), {\cf22 "+m"}(*target)\par
00042         :\par
00043         : {\cf22 "memory"}\par
00044         );\par
00045     {\cf19 return} value;\par
00046 \}\par
00047 \par
00054 {\cf17 static} {\cf17 inline} {\cf18 void}* InterlockedExchangePtr({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target, {\cf18 void}* value)\par
00055 \{\par
00056     __asm__ {\cf17 volatile}(\par
00057         {\cf22 "xchg %0, %1"}\par
00058         : {\cf22 "+r"}(value), {\cf22 "+m"}(*target)\par
00059         :\par
00060         : {\cf22 "memory"}\par
00061         );\par
00062     {\cf19 return} value;\par
00063 \}\par
00064 \par
00072 {\cf17 static} {\cf17 inline} int32_t InterlockedCompareExchange32({\cf17 volatile} int32_t* target, int32_t value, int32_t comparand)\par
00073 \{\par
00074     __asm__ {\cf17 volatile}(\par
00075         {\cf22 "lock cmpxchg %2, %1"}\par
00076         : {\cf22 "+a"}(comparand), {\cf22 "+m"}(*target)\par
00077         : {\cf22 "r"}(value)\par
00078         : {\cf22 "memory"}\par
00079         );\par
00080     {\cf19 return} comparand;\par
00081 \}\par
00082 \par
00090 {\cf17 static} {\cf17 inline} int64_t InterlockedCompareExchange64({\cf17 volatile} int64_t* target, int64_t value, int64_t comparand)\par
00091 \{\par
00092     __asm__ {\cf17 volatile}(\par
00093         {\cf22 "lock cmpxchg %2, %1"}\par
00094         : {\cf22 "+a"}(comparand), {\cf22 "+m"}(*target)\par
00095         : {\cf22 "r"}(value)\par
00096         : {\cf22 "memory"}\par
00097         );\par
00098     {\cf19 return} comparand;\par
00099 \}\par
00100 \par
00108 {\cf17 static} {\cf17 inline} {\cf18 void}* InterlockedCompareExchangePtr({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target, {\cf18 void}* value, {\cf18 void}* comparand)\par
00109 \{\par
00110     {\cf18 void}* prev;\par
00111     __asm__ {\cf17 volatile}(\par
00112         {\cf22 "lock cmpxchg %2, %1"}\par
00113         : {\cf22 "+a"}(comparand), {\cf22 "+m"}(*target)\par
00114         : {\cf22 "r"}(value)\par
00115         : {\cf22 "memory"}\par
00116         );\par
00117     prev = comparand;\par
00118     {\cf19 return} prev;\par
00119 \}\par
00120 \par
00127 {\cf17 static} {\cf17 inline} int32_t InterlockedAdd32({\cf17 volatile} int32_t* target, int32_t value)\par
00128 \{\par
00129     __asm__ {\cf17 volatile}(\par
00130         {\cf22 "lock xadd %0, %1"}\par
00131         : {\cf22 "+r"}(value), {\cf22 "+m"}(*target)\par
00132         :\par
00133         : {\cf22 "memory"}\par
00134         );\par
00135     {\cf19 return} value + *target; {\cf20 /* value now holds original, so add*/}\par
00136 \}\par
00137 \par
00143 {\cf17 static} {\cf17 inline} int32_t InterlockedIncrement32({\cf17 volatile} int32_t* target)\par
00144 \{\par
00145     {\cf19 return} InterlockedAdd32(target, 1);\par
00146 \}\par
00147 \par
00153 {\cf17 static} {\cf17 inline} int32_t InterlockedDecrement32({\cf17 volatile} int32_t* target)\par
00154 \{\par
00155     {\cf19 return} InterlockedAdd32(target, -1);\par
00156 \}\par
00157 \par
00164 {\cf17 static} {\cf17 inline} int32_t InterlockedAnd32({\cf17 volatile} int32_t* target, int32_t value)\par
00165 \{\par
00166     __asm__ {\cf17 volatile}(\par
00167         {\cf22 "lock and %1, %0"}\par
00168         : {\cf22 "+m"}(*target)\par
00169         : {\cf22 "r"}(value)\par
00170         : {\cf22 "memory"}\par
00171         );\par
00172     {\cf19 return} *target;\par
00173 \}\par
00174 \par
00181 {\cf17 static} {\cf17 inline} int32_t InterlockedOr32({\cf17 volatile} int32_t* target, int32_t value)\par
00182 \{\par
00183     __asm__ {\cf17 volatile}(\par
00184         {\cf22 "lock or %1, %0"}\par
00185         : {\cf22 "+m"}(*target)\par
00186         : {\cf22 "r"}(value)\par
00187         : {\cf22 "memory"}\par
00188         );\par
00189     {\cf19 return} *target;\par
00190 \}\par
00191 \par
00192 {\cf21 #endif }{\cf20 /* ATOMIC_H */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/intrin.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/intrin.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/intrin.h}
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC1_COMMAND_MASTER}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC1_DATA}\~ 0x21\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC2_COMMAND_SLAVE}\~ 0xA0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC2_DATA}\~ 0xA1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC_EOI}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNREFERENCED_PARAMETER}(x)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PIC1_COMMAND_MASTER\:intrin.h}
{\xe \v intrin.h\:PIC1_COMMAND_MASTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC1_COMMAND_MASTER\~ 0x20}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b intrin.h}.}\par
}
{\xe \v PIC1_DATA\:intrin.h}
{\xe \v intrin.h\:PIC1_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC1_DATA\~ 0x21}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b intrin.h}.}\par
}
{\xe \v PIC2_COMMAND_SLAVE\:intrin.h}
{\xe \v intrin.h\:PIC2_COMMAND_SLAVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC2_COMMAND_SLAVE\~ 0xA0}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b intrin.h}.}\par
}
{\xe \v PIC2_DATA\:intrin.h}
{\xe \v intrin.h\:PIC2_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC2_DATA\~ 0xA1}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b intrin.h}.}\par
}
{\xe \v PIC_EOI\:intrin.h}
{\xe \v intrin.h\:PIC_EOI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC_EOI\~ 0x20}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b intrin.h}.}\par
}
{\xe \v UNREFERENCED_PARAMETER\:intrin.h}
{\xe \v intrin.h\:UNREFERENCED_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNREFERENCED_PARAMETER( x)}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (void)(x)\par
}
{
Definition at line {\b 19} of file {\b intrin.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
intrin.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/intrin.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrin/intrin.h}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Intrinsics for easy assembly use.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_INTRINSICS_H}\par
00007 {\cf21 #define X86_INTRINSICS_H}\par
00008 \par
00009  {\cf20 // PIC Ports}\par
00010 {\cf21 #define PIC1_COMMAND_MASTER 0x20}\par
00011 {\cf21 #define PIC1_DATA           0x21}\par
00012 {\cf21 #define PIC2_COMMAND_SLAVE  0xA0}\par
00013 {\cf21 #define PIC2_DATA           0xA1}\par
00014 \par
00015 {\cf20 // End of Interrupt command code}\par
00016 {\cf21 #define PIC_EOI 0x20}\par
00017 \par
00018 {\cf21 #ifndef UNREFERENCED_PARAMETER}\par
00019 {\cf21 #define UNREFERENCED_PARAMETER(x) (void)(x)}\par
00020 {\cf21 #endif}\par
00021 \par
00022 {\cf21 #ifdef _MSC_VER}\par
00023 {\cf21 #ifndef __asm__}\par
00024 {\cf21 #define __asm__ __asm}\par
00025 {\cf21 #endif}\par
00026 {\cf21 #endif}\par
00027 \par
00028 {\cf20 // Disable interrupts (cli)}\par
00029 {\cf17 static} {\cf17 inline} {\cf18 void} __cli({\cf18 void}) \{\par
00030     __asm__ {\cf17 volatile} ({\cf22 "cli"});\par
00031 \}\par
00032 \par
00033 {\cf20 // Enable interrupts (sti)}\par
00034 {\cf17 static} {\cf17 inline} {\cf18 void} __sti({\cf18 void}) \{\par
00035     __asm__ {\cf17 volatile} ({\cf22 "sti"});\par
00036 \}\par
00037 \par
00038 {\cf20 // Halt CPU until next interrupt (hlt)}\par
00039 {\cf17 static} {\cf17 inline} {\cf18 void} __hlt({\cf18 void}) \{\par
00040     __asm__ {\cf17 volatile} ({\cf22 "hlt"});\par
00041 \}\par
00042 \par
00043 {\cf20 // Read CR0 register}\par
00044 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} {\cf18 int} __read_cr0({\cf18 void}) \{\par
00045     {\cf18 unsigned} {\cf18 long} {\cf18 int} val;\par
00046     __asm__ {\cf17 volatile} ({\cf22 "mov %%cr0, %0"} : {\cf22 "=r"}(val));\par
00047     {\cf19 return} val;\par
00048 \}\par
00049 \par
00050 {\cf20 // Write CR0 register}\par
00051 {\cf17 static} {\cf17 inline} {\cf18 void} __write_cr0({\cf18 unsigned} {\cf18 long} {\cf18 int} val) \{\par
00052     __asm__ {\cf17 volatile} ({\cf22 "mov %0, %%cr0"} :: {\cf22 "r"}(val));\par
00053 \}\par
00054 \par
00055 {\cf20 // CR2 (Page fault linear address)}\par
00056 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} __read_cr2({\cf18 void}) \{\par
00057     {\cf18 unsigned} {\cf18 long} val;\par
00058     __asm__ {\cf17 volatile}({\cf22 "mov %%cr2, %0"} : {\cf22 "=r"}(val));\par
00059     {\cf19 return} val;\par
00060 \}\par
00061 \par
00062 {\cf17 static} {\cf17 inline} {\cf18 void} __write_cr2({\cf18 unsigned} {\cf18 long} val) \{\par
00063     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr2"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00064 \}\par
00065 \par
00066 {\cf20 // CR3 (Page table base address)}\par
00067 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} __read_cr3({\cf18 void}) \{\par
00068     {\cf18 unsigned} {\cf18 long} val;\par
00069     __asm__ {\cf17 volatile}({\cf22 "mov %%cr3, %0"} : {\cf22 "=r"}(val));\par
00070     {\cf19 return} val;\par
00071 \}\par
00072 {\cf17 static} {\cf17 inline} {\cf18 void} __write_cr3({\cf18 unsigned} {\cf18 long} val) \{\par
00073     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr3"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00074 \}\par
00075 \par
00076 {\cf20 // CR4 (Feature control)}\par
00077 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} __read_cr4({\cf18 void}) \{\par
00078     {\cf18 unsigned} {\cf18 long} val;\par
00079     __asm__ {\cf17 volatile}({\cf22 "mov %%cr4, %0"} : {\cf22 "=r"}(val));\par
00080     {\cf19 return} val;\par
00081 \}\par
00082 {\cf17 static} {\cf17 inline} {\cf18 void} __write_cr4({\cf18 unsigned} {\cf18 long} val) \{\par
00083     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr4"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00084 \}\par
00085 \par
00086 {\cf20 // CR8 (Task Priority Register, x86-64 only)}\par
00087 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} __read_cr8({\cf18 void}) \{\par
00088     {\cf18 unsigned} {\cf18 long} val;\par
00089     __asm__ {\cf17 volatile}({\cf22 "mov %%cr8, %0"} : {\cf22 "=r"}(val));\par
00090     {\cf19 return} val;\par
00091 \}\par
00092 {\cf17 static} {\cf17 inline} {\cf18 void} __write_cr8({\cf18 unsigned} {\cf18 long} val) \{\par
00093     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr8"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00094 \}\par
00095 \par
00096 \par
00097 {\cf20 // Read DRx register (dr0-dr7) (Usage __read_dr(3) = will return dr3.}\par
00098 {\cf17 static} {\cf17 inline} uint64_t __read_dr({\cf18 int} reg) \{\par
00099     {\cf18 unsigned} {\cf18 long} val = 0;\par
00100     {\cf19 switch} (reg) \{\par
00101         {\cf19 case} 0: __asm__ {\cf17 volatile}({\cf22 "mov %%dr0, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00102         {\cf19 case} 1: __asm__ {\cf17 volatile}({\cf22 "mov %%dr1, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00103         {\cf19 case} 2: __asm__ {\cf17 volatile}({\cf22 "mov %%dr2, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00104         {\cf19 case} 3: __asm__ {\cf17 volatile}({\cf22 "mov %%dr3, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00105         {\cf19 case} 6: __asm__ {\cf17 volatile}({\cf22 "mov %%dr6, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00106         {\cf19 case} 7: __asm__ {\cf17 volatile}({\cf22 "mov %%dr7, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00107         {\cf19 default}: {\cf19 break};\par
00108     \}\par
00109     {\cf19 return} val;\par
00110 \}\par
00111 \par
00112 {\cf20 // Write DRx register (dr0-dr7) (Usage __write_dr(3, 0x5000) = will write 0x5000 to dr3.}\par
00113 {\cf17 static} {\cf17 inline} {\cf18 void} __write_dr({\cf18 int} reg, uint64_t val) \{\par
00114     {\cf19 switch} (reg) \{\par
00115         {\cf19 case} 0: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr0"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00116         {\cf19 case} 1: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr1"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00117         {\cf19 case} 2: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr2"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00118         {\cf19 case} 3: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr3"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00119         {\cf19 case} 6: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr6"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00120         {\cf19 case} 7: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr7"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00121         {\cf19 default}: {\cf19 break};\par
00122     \}\par
00123 \}\par
00124 {\cf17 static} {\cf17 inline} {\cf18 void} __lidt({\cf18 void}* idt_ptr) \{\par
00125     __asm__ {\cf17 volatile} ({\cf22 "lidt (%0)"} :: {\cf22 "r"}(idt_ptr));\par
00126 \}\par
00127 \par
00128 {\cf20 // Read RFLAGS register}\par
00129 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 long} {\cf18 int} __read_rflags({\cf18 void}) \{\par
00130     {\cf18 unsigned} {\cf18 long} {\cf18 int} rflags;\par
00131     __asm__ {\cf17 volatile} (\par
00132         {\cf22 "pushfl\\n\\t"}\par
00133         {\cf22 "pop %0"}\par
00134         : {\cf22 "=r"}(rflags)\par
00135         );\par
00136     {\cf19 return} rflags;\par
00137 \}\par
00138 \par
00139 {\cf20 // Write RFLAGS register}\par
00140 {\cf17 static} {\cf17 inline} {\cf18 void} __write_rflags({\cf18 unsigned} {\cf18 long} {\cf18 int} rflags) \{\par
00141     __asm__ {\cf17 volatile} (\par
00142         {\cf22 "push %0\\n\\t"}\par
00143         {\cf22 "popfl"}\par
00144         :: {\cf22 "r"}(rflags)\par
00145         );\par
00146 \}\par
00147 \par
00148 {\cf20 // Read port (inw)}\par
00149 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 short} __inword({\cf18 unsigned} {\cf18 short} port) \{\par
00150     {\cf18 unsigned} {\cf18 short} ret;\par
00151     __asm__ {\cf17 volatile} ({\cf22 "inw %1, %0"} : {\cf22 "=a"}(ret) : {\cf22 "Nd"}(port));\par
00152     {\cf19 return} ret;\par
00153 \}\par
00154 \par
00155 {\cf20 // Write port (outw)}\par
00156 {\cf17 static} {\cf17 inline} {\cf18 void} __outword({\cf18 unsigned} {\cf18 short} port, {\cf18 unsigned} {\cf18 short} val) \{\par
00157     __asm__ {\cf17 volatile} ({\cf22 "outw %0, %1"} : : {\cf22 "a"}(val), {\cf22 "Nd"}(port));\par
00158 \}\par
00159 \par
00160 {\cf20 // Read port (inb)}\par
00161 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 char} __inbyte({\cf18 unsigned} {\cf18 short} port) \{\par
00162     {\cf18 unsigned} {\cf18 char} ret;\par
00163     __asm__ {\cf17 volatile} ({\cf22 "inb %1, %0"} : {\cf22 "=a"}(ret) : {\cf22 "Nd"}(port));\par
00164     {\cf19 return} ret;\par
00165 \}\par
00166 \par
00167 {\cf20 // Write port (outb)}\par
00168 {\cf17 static} {\cf17 inline} {\cf18 void} __outbyte({\cf18 unsigned} {\cf18 short} port, {\cf18 unsigned} {\cf18 char} val) \{\par
00169     __asm__ {\cf17 volatile} ({\cf22 "outb %0, %1"} :: {\cf22 "a"}(val), {\cf22 "Nd"}(port));\par
00170 \}\par
00171 \par
00172 {\cf17 static} {\cf17 inline} {\cf18 void} send_eoi({\cf18 unsigned} {\cf18 char} irq) \{\par
00173     {\cf19 if} (irq >= 8) \{\par
00174         __outbyte(PIC2_COMMAND_SLAVE, PIC_EOI);  {\cf20 // Slave PIC}\par
00175     \}\par
00176     __outbyte(PIC1_COMMAND_MASTER, PIC_EOI);      {\cf20 // Master PIC}\par
00177 \}\par
00178 \par
00179 {\cf17 static} {\cf17 inline} {\cf18 void} invlpg({\cf18 void}* m) \{\par
00180     __asm__ {\cf17 volatile}({\cf22 "invlpg (%0)"} : : {\cf22 "b"}(m) : {\cf22 "memory"});\par
00181 \}\par
00182 \par
00183 {\cf17 static} {\cf17 inline} uint64_t __readmsr(uint32_t msr) \{\par
00184     uint32_t lo, hi;\par
00185     __asm__ {\cf17 volatile} ({\cf22 "rdmsr"} : {\cf22 "=a"}(lo), {\cf22 "=d"}(hi) : {\cf22 "c"}(msr));\par
00186     {\cf19 return} ((uint64_t)hi << 32) | lo;\par
00187 \}\par
00188 \par
00189 {\cf17 static} {\cf17 inline} {\cf18 void} __writemsr(uint32_t msr, uint64_t value) \{\par
00190     uint32_t lo = value & 0xFFFFFFFF;\par
00191     uint32_t hi = value >> 32;\par
00192     __asm__ {\cf17 volatile} ({\cf22 "wrmsr"} : : {\cf22 "c"}(msr), {\cf22 "a"}(lo), {\cf22 "d"}(hi));\par
00193 \}\par
00194 \par
00195 {\cf17 static} {\cf17 inline} uint64_t __read_rbp({\cf18 void}) \{\par
00196     uint64_t val;\par
00197     __asm__ {\cf17 volatile} ({\cf22 "mov %%rbp, %0"} : {\cf22 "=r"}(val));\par
00198     {\cf19 return} val;\par
00199 \}\par
00200 \par
00201 {\cf17 static} {\cf17 inline} uint64_t __read_rsp({\cf18 void}) \{\par
00202     uint64_t val;\par
00203     __asm__ {\cf17 volatile} ({\cf22 "mov %%rsp, %0"} : {\cf22 "=r"}(val));\par
00204     {\cf19 return} val;\par
00205 \}\par
00206 \par
00207 {\cf17 static} {\cf17 inline} uint64_t __read_rip({\cf18 void}) \{\par
00208     uint64_t rip;\par
00209     __asm__ {\cf17 volatile} ({\cf22 "leaq (%%rip), %0"} : {\cf22 "=r"}(rip));\par
00210     {\cf19 return} rip;\par
00211 \}\par
00212 \par
00213 {\cf17 static} {\cf17 inline} {\cf18 void} __pause({\cf18 void}) \{\par
00214     __asm__ {\cf17 volatile}({\cf22 "pause"} ::: {\cf22 "memory"});\par
00215 \}\par
00216 \par
00217 {\cf17 static} {\cf17 inline} uint64_t __readgsqword(uint64_t offset) \{\par
00218     uint64_t value;\par
00219     __asm__ {\cf17 volatile} (\par
00220         {\cf22 "movq %%gs:(%1), %0"}\par
00221         : {\cf22 "=r"}(value)\par
00222         : {\cf22 "r"}(offset)\par
00223         : {\cf22 "memory"}\par
00224         );\par
00225     {\cf19 return} value;\par
00226 \}\par
00227 \par
00228 {\cf17 static} {\cf17 inline} uint64_t __readfsqword(uint64_t offset) \{\par
00229     uint64_t value;\par
00230     __asm__ {\cf17 volatile} (\par
00231         {\cf22 "movq %%fs:(%1), %0"}\par
00232         : {\cf22 "=r"}(value)\par
00233         : {\cf22 "r"}(offset)\par
00234         : {\cf22 "memory"}\par
00235         );\par
00236     {\cf19 return} value;\par
00237 \}\par
00238 \par
00239 \par
00240 {\cf21 #endif }{\cf20 // X86_INTRINSICS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "kernel.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_AHCI_CONTROLLERS}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MEMORY_MAP_SIZE}\~ 0x4000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISRAEL_UTC_OFFSET}\~ 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_memory_map} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_gop} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_boot_info} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitCPU} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_idle_checks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_main} ({\b BOOT_INFO} *boot_info)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b ahci_bases_local} [{\b MAX_AHCI_CONTROLLERS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBugChecking} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LASTFUNC_HISTORY} {\b lastfunc_history} = \{ .current_index = -1 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPU} {\b cpu}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ISRAEL_UTC_OFFSET\:kernel.c}
{\xe \v kernel.c\:ISRAEL_UTC_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISRAEL_UTC_OFFSET\~ 3}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MAX_AHCI_CONTROLLERS\:kernel.c}
{\xe \v kernel.c\:MAX_AHCI_CONTROLLERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_AHCI_CONTROLLERS\~ 32}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b kernel.c}.}\par
}
{\xe \v MAX_MEMORY_MAP_SIZE\:kernel.c}
{\xe \v kernel.c\:MAX_MEMORY_MAP_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MEMORY_MAP_SIZE\~ 0x4000}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b kernel.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v copy_gop\:kernel.c}
{\xe \v kernel.c\:copy_gop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_gop ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b kernel.c}.}\par
}
{\xe \v copy_memory_map\:kernel.c}
{\xe \v kernel.c\:copy_memory_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_memory_map ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b kernel.c}.}\par
}
{\xe \v init_boot_info\:kernel.c}
{\xe \v kernel.c\:init_boot_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_boot_info ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b kernel.c}.}\par
}
{\xe \v InitCPU\:kernel.c}
{\xe \v kernel.c\:InitCPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitCPU (void )}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b kernel.c}.}\par
}
{\xe \v kernel_idle_checks\:kernel.c}
{\xe \v kernel.c\:kernel_idle_checks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_idle_checks (void )}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b kernel.c}.}\par
}
{\xe \v kernel_main\:kernel.c}
{\xe \v kernel.c\:kernel_main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_main ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remember that paging is on when this is called, as UEFI turned it on. \par
}{
Definition at line {\b 153} of file {\b kernel.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ahci_bases_local\:kernel.c}
{\xe \v kernel.c\:ahci_bases_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t ahci_bases_local[{\b MAX_AHCI_CONTROLLERS}]}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b kernel.c}.}\par
}
{\xe \v boot_info_local\:kernel.c}
{\xe \v kernel.c\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b kernel.c}.}\par
}
{\xe \v cpu\:kernel.c}
{\xe \v kernel.c\:cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPU} cpu}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b kernel.c}.}\par
}
{\xe \v gop_local\:kernel.c}
{\xe \v kernel.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
{\xe \v isBugChecking\:kernel.c}
{\xe \v kernel.c\:isBugChecking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBugChecking = false}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b kernel.c}.}\par
}
{\xe \v lastfunc_history\:kernel.c}
{\xe \v kernel.c\:lastfunc_history}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LASTFUNC_HISTORY} lastfunc_history = \{ .current_index = -1 \}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
kernel.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Core Kernel Entry Point for MatanelOS.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "kernel.h"}\par
00008 {\cf21 #ifndef _MSC_VER}\par
00009 {\cf17 _Static_assert}({\cf17 sizeof}({\cf18 void}*) == 8, {\cf22 "This Kernel is 64 bit only! The 32bit version is deprecated."});\par
00010 {\cf21 #endif}\par
00011 \par
00012 {\cf21 #define MAX_AHCI_CONTROLLERS 32}\par
00013 uint64_t ahci_bases_local[MAX_AHCI_CONTROLLERS];\par
00014 \par
00015 GOP_PARAMS gop_local;\par
00016 BOOT_INFO boot_info_local;\par
00017 \par
00018 {\cf20 /*}\par
00019 {\cf20 Global variables initialization}\par
00020 {\cf20 */}\par
00021 {\cf18 bool} isBugChecking = {\cf17 false};\par
00022 LASTFUNC_HISTORY lastfunc_history = \{ .current_index = -1 \};\par
00023 CPU cpu;\par
00024 \par
00025 {\cf20 //DECLARE_THREAD(workerThread, 4096)}\par
00026 {\cf20 /*}\par
00027 {\cf20 Ended}\par
00028 {\cf20 */}\par
00029 {\cf21 #define MAX_MEMORY_MAP_SIZE 0x4000  }{\cf20 // 16 KB, enough for ~256 descriptors}\par
00030 \par
00031 {\cf17 static} EFI_MEMORY_DESCRIPTOR memory_map_copy[MAX_MEMORY_MAP_SIZE / {\cf17 sizeof}(EFI_MEMORY_DESCRIPTOR)];\par
00032 \par
00033 {\cf18 void} copy_memory_map(BOOT_INFO* boot_info) \{\par
00034     {\cf19 if} (!boot_info || !boot_info->MemoryMap) {\cf19 return};\par
00035     {\cf19 if} (boot_info->MapSize > MAX_MEMORY_MAP_SIZE) \{\par
00036         {\cf20 // handle error, memory map too big}\par
00037         MtBugcheck(NULL, NULL, MEMORY_MAP_SIZE_OVERRUN, 0, {\cf17 false});\par
00038     \}\par
00039 \par
00040     {\cf20 // Copy the entire memory map into the static buffer}\par
00041     kmemcpy(memory_map_copy, boot_info->MemoryMap, boot_info->MapSize);\par
00042 \par
00043     boot_info_local.MemoryMap = memory_map_copy;\par
00044     boot_info_local.MapSize = boot_info->MapSize;\par
00045     boot_info_local.DescriptorSize = boot_info->DescriptorSize;\par
00046     boot_info_local.DescriptorVersion = boot_info->DescriptorVersion;\par
00047 \}\par
00048 \par
00049 {\cf18 void} copy_gop(BOOT_INFO* boot_info) \{\par
00050     {\cf19 if} (!boot_info || !boot_info->Gop) {\cf19 return};\par
00051 \par
00052     {\cf20 // Copy the GOP data to a local global variable}\par
00053     gop_local = *(boot_info->Gop);\par
00054 \par
00055     {\cf20 // Update all relevant pointers to point to the local copy}\par
00056     boot_info->Gop = &gop_local;\par
00057     boot_info_local.Gop = &gop_local;\par
00058 \}\par
00059 \par
00060 \par
00061 {\cf18 void} init_boot_info(BOOT_INFO* boot_info) \{\par
00062     {\cf19 if} (!boot_info) {\cf19 return};\par
00063 \par
00064     copy_memory_map(boot_info);\par
00065     copy_gop(boot_info);\par
00066     {\cf19 if} (boot_info->AhciCount > MAX_AHCI_CONTROLLERS) \{\par
00067         MtBugcheck(NULL, NULL, BAD_AHCI_COUNT, 0, {\cf17 false});\par
00068     \}\par
00069     {\cf19 for} (uint32_t i = 0; i < boot_info->AhciCount; i++) \{\par
00070         ahci_bases_local[i] = boot_info->AhciBarBases[i];\par
00071     \}\par
00072     boot_info_local.AhciBarBases = ahci_bases_local;\par
00073     boot_info_local.AhciCount = boot_info->AhciCount;\par
00074     boot_info_local.KernelStackTop = boot_info->KernelStackTop;\par
00075     boot_info_local.Pml4Phys = boot_info->Pml4Phys;\par
00076 \}\par
00077 \par
00078 {\cf17 static} {\cf18 void} InitialiseControlRegisters({\cf18 void}) \{\par
00079 \par
00080     {\cf20 /* CR0 */}\par
00081     {\cf18 unsigned} {\cf18 long} cr0 = __read_cr0();\par
00082     cr0 |= (1UL << 16); {\cf20 // Set bit 16 (WRITE PROTECT), so when the kernel touches read only memory it would #PF.}\par
00083 {\cf21 #ifdef DEBUG}\par
00084     cr0 |= (1UL << 30); {\cf20 // Set bit 30 (CACHE DISABLE).}\par
00085 {\cf21 #endif}\par
00086     __write_cr0(cr0);\par
00087 \par
00088     {\cf20 /* CR4 */}\par
00089     {\cf18 unsigned} {\cf18 long} cr4 = __read_cr4();\par
00090     cr4 |= (1UL << 11); {\cf20 // Set bit 11 - User Mode Instruction Prevention. This'll be useful against user mode attacks to locate IDT/GDT/LDT...}\par
00091     __write_cr4(cr4);\par
00092 \}\par
00093 \par
00094 {\cf18 void} InitCPU({\cf18 void}) \{\par
00095     cpu.currentIrql = PASSIVE_LEVEL;\par
00096     cpu.schedulerEnabled = NULL; {\cf20 // since NULL is 0, it would be false.}\par
00097     cpu.currentThread = NULL;\par
00098     cpu.readyQueue.head = cpu.readyQueue.tail = NULL;\par
00099 \}\par
00100 \par
00101 {\cf17 static} {\cf17 inline} {\cf18 bool} interrupts_enabled({\cf18 void}) \{\par
00102     {\cf18 unsigned} {\cf18 long} flags;\par
00103     __asm__ __volatile__({\cf22 "pushfq; popq %0"} : {\cf22 "=r"}(flags));\par
00104     {\cf19 return} (flags & (1UL << 9)) != 0; {\cf20 // IF is bit 9}\par
00105 \}\par
00106 \par
00107 {\cf18 void} kernel_idle_checks({\cf18 void}) \{\par
00108     tracelast_func({\cf22 "kernel_idle_checks - Thread"});\par
00109     {\cf17 static} {\cf17 volatile} {\cf18 bool} first_time = {\cf17 true};\par
00110 \par
00111     {\cf19 if} (first_time) \{\par
00112         first_time = {\cf17 false};\par
00113         gop_printf_forced(0xFF000FF0, {\cf22 "Reached the scheduler!\\n"});\par
00114         {\cf19 for} ({\cf17 volatile} uint64_t i = 0; i < 100000000ULL; ++i) \{\par
00115             {\cf20 /* delay loop */}\par
00116         \}\par
00117 \par
00118         gop_printf_forced(0xFF000FF0, {\cf22 "**Ended Testing Thread Execution**\\n"});\par
00119     \}\par
00120     {\cf20 /*}\par
00121 {\cf20     assert((interrupts_enabled()) == true, "Interrupts are not enabled...");}\par
00122 {\cf20     */}\par
00123     {\cf19 while} (1) \{\par
00124         __hlt();\par
00125     \}\par
00126 \}\par
00127 \par
00128 {\cf17 static} {\cf18 void} test({\cf18 void}) \{\par
00129     tracelast_func({\cf22 "test - Thread"});\par
00130     gop_printf_forced(0xFF00FF00, {\cf22 "Hit Test!\\n"});\par
00131     {\cf17 volatile} uint64_t z = 0;\par
00132     {\cf19 for} (uint64_t i = 0; i < 0xFFFFFFF; i++) \{\par
00133         z++;\par
00134     \}\par
00135     Thread* currentThread = MtGetCurrentThread();\par
00136     gop_printf(COLOR_OLIVE, {\cf22 "Current thread in test: %p\\n"}, currentThread);\par
00137     gop_printf_forced(0xFFA020F0, {\cf22 "**Ended Test.**\\n"});\par
00138 \}\par
00139 \par
00140 {\cf17 static} {\cf18 void} funcWithParam({\cf18 int}* integer) \{\par
00141     tracelast_func({\cf22 "funcWithParam - Thread"});\par
00142     gop_printf_forced(COLOR_OLIVE, {\cf22 "Hit funcWithParam, Integer: %d\\n"}, *integer);\par
00143     {\cf17 volatile} uint64_t z = 0;\par
00144     {\cf19 for} (uint64_t i = 0; i < 0xFFFFFFF; i++) \{\par
00145         z++;\par
00146     \}\par
00147     Thread* currentThread = MtGetCurrentThread();\par
00148     gop_printf(COLOR_OLIVE, {\cf22 "Current thread in funcWithParam: %p\\n"}, currentThread);\par
00149     gop_printf_forced(COLOR_OLIVE, {\cf22 "**Ended funcWithParam.**\\n"});\par
00150 \}\par
00151 \par
00153 {\cf18 void} kernel_main(BOOT_INFO* boot_info) \{\par
00154     {\cf20 //tracelast_func("kernel_main");}\par
00155     {\cf20 // 1. CORE SYSTEM INITIALIZATION}\par
00156     __cli();\par
00157     {\cf20 // Initialize the CR (Control Registers) registers to our settings.}\par
00158     InitialiseControlRegisters();\par
00159     {\cf20 // Zero the BSS.}\par
00160     zero_bss();\par
00161     {\cf20 // Create the local boot struct.}\par
00162     init_boot_info(boot_info);\par
00163     {\cf20 // Initialize the global CPU struct.}\par
00164     InitCPU();\par
00165     {\cf20 // Initialize interrupts & exceptions.}\par
00166     init_interrupts();\par
00167     {\cf20 // Initialize the frame bitmaps for dynamic frame allocation.}\par
00168     frame_bitmap_init();\par
00169     {\cf20 // Finally, initialize our heap for memory allocation (like threads, processes, structs..)}\par
00170     init_heap();\par
00171     _MtSetIRQL(PASSIVE_LEVEL);\par
00172     {\cf20 /* Initiate Scheduler and DPCs */}\par
00173     InitScheduler();\par
00174     init_dpc_system();\par
00175     gop_clear_screen(&gop_local, 0); {\cf20 // 0 is just black. (0x0000000)}\par
00176     {\cf20 //MemoryTest();}\par
00177     {\cf20 //__cli();}\par
00178     {\cf20 //__hlt();}\par
00179     {\cf17 extern} uint32_t cursor_x, cursor_y;\par
00180     cursor_x = cursor_y = 0; {\cf20 // set to 0, since it somehow decrements them.}\par
00181 \par
00182     uint64_t rip;\par
00183     __asm__ {\cf17 volatile} (\par
00184         {\cf22 "lea 1f(%%rip), %0\\n\\t"}  {\cf20 // Calculate the address of label 1 relative to RIP}\par
00185         {\cf22 "1:"}                     {\cf20 // The label whose address we want}\par
00186         : {\cf22 "=r"}(rip)              {\cf20 // Output to the 'rip' variable}\par
00187         );\par
00188 \par
00189     gop_printf_forced(0xFFFFFF00, {\cf22 "Current RIP: %p\\n"}, rip);\par
00190 \par
00191     {\cf19 if} (rip >= KERNEL_VA_START) \{\par
00192         gop_printf_forced(0x00FF00FF, {\cf22 "**[+] Running in higher-half**\\n"});\par
00193     \}\par
00194     {\cf19 else} \{\par
00195         gop_printf_forced(0xFF0000FF, {\cf22 "[-] Still identity-mapped\\n"});\par
00196     \}\par
00197 \par
00198     {\cf18 void}* buf = MtAllocateVirtualMemory(64, 16);\par
00199     gop_printf_forced(0xFFFFFF00, {\cf22 "buf addr: %p\\n"}, buf);\par
00200     {\cf18 void}* buf2 = MtAllocateVirtualMemory(128, 16);\par
00201     gop_printf_forced(0xFFFFFF00, {\cf22 "buf2 addr: %p\\n"}, buf2);\par
00202     MtFreeVirtualMemory(buf2);\par
00203     {\cf18 void}* buf3 = MtAllocateVirtualMemory(128, 16);\par
00204     gop_printf_forced(0xFFFFFF00, {\cf22 "buf3 addr (should be same as buf2): %p\\n"}, buf3);\par
00205     {\cf18 void}* buf4 = MtAllocateVirtualMemory(2048, 16);\par
00206     gop_printf_forced(0xFF964B00, {\cf22 "buf4 addr (should reside after buf3, allocated 2048 bytes): %p\\n"}, buf4);\par
00207     {\cf18 void}* buf5 = MtAllocateVirtualMemory(64, 16);\par
00208     gop_printf_forced(0xFF964B00, {\cf22 "buf5 addr (should be a larger addr): %p\\n"}, buf5);\par
00209     {\cf18 void}* buf6 = MtAllocateVirtualMemory(5000, 64);\par
00210     gop_printf_forced(0xFFFFFF00, {\cf22 "buf6 addr (should use dynamic memory): %p\\n"}, buf6);\par
00211     {\cf18 void}* buf7 = MtAllocateVirtualMemory(10000, 128);\par
00212     gop_printf_forced(0xFFFFFF00, {\cf22 "buf7 addr (should use dynamic memory, extremely larger): %p\\n"}, buf7);\par
00213     {\cf20 // check}\par
00214     {\cf18 void}* addr = 0;\par
00215     gop_printf(COLOR_ORANGE, {\cf22 "Address: %p is %s\\n"}, addr, MtIsAddressValid(addr) ? {\cf22 "Valid"} : {\cf22 "Invalid"});\par
00216     gop_printf(COLOR_ORANGE, {\cf22 "Address %p (buf7) is %s\\n"}, buf7, MtIsAddressValid(buf7) ? {\cf22 "Valid"} : {\cf22 "Invalid"});\par
00217     gop_printf(COLOR_MAGENTA, {\cf22 "BUF7 (VIRT): %p | (PHYS): %p\\n"}, buf7, MtTranslateVirtualToPhysical(buf7));\par
00218 {\cf21 #ifdef CAUSE_BUGCHECK}\par
00219     CTX_FRAME regs;\par
00220     SAVE_CTX_FRAME(&regs);\par
00221     MtBugcheck(&regs, NULL, MANUALLY_INITIATED_CRASH, 0xDEADBEEF, {\cf17 true});\par
00222 {\cf21 #endif}\par
00223 \par
00224     {\cf19 if} (checkcpuid()) \{\par
00225         {\cf18 char} str[256];\par
00226         getCpuName(str);\par
00227         gop_printf(COLOR_GREEN, {\cf22 "CPU Identified: %s\\n"}, str);\par
00228     \}\par
00229 \par
00230     MTSTATUS status;\par
00231     status = vfs_init();\par
00232     gop_printf(COLOR_RED, {\cf22 "vfs_init returned: %s\\n"}, MT_SUCCEEDED(status) ? {\cf22 "Success"} : {\cf22 "Unsuccessful"});\par
00233     {\cf19 if} (MT_FAILURE(status)) \{\par
00234         CTX_FRAME ctx;\par
00235         SAVE_CTX_FRAME(&ctx);\par
00236         MtBugcheck(&ctx, NULL, FILESYSTEM_PANIC, 0, {\cf17 false});\par
00237     \}\par
00238 \par
00239     TIME_ENTRY currTime = get_time();\par
00240 \par
00241 {\cf21 #define ISRAEL_UTC_OFFSET 3}\par
00242     gop_printf(COLOR_GREEN, {\cf22 "Current Time: %d/%d/%d | %d:%d:%d\\n"}, currTime.year, currTime.month, currTime.day, currTime.hour + ISRAEL_UTC_OFFSET, currTime.minute, currTime.second);\par
00243 \par
00244     {\cf18 char} listings[256];\par
00245     status = vfs_listdir({\cf22 "/"}, listings, {\cf17 sizeof}(listings));\par
00246     gop_printf(COLOR_RED, {\cf22 "vfs_listdir returned: %p\\n"}, status);\par
00247     gop_printf(COLOR_RED, {\cf22 "root directory is: %s\\n"}, vfs_is_dir_empty({\cf22 "/"}) ? {\cf22 "Empty"} : {\cf22 "Not Empty"});\par
00248     gop_printf(COLOR_CYAN, {\cf22 "%s"}, listings);\par
00249 \par
00250     MtCreateThread((ThreadEntry)test, NULL, DEFAULT_TIMESLICE_TICKS, {\cf17 true});\par
00251     {\cf18 int} integer = 1234;\par
00252     MtCreateThread((ThreadEntry)funcWithParam, &integer, DEFAULT_TIMESLICE_TICKS, {\cf17 true}); {\cf20 // I have tested 5+ threads, works perfectly as it should.}\par
00253     {\cf20 /* Enable LAPIC Now. */}\par
00254     lapic_init_bsp();\par
00255     lapic_enable();\par
00256     init_lapic_timer(100); {\cf20 // 10ms.}\par
00257     __sti();\par
00258     Schedule();\par
00259 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdatomic.h>}\par
{\f2 #include "trace.h"}\par
{\f2 #include "assert.h"}\par
{\f2 #include "intrin/intrin.h"}\par
{\f2 #include "cpu/cpu.h"}\par
{\f2 #include "filesystem/fat32/fat32.h"}\par
{\f2 #include "memory/allocator/uefi_memory.h"}\par
{\f2 #include "memory/memory.h"}\par
{\f2 #include "memory/paging/paging.h"}\par
{\f2 #include "defs/stdarg_myos.h"}\par
{\f2 #include "interrupts/idt.h"}\par
{\f2 #include "interrupts/handlers/handlers.h"}\par
{\f2 #include "bugcheck/bugcheck.h"}\par
{\f2 #include "memory/allocator/allocator.h"}\par
{\f2 #include "drivers/blk/block.h"}\par
{\f2 #include "drivers/ahci/ahci.h"}\par
{\f2 #include "drivers/gop/gop.h"}\par
{\f2 #include "cpu/cpuid/cpuid.h"}\par
{\f2 #include "time.h"}\par
{\f2 #include "filesystem/vfs/vfs.h"}\par
{\f2 #include "cpu/apic/apic.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNREFERENCED_PARAMETER}(x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define CAUSE_BUGCHECK }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gop_printf_forced}(color,  fmt, ...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALLOCATIONS}\~ 1000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BLOCK_SIZE}\~ 128\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALIGNMENT}\~ 16\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BOOT_INFO} {\b BOOT_INFO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_idle_checks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_main} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_memory_map} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_gop} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_boot_info} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitCPU} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_context_frame} ({\b CTX_FRAME} *registers)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_interrupt_frame} ({\b INT_FRAME} *intfr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBugChecking}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LASTFUNC_HISTORY} {\b lastfunc_history}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ALIGNMENT\:kernel.h}
{\xe \v kernel.h\:ALIGNMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALIGNMENT\~ 16}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b kernel.h}.}\par
}
{\xe \v ALLOCATIONS\:kernel.h}
{\xe \v kernel.h\:ALLOCATIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALLOCATIONS\~ 1000}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b kernel.h}.}\par
}
{\xe \v BLOCK_SIZE\:kernel.h}
{\xe \v kernel.h\:BLOCK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BLOCK_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b kernel.h}.}\par
}
{\xe \v gop_printf_forced\:kernel.h}
{\xe \v kernel.h\:gop_printf_forced}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gop_printf_forced( color,  fmt,  ...)}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gop_printf(color, fmt, ##__VA_ARGS__)\par
}
{
Definition at line {\b 70} of file {\b kernel.h}.}\par
}
{\xe \v UNREFERENCED_PARAMETER\:kernel.h}
{\xe \v kernel.h\:UNREFERENCED_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNREFERENCED_PARAMETER( x)}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (void)(x)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define CAUSE_BUGCHECK }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define REMINDER \par
}{
Definition at line {\b 36} of file {\b kernel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BOOT_INFO\:kernel.h}
{\xe \v kernel.h\:BOOT_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BOOT_INFO} {\b BOOT_INFO}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b kernel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v copy_gop\:kernel.h}
{\xe \v kernel.h\:copy_gop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_gop ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b kernel.c}.}\par
}
{\xe \v copy_memory_map\:kernel.h}
{\xe \v kernel.h\:copy_memory_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_memory_map ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b kernel.c}.}\par
}
{\xe \v init_boot_info\:kernel.h}
{\xe \v kernel.h\:init_boot_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_boot_info ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b kernel.c}.}\par
}
{\xe \v InitCPU\:kernel.h}
{\xe \v kernel.h\:InitCPU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitCPU (void )}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b kernel.c}.}\par
}
{\xe \v kernel_idle_checks\:kernel.h}
{\xe \v kernel.h\:kernel_idle_checks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_idle_checks (void )}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b kernel.c}.}\par
}
{\xe \v kernel_main\:kernel.h}
{\xe \v kernel.h\:kernel_main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_main ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remember that paging is on when this is called, as UEFI turned it on. \par
}{
Definition at line {\b 153} of file {\b kernel.c}.}\par
}
{\xe \v read_context_frame\:kernel.h}
{\xe \v kernel.h\:read_context_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_context_frame ({\b CTX_FRAME} * registers){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v read_interrupt_frame\:kernel.h}
{\xe \v kernel.h\:read_interrupt_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_interrupt_frame ({\b INT_FRAME} * intfr){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v isBugChecking\:kernel.h}
{\xe \v kernel.h\:isBugChecking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBugChecking{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b kernel.c}.}\par
}
{\xe \v lastfunc_history\:kernel.h}
{\xe \v kernel.h\:lastfunc_history}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b LASTFUNC_HISTORY} lastfunc_history{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
kernel.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Core Kernel Includes, includes all core and necessary header files.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_KERNEL_H}\par
00008 {\cf21 #define X86_KERNEL_H}\par
00009 \par
00010 {\cf20 // Standard headers, required.}\par
00011 {\cf21 #include <stddef.h>}\par
00012 {\cf21 #include <stdbool.h>}\par
00013 {\cf21 #include <stdint.h>}\par
00014 {\cf21 #include <stdatomic.h>}\par
00015 {\cf21 #include "trace.h"}\par
00016 \par
00017 {\cf20 // forward declarations, i don't think i need them.}\par
00018 \par
00019 {\cf17 typedef} {\cf17 struct }_BLOCK_DEVICE BLOCK_DEVICE;\par
00020 {\cf17 typedef} {\cf17 struct }_BOOT_INFO BOOT_INFO;\par
00021 {\cf17 typedef} {\cf17 struct }_CTX_FRAME CTX_FRAME;\par
00022 \par
00023 \par
00024 {\cf20 // Standard globals}\par
00025 {\cf17 extern} {\cf18 bool} isBugChecking;\par
00026 {\cf17 extern} LASTFUNC_HISTORY lastfunc_history; {\cf20 // grab lastfunc from kernel.c}\par
00027 \par
00028 {\cf20 /* Uncomment to trigger a bugcheck on entry */}\par
00030 \par
00031 {\cf20 /* Uncomment to show all reminders in a static assertion */}\par
00033 \par
00034 {\cf20 /* To define DEBUG globally, use a compiler flag. I removed this since I now transitioned each header to iself and others instead of relying on kernel.h that caused circular includes. */}\par
00035 \par
00036 {\cf21 #define UNREFERENCED_PARAMETER(x) (void)(x)}\par
00037 {\cf21 #include "assert.h"}\par
00038 {\cf21 #include "intrin/intrin.h"}\par
00039 {\cf21 #include "cpu/cpu.h"}\par
00040 {\cf21 #include "filesystem/fat32/fat32.h"}\par
00041 {\cf21 #include "memory/allocator/uefi_memory.h"}\par
00042 {\cf21 #include "memory/memory.h"}\par
00043 {\cf21 #include "memory/paging/paging.h"}\par
00044 {\cf21 #include "defs/stdarg_myos.h"}\par
00045 {\cf21 #include "interrupts/idt.h"}\par
00046 {\cf21 #include "interrupts/handlers/handlers.h"}\par
00047 {\cf21 #include "bugcheck/bugcheck.h"}\par
00048 {\cf21 #include "memory/allocator/allocator.h"}\par
00049 {\cf21 #include "drivers/blk/block.h"}\par
00050 {\cf21 #include "drivers/ahci/ahci.h"}\par
00051 {\cf21 #include "drivers/gop/gop.h"}\par
00052 {\cf21 #include "cpu/cpuid/cpuid.h"}\par
00053 {\cf21 #include "time.h"}\par
00054 {\cf21 #include "filesystem/vfs/vfs.h"}\par
00055 {\cf21 #include "cpu/apic/apic.h"}\par
00056 \par
00057 {\cf20 // Entry point in C}\par
00058 {\cf18 void} kernel_idle_checks({\cf18 void});\par
00059 {\cf18 void} kernel_main(BOOT_INFO* boot_info);\par
00060 {\cf20 // Function declarations.}\par
00061 {\cf18 void} copy_memory_map(BOOT_INFO* boot_info);\par
00062 {\cf18 void} copy_gop(BOOT_INFO* boot_info);\par
00063 {\cf18 void} init_boot_info(BOOT_INFO* boot_info);\par
00064 {\cf18 void} InitCPU({\cf18 void});\par
00065 \par
00066 {\cf20 // Custom assembly functions externals.}\par
00067 {\cf17 extern} {\cf18 void} read_context_frame(CTX_FRAME* registers);\par
00068 {\cf17 extern} {\cf18 void} read_interrupt_frame(INT_FRAME* intfr);\par
00069 \par
00070 {\cf21 #define gop_printf_forced(color, fmt, ...) gop_printf(color, fmt, ##__VA_ARGS__)}\par
00071 \par
00072 {\cf21 #define ALLOCATIONS 1000}\par
00073 {\cf21 #define BLOCK_SIZE  128}\par
00074 {\cf21 #define ALIGNMENT   16}\par
00075 \par
00077 {\cf17 static} {\cf18 int} MemoryTest({\cf18 void}) \{\par
00078     {\cf18 void}* blocks[ALLOCATIONS];\par
00079 \par
00080     {\cf20 // Allocation + write test}\par
00081     {\cf19 for} ({\cf18 int} i = 0; i < ALLOCATIONS; i++) \{\par
00082         blocks[i] = MtAllocateVirtualMemory(BLOCK_SIZE, ALIGNMENT);\par
00083         {\cf19 if} (!blocks[i]) \{\par
00084             gop_printf_forced(0xFFFF0000, {\cf22 "Allocation failed at index %d\\n"}, i);\par
00085             {\cf19 return} -1;\par
00086         \}\par
00087 \par
00088         {\cf20 // Alignment test}\par
00089         {\cf19 if} ((uintptr_t)blocks[i] % ALIGNMENT != 0) \{\par
00090             gop_printf_forced(0xFFFF8000, {\cf22 "Misaligned block at index %d: %p\\n"}, i, blocks[i]);\par
00091             {\cf19 return} -2;\par
00092         \}\par
00093 \par
00094         {\cf20 // Fill memory}\par
00095         {\cf19 for} ({\cf18 int} j = 0; j < BLOCK_SIZE; j++) \{\par
00096             ((uint8_t*)blocks[i])[j] = (uint8_t)(i + j);\par
00097         \}\par
00098     \}\par
00099 \par
00100     {\cf20 // Verify and free}\par
00101     {\cf19 for} ({\cf18 int} i = 0; i < ALLOCATIONS; i++) \{\par
00102         {\cf19 for} ({\cf18 int} j = 0; j < BLOCK_SIZE; j++) \{\par
00103             {\cf19 if} (((uint8_t*)blocks[i])[j] != (uint8_t)(i + j)) \{\par
00104                 gop_printf_forced(0xFF0000FF, {\cf22 "Memory corruption at block %d, byte %d\\n"}, i, j);\par
00105                 {\cf19 return} -3;\par
00106             \}\par
00107         \}\par
00108 \par
00109         MtFreeVirtualMemory(blocks[i]);\par
00110     \}\par
00111 \par
00112     gop_printf_forced(0xFF00FF00, {\cf22 "Memory test completed successfully.\\n"});\par
00113     {\cf19 return} 0;\par
00114 \}\par
00115 \par
00116 {\cf21 #endif }{\cf20 // X86_KERNEL_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.c}
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "allocator.h"}\par
{\f2 #include "../../bugcheck/bugcheck.h"}\par
{\f2 #include "../memory.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b frame_bitmap_init} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b alloc_frame} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_frame} (uintptr_t p)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alloc_frame\:allocator.c}
{\xe \v allocator.c\:alloc_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t alloc_frame (void )}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removed reserved pages use, for safeguarding against memory corruption within the kernel.\par
}{
Definition at line {\b 133} of file {\b allocator.c}.}\par
}
{\xe \v frame_bitmap_init\:allocator.c}
{\xe \v allocator.c\:frame_bitmap_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frame_bitmap_init (void )}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b allocator.c}.}\par
}
{\xe \v free_frame\:allocator.c}
{\xe \v allocator.c\:free_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_frame (uintptr_t p)}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b allocator.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
allocator.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.c}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "allocator.h"}\par
00002 {\cf21 #include "../../bugcheck/bugcheck.h"}\par
00003 {\cf21 #include "../memory.h"}\par
00004 \par
00005 {\cf17 static} uint8_t* frame_bitmap = NULL;\par
00006 {\cf17 static} {\cf18 size_t} total_frames = 0;\par
00007 \par
00008 {\cf17 static} {\cf17 inline} {\cf18 void} set_frame({\cf18 size_t} frame) \{\par
00009     tracelast_func({\cf22 "set_frame"});\par
00010     uint64_t rip;\par
00011     GET_RIP(rip);\par
00012     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00013     {\cf19 if} (frame >= total_frames) \{\par
00014         CTX_FRAME ctx;\par
00015         SAVE_CTX_FRAME(&ctx);\par
00016         MtBugcheck(&ctx, NULL, FRAME_LIMIT_REACHED, 0, {\cf17 false});\par
00017     \}\par
00018     frame_bitmap[frame / 8] |= (uint8_t)(1 << (frame % 8));\par
00019 \}\par
00020 \par
00021 {\cf17 static} {\cf17 inline} {\cf18 void} clear_frame({\cf18 size_t} frame) \{\par
00022     tracelast_func({\cf22 "clear_frame"});\par
00023     uint64_t rip;\par
00024     GET_RIP(rip);\par
00025     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00026     {\cf19 if} (frame < total_frames) \{\par
00027         frame_bitmap[frame / 8] &= (uint8_t)~(1 << (frame % 8));\par
00028     \}\par
00029 \}\par
00030 \par
00031 {\cf17 static} {\cf17 inline} {\cf18 bool} test_frame({\cf18 size_t} frame) \{\par
00032     tracelast_func({\cf22 "test_frame"});\par
00033     uint64_t rip;\par
00034     GET_RIP(rip);\par
00035     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00036     {\cf19 return} (frame < total_frames) && (frame_bitmap[frame / 8] & (1 << (frame % 8)));\par
00037 \}\par
00038 \par
00039 {\cf17 static} uint64_t get_total_memory_size({\cf17 const} BOOT_INFO* boot_info) \{\par
00040     uint64_t highest_addr = 0;\par
00041 \par
00042     {\cf20 // Calculate the number of entries in the memory map}\par
00043     {\cf18 size_t} entry_count = boot_info->MapSize / boot_info->DescriptorSize;\par
00044 \par
00045     {\cf20 // Get a pointer to the first descriptor}\par
00046     EFI_MEMORY_DESCRIPTOR* desc = boot_info->MemoryMap;\par
00047 \par
00048     {\cf19 for} ({\cf18 size_t} i = 0; i < entry_count; i++) \{\par
00049         {\cf20 // Calculate the end address of the current memory region.}\par
00050         uint64_t region_end = desc->PhysicalStart + (desc->NumberOfPages * FRAME_SIZE);\par
00051 \par
00052         {\cf20 // If this region ends at a higher address, update our maximum.}\par
00053         {\cf19 if} (region_end > highest_addr) highest_addr = region_end;\par
00054 \par
00055         desc = (EFI_MEMORY_DESCRIPTOR*)((uint8_t*)desc + boot_info->DescriptorSize);\par
00056     \}\par
00057 \par
00058     {\cf19 return} highest_addr;\par
00059 \}\par
00060 \par
00061 {\cf18 void} frame_bitmap_init({\cf18 void}) \{\par
00062     tracelast_func({\cf22 "frame_bitmap_init"});\par
00063     uint64_t rip;\par
00064     GET_RIP(rip);\par
00065     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00066 \par
00067     {\cf20 // 1. Calculate the total memory size and required bitmap size}\par
00068     uint64_t total_memory = get_total_memory_size(&boot_info_local);\par
00069     total_frames = (total_memory + FRAME_SIZE - 1) / FRAME_SIZE; {\cf20 // round up}\par
00070     {\cf18 size_t} bitmap_size = (total_frames + 7) / 8;\par
00071 \par
00072     {\cf20 // 2. Find a place in physical memory for our bitmap}\par
00073     {\cf18 size_t} entry_count = boot_info_local.MapSize / boot_info_local.DescriptorSize;\par
00074     EFI_MEMORY_DESCRIPTOR* desc = boot_info_local.MemoryMap;\par
00075     uintptr_t bitmap_phys = 0;\par
00076     {\cf19 for} ({\cf18 size_t} i = 0; i < entry_count; ++i) \{\par
00077         {\cf20 // Look for a usable region that's big enough}\par
00078         {\cf19 if} (classify(desc->Type) && (desc->NumberOfPages * FRAME_SIZE) >= bitmap_size) \{\par
00079             {\cf20 // We found a spot! Use its physical start address.}\par
00080             bitmap_phys = desc->PhysicalStart;\par
00081             frame_bitmap = (uint8_t*)(bitmap_phys + PHYS_MEM_OFFSET);\par
00082             {\cf19 break};\par
00083         \}\par
00084         desc = (EFI_MEMORY_DESCRIPTOR*)((uint8_t*)desc + boot_info_local.DescriptorSize);\par
00085     \}\par
00086 \par
00087     {\cf19 if} (!bitmap_phys) \{\par
00088         MtBugcheck(NULL, NULL, STACK_SEGMENT_OVERRUN, 0, {\cf17 false});\par
00089         {\cf19 return};\par
00090     \}\par
00091 \par
00092     {\cf19 if} (frame_bitmap == NULL) \{\par
00093         {\cf20 // This is a catastrophic failure. We couldn't find anywhere to put the bitmap.}\par
00094         MtBugcheck(NULL, NULL, FRAME_BITMAP_CREATION_FAILURE, 0, {\cf17 false});\par
00095         {\cf19 return};\par
00096     \}\par
00097 \par
00098 \par
00099     {\cf20 // 3. Initialize the bitmap}\par
00100     {\cf20 // Mark all frames as used/reserved initially}\par
00101     kmemset(frame_bitmap, 0xFF, bitmap_size);\par
00102 \par
00103     {\cf20 // 4. Mark the bitmap's OWN frames as used! (Crucial!)}\par
00104     {\cf18 size_t} bitmap_pages = (bitmap_size + FRAME_SIZE - 1) / FRAME_SIZE;\par
00105     {\cf18 size_t} bitmap_base_frame = bitmap_phys / FRAME_SIZE; {\cf20 // physical here}\par
00106     {\cf19 for} ({\cf18 size_t} i = 0; i < bitmap_pages; i++) \{\par
00107         set_frame(bitmap_base_frame + i);\par
00108     \}\par
00109 \par
00110     {\cf20 // 5. Clear usable frames based on the rest of the memory map}\par
00111     desc = boot_info_local.MemoryMap;\par
00112     {\cf19 for} ({\cf18 size_t} i = 0; i < entry_count; ++i) \{\par
00113         {\cf19 if} (desc->Type == EfiConventionalMemory) \{\par
00114             uintptr_t base = desc->PhysicalStart;\par
00115             uint64_t pages = desc->NumberOfPages;\par
00116             {\cf19 for} (uint64_t p = 0; p < pages; ++p) \{\par
00117                 {\cf18 size_t} frame_idx = (base / FRAME_SIZE) + p;\par
00118 \par
00119                 {\cf20 // Don't free the frames we are using for the bitmap itself!}\par
00120                 {\cf19 if} (frame_idx >= ((uintptr_t)bitmap_phys / FRAME_SIZE) &&\par
00121                     frame_idx < (((uintptr_t)bitmap_phys / FRAME_SIZE) + bitmap_pages)) \{\par
00122                     {\cf19 continue};\par
00123                 \}\par
00124 \par
00125                 clear_frame(frame_idx);\par
00126             \}\par
00127         \}\par
00128         desc = (EFI_MEMORY_DESCRIPTOR*)((uint8_t*)desc + boot_info_local.DescriptorSize);\par
00129     \}\par
00130 \}\par
00131 \par
00132 {\cf20 // Early\'E2\'80\'90boot frame allocator:}\par
00133 uintptr_t alloc_frame({\cf18 void}) \{\par
00134     tracelast_func({\cf22 "alloc_frame"});\par
00135     uint64_t rip;\par
00136     GET_RIP(rip);\par
00137     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00139     {\cf19 for} ({\cf18 size_t} frame = 0; frame < total_frames; ++frame) \{\par
00140         {\cf19 if} (!(frame_bitmap[frame / 8] & (1 << (frame % 8)))) \{\par
00141             {\cf20 // mark and return}\par
00142             frame_bitmap[frame / 8] |= (1 << (frame % 8));\par
00143             {\cf19 return} (uintptr_t)(frame * FRAME_SIZE);\par
00144         \}\par
00145     \}\par
00146     {\cf19 return} 0;\par
00147 \}\par
00148 \par
00149 {\cf18 void} free_frame(uintptr_t p) \{\par
00150     tracelast_func({\cf22 "free_frame"});\par
00151     uint64_t rip;\par
00152     GET_RIP(rip);\par
00153     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00154     {\cf18 size_t} frame = (uintptr_t)p / FRAME_SIZE;\par
00155     clear_frame(frame);\par
00156 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.h}
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../cpu/cpu.h"}\par
{\f2 #include "../../trace.h"}\par
{\f2 #include "uefi_memory.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PHYS_MEM_OFFSET}\~ 0xffff880000000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FRAME_SIZE}\~ 4096ULL\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b frame_bitmap_init} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b alloc_frame} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b free_frame} (uintptr_t p)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FRAME_SIZE\:allocator.h}
{\xe \v allocator.h\:FRAME_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FRAME_SIZE\~ 4096ULL}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b allocator.h}.}\par
}
{\xe \v PHYS_MEM_OFFSET\:allocator.h}
{\xe \v allocator.h\:PHYS_MEM_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PHYS_MEM_OFFSET\~ 0xffff880000000000ULL}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b allocator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v alloc_frame\:allocator.h}
{\xe \v allocator.h\:alloc_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t alloc_frame (void )}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removed reserved pages use, for safeguarding against memory corruption within the kernel.\par
}{
Definition at line {\b 133} of file {\b allocator.c}.}\par
}
{\xe \v frame_bitmap_init\:allocator.h}
{\xe \v allocator.h\:frame_bitmap_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void frame_bitmap_init (void )}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b allocator.c}.}\par
}
{\xe \v free_frame\:allocator.h}
{\xe \v allocator.h\:free_frame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void free_frame (uintptr_t p)}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b allocator.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
allocator.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/allocator.h}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Dynamic Memory Allocation Header.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_ALLOCATOR_H}\par
00007 {\cf21 #define X86_ALLOCATOR_H}\par
00008 \par
00009 {\cf21 #define PHYS_MEM_OFFSET 0xffff880000000000ULL}\par
00010 \par
00011 {\cf20 // Standard headers, required.}\par
00012 {\cf21 #include <stddef.h>}\par
00013 {\cf21 #include <stdbool.h>}\par
00014 {\cf21 #include <stdint.h>}\par
00015 {\cf21 #include "../../cpu/cpu.h"}\par
00016 {\cf21 #include "../../trace.h"}\par
00017 {\cf21 #include "uefi_memory.h"}\par
00018 \par
00019 {\cf21 #define FRAME_SIZE 4096ULL}\par
00020 \par
00026 {\cf17 static} {\cf17 inline} {\cf18 bool} classify({\cf18 int} type) \{\par
00027     {\cf19 return} type == EfiConventionalMemory;\par
00028 \}\par
00029 \par
00030 {\cf20 // Initialize frame bitmap based on UEFI memory map}\par
00031 {\cf20 // Must be called after gEfiMemoryMap* variables are set}\par
00032 {\cf18 void} frame_bitmap_init({\cf18 void});\par
00033 \par
00034 {\cf20 // Allocate one 4KiB physical frame; returns physical address or 0 if NULL.}\par
00035 uintptr_t alloc_frame({\cf18 void});\par
00036 \par
00037 {\cf20 // Free a previously allocated frame (pass the physical address)}\par
00038 {\cf18 void} free_frame(uintptr_t p);\par
00039 \par
00040 {\cf21 #endif }{\cf20 // ALLOCATOR_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/uefi_memory.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/uefi_memory.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/uefi_memory.h}
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EFI_MEMORY_DESCRIPTOR}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _GOP_PARAMS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BOOT_INFO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiReservedMemoryType}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiLoaderCode}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiLoaderData}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiBootServicesCode}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiBootServicesData}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiRuntimeServicesCode}\~ 5\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiRuntimeServicesData}\~ 6\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiConventionalMemory}\~ 7\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EFI_MEMORY_DESCRIPTOR} {\b EFI_MEMORY_DESCRIPTOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _GOP_PARAMS} {\b GOP_PARAMS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BOOT_INFO} {\b BOOT_INFO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v EfiBootServicesCode\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiBootServicesCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiBootServicesCode\~ 3}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiBootServicesData\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiBootServicesData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiBootServicesData\~ 4}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiConventionalMemory\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiConventionalMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiConventionalMemory\~ 7}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiLoaderCode\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiLoaderCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiLoaderCode\~ 1}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiLoaderData\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiLoaderData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiLoaderData\~ 2}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiReservedMemoryType\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiReservedMemoryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiReservedMemoryType\~ 0}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiRuntimeServicesCode\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiRuntimeServicesCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiRuntimeServicesCode\~ 5}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b uefi_memory.h}.}\par
}
{\xe \v EfiRuntimeServicesData\:uefi_memory.h}
{\xe \v uefi_memory.h\:EfiRuntimeServicesData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiRuntimeServicesData\~ 6}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b uefi_memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BOOT_INFO\:uefi_memory.h}
{\xe \v uefi_memory.h\:BOOT_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BOOT_INFO} {\b BOOT_INFO}}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EFI_MEMORY_DESCRIPTOR\:uefi_memory.h}
{\xe \v uefi_memory.h\:EFI_MEMORY_DESCRIPTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EFI_MEMORY_DESCRIPTOR} {\b EFI_MEMORY_DESCRIPTOR}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GOP_PARAMS\:uefi_memory.h}
{\xe \v uefi_memory.h\:GOP_PARAMS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _GOP_PARAMS} {\b GOP_PARAMS}}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v boot_info_local\:uefi_memory.h}
{\xe \v uefi_memory.h\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
uefi_memory.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/uefi_memory.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/allocator/uefi_memory.h}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef UEFI_MEMORY_H}\par
00002 {\cf21 #define UEFI_MEMORY_H}\par
00003 \par
00004 {\cf20 // Standard headers, required.}\par
00005 {\cf21 #include <stddef.h>}\par
00006 {\cf21 #include <stdbool.h>}\par
00007 {\cf21 #include <stdint.h>}\par
00008 \par
00009 {\cf20 // global}\par
00010 {\cf17 typedef} {\cf17 struct }_BLOCK_DEVICE BLOCK_DEVICE;\par
00011 \par
00012 {\cf20 // Minimal UEFI memory descriptor for kernel use}\par
00013 {\cf20 // Matches UEFI spec EFI_MEMORY_DESCRIPTOR up to PhysicalStart, NumberOfPages, Type}\par
00014 \par
00015 {\cf17 typedef} {\cf17 struct }_EFI_MEMORY_DESCRIPTOR \{\par
00016     uint32_t Type;         {\cf20 // What this memory region is used for}\par
00017     uint32_t Pad;          {\cf20 // Alignment / padding}\par
00018     uint64_t PhysicalStart; {\cf20 // Physical start address of the region}\par
00019     uint64_t VirtualStart;  {\cf20 // Virtual start (usually 0 during boot)}\par
00020     uint64_t NumberOfPages; {\cf20 // Size of the region in pages (usually 4 KB)}\par
00021     uint64_t Attribute;     {\cf20 // Flags (cacheable, runtime, etc.)}\par
00022 \} EFI_MEMORY_DESCRIPTOR;\par
00023 \par
00024 {\cf17 typedef} {\cf17 struct }_GOP_PARAMS \{\par
00025     uint64_t FrameBufferBase;\par
00026     uint64_t FrameBufferSize;\par
00027     uint32_t Width;               {\cf20 // Visible width in pixels}\par
00028     uint32_t Height;              {\cf20 // Visible height in pixels}\par
00029     uint32_t PixelsPerScanLine;   {\cf20 // Actual pixels per row in framebuffer (stride)}\par
00030 \} GOP_PARAMS;\par
00031 \par
00032 {\cf17 typedef} {\cf17 struct }_BOOT_INFO \{\par
00033     GOP_PARAMS* Gop;\par
00034     EFI_MEMORY_DESCRIPTOR* MemoryMap;\par
00035     {\cf18 size_t}                    MapSize;       \par
00036     {\cf18 size_t}                    DescriptorSize;\par
00037     uint32_t                  DescriptorVersion;\par
00038     {\cf18 size_t}                  AhciCount;\par
00039     uint64_t*                 AhciBarBases;\par
00040     uint64_t KernelStackTop;\par
00041     uintptr_t Pml4Phys;\par
00042 \} BOOT_INFO;\par
00043 {\cf21 #ifndef _MSC_VER }\par
00044 {\cf17 _Static_assert}({\cf17 sizeof}(BOOT_INFO) == 72, {\cf22 "Size of BOOT_INFO doesn't equal 72 bytes. Update the struct."});\par
00045 {\cf21 #endif}\par
00046 \par
00047 {\cf20 // Memory types (we only need ConventionalMemory here)}\par
00048 {\cf21 #define EfiReservedMemoryType          0}\par
00049 {\cf21 #define EfiLoaderCode                  1}\par
00050 {\cf21 #define EfiLoaderData                  2}\par
00051 {\cf21 #define EfiBootServicesCode            3 }\par
00052 {\cf21 #define EfiBootServicesData            4 }\par
00053 {\cf21 #define EfiRuntimeServicesCode         5}\par
00054 {\cf21 #define EfiRuntimeServicesData         6}\par
00055 {\cf21 #define EfiConventionalMemory          7 }\par
00056 {\cf20 // ... other types omitted for brevity}\par
00057 \par
00058 {\cf17 extern} BOOT_INFO boot_info_local;\par
00059 \par
00060 {\cf21 #endif }{\cf20 // UEFI_MEMORY_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c}
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "memory.h"}\par
{\f2 #include "../drivers/gop/gop.h"}\par
{\f2 #include "../bugcheck/bugcheck.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zero_bss} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zeroes out the BSS section (garbage data that might have left there) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_heap} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the Kernel's HEAP for dynamic memory allocation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b kmemset} (void *dest, int64_t val, uint64_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b kmemcpy} (void *dest, const void *src, uint32_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MtAllocateVirtualMemory} (size_t wanted_size, size_t align)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate {\f2 wanted_size}  bytes with {\f2 align}  alignment. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MtIsHeapAddressAllocated} (void *ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns if the heap pointer given has been allocated by MtAllocateVirtualMemory or not. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MtAllocateVirtualMemoryEx} (size_t wanted_size, size_t align, uint64_t flags)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b THE USE OF THIS FUNCTION IS NOT RECOMMENDED \'96 TO ADD {\b FLAGS} TO AN ALLOCATED MEMORY BUFFER USE MtAddPageFlags TO ITS POINTER!!!}  ** FREEING THE MEMORY OF THIS BUFFER WILL RESULT IN A PAGE FAULT ** Allocates a block of memory from the kernel's memory manager, and sets the paging flags according to the user. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtFreeVirtualMemory} (void *ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases (frees) a previously allocated block of memory back to the kernel\'92s memory manager. (DOES NOT UNMAP IF FUNCTION USED IS MtAllocateVirtualMemory !) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b heap_current_end}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_heap\:memory.c}
{\xe \v memory.c\:init_heap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_heap (void )}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the Kernel's HEAP for dynamic memory allocation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function declares the globals for the heap current end, as well as setting up the free_list pointer. It first creates 1 initial 4KiB frame, maps it to be paged in virtual memory, and increases the heap current end by the frame size (4KiB), so that 1 starting page is allocated. \par
}{
Definition at line {\b 36} of file {\b memory.c}.}\par
}
{\xe \v kmemcpy\:memory.c}
{\xe \v memory.c\:kmemcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * kmemcpy (void * dest, const void * src, uint32_t len)}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b memory.c}.}\par
}
{\xe \v kmemset\:memory.c}
{\xe \v memory.c\:kmemset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * kmemset (void * dest, int64_t val, uint64_t len)}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b memory.c}.}\par
}
{\xe \v MtAllocateVirtualMemory\:memory.c}
{\xe \v memory.c\:MtAllocateVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MtAllocateVirtualMemory (size_t wanted_size, size_t align)}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate {\f2 wanted_size}  bytes with {\f2 align}  alignment. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocates a block of memory from the kernel\'92s memory manager. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zero the new memory block out.\par
}{
Definition at line {\b 154} of file {\b memory.c}.}\par
}
{\xe \v MtAllocateVirtualMemoryEx\:memory.c}
{\xe \v memory.c\:MtAllocateVirtualMemoryEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MtAllocateVirtualMemoryEx (size_t size, size_t align, uint64_t flags)}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b THE USE OF THIS FUNCTION IS NOT RECOMMENDED \'96 TO ADD {\b FLAGS} TO AN ALLOCATED MEMORY BUFFER USE MtAddPageFlags TO ITS POINTER!!!}  ** FREEING THE MEMORY OF THIS BUFFER WILL RESULT IN A PAGE FAULT ** Allocates a block of memory from the kernel's memory manager, and sets the paging flags according to the user. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{Size in bytes to allocate\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i align} \cell }{Alignment for each byteblock (use internal structs for process \\ other - use _Alignof)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{PAGE_FLAGS flags.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to start of allocated memory\par
}}}{
Definition at line {\b 227} of file {\b memory.c}.}\par
}
{\xe \v MtFreeVirtualMemory\:memory.c}
{\xe \v memory.c\:MtFreeVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtFreeVirtualMemory (void * ptr)}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases (frees) a previously allocated block of memory back to the kernel\'92s memory manager. (DOES NOT UNMAP IF FUNCTION USED IS MtAllocateVirtualMemory !) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Pointer to the allocated memory block to free\cell }
{\row }
}
}{
Definition at line {\b 276} of file {\b memory.c}.}\par
}
{\xe \v MtIsHeapAddressAllocated\:memory.c}
{\xe \v memory.c\:MtIsHeapAddressAllocated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MtIsHeapAddressAllocated (void * ptr)}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns if the heap pointer given has been allocated by MtAllocateVirtualMemory or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Address of what is given from MtAllocateVirtualMemory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 220} of file {\b memory.c}.}\par
}
{\xe \v zero_bss\:memory.c}
{\xe \v memory.c\:zero_bss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void zero_bss (void )}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zeroes out the BSS section (garbage data that might have left there) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function takes the start and end address of the {\f2 .bss}  section (provided by the linker script), and iterates over each byte from the start address up to (but not including) the end address, writing zero to each location. This ensures all global/static variables without initializers are zeroed. \par
}{
Definition at line {\b 23} of file {\b memory.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gop_local\:memory.c}
{\xe \v memory.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b kernel.c}.}\par
}
{\xe \v heap_current_end\:memory.c}
{\xe \v memory.c\:heap_current_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t heap_current_end}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b memory.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
memory.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Memory Management Implementation}\par
00005 {\cf20  */}\par
00006 {\cf21 #include "memory.h"}\par
00007 {\cf21 #include "../drivers/gop/gop.h"}\par
00008 {\cf21 #include "../bugcheck/bugcheck.h"}\par
00009 \par
00010 {\cf20 /* Head of the free list */}\par
00011 {\cf17 static} BLOCK_HEADER* free_list = NULL;\par
00012 {\cf17 extern} GOP_PARAMS gop_local;\par
00013 uintptr_t heap_current_end;\par
00014 \par
00023 {\cf18 void} zero_bss({\cf18 void}) \{\par
00024     tracelast_func({\cf22 "zero_bss"});\par
00025     uint8_t* p = &bss_start;\par
00026     {\cf19 while} (p < &bss_end) *p++ = 0;\par
00027 \}\par
00028 \par
00036 {\cf18 void} init_heap({\cf18 void}) \{\par
00037     tracelast_func({\cf22 "init_heap"});\par
00038 \par
00039     {\cf20 // map that frame:}\par
00040     uintptr_t phys = alloc_frame();\par
00041     map_page(({\cf18 void}*)HEAP_START, phys, PAGE_PRESENT | PAGE_RW);\par
00042 \par
00043     heap_current_end = HEAP_START;\par
00044     free_list = (BLOCK_HEADER*)HEAP_START;\par
00045     free_list->size = FRAME_SIZE;    {\cf20 // only 4 KiB initially}\par
00046     free_list->next = NULL;\par
00047 \par
00048     kmemset(({\cf18 void}*)HEAP_START, 0, FRAME_SIZE);\par
00049     heap_current_end += FRAME_SIZE;\par
00050 \}\par
00051 \par
00058 {\cf17 static} {\cf18 void} insert_block_sorted(BLOCK_HEADER* newblock) \{\par
00059     tracelast_func({\cf22 "insert_block_sorted"});\par
00060     uint64_t rip;\par
00061     GET_RIP(rip);\par
00062     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00063     {\cf19 if} (!free_list || newblock < free_list) \{\par
00064         newblock->next = free_list;\par
00065         free_list = newblock;\par
00066         {\cf19 return};\par
00067     \}\par
00068 \par
00069     BLOCK_HEADER* current = free_list;\par
00070     {\cf19 while} (current->next && current->next < newblock) \{\par
00071         current = current->next;\par
00072     \}\par
00073 \par
00074     newblock->next = current->next;\par
00075     current->next = newblock;\par
00076 \}\par
00077 \par
00078 {\cf20 /* Merge adjacent free blocks to reduce fragmentation */}\par
00079 {\cf17 static} {\cf18 void} coalesce_free_list({\cf18 void}) \{\par
00080     tracelast_func({\cf22 "coalesce_free_list"});\par
00081     uint64_t rip;\par
00082     GET_RIP(rip);\par
00083     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00084     BLOCK_HEADER* b = free_list;\par
00085     {\cf19 while} (b && b->next) \{\par
00086         uintptr_t end_of_b = (uintptr_t)b + b->size;\par
00087         {\cf19 if} (end_of_b == (uintptr_t)b->next) \{\par
00088             {\cf20 /* Adjacent: merge */}\par
00089             b->size += b->next->size;\par
00090             b->next = b->next->next;\par
00091         \}\par
00092         {\cf19 else} \{\par
00093             b = b->next;\par
00094         \}\par
00095     \}\par
00096 \}\par
00097 \par
00098 {\cf17 static} {\cf18 bool} grow_heap_by_one_page({\cf18 void}) \{\par
00099     tracelast_func({\cf22 "grow_heap_by_one_page"});\par
00100     uint64_t rip;\par
00101     GET_RIP(rip);\par
00102     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00103     {\cf20 // grab a physical frame}\par
00104     uintptr_t phys = alloc_frame();\par
00105     {\cf19 if} (!phys) \{ {\cf19 return} {\cf17 false}; \}\par
00106 \par
00107     {\cf20 // map it at the end of the heap.}\par
00108     {\cf20 // here it where it maps the page, I was confused on how it worked, forgot about it.}\par
00109     map_page(({\cf18 void}*)heap_current_end, phys, PAGE_PRESENT | PAGE_RW {\cf20 /* | PAGE_USER Would be used later on, when this kernel has both user mode and kernel mode */} );\par
00110     \par
00111     {\cf20 // Zero the page.}\par
00112     kmemset(({\cf18 void}*)heap_current_end, 0, FRAME_SIZE);\par
00113     {\cf20 // insert a new region}\par
00114     BLOCK_HEADER* block = (BLOCK_HEADER*)heap_current_end;\par
00115     block->size = FRAME_SIZE;\par
00116     insert_block_sorted(block);\par
00117     coalesce_free_list();\par
00118 \par
00119     {\cf20 // advance our end.}\par
00120     heap_current_end += FRAME_SIZE;\par
00121     {\cf19 return} {\cf17 true};\par
00122 \}\par
00123 \par
00124 {\cf20 // Memory Set.}\par
00125 {\cf18 void}* kmemset({\cf18 void}* dest, int64_t val, uint64_t len) \{\par
00126     tracelast_func({\cf22 "kmemset"});\par
00127     uint64_t rip;\par
00128     GET_RIP(rip);\par
00129     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00130     uint8_t* ptr = dest;\par
00131     {\cf19 for} (uint32_t i = 0; i < len; i++) \{\par
00132         ptr[i] = (uint8_t)val;\par
00133     \}\par
00134     {\cf19 return} dest;\par
00135 \}\par
00136 \par
00137 {\cf20 // Memory copy.}\par
00138 {\cf18 void}* kmemcpy({\cf18 void}* dest, {\cf17 const} {\cf18 void}* src, uint32_t len) \{\par
00139     tracelast_func({\cf22 "kmemcpy"});\par
00140     uint64_t rip;\par
00141     GET_RIP(rip);\par
00142     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00143     uint8_t* d = (uint8_t*)dest;\par
00144     {\cf17 const} uint8_t* s = ({\cf17 const} uint8_t*)src;\par
00145     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < len; i++) \{\par
00146         d[i] = s[i];\par
00147     \}\par
00148     {\cf19 return} dest;\par
00149 \}\par
00150 \par
00154 {\cf18 void}* MtAllocateVirtualMemory({\cf18 size_t} wanted_size, {\cf18 size_t} align) \{\par
00155     tracelast_func({\cf22 "MtAllocateVirtualMemory"});\par
00156     uint64_t rip;\par
00157     GET_RIP(rip);\par
00158     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00159     {\cf20 // Precompute maximum pages we'll ever need (worst-case alignment overhead)}\par
00160     {\cf18 size_t} max_overhead = {\cf17 sizeof}(BLOCK_HEADER) + {\cf17 sizeof}({\cf18 void}*) + (align - 1);\par
00161     {\cf18 size_t} max_alloc = max_overhead + wanted_size;\par
00162 \par
00163     {\cf19 for} (;;) \{\par
00164         {\cf20 // 1 - First fit search.}\par
00165         BLOCK_HEADER** cur = &free_list;\par
00166         {\cf19 while} (*cur) \{\par
00167             BLOCK_HEADER* blk = *cur;\par
00168 \par
00169             uintptr_t raw_start = (uintptr_t)(blk + 1) + {\cf17 sizeof}({\cf18 void}*);\par
00170             uintptr_t aligned_start = (raw_start + align - 1) & ~(align - 1);\par
00171             uintptr_t header_store = aligned_start - {\cf17 sizeof}({\cf18 void}*);\par
00172             uintptr_t alloc_end = aligned_start + wanted_size;\par
00173             {\cf18 size_t}    real_total = alloc_end - (uintptr_t)blk;\par
00174 \par
00175             {\cf19 if} (blk->size >= real_total) \{\par
00176                 {\cf20 /* If the block is big enough to split */}\par
00177                 {\cf19 if} (blk->size >= real_total + {\cf17 sizeof}(BLOCK_HEADER) + align) \{\par
00178                     {\cf20 /* Split off the tail into a new free block */}\par
00179                     BLOCK_HEADER* next_blk = (BLOCK_HEADER*)((uintptr_t)blk + real_total);\par
00180                     next_blk->size = blk->size - real_total;\par
00181                     next_blk->next = blk->next;\par
00182 \par
00183                     {\cf20 /* Shrink current block to allocated size */}\par
00184                     blk->size = real_total;\par
00185                     *cur = next_blk;\par
00186                 \}\par
00187                 {\cf19 else} \{\par
00188                     {\cf20 /* Use the entire block */}\par
00189                     *cur = blk->next;\par
00190                 \}\par
00191 \par
00192                 {\cf20 // Store header pointer for free}\par
00193                 blk->in_use = {\cf17 true};\par
00194                 blk->next = NULL;\par
00195                 blk->kind = BLK_NORMAL;\par
00196                 ((BLOCK_HEADER**)header_store)[0] = blk;\par
00198                 kmemset(({\cf18 void}*)aligned_start, 0, wanted_size);\par
00199                 {\cf20 // Return the newly allocated memory ptr.}\par
00200                 {\cf19 return} ({\cf18 void}*)aligned_start;\par
00201             \}\par
00202 \par
00203             cur = &blk->next;\par
00204         \}\par
00205 \par
00206         {\cf20 // 2 - No available block is found, grow heap conservatively}\par
00207         {\cf18 size_t} pages_needed = (max_alloc + FRAME_SIZE - 1) / FRAME_SIZE;\par
00208         {\cf19 for} ({\cf18 size_t} i = 0; i < pages_needed; i++) \{\par
00209             {\cf19 if} (!grow_heap_by_one_page()) \{\par
00210                 CTX_FRAME ctx;\par
00211                 SAVE_CTX_FRAME(&ctx);\par
00212                 MtBugcheck(&ctx, NULL, MEMORY_LIMIT_REACHED, 0, {\cf17 false});\par
00213             \}\par
00214         \}\par
00215         {\cf20 // We have grown the amount, retry.}\par
00216         {\cf19 continue};\par
00217     \}\par
00218 \}\par
00219 \par
00220 {\cf18 bool} MtIsHeapAddressAllocated({\cf18 void}* ptr) \{\par
00221     {\cf19 if} (!ptr) {\cf19 return} {\cf17 false};\par
00222     BLOCK_HEADER* header = ((BLOCK_HEADER**)ptr)[-1];\par
00223     {\cf19 if} (!header) {\cf19 return} {\cf17 false};\par
00224     {\cf19 return} header->in_use;\par
00225 \}\par
00226 \par
00227 {\cf18 void}* MtAllocateVirtualMemoryEx({\cf18 size_t} wanted_size, {\cf18 size_t} align, uint64_t flags) \{\par
00228     tracelast_func({\cf22 "MtAllocateVirtualMemoryEx"});\par
00229     {\cf19 if} (align == 0 || (align & (align - 1)) != 0) {\cf19 return} NULL;\par
00230     {\cf20 // 1. Calculate the total size needed, including our header and alignment padding.}\par
00231     {\cf18 size_t} header_size = {\cf17 sizeof}(BLOCK_HEADER) + {\cf17 sizeof}({\cf18 void}*); {\cf20 // For header and original pointer}\par
00232     {\cf18 size_t} total_size = wanted_size + header_size + (align - 1);\par
00233 \par
00234     {\cf20 // 2. Round this up to the nearest page size (4K)}\par
00235     {\cf18 size_t} pages_needed = (total_size + FRAME_SIZE - 1) / FRAME_SIZE;\par
00236     {\cf18 size_t} region_size = pages_needed * FRAME_SIZE;\par
00237 \par
00238     {\cf20 // 3. Map a new, contiguous region of memory with the specified flags.}\par
00239     {\cf20 //    We will map it at the end of the current heap.}\par
00240     {\cf18 void}* region_start_virt = ({\cf18 void}*)heap_current_end;\par
00241 \par
00242     {\cf19 for} ({\cf18 size_t} i = 0; i < pages_needed; i++) \{\par
00243         uintptr_t phys = alloc_frame();\par
00244         {\cf19 if} (!phys) \{\par
00245             {\cf20 // Out of memory, we should probably shrink heap_current_end back down and fail.}\par
00246             {\cf20 // For now, we'll bugcheck.}\par
00247             CTX_FRAME ctx;\par
00248             SAVE_CTX_FRAME(&ctx);\par
00249             MtBugcheck(&ctx, NULL, MEMORY_LIMIT_REACHED, 0, {\cf17 false});\par
00250         \}\par
00251         {\cf18 void}* va = (uint8_t*)region_start_virt + (i * FRAME_SIZE);\par
00252         map_page(va, phys, flags);\par
00253     \}\par
00254 \par
00255     heap_current_end += region_size; {\cf20 // Claim the virtual address space immediately}\par
00256 \par
00257     {\cf20 // 4. Set up the block header at the start of our new region.}\par
00258     BLOCK_HEADER* blk = (BLOCK_HEADER*)region_start_virt;\par
00259     blk->size = region_size;\par
00260     blk->next = NULL;\par
00261     blk->in_use = {\cf17 true};\par
00262     blk->kind = BLK_EX;\par
00263 \par
00264     {\cf20 // 5. Perform the same alignment logic as before to get the final user pointer.}\par
00265     uintptr_t raw_start = (uintptr_t)(blk + 1) + {\cf17 sizeof}({\cf18 void}*);\par
00266     uintptr_t aligned_start = (raw_start + align - 1) & ~(align - 1);\par
00267     uintptr_t header_store = aligned_start - {\cf17 sizeof}({\cf18 void}*);\par
00268 \par
00269     {\cf20 // Store the original block pointer for the free function.}\par
00270     ((BLOCK_HEADER**)header_store)[0] = blk;\par
00271 \par
00272     kmemset(({\cf18 void}*)aligned_start, 0, wanted_size);\par
00273     {\cf19 return} ({\cf18 void}*)aligned_start;\par
00274 \}\par
00275 \par
00276 {\cf18 void} MtFreeVirtualMemory({\cf18 void}* ptr) \{\par
00277     {\cf19 if} (!ptr) {\cf19 return};\par
00278     tracelast_func({\cf22 "MtFreeVirtualMemory"});\par
00279 \par
00280     {\cf20 // Get the block header}\par
00281     BLOCK_HEADER* blk = ((BLOCK_HEADER**)ptr)[-1];\par
00282 \par
00283     {\cf20 // Check for our magic number}\par
00284     {\cf19 if} (blk->kind == BLK_EX) \{\par
00285         {\cf20 // This is a special allocation from MtAllocateVirtualMemoryEx.}\par
00286         {\cf20 // We need to unmap its pages instead of returning it to the free list.}\par
00287         {\cf18 size_t} region_size = blk->size;\par
00288         {\cf18 size_t} pages_to_unmap = region_size / FRAME_SIZE;\par
00289         blk->in_use = {\cf17 false};\par
00290         blk->kind = 0;\par
00291         {\cf19 for} ({\cf18 size_t} i = 0; i < pages_to_unmap; i++) \{\par
00292             {\cf18 void}* va_to_unmap = (uint8_t*)blk + (i * FRAME_SIZE);\par
00293             unmap_page(va_to_unmap); {\cf20 // This also frees the physical frame}\par
00294         \}\par
00295         {\cf19 return};\par
00296     \}\par
00297     \par
00298     kmemset(({\cf18 void}*)(blk + 1), 0, blk->size - {\cf17 sizeof}(BLOCK_HEADER));\par
00299     blk->in_use = {\cf17 false};\par
00300     insert_block_sorted(blk);\par
00301     coalesce_free_list();\par
00302 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.h}
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../cpu/cpu.h"}\par
{\f2 #include "../memory/allocator/allocator.h"}\par
{\f2 #include "../memory/paging/paging.h"}\par
{\f2 #include "../trace.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BLOCK_HEADER}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HEAP_START}\~ ((uintptr_t)(&{\b kernel_end}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HEAP_END}\~ (PHYS_MEM_BASE + PHYS_MEM_SIZE)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HEAP_SIZE}\~ ({\b HEAP_END} - {\b HEAP_START})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BLOCK_HEADER} {\b BLOCK_HEADER}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b BLK_NORMAL} = 0
, {\b BLK_EX} = 1
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b zero_bss} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zeroes out the BSS section (garbage data that might have left there) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b check_bss_zeroed} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_heap} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the Kernel's HEAP for dynamic memory allocation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b kmemset} (void *dest, int64_t val, uint64_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b kmemcpy} (void *dest, const void *src, uint32_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MtAllocateVirtualMemory} (size_t size, size_t align)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocates a block of memory from the kernel\'92s memory manager. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MtAllocateVirtualMemoryEx} (size_t size, size_t align, uint64_t flags)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b THE USE OF THIS FUNCTION IS NOT RECOMMENDED \'96 TO ADD {\b FLAGS} TO AN ALLOCATED MEMORY BUFFER USE MtAddPageFlags TO ITS POINTER!!!}  ** FREEING THE MEMORY OF THIS BUFFER WILL RESULT IN A PAGE FAULT ** Allocates a block of memory from the kernel's memory manager, and sets the paging flags according to the user. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtFreeVirtualMemory} (void *ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases (frees) a previously allocated block of memory back to the kernel\'92s memory manager. (DOES NOT UNMAP IF FUNCTION USED IS MtAllocateVirtualMemory !) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MtIsHeapAddressAllocated} (void *ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns if the heap pointer given has been allocated by MtAllocateVirtualMemory or not. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b kernel_end}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b kernel_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const size_t {\b kernel_length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b bss_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b bss_end}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HEAP_END\:memory.h}
{\xe \v memory.h\:HEAP_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HEAP_END\~ (PHYS_MEM_BASE + PHYS_MEM_SIZE)}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b memory.h}.}\par
}
{\xe \v HEAP_SIZE\:memory.h}
{\xe \v memory.h\:HEAP_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HEAP_SIZE\~ ({\b HEAP_END} - {\b HEAP_START})}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b memory.h}.}\par
}
{\xe \v HEAP_START\:memory.h}
{\xe \v memory.h\:HEAP_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HEAP_START\~ ((uintptr_t)(&{\b kernel_end}))}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BLOCK_HEADER\:memory.h}
{\xe \v memory.h\:BLOCK_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BLOCK_HEADER} {\b BLOCK_HEADER}}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BLK_NORMAL\:memory.h}
{\xe \v memory.h\:BLK_NORMAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BLK_NORMAL{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
\cell }{\cell }{\row }
{\xe \v BLK_EX\:memory.h}
{\xe \v memory.h\:BLK_EX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BLK_EX{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 45} of file {\b memory.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v check_bss_zeroed\:memory.h}
{\xe \v memory.h\:check_bss_zeroed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool check_bss_zeroed (void )}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v init_heap\:memory.h}
{\xe \v memory.h\:init_heap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_heap (void )}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the Kernel's HEAP for dynamic memory allocation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function declares the globals for the heap current end, as well as setting up the free_list pointer. It first creates 1 initial 4KiB frame, maps it to be paged in virtual memory, and increases the heap current end by the frame size (4KiB), so that 1 starting page is allocated. \par
}{
Definition at line {\b 36} of file {\b memory.c}.}\par
}
{\xe \v kmemcpy\:memory.h}
{\xe \v memory.h\:kmemcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * kmemcpy (void * dest, const void * src, uint32_t len)}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b memory.c}.}\par
}
{\xe \v kmemset\:memory.h}
{\xe \v memory.h\:kmemset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * kmemset (void * dest, int64_t val, uint64_t len)}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b memory.c}.}\par
}
{\xe \v MtAllocateVirtualMemory\:memory.h}
{\xe \v memory.h\:MtAllocateVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MtAllocateVirtualMemory (size_t wanted_size, size_t align)}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocates a block of memory from the kernel\'92s memory manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{Size in bytes to allocate\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i align} \cell }{Alignment for each byte block (use internal structs for process \\ other - use _Alignof)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to start of allocated memory\par
}}Allocates a block of memory from the kernel\'92s memory manager. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zero the new memory block out.\par
}{
Definition at line {\b 154} of file {\b memory.c}.}\par
}
{\xe \v MtAllocateVirtualMemoryEx\:memory.h}
{\xe \v memory.h\:MtAllocateVirtualMemoryEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MtAllocateVirtualMemoryEx (size_t size, size_t align, uint64_t flags)}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b THE USE OF THIS FUNCTION IS NOT RECOMMENDED \'96 TO ADD {\b FLAGS} TO AN ALLOCATED MEMORY BUFFER USE MtAddPageFlags TO ITS POINTER!!!}  ** FREEING THE MEMORY OF THIS BUFFER WILL RESULT IN A PAGE FAULT ** Allocates a block of memory from the kernel's memory manager, and sets the paging flags according to the user. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{Size in bytes to allocate\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i align} \cell }{Alignment for each byteblock (use internal structs for process \\ other - use _Alignof)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{PAGE_FLAGS flags.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to start of allocated memory\par
}}}{
Definition at line {\b 227} of file {\b memory.c}.}\par
}
{\xe \v MtFreeVirtualMemory\:memory.h}
{\xe \v memory.h\:MtFreeVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtFreeVirtualMemory (void * ptr)}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Releases (frees) a previously allocated block of memory back to the kernel\'92s memory manager. (DOES NOT UNMAP IF FUNCTION USED IS MtAllocateVirtualMemory !) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Pointer to the allocated memory block to free\cell }
{\row }
}
}{
Definition at line {\b 276} of file {\b memory.c}.}\par
}
{\xe \v MtIsHeapAddressAllocated\:memory.h}
{\xe \v memory.h\:MtIsHeapAddressAllocated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MtIsHeapAddressAllocated (void * ptr)}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns if the heap pointer given has been allocated by MtAllocateVirtualMemory or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ptr} \cell }{Address of what is given from MtAllocateVirtualMemory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 220} of file {\b memory.c}.}\par
}
{\xe \v zero_bss\:memory.h}
{\xe \v memory.h\:zero_bss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void zero_bss (void )}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zeroes out the BSS section (garbage data that might have left there) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function takes the start and end address of the {\f2 .bss}  section (provided by the linker script), and iterates over each byte from the start address up to (but not including) the end address, writing zero to each location. This ensures all global/static variables without initializers are zeroed. \par
}{
Definition at line {\b 23} of file {\b memory.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v bss_end\:memory.h}
{\xe \v memory.h\:bss_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bss_end{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bss_start\:memory.h}
{\xe \v memory.h\:bss_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bss_start{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kernel_end\:memory.h}
{\xe \v memory.h\:kernel_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t kernel_end{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kernel_length\:memory.h}
{\xe \v memory.h\:kernel_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t kernel_length{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kernel_start\:memory.h}
{\xe \v memory.h\:kernel_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t kernel_start{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
memory.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.h}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Memory Management Header}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef MEMORY_H}\par
00008 {\cf21 #define MEMORY_H}\par
00009  {\cf20 // Standard headers, required.}\par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stdint.h>}\par
00013 {\cf21 #include "../cpu/cpu.h"}\par
00014 {\cf21 #include "../memory/allocator/allocator.h"}\par
00015 {\cf21 #include "../memory/paging/paging.h"}\par
00016 {\cf21 #include "../trace.h"}\par
00017 {\cf20 /* Symbol defined in linker script, end of loaded kernel */}\par
00018 {\cf17 extern} uint8_t kernel_end;\par
00019 {\cf17 extern} uint8_t kernel_start;\par
00020 {\cf17 extern} {\cf17 const} {\cf18 size_t} kernel_length;\par
00021 \par
00022 {\cf20 /* Zero Out BSS */}\par
00023 {\cf17 extern} uint8_t bss_start;\par
00024 {\cf17 extern} uint8_t bss_end;\par
00025 \par
00026 {\cf18 void} zero_bss({\cf18 void});\par
00027 {\cf18 bool} check_bss_zeroed({\cf18 void});\par
00028 \par
00029 {\cf20 /* Heap Size */}\par
00030 \par
00031 {\cf20 /* Start and end of the heap region */}\par
00032 {\cf21 #define HEAP_START ((uintptr_t)(&kernel_end))}\par
00033 {\cf21 #define HEAP_END   (PHYS_MEM_BASE + PHYS_MEM_SIZE)}\par
00034 \par
00035 {\cf21 #define HEAP_SIZE  (HEAP_END - HEAP_START)}\par
00036 \par
00037 {\cf20 /* Block header placed immediately before each allocated chunk */}\par
00038 {\cf17 typedef} {\cf17 struct }_BLOCK_HEADER \{\par
00039     {\cf18 size_t} size;               {\cf20 /* total size of this block (including header) */}\par
00040     {\cf17 struct }_BLOCK_HEADER* next; {\cf20 /* next free block in the free list */}\par
00041     {\cf18 bool} in_use;\par
00042     uint32_t kind;\par
00043 \} BLOCK_HEADER;\par
00044 \par
00045 {\cf17 enum} \{ BLK_NORMAL = 0, BLK_EX = 1 \};\par
00046 \par
00047 {\cf20 /* Initialize the free list to cover the whole heap */}\par
00048 {\cf18 void} init_heap({\cf18 void});\par
00049 \par
00050 {\cf20 /* Simple Memset */}\par
00051 {\cf18 void}* kmemset({\cf18 void}* dest, int64_t val, uint64_t len);\par
00052 \par
00053 {\cf20 /* Added Memcpy */}\par
00054 {\cf18 void}* kmemcpy({\cf18 void}* dest, {\cf17 const} {\cf18 void}* src, uint32_t len);\par
00055 \par
00062 {\cf18 void}* MtAllocateVirtualMemory({\cf18 size_t} size, {\cf18 size_t} align);\par
00063 \par
00073 {\cf18 void}* MtAllocateVirtualMemoryEx({\cf18 size_t} size, {\cf18 size_t} align, uint64_t flags);\par
00074 \par
00079 {\cf18 void} MtFreeVirtualMemory({\cf18 void}* ptr);\par
00080 \par
00086 {\cf18 bool} MtIsHeapAddressAllocated({\cf18 void}* ptr);\par
00087 \par
00088 {\cf21 #endif }{\cf20 /* MEMORY_H */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.c}
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "paging.h"}\par
{\f2 #include "../../interrupts/idt.h"}\par
{\f2 #include "../memory.h"}\par
{\f2 #include "../../drivers/ahci/ahci.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGE_ENTRIES}\~ 512\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGE_SIZE_4K}\~ 0x1000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGE_MASK}\~ 0xFFFULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGE_ALIGN_DOWN}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGE_ALIGN_UP}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RECURSIVE_INDEX}\~ 0x1FF\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b map_page} (void *virtualaddress, uintptr_t physicaladdress, uint64_t flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b unmap_page} (void *virtualaddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_page_writable} (void *virtualaddress, bool writable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_page_user_access} (void *virtualaddress, bool user_accessible)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtAddPageFlags} (void *virtualaddress, uint64_t flags)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds (doesn't set) flags to the specified virtual address (if exists). This DOES NOT set flags! (Which means flags that are ON will stay ON and will not get rewritten) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MtIsAddressValid} (void *virtualAddr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if the virtual address given to it, is valid and present in the page tables of the kernel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MtTranslateVirtualToPhysical} (void *virtualaddress)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function translates the virtual address to its corresponding physical address in the page tables if present. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PAGE_ALIGN_DOWN\:paging.c}
{\xe \v paging.c\:PAGE_ALIGN_DOWN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGE_ALIGN_DOWN( x)}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((x) & ~PAGE_MASK)\par
}
{
Definition at line {\b 18} of file {\b paging.c}.}\par
}
{\xe \v PAGE_ALIGN_UP\:paging.c}
{\xe \v paging.c\:PAGE_ALIGN_UP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGE_ALIGN_UP( x)}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((x) + PAGE_MASK) & ~PAGE_MASK)\par
}
{
Definition at line {\b 19} of file {\b paging.c}.}\par
}
{\xe \v PAGE_ENTRIES\:paging.c}
{\xe \v paging.c\:PAGE_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGE_ENTRIES\~ 512}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b paging.c}.}\par
}
{\xe \v PAGE_MASK\:paging.c}
{\xe \v paging.c\:PAGE_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGE_MASK\~ 0xFFFULL}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b paging.c}.}\par
}
{\xe \v PAGE_SIZE_4K\:paging.c}
{\xe \v paging.c\:PAGE_SIZE_4K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGE_SIZE_4K\~ 0x1000}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b paging.c}.}\par
}
{\xe \v RECURSIVE_INDEX\:paging.c}
{\xe \v paging.c\:RECURSIVE_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RECURSIVE_INDEX\~ 0x1FF}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b paging.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v map_page\:paging.c}
{\xe \v paging.c\:map_page}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void map_page (void * virtualaddress, uintptr_t physicaladdress, uint64_t flags)}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b paging.c}.}\par
}
{\xe \v MtAddPageFlags\:paging.c}
{\xe \v paging.c\:MtAddPageFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtAddPageFlags (void * virtualaddress, uint64_t flags)}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds (doesn't set) flags to the specified virtual address (if exists). This DOES NOT set flags! (Which means flags that are ON will stay ON and will not get rewritten) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i virtualaddress} \cell }{VA\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{PAGE_FLAGS flags.\cell }
{\row }
}
}{
Definition at line {\b 251} of file {\b paging.c}.}\par
}
{\xe \v MtIsAddressValid\:paging.c}
{\xe \v paging.c\:MtIsAddressValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MtIsAddressValid (void * virtualAddr)}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if the virtual address given to it, is valid and present in the page tables of the kernel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i virtualAddr} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based if present or not.\par
}}}{
Definition at line {\b 285} of file {\b paging.c}.}\par
}
{\xe \v MtTranslateVirtualToPhysical\:paging.c}
{\xe \v paging.c\:MtTranslateVirtualToPhysical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MtTranslateVirtualToPhysical (void * virtualaddress)}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function translates the virtual address to its corresponding physical address in the page tables if present. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i virtualaddress} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Physical Address or 0 if not found.\par
}}}{
Definition at line {\b 314} of file {\b paging.c}.}\par
}
{\xe \v set_page_user_access\:paging.c}
{\xe \v paging.c\:set_page_user_access}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_page_user_access (void * virtualaddress, bool user_accessible)}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b paging.c}.}\par
}
{\xe \v set_page_writable\:paging.c}
{\xe \v paging.c\:set_page_writable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_page_writable (void * virtualaddress, bool writable)}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b paging.c}.}\par
}
{\xe \v unmap_page\:paging.c}
{\xe \v paging.c\:unmap_page}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool unmap_page (void * virtualaddress)}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b paging.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
paging.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.c}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     64-bit Memory Paging Implementation (4-level paging)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "paging.h"}\par
00008 {\cf21 #include "../../interrupts/idt.h"}\par
00009 {\cf21 #include "../memory.h"}\par
00010 {\cf21 #include "../../drivers/ahci/ahci.h"}\par
00011 \par
00012  {\cf20 // Constants for x86_64 paging}\par
00013 {\cf21 #define PAGE_ENTRIES        512}\par
00014 {\cf21 #define PAGE_SIZE_4K        0x1000}\par
00015 \par
00016 {\cf20 // Constants for aligning paging for AHCI}\par
00017 {\cf21 #define PAGE_MASK        0xFFFULL}\par
00018 {\cf21 #define PAGE_ALIGN_DOWN(x)  ((x) & ~PAGE_MASK)}\par
00019 {\cf21 #define PAGE_ALIGN_UP(x)    (((x) + PAGE_MASK) & ~PAGE_MASK)}\par
00020 {\cf21 #define RECURSIVE_INDEX 0x1FF}\par
00021 \par
00022 {\cf20 // From now on, physical addresses are uintptr_t, and virtual addresses are void pointers.}\par
00023 \par
00024 {\cf17 static} {\cf17 inline} uint64_t canonical_high(uint64_t addr) \{\par
00025     {\cf20 // If bit 47 is set, set all higher bits}\par
00026     {\cf19 if} (addr & (1ULL << 47)) \{\par
00027         {\cf19 return} addr | 0xFFFF000000000000ULL;\par
00028     \}\par
00029     {\cf19 return} addr;\par
00030 \}\par
00031 \par
00032 {\cf20 // Build recursive virtual pointer for different table levels:}\par
00033 {\cf20 // To get PML4 pointer:}\par
00034 {\cf17 static} {\cf17 inline} uint64_t* pml4_from_recursive({\cf18 void}) \{\par
00035     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00036         ((uint64_t)RECURSIVE_INDEX << 30) |\par
00037         ((uint64_t)RECURSIVE_INDEX << 21) |\par
00038         ((uint64_t)RECURSIVE_INDEX << 12);\par
00039     va = canonical_high(va);\par
00040     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00041 \}\par
00042 \par
00043 {\cf17 static} {\cf17 inline} uint64_t* pdpt_from_recursive({\cf18 size_t} pml4_i) \{\par
00044     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00045         ((uint64_t)RECURSIVE_INDEX << 30) |\par
00046         ((uint64_t)RECURSIVE_INDEX << 21) |\par
00047         ((uint64_t)pml4_i << 12); {\cf20 // <-- CORRECTED}\par
00048     va = canonical_high(va);\par
00049     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00050 \}\par
00051 \par
00052 {\cf20 // To get PD page for pml4_i, pdpt_i}\par
00053 {\cf17 static} {\cf17 inline} uint64_t* pd_from_recursive({\cf18 size_t} pml4_i, {\cf18 size_t} pdpt_i) \{\par
00054     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00055         ((uint64_t)RECURSIVE_INDEX << 30) |\par
00056         ((uint64_t)pml4_i << 21) |        {\cf20 // <-- CORRECTED}\par
00057         ((uint64_t)pdpt_i << 12);       {\cf20 // <-- CORRECTED}\par
00058     va = canonical_high(va);\par
00059     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00060 \}\par
00061 \par
00062 {\cf20 // To get PT page for pml4_i, pdpt_i, pd_i}\par
00063 {\cf17 static} {\cf17 inline} uint64_t* pt_from_recursive({\cf18 size_t} pml4_i, {\cf18 size_t} pdpt_i, {\cf18 size_t} pd_i) \{\par
00064     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00065         ((uint64_t)pml4_i << 30) |\par
00066         ((uint64_t)pdpt_i << 21) |\par
00067         ((uint64_t)pd_i << 12);\par
00068     va = canonical_high(va);\par
00069     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00070 \}\par
00071 \par
00072 {\cf20 // Extract indices from virtual address}\par
00073 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pml4_index(uint64_t va) \{ {\cf19 return} (va >> 39) & 0x1FF; \}\par
00074 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pdpt_index(uint64_t va) \{ {\cf19 return} (va >> 30) & 0x1FF; \}\par
00075 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pd_index(uint64_t va) \{ {\cf19 return} (va >> 21) & 0x1FF; \}\par
00076 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pt_index(uint64_t va) \{ {\cf19 return} (va >> 12) & 0x1FF; \}\par
00077 \par
00078 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_offset(uint64_t va) \{\par
00079     {\cf19 return} va & 0xFFF;\par
00080 \}\par
00081 \par
00082 {\cf20 // Input pt[pt_i] into the function}\par
00083 {\cf17 static} {\cf17 inline} uintptr_t get_frame_base(uint64_t pt_pti) \{\par
00084     {\cf19 return} pt_pti & 0xFFFFFFFFF000;\par
00085 \}\par
00086 \par
00087 {\cf17 static} {\cf18 void} map_range_higher(uintptr_t phys_start, uintptr_t phys_end, {\cf18 void}* va_start, uint64_t flags) \{\par
00088     uintptr_t p = phys_start;\par
00089     uintptr_t v = (uintptr_t)va_start;\par
00090 \par
00091     {\cf19 for} (; p < phys_end; p += PAGE_SIZE_4K, v += PAGE_SIZE_4K) \{\par
00092         map_page(({\cf18 void}*)v, p, flags);\par
00093     \}\par
00094 \}\par
00095 \par
00096 {\cf20 // Corrected map_page function}\par
00097 {\cf18 void} map_page({\cf18 void}* virtualaddress, uintptr_t physicaladdress, uint64_t flags) \{\par
00098     tracelast_func({\cf22 "map_page"});\par
00099     uint64_t va = (uint64_t)virtualaddress;\par
00100     uintptr_t pa = physicaladdress;\par
00101     BUGCHECK_ADDITIONALS addt = \{ 0 \};\par
00102     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00103     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00104     {\cf18 size_t} pd_i = get_pd_index(va);\par
00105     {\cf18 size_t} pt_i = get_pt_index(va);\par
00106 \par
00107     uint64_t* pml4_va = pml4_from_recursive();\par
00108 \par
00109     {\cf20 // 2. Ensure PDPT exists}\par
00110     {\cf19 if} (!(pml4_va[pml4_i] & PAGE_PRESENT)) \{\par
00111         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "In PML4, VA: %p, PA: %p, FLAGS: %d"}, virtualaddress, physicaladdress, flags);\par
00112         MtBugcheckEx(NULL, NULL, BAD_PAGING, &addt, {\cf17 true});\par
00113     \}\par
00114     uint64_t* pdpt_va = pdpt_from_recursive(pml4_i);\par
00115 \par
00116     {\cf20 // 3. Ensure PD exists}\par
00117     {\cf19 if} (!(pdpt_va[pdpt_i] & PAGE_PRESENT)) \{\par
00118         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "In PDPT, VA: %p, PA: %p, FLAGS: %d"}, virtualaddress, physicaladdress, flags);\par
00119         MtBugcheckEx(NULL, NULL, BAD_PAGING, &addt, {\cf17 true});\par
00120     \}\par
00121     uint64_t* pd_va = pd_from_recursive(pml4_i, pdpt_i);\par
00122 \par
00123     {\cf20 // 4. Ensure PT exists}\par
00124     {\cf19 if} (!(pd_va[pd_i] & PAGE_PRESENT)) \{\par
00125         ksnprintf(addt.str, {\cf17 sizeof}(addt.str), {\cf22 "In PD, VA: %p, PA: %p, FLAGS: %d"}, virtualaddress, physicaladdress, flags);\par
00126         MtBugcheckEx(NULL, NULL, BAD_PAGING, &addt, {\cf17 true});\par
00127     \}\par
00128     uint64_t* pt_va = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00129 \par
00130     {\cf20 // 5. Map the page}\par
00131     pt_va[pt_i] = (pa & ~0xFFFULL) | flags;\par
00132 \par
00133     {\cf20 // 6. Flush the TLB for the target virtual address}\par
00134     invlpg(virtualaddress);\par
00135 \}\par
00136 \par
00137 {\cf20 // Unmap a page (remove mapping and free frame)}\par
00138 {\cf18 bool} unmap_page({\cf18 void}* virtualaddress) \{\par
00139     tracelast_func({\cf22 "unmap_page"});\par
00140     uint64_t rip;\par
00141     GET_RIP(rip);\par
00142     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00143     uint64_t va = (uint64_t)virtualaddress;\par
00144 \par
00145     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00146     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00147     {\cf18 size_t} pd_i = get_pd_index(va);\par
00148     {\cf18 size_t} pt_i = get_pt_index(va);\par
00149 \par
00150     {\cf20 // FIX: Use recursive helpers to get VIRTUAL addresses of tables}\par
00151     uint64_t* pml4 = pml4_from_recursive();\par
00152     {\cf19 if} (!(pml4[pml4_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00153 \par
00154     uint64_t* pdpt = pdpt_from_recursive(pml4_i);\par
00155     {\cf19 if} (!(pdpt[pdpt_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00156 \par
00157     uint64_t* pd = pd_from_recursive(pml4_i, pdpt_i);\par
00158     {\cf19 if} (!(pd[pd_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00159 \par
00160     uint64_t* pt = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00161     {\cf19 if} (!(pt[pt_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00162 \par
00163     uintptr_t phys_addr = (uintptr_t)(pt[pt_i] & ~0xFFFULL);\par
00164 \par
00165     free_frame(phys_addr); {\cf20 // Free the underlying physical frame}\par
00166     pt[pt_i] = 0; {\cf20 // Clear the entry}\par
00167     invlpg(virtualaddress); {\cf20 // Invalidate the address}\par
00168     {\cf19 return} {\cf17 true};\par
00169 \}\par
00170 \par
00171 {\cf20 // Set writable flag on a page}\par
00172 {\cf18 void} set_page_writable({\cf18 void}* virtualaddress, {\cf18 bool} writable) \{\par
00173     tracelast_func({\cf22 "set_page_writable"});\par
00174     uint64_t rip;\par
00175     GET_RIP(rip);\par
00176     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00177     uint64_t va = (uint64_t)virtualaddress;\par
00178 \par
00179     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00180     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00181     {\cf18 size_t} pd_i = get_pd_index(va);\par
00182     {\cf18 size_t} pt_i = get_pt_index(va);\par
00183 \par
00184     uint64_t* pml4 = pml4_from_recursive();\par
00185 \par
00186     {\cf19 if} (!(pml4[pml4_i] & PAGE_PRESENT)) {\cf19 return};\par
00187     uint64_t* pdpt = pdpt_from_recursive(pml4_i);\par
00188 \par
00189     {\cf19 if} (!(pdpt[pdpt_i] & PAGE_PRESENT)) {\cf19 return};\par
00190     uint64_t* pd = pd_from_recursive(pml4_i, pdpt_i);\par
00191 \par
00192     {\cf19 if} (!(pd[pd_i] & PAGE_PRESENT)) {\cf19 return};\par
00193     uint64_t* pt = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00194 \par
00195     uint64_t entry = pt[pt_i];\par
00196     {\cf19 if} (writable) \{\par
00197         entry |= PAGE_RW;\par
00198     \}\par
00199     {\cf19 else} \{\par
00200         entry &= ~((uint64_t)PAGE_RW);\par
00201     \}\par
00202     pt[pt_i] = entry;\par
00203 \par
00204     {\cf20 // only flush if paging is already on:}\par
00205     uint64_t cr0;\par
00206     __asm__ {\cf17 volatile}({\cf22 "mov %%cr0, %0"} : {\cf22 "=r"}(cr0));\par
00207     {\cf19 if} (cr0 & 0x80000000) \{\par
00208         invlpg(({\cf18 void}*)va);\par
00209     \}\par
00210 \}\par
00211 \par
00212 {\cf18 void} set_page_user_access({\cf18 void}* virtualaddress, {\cf18 bool} user_accessible) \{\par
00213     tracelast_func({\cf22 "set_page_user_access"});\par
00214     uint64_t rip;\par
00215     GET_RIP(rip);\par
00216     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00217     uint64_t va = (uint64_t)virtualaddress;\par
00218 \par
00219     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00220     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00221     {\cf18 size_t} pd_i = get_pd_index(va);\par
00222     {\cf18 size_t} pt_i = get_pt_index(va);\par
00223 \par
00224     uint64_t* pml4 = pml4_from_recursive();\par
00225 \par
00226     {\cf19 if} (!(pml4[pml4_i] & PAGE_PRESENT)) {\cf19 return};\par
00227     uint64_t* pdpt = pdpt_from_recursive(pml4_i);\par
00228     {\cf19 if} (!(pdpt[pdpt_i] & PAGE_PRESENT)) {\cf19 return};\par
00229     uint64_t* pd = pd_from_recursive(pml4_i, pdpt_i);\par
00230     {\cf19 if} (!(pd[pd_i] & PAGE_PRESENT)) {\cf19 return};\par
00231     uint64_t* pt = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00232     {\cf19 if} (!(pt[pt_i] & PAGE_PRESENT)) {\cf19 return};\par
00233 \par
00234     uint64_t entry = pt[pt_i];\par
00235     {\cf19 if} (user_accessible) \{\par
00236         entry |= PAGE_USER;\par
00237     \}\par
00238     {\cf19 else} \{\par
00239         entry &= ~((uint64_t)PAGE_USER);\par
00240     \}\par
00241     pt[pt_i] = entry;\par
00242 \par
00243     {\cf20 // only flush if paging is already on:}\par
00244     uint64_t cr0;\par
00245     __asm__ {\cf17 volatile}({\cf22 "mov %%cr0, %0"} : {\cf22 "=r"}(cr0));\par
00246     {\cf19 if} (cr0 & 0x80000000) \{\par
00247         invlpg(({\cf18 void}*)va);\par
00248     \}\par
00249 \}\par
00250 \par
00251 {\cf18 void} MtAddPageFlags({\cf18 void}* virtualaddress, uint64_t flags) \{\par
00252     tracelast_func({\cf22 "set_page_flags"});\par
00253     uint64_t rip;\par
00254     GET_RIP(rip);\par
00255     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00256     uint64_t va = (uint64_t)virtualaddress;\par
00257 \par
00258     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00259     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00260     {\cf18 size_t} pd_i = get_pd_index(va);\par
00261     {\cf18 size_t} pt_i = get_pt_index(va);\par
00262 \par
00263     uint64_t* pml4 = pml4_from_recursive();\par
00264 \par
00265     {\cf19 if} (!(pml4[pml4_i] & PAGE_PRESENT)) {\cf19 return};\par
00266     uint64_t* pdpt = pdpt_from_recursive(pml4_i);\par
00267     {\cf19 if} (!(pdpt[pdpt_i] & PAGE_PRESENT)) {\cf19 return};\par
00268     uint64_t* pd = pd_from_recursive(pml4_i, pdpt_i);\par
00269     {\cf19 if} (!(pd[pd_i] & PAGE_PRESENT)) {\cf19 return};\par
00270     uint64_t* pt = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00271     {\cf19 if} (!(pt[pt_i] & PAGE_PRESENT)) {\cf19 return};\par
00272 \par
00273     uint64_t entry = pt[pt_i];\par
00274     entry |= flags;\par
00275     pt[pt_i] = entry;\par
00276 \par
00277     {\cf20 // only flush if paging is already on:}\par
00278     uint64_t cr0;\par
00279     __asm__ {\cf17 volatile}({\cf22 "mov %%cr0, %0"} : {\cf22 "=r"}(cr0));\par
00280     {\cf19 if} (cr0 & 0x80000000) \{\par
00281         invlpg(({\cf18 void}*)va);\par
00282     \}\par
00283 \}\par
00284 \par
00285 {\cf18 bool} MtIsAddressValid({\cf18 void}* virtualAddr) \{\par
00286     tracelast_func({\cf22 "MtIsAddressValid"});\par
00287     uint64_t rip;\par
00288     GET_RIP(rip);\par
00289     enforce_max_irql(DISPATCH_LEVEL, ({\cf18 void}*)rip);\par
00290 \par
00291     uint64_t va = (uint64_t)virtualAddr;\par
00292 \par
00293     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00294     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00295     {\cf18 size_t} pd_i = get_pd_index(va);\par
00296     {\cf18 size_t} pt_i = get_pt_index(va);\par
00297 \par
00298     uint64_t* pml4 = pml4_from_recursive();\par
00299     {\cf19 if} (!(pml4[pml4_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00300 \par
00301     {\cf20 // advance}\par
00302     uint64_t* pdpt = pdpt_from_recursive(pml4_i);\par
00303     {\cf19 if} (!(pdpt[pdpt_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00304 \par
00305     uint64_t* pd = pd_from_recursive(pml4_i, pdpt_i);\par
00306     {\cf19 if} (!(pd[pd_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00307 \par
00308     uint64_t* pt = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00309     {\cf19 if} (!(pt[pt_i] & PAGE_PRESENT)) {\cf19 return} {\cf17 false};\par
00310 \par
00311     {\cf19 return} {\cf17 true};\par
00312 \}\par
00313 \par
00314 uintptr_t MtTranslateVirtualToPhysical({\cf18 void}* virtualaddress) \{\par
00315     uint64_t va = (uint64_t)virtualaddress;\par
00316     {\cf18 size_t} pml4_i = get_pml4_index(va), pdpt_i = get_pdpt_index(va);\par
00317     {\cf18 size_t} pd_i = get_pd_index(va), pt_i = get_pt_index(va);\par
00318     {\cf18 size_t} offset = get_offset(va);\par
00319 \par
00320     uint64_t* pml4 = pml4_from_recursive();\par
00321     {\cf19 if} (!(pml4[pml4_i] & PAGE_PRESENT)) {\cf19 return} 0;\par
00322 \par
00323     uint64_t* pdpt = pdpt_from_recursive(pml4_i);\par
00324     uint64_t pdpt_entry = pdpt[pdpt_i];\par
00325     {\cf19 if} (!(pdpt_entry & PAGE_PRESENT)) {\cf19 return} 0;\par
00326     {\cf20 // 1GiB page?}\par
00327     {\cf19 if} (pdpt_entry & PAGE_PS) \{\par
00328         uintptr_t base = (pdpt_entry & ~((1ULL << 30) - 1)); {\cf20 // mask lower 30 bits}\par
00329         {\cf19 return} base + (va & ((1ULL << 30) - 1));\par
00330     \}\par
00331 \par
00332     uint64_t* pd = pd_from_recursive(pml4_i, pdpt_i);\par
00333     uint64_t pd_entry = pd[pd_i];\par
00334     {\cf19 if} (!(pd_entry & PAGE_PRESENT)) {\cf19 return} 0;\par
00335     {\cf20 // 2MiB page?}\par
00336     {\cf19 if} (pd_entry & PAGE_PS) \{\par
00337         uintptr_t base = pd_entry & ~((1ULL << 21) - 1);\par
00338         {\cf19 return} base + (va & ((1ULL << 21) - 1));\par
00339     \}\par
00340 \par
00341     uint64_t* pt = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00342     uint64_t pt_entry = pt[pt_i];\par
00343     {\cf19 if} (!(pt_entry & PAGE_PRESENT)) {\cf19 return} 0;\par
00344 \par
00345     uintptr_t base = pt_entry & ~0xFFFULL;\par
00346     {\cf19 return} base + offset;\par
00347 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.h}
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../cpu/cpu.h"}\par
{\f2 #include "../../drivers/gop/gop.h"}\par
{\f2 #include "../../trace.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_VA_START}\~ 0xfffff80000000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_PHYS_BASE}\~ 0x100000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MEM_TO_MAP}\~ 0x100000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNMAPPED_LOW_MEM_SIZE}\~ 0x10000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FLAGS} {\b FLAGS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FLAGS} \{ {\b PAGE_PRESENT} = 1 << 0
, {\b PAGE_RW} = 1 << 1
, {\b PAGE_USER} = 1 << 2
, {\b PAGE_PWT} = 0x8
, {\b PAGE_PCD} = 0x10
, {\b PAGE_ACCESSED} = 0x20
, {\b PAGE_DIRTY} = 0x40
, {\b PAGE_PS} = 0x80
, {\b PAGE_GLOBAL} = 0x100
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_page_writable} (void *virtualaddress, bool writable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_page_user_access} (void *virtualaddress, bool user_accessible)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b map_page} (void *virtualaddress, uintptr_t physicaladdress, uint64_t flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b unmap_page} (void *virtualaddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MtIsAddressValid} (void *virtualAddr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if the virtual address given to it, is valid and present in the page tables of the kernel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MtTranslateVirtualToPhysical} (void *virtualaddress)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function translates the virtual address to its corresponding physical address in the page tables if present. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MtAddPageFlags} (void *virtualaddress, uint64_t flags)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds (doesn't set) flags to the specified virtual address (if exists). This DOES NOT set flags! (Which means flags that are ON will stay ON and will not get rewritten) }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v KERNEL_PHYS_BASE\:paging.h}
{\xe \v paging.h\:KERNEL_PHYS_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_PHYS_BASE\~ 0x100000}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b paging.h}.}\par
}
{\xe \v KERNEL_VA_START\:paging.h}
{\xe \v paging.h\:KERNEL_VA_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_VA_START\~ 0xfffff80000000000ULL}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b paging.h}.}\par
}
{\xe \v MEM_TO_MAP\:paging.h}
{\xe \v paging.h\:MEM_TO_MAP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MEM_TO_MAP\~ 0x100000000ULL}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b paging.h}.}\par
}
{\xe \v UNMAPPED_LOW_MEM_SIZE\:paging.h}
{\xe \v paging.h\:UNMAPPED_LOW_MEM_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNMAPPED_LOW_MEM_SIZE\~ 0x10000}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b paging.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FLAGS\:paging.h}
{\xe \v paging.h\:FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FLAGS} {\b FLAGS}}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FLAGS\:paging.h}
{\xe \v paging.h\:_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FLAGS}}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PAGE_PRESENT\:paging.h}
{\xe \v paging.h\:PAGE_PRESENT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PRESENT{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
\cell }{\cell }{\row }
{\xe \v PAGE_RW\:paging.h}
{\xe \v paging.h\:PAGE_RW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_RW{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
\cell }{\cell }{\row }
{\xe \v PAGE_USER\:paging.h}
{\xe \v paging.h\:PAGE_USER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_USER{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
\cell }{\cell }{\row }
{\xe \v PAGE_PWT\:paging.h}
{\xe \v paging.h\:PAGE_PWT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PWT{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
\cell }{\cell }{\row }
{\xe \v PAGE_PCD\:paging.h}
{\xe \v paging.h\:PAGE_PCD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PCD{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
\cell }{\cell }{\row }
{\xe \v PAGE_ACCESSED\:paging.h}
{\xe \v paging.h\:PAGE_ACCESSED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_ACCESSED{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
\cell }{\cell }{\row }
{\xe \v PAGE_DIRTY\:paging.h}
{\xe \v paging.h\:PAGE_DIRTY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_DIRTY{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
\cell }{\cell }{\row }
{\xe \v PAGE_PS\:paging.h}
{\xe \v paging.h\:PAGE_PS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PS{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
\cell }{\cell }{\row }
{\xe \v PAGE_GLOBAL\:paging.h}
{\xe \v paging.h\:PAGE_GLOBAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_GLOBAL{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 26} of file {\b paging.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v map_page\:paging.h}
{\xe \v paging.h\:map_page}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void map_page (void * virtualaddress, uintptr_t physicaladdress, uint64_t flags)}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b paging.c}.}\par
}
{\xe \v MtAddPageFlags\:paging.h}
{\xe \v paging.h\:MtAddPageFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MtAddPageFlags (void * virtualaddress, uint64_t flags)}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds (doesn't set) flags to the specified virtual address (if exists). This DOES NOT set flags! (Which means flags that are ON will stay ON and will not get rewritten) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i virtualaddress} \cell }{VA\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i flags} \cell }{PAGE_FLAGS flags.\cell }
{\row }
}
}{
Definition at line {\b 251} of file {\b paging.c}.}\par
}
{\xe \v MtIsAddressValid\:paging.h}
{\xe \v paging.h\:MtIsAddressValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MtIsAddressValid (void * virtualAddr)}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks if the virtual address given to it, is valid and present in the page tables of the kernel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i virtualAddr} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based if present or not.\par
}}}{
Definition at line {\b 285} of file {\b paging.c}.}\par
}
{\xe \v MtTranslateVirtualToPhysical\:paging.h}
{\xe \v paging.h\:MtTranslateVirtualToPhysical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MtTranslateVirtualToPhysical (void * virtualaddress)}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function translates the virtual address to its corresponding physical address in the page tables if present. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i virtualaddress} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Physical Address or 0 if not found.\par
}}}{
Definition at line {\b 314} of file {\b paging.c}.}\par
}
{\xe \v set_page_user_access\:paging.h}
{\xe \v paging.h\:set_page_user_access}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_page_user_access (void * virtualaddress, bool user_accessible)}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b paging.c}.}\par
}
{\xe \v set_page_writable\:paging.h}
{\xe \v paging.h\:set_page_writable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_page_writable (void * virtualaddress, bool writable)}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b paging.c}.}\par
}
{\xe \v unmap_page\:paging.h}
{\xe \v paging.h\:unmap_page}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool unmap_page (void * virtualaddress)}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b paging.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
paging.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/paging/paging.h}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Paging and Dynamic Memory Allocation setup header.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_PAGING_H}\par
00007 {\cf21 #define X86_PAGING_H}\par
00008 \par
00009 \par
00010 {\cf20 // Standard headers, required.}\par
00011 {\cf21 #include <stddef.h>}\par
00012 {\cf21 #include <stdbool.h>}\par
00013 {\cf21 #include <stdint.h>}\par
00014 {\cf21 #include "../../cpu/cpu.h"}\par
00015 {\cf21 #include "../../drivers/gop/gop.h"}\par
00016 {\cf21 #include "../../trace.h"}\par
00017 \par
00018 {\cf21 #define KERNEL_VA_START 0xfffff80000000000ULL}\par
00019 {\cf21 #define KERNEL_PHYS_BASE 0x100000}\par
00020 {\cf21 #define MEM_TO_MAP 0x100000000ULL}\par
00021 {\cf21 #define UNMAPPED_LOW_MEM_SIZE 0x10000}\par
00022 \par
00023 {\cf20 // Flags for PDE/PTE}\par
00024 {\cf20 // Included = BIT SET (1)}\par
00025 {\cf20 // Not Included = BIT NOT SET (0)}\par
00026 {\cf17 typedef} {\cf17 enum} _FLAGS \{\par
00027     PAGE_PRESENT = 1 << 0,  {\cf20 // Bit 0}\par
00028     {\cf20 // 0 = page not present (access causes page fault)}\par
00029     {\cf20 // 1 = page is present, MMU translates virtual addresses}\par
00030 \par
00031     PAGE_RW = 1 << 1,  {\cf20 // Bit 1}\par
00032     {\cf20 // 0 = read-only}\par
00033     {\cf20 // 1 = read/write}\par
00034 \par
00035     PAGE_USER = 1 << 2,  {\cf20 // Bit 2}\par
00036     {\cf20 // 0 = supervisor (kernel) only}\par
00037     {\cf20 // 1 = user-mode access allowed}\par
00038 \par
00039     PAGE_PWT = 0x8,     {\cf20 // Bit 3}\par
00040     {\cf20 // Page Write-Through}\par
00041     {\cf20 // 0 = write-back caching}\par
00042     {\cf20 // 1 = write-through caching}\par
00043 \par
00044     PAGE_PCD = 0x10,    {\cf20 // Bit 4}\par
00045     {\cf20 // Page Cache Disable}\par
00046     {\cf20 // 0 = cacheable}\par
00047     {\cf20 // 1 = cache disabled}\par
00048 \par
00049     PAGE_ACCESSED = 0x20,    {\cf20 // Bit 5}\par
00050     {\cf20 // Set by CPU when page is read or written}\par
00051 \par
00052     PAGE_DIRTY = 0x40,    {\cf20 // Bit 6}\par
00053     {\cf20 // Set by CPU when page is written to}\par
00054 \par
00055     PAGE_PS = 0x80,    {\cf20 // Bit 7}\par
00056     {\cf20 // Page Size}\par
00057     {\cf20 // 0 = normal 4KB page}\par
00058     {\cf20 // 1 = large page (4MB in PDE, 2MB in PTE for PAE/long mode)}\par
00059 \par
00060     PAGE_GLOBAL = 0x100,   {\cf20 // Bit 8}\par
00061     {\cf20 // Global page}\par
00062     {\cf20 // Not flushed from TLB on CR3 reload}\par
00063 \} FLAGS;\par
00064 \par
00065 {\cf18 void} set_page_writable({\cf18 void}* virtualaddress, {\cf18 bool} writable);\par
00066 {\cf18 void} set_page_user_access({\cf18 void}* virtualaddress, {\cf18 bool} user_accessible);\par
00067 {\cf18 void} map_page({\cf18 void}* virtualaddress, uintptr_t physicaladdress, uint64_t flags);\par
00068 {\cf18 bool} unmap_page({\cf18 void}* virtualaddress);\par
00069 \par
00075 {\cf18 bool} MtIsAddressValid({\cf18 void}* virtualAddr);\par
00076 \par
00082 uintptr_t MtTranslateVirtualToPhysical({\cf18 void}* virtualaddress);\par
00083 \par
00090 {\cf18 void} MtAddPageFlags({\cf18 void}* virtualaddress, uint64_t flags);\par
00091 \par
00092 {\cf17 static} {\cf17 inline} {\cf18 void}* MtTranslateKernelPhysicalToVirtual(uintptr_t phys) \{\par
00093     {\cf20 // assume PHYS_MEM_OFFSET and MEM_TO_MAP/UNMAPPED_LOW_MEM_SIZE are known}\par
00094     {\cf19 if} (phys >= UNMAPPED_LOW_MEM_SIZE && phys < MEM_TO_MAP) \{\par
00095         {\cf19 return} ({\cf18 void}*)(phys + PHYS_MEM_OFFSET);\par
00096     \}\par
00097     {\cf19 return} NULL; {\cf20 // not mapped}\par
00098 \}\par
00099 \par
00100 {\cf17 static} {\cf17 inline} uintptr_t MtTranslateKernelVirtualToPhysical({\cf18 void}* v) \{\par
00101     uintptr_t va = (uintptr_t)v;\par
00102     {\cf19 if} (va >= PHYS_MEM_OFFSET && va < PHYS_MEM_OFFSET + MEM_TO_MAP) \{\par
00103         {\cf19 return} va - PHYS_MEM_OFFSET;\par
00104     \}\par
00105     {\cf19 return} 0; {\cf20 // not in direct-map window}\par
00106 \}\par
00107 \par
00108 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_SUCCEEDED}(Status)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macros to test status. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAILURE}(Status)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_SUCCESS}\~ (({\b MTSTATUS})0x00000000L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NOT_IMPLEMENTED}\~ (({\b MTSTATUS})0xC0000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_PARAM}\~ (({\b MTSTATUS})0xC0000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_STATE}\~ (({\b MTSTATUS})0xC0000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_ACCESS_DENIED}\~ (({\b MTSTATUS})0xC0000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_TIMEOUT}\~ (({\b MTSTATUS})0xC0000005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_UNSUPPORTED_OP}\~ (({\b MTSTATUS})0xC0000006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_ALREADY_EXISTS}\~ (({\b MTSTATUS})0xC0000007L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NOT_FOUND}\~ (({\b MTSTATUS})0xC0000008L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC0000009L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NO_MEMORY}\~ (({\b MTSTATUS})0xC1000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_MEMORY_LIMIT}\~ (({\b MTSTATUS})0xC1000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PAGE_FAULT_ERROR}\~ (({\b MTSTATUS})0xC1000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_HEAP_CORRUPTION}\~ (({\b MTSTATUS})0xC1000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_ADDRESS}\~ (({\b MTSTATUS})0xC1000005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_IO_ERROR}\~ (({\b MTSTATUS})0xC2000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_CORRUPTED}\~ (({\b MTSTATUS})0xC2000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_READ_ONLY}\~ (({\b MTSTATUS})0xC2000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_NO_SPACE}\~ (({\b MTSTATUS})0xC2000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_PERMISSION_DENIED}\~ (({\b MTSTATUS})0xC2000005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_INITIALIZATION_FAILURE}\~ (({\b MTSTATUS})0xC2000006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC2000007L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_CLUSTERS_FULL}\~ (({\b MTSTATUS})0xC2010001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_INVALID_CLUSTER}\~ (({\b MTSTATUS})0xC2010002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_DIR_FULL}\~ (({\b MTSTATUS})0xC2010003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_FILE_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_PATH_TOO_LONG}\~ (({\b MTSTATUS})0xC2010005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_INVALID_FILENAME}\~ (({\b MTSTATUS})0xC2010006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_EOF}\~ (({\b MTSTATUS})0xC2010007L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_DIRECTORY_ALREADY_EXISTS}\~ (({\b MTSTATUS})0xC2010008L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_PARENT_PATH_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010009L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_PARENT_PATH_NOT_DIR}\~ (({\b MTSTATUS})0xC2010010L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_INVALID_WRITE_MODE}\~ (({\b MTSTATUS})0xC2010011L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_CLUSTER_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010012L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_CLUSTER_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC2010013L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_DIRECTORY_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010014L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_NOT_READY}\~ (({\b MTSTATUS})0xC3000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_ERROR}\~ (({\b MTSTATUS})0xC3000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_TIMEOUT}\~ (({\b MTSTATUS})0xC3000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_UNSUPPORTED}\~ (({\b MTSTATUS})0xC3000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_INIT_FAILED}\~ (({\b MTSTATUS})0xC3010001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_PORT_FAILURE}\~ (({\b MTSTATUS})0xC3010002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_READ_FAILURE}\~ (({\b MTSTATUS})0xC3010003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_WRITE_FAILURE}\~ (({\b MTSTATUS})0xC3010004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_TIMEOUT}\~ (({\b MTSTATUS})0xC3010005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC3010006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_NOT_FOUND}\~ (({\b MTSTATUS})0xC4000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_CREATION_FAIL}\~ (({\b MTSTATUS})0xC4000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_SCHEDULER_ERROR}\~ (({\b MTSTATUS})0xC4000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_IRQL}\~ (({\b MTSTATUS})0xC4000004L)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int32_t {\b MTSTATUS}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MT_ACCESS_DENIED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_ACCESS_DENIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_ACCESS_DENIED\~ (({\b MTSTATUS})0xC0000004L)}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC3010006L)}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_INIT_FAILED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_INIT_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_INIT_FAILED\~ (({\b MTSTATUS})0xC3010001L)}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_PORT_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_PORT_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_PORT_FAILURE\~ (({\b MTSTATUS})0xC3010002L)}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_READ_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_READ_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_READ_FAILURE\~ (({\b MTSTATUS})0xC3010003L)}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_TIMEOUT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_TIMEOUT\~ (({\b MTSTATUS})0xC3010005L)}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_WRITE_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_WRITE_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_WRITE_FAILURE\~ (({\b MTSTATUS})0xC3010004L)}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_ALREADY_EXISTS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_ALREADY_EXISTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_ALREADY_EXISTS\~ (({\b MTSTATUS})0xC0000007L)}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_ERROR\~ (({\b MTSTATUS})0xC3000002L)}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_NOT_READY\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_NOT_READY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_NOT_READY\~ (({\b MTSTATUS})0xC3000001L)}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_TIMEOUT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_TIMEOUT\~ (({\b MTSTATUS})0xC3000003L)}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_UNSUPPORTED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_UNSUPPORTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_UNSUPPORTED\~ (({\b MTSTATUS})0xC3000004L)}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAILURE( Status)}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((Status) < 0)\par
}
{
Definition at line {\b 16} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_CLUSTER_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_CLUSTER_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_CLUSTER_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC2010013L)}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_CLUSTER_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_CLUSTER_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_CLUSTER_NOT_FOUND\~ (({\b MTSTATUS})0xC2010012L)}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_CLUSTERS_FULL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_CLUSTERS_FULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_CLUSTERS_FULL\~ (({\b MTSTATUS})0xC2010001L)}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_DIR_FULL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_DIR_FULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_DIR_FULL\~ (({\b MTSTATUS})0xC2010003L)}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_DIRECTORY_ALREADY_EXISTS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_DIRECTORY_ALREADY_EXISTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_DIRECTORY_ALREADY_EXISTS\~ (({\b MTSTATUS})0xC2010008L)}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_DIRECTORY_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_DIRECTORY_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_DIRECTORY_NOT_FOUND\~ (({\b MTSTATUS})0xC2010014L)}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_EOF\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_EOF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_EOF\~ (({\b MTSTATUS})0xC2010007L)}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_FILE_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_FILE_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_FILE_NOT_FOUND\~ (({\b MTSTATUS})0xC2010004L)}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_INVALID_CLUSTER\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_INVALID_CLUSTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_INVALID_CLUSTER\~ (({\b MTSTATUS})0xC2010002L)}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_INVALID_FILENAME\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_INVALID_FILENAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_INVALID_FILENAME\~ (({\b MTSTATUS})0xC2010006L)}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_INVALID_WRITE_MODE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_INVALID_WRITE_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_INVALID_WRITE_MODE\~ (({\b MTSTATUS})0xC2010011L)}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_PARENT_PATH_NOT_DIR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_PARENT_PATH_NOT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_PARENT_PATH_NOT_DIR\~ (({\b MTSTATUS})0xC2010010L)}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_PARENT_PATH_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_PARENT_PATH_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_PARENT_PATH_NOT_FOUND\~ (({\b MTSTATUS})0xC2010009L)}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_PATH_TOO_LONG\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_PATH_TOO_LONG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_PATH_TOO_LONG\~ (({\b MTSTATUS})0xC2010005L)}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC0000009L)}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_HEAP_CORRUPTION\:mtstatus.h}
{\xe \v mtstatus.h\:MT_HEAP_CORRUPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_HEAP_CORRUPTION\~ (({\b MTSTATUS})0xC1000004L)}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_ADDRESS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_ADDRESS\~ (({\b MTSTATUS})0xC1000005L)}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_IRQL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_IRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_IRQL\~ (({\b MTSTATUS})0xC4000004L)}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_PARAM\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_PARAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_PARAM\~ (({\b MTSTATUS})0xC0000002L)}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_STATE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_STATE\~ (({\b MTSTATUS})0xC0000003L)}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_IO_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_IO_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_IO_ERROR\~ (({\b MTSTATUS})0xC2000001L)}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_MEMORY_LIMIT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_MEMORY_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_MEMORY_LIMIT\~ (({\b MTSTATUS})0xC1000002L)}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NO_MEMORY\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NO_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NO_MEMORY\~ (({\b MTSTATUS})0xC1000001L)}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NOT_FOUND\~ (({\b MTSTATUS})0xC0000008L)}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NOT_IMPLEMENTED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NOT_IMPLEMENTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NOT_IMPLEMENTED\~ (({\b MTSTATUS})0xC0000001L)}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_PAGE_FAULT_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_PAGE_FAULT_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PAGE_FAULT_ERROR\~ (({\b MTSTATUS})0xC1000003L)}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_SCHEDULER_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_SCHEDULER_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_SCHEDULER_ERROR\~ (({\b MTSTATUS})0xC4000003L)}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_SUCCEEDED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_SUCCEEDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_SUCCEEDED( Status)}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((Status) >= 0)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macros to test status. }}\par
{
Definition at line {\b 15} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_SUCCESS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_SUCCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_SUCCESS\~ (({\b MTSTATUS})0x00000000L)}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_THREAD_CREATION_FAIL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_THREAD_CREATION_FAIL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_CREATION_FAIL\~ (({\b MTSTATUS})0xC4000002L)}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_THREAD_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_THREAD_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_NOT_FOUND\~ (({\b MTSTATUS})0xC4000001L)}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_TIMEOUT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_TIMEOUT\~ (({\b MTSTATUS})0xC0000005L)}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_UNSUPPORTED_OP\:mtstatus.h}
{\xe \v mtstatus.h\:MT_UNSUPPORTED_OP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_UNSUPPORTED_OP\~ (({\b MTSTATUS})0xC0000006L)}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_CORRUPTED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_CORRUPTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_CORRUPTED\~ (({\b MTSTATUS})0xC2000002L)}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC2000007L)}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_INITIALIZATION_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_INITIALIZATION_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_INITIALIZATION_FAILURE\~ (({\b MTSTATUS})0xC2000006L)}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_NO_SPACE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_NO_SPACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_NO_SPACE\~ (({\b MTSTATUS})0xC2000004L)}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_PERMISSION_DENIED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_PERMISSION_DENIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_PERMISSION_DENIED\~ (({\b MTSTATUS})0xC2000005L)}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_READ_ONLY\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_READ_ONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_READ_ONLY\~ (({\b MTSTATUS})0xC2000003L)}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b mtstatus.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v MTSTATUS\:mtstatus.h}
{\xe \v mtstatus.h\:MTSTATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int32_t {\b MTSTATUS}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b mtstatus.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mtstatus.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      MTStatus definitions per subsystem or kernel wide. (STATUS RETURNS)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef MTSTATUS_H}\par
00008 {\cf21 #define MTSTATUS_H}\par
00009 \par
00010 {\cf21 #include <stdint.h>}\par
00011 \par
00012 {\cf17 typedef} int32_t MTSTATUS;\par
00013 \par
00015 {\cf21 #define MT_SUCCEEDED(Status) ((Status) >= 0)}\par
00016 {\cf21 #define MT_FAILURE(Status)    ((Status) < 0)}\par
00017 \par
00018 {\cf20 //}\par
00019 {\cf20 // ==========================}\par
00020 {\cf20 // GENERAL MTSTATUS}\par
00021 {\cf20 // ==========================}\par
00022 {\cf21 #define MT_SUCCESS              ((MTSTATUS)0x00000000L)}\par
00023 {\cf21 #define MT_NOT_IMPLEMENTED      ((MTSTATUS)0xC0000001L)}\par
00024 {\cf21 #define MT_INVALID_PARAM        ((MTSTATUS)0xC0000002L)}\par
00025 {\cf21 #define MT_INVALID_STATE        ((MTSTATUS)0xC0000003L)}\par
00026 {\cf21 #define MT_ACCESS_DENIED        ((MTSTATUS)0xC0000004L)}\par
00027 {\cf21 #define MT_TIMEOUT              ((MTSTATUS)0xC0000005L)}\par
00028 {\cf21 #define MT_UNSUPPORTED_OP       ((MTSTATUS)0xC0000006L)}\par
00029 {\cf21 #define MT_ALREADY_EXISTS       ((MTSTATUS)0xC0000007L)}\par
00030 {\cf21 #define MT_NOT_FOUND            ((MTSTATUS)0xC0000008L)}\par
00031 {\cf21 #define MT_GENERAL_FAILURE      ((MTSTATUS)0xC0000009L)}\par
00032 \par
00033 {\cf20 //}\par
00034 {\cf20 // ==========================}\par
00035 {\cf20 // MEMORY MTSTATUS}\par
00036 {\cf20 // ==========================}\par
00037 {\cf21 #define MT_NO_MEMORY            ((MTSTATUS)0xC1000001L)}\par
00038 {\cf21 #define MT_MEMORY_LIMIT         ((MTSTATUS)0xC1000002L)}\par
00039 {\cf21 #define MT_PAGE_FAULT_ERROR     ((MTSTATUS)0xC1000003L)}\par
00040 {\cf21 #define MT_HEAP_CORRUPTION      ((MTSTATUS)0xC1000004L)}\par
00041 {\cf21 #define MT_INVALID_ADDRESS      ((MTSTATUS)0xC1000005L)}\par
00042 \par
00043 {\cf20 //}\par
00044 {\cf20 // ==========================}\par
00045 {\cf20 // VIRTUAL FILESYSTEM MTSTATUS}\par
00046 {\cf20 // ==========================}\par
00047 {\cf21 #define MT_IO_ERROR                     ((MTSTATUS)0xC2000001L)}\par
00048 {\cf21 #define MT_VFS_CORRUPTED                ((MTSTATUS)0xC2000002L)}\par
00049 {\cf21 #define MT_VFS_READ_ONLY                ((MTSTATUS)0xC2000003L)}\par
00050 {\cf21 #define MT_VFS_NO_SPACE                 ((MTSTATUS)0xC2000004L)}\par
00051 {\cf21 #define MT_VFS_PERMISSION_DENIED        ((MTSTATUS)0xC2000005L)}\par
00052 {\cf21 #define MT_VFS_INITIALIZATION_FAILURE   ((MTSTATUS)0xC2000006L)}\par
00053 {\cf21 #define MT_VFS_GENERAL_FAILURE          ((MTSTATUS)0xC2000007L)}\par
00054 \par
00055 {\cf20 //}\par
00056 {\cf20 // FAT32-specific MTSTATUS}\par
00057 {\cf20 //}\par
00058 {\cf21 #define MT_FAT32_CLUSTERS_FULL      ((MTSTATUS)0xC2010001L) }{\cf20 // No free clusters left}\par
00059 {\cf21 #define MT_FAT32_INVALID_CLUSTER    ((MTSTATUS)0xC2010002L) }{\cf20 // Invalid cluster reference}\par
00060 {\cf21 #define MT_FAT32_DIR_FULL           ((MTSTATUS)0xC2010003L) }{\cf20 // Directory has no free entries}\par
00061 {\cf21 #define MT_FAT32_FILE_NOT_FOUND     ((MTSTATUS)0xC2010004L)}\par
00062 {\cf21 #define MT_FAT32_PATH_TOO_LONG      ((MTSTATUS)0xC2010005L)}\par
00063 {\cf21 #define MT_FAT32_INVALID_FILENAME   ((MTSTATUS)0xC2010006L)}\par
00064 {\cf21 #define MT_FAT32_EOF                ((MTSTATUS)0xC2010007L) }{\cf20 // End of file reached}\par
00065 {\cf21 #define MT_FAT32_DIRECTORY_ALREADY_EXISTS ((MTSTATUS)0xC2010008L) }{\cf20 // The specified directory already exists in the path.}\par
00066 {\cf21 #define MT_FAT32_PARENT_PATH_NOT_FOUND ((MTSTATUS)0xC2010009L) }{\cf20 // The directory's parent path has not been found.}\par
00067 {\cf21 #define MT_FAT32_PARENT_PATH_NOT_DIR ((MTSTATUS)0xC2010010L) }{\cf20 // The directory's parent path is not a directory.}\par
00068 {\cf21 #define MT_FAT32_INVALID_WRITE_MODE ((MTSTATUS)0xC2010011L) }{\cf20 // The write mode given to the function is invalid. (Not in FAT32_WRITE_MODE enum)}\par
00069 {\cf21 #define MT_FAT32_CLUSTER_NOT_FOUND ((MTSTATUS)0xC2010012L) }{\cf20 // The directory's / file cluster couldn't have been found.}\par
00070 {\cf21 #define MT_FAT32_CLUSTER_GENERAL_FAILURE ((MTSTATUS)0xC2010013L) }{\cf20 // General failure on a cluster operation.}\par
00071 {\cf21 #define MT_FAT32_DIRECTORY_NOT_FOUND ((MTSTATUS)0xC2010014L) }{\cf20 // FAT32 Directory not found.}\par
00072 \par
00073 {\cf20 //}\par
00074 {\cf20 // ==========================}\par
00075 {\cf20 // DRIVER / DEVICE MTSTATUS}\par
00076 {\cf20 // ==========================}\par
00077 {\cf21 #define MT_DEVICE_NOT_READY     ((MTSTATUS)0xC3000001L)}\par
00078 {\cf21 #define MT_DEVICE_ERROR         ((MTSTATUS)0xC3000002L)}\par
00079 {\cf21 #define MT_DEVICE_TIMEOUT       ((MTSTATUS)0xC3000003L)}\par
00080 {\cf21 #define MT_DEVICE_UNSUPPORTED   ((MTSTATUS)0xC3000004L)}\par
00081 {\cf21 #define MT_AHCI_INIT_FAILED     ((MTSTATUS)0xC3010001L)}\par
00082 {\cf21 #define MT_AHCI_PORT_FAILURE    ((MTSTATUS)0xC3010002L)}\par
00083 {\cf21 #define MT_AHCI_READ_FAILURE    ((MTSTATUS)0xC3010003L)}\par
00084 {\cf21 #define MT_AHCI_WRITE_FAILURE   ((MTSTATUS)0xC3010004L)}\par
00085 {\cf21 #define MT_AHCI_TIMEOUT         ((MTSTATUS)0xC3010005L)}\par
00086 {\cf21 #define MT_AHCI_GENERAL_FAILURE ((MTSTATUS)0xC3010006L)}\par
00087 \par
00088 {\cf20 //}\par
00089 {\cf20 // ==========================}\par
00090 {\cf20 // THREAD / SCHEDULER MTSTATUS}\par
00091 {\cf20 // ==========================}\par
00092 {\cf21 #define MT_THREAD_NOT_FOUND     ((MTSTATUS)0xC4000001L)}\par
00093 {\cf21 #define MT_THREAD_CREATION_FAIL ((MTSTATUS)0xC4000002L)}\par
00094 {\cf21 #define MT_SCHEDULER_ERROR      ((MTSTATUS)0xC4000003L)}\par
00095 {\cf21 #define MT_INVALID_IRQL         ((MTSTATUS)0xC4000004L)}\par
00096 \par
00097 {\cf21 #endif }{\cf20 // MTSTATUS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "intrin/intrin.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TIME_ENTRY}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CMOS_ADDRESS}\~ 0x70\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CMOS_DATA}\~ 0x71\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CMOS_ADDRESS\:time.h}
{\xe \v time.h\:CMOS_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CMOS_ADDRESS\~ 0x70}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b time.h}.}\par
}
{\xe \v CMOS_DATA\:time.h}
{\xe \v time.h\:CMOS_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CMOS_DATA\~ 0x71}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b time.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
time.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     CMOS Time implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_TIME_H}\par
00008 {\cf21 #define X86_TIME_H}\par
00009 {\cf21 #include <stdint.h>}\par
00010 {\cf21 #include <stdbool.h>}\par
00011 {\cf21 #include "intrin/intrin.h"}\par
00012 \par
00013 {\cf20 // RTC CMOS ports}\par
00014 {\cf21 #define CMOS_ADDRESS 0x70}\par
00015 {\cf21 #define CMOS_DATA    0x71}\par
00016 \par
00017 {\cf20 // TIME_ENTRY struct with full date}\par
00018 {\cf17 typedef} {\cf17 struct }\{\par
00019     uint8_t second;   {\cf20 // 0\'9659}\par
00020     uint8_t minute;   {\cf20 // 0\'9659}\par
00021     uint8_t hour;     {\cf20 // 0\'9623}\par
00022     uint8_t day;      {\cf20 // 1\'9631}\par
00023     uint8_t month;    {\cf20 // 1\'9612}\par
00024     uint16_t year;    {\cf20 // full year, e.g., 2025}\par
00025 \} TIME_ENTRY;\par
00026 \par
00027 {\cf20 // Read from CMOS}\par
00028 {\cf17 static} {\cf17 inline} uint8_t cmos_read(uint8_t reg) \{\par
00029     __outbyte(CMOS_ADDRESS, reg);\par
00030     {\cf19 return} __inbyte(CMOS_DATA);\par
00031 \}\par
00032 \par
00033 {\cf20 // Check if RTC is updating}\par
00034 {\cf17 static} {\cf17 inline} {\cf18 bool} rtc_updating({\cf18 void}) \{\par
00035     __outbyte(CMOS_ADDRESS, 0x0A);\par
00036     {\cf19 return} (__inbyte(CMOS_DATA) & 0x80) != 0;\par
00037 \}\par
00038 \par
00039 {\cf20 // Convert BCD \'E2\'86\'92 binary}\par
00040 {\cf17 static} {\cf17 inline} uint8_t bcd_to_bin(uint8_t val) \{\par
00041     {\cf19 return} ((val >> 4) * 10) + (val & 0x0F);\par
00042 \}\par
00043 \par
00044 {\cf20 // Get current time/date (GIVES UTC TIME)}\par
00045 {\cf17 static} TIME_ENTRY get_time({\cf18 void}) \{\par
00046     TIME_ENTRY t;\par
00047     uint8_t century = 0;\par
00048     uint8_t regB;\par
00049 \par
00050     {\cf20 // Wait until RTC is not updating}\par
00051     {\cf19 while} (rtc_updating());\par
00052 \par
00053     {\cf20 // Read raw values}\par
00054     t.second = cmos_read(0x00);\par
00055     t.minute = cmos_read(0x02);\par
00056     t.hour = cmos_read(0x04);\par
00057     t.day = cmos_read(0x07);\par
00058     t.month = cmos_read(0x08);\par
00059     uint8_t year = cmos_read(0x09);\par
00060 \par
00061     {\cf20 // Some BIOSes provide century register (0x32) if available}\par
00062     century = cmos_read(0x32);\par
00063 \par
00064     {\cf20 // Status register B tells us data format}\par
00065     regB = cmos_read(0x0B);\par
00066 \par
00067     {\cf20 // Convert from BCD if needed}\par
00068     {\cf19 if} (!(regB & 0x04)) \{\par
00069         t.second = bcd_to_bin(t.second);\par
00070         t.minute = bcd_to_bin(t.minute);\par
00071         t.hour = bcd_to_bin(t.hour & 0x7F);\par
00072         t.day = bcd_to_bin(t.day);\par
00073         t.month = bcd_to_bin(t.month);\par
00074         year = bcd_to_bin(year);\par
00075         {\cf19 if} (century) century = bcd_to_bin(century);\par
00076     \}\par
00077 \par
00078     {\cf20 // Convert 12h \'E2\'86\'92 24h if needed}\par
00079     {\cf19 if} (!(regB & 0x02) && (t.hour & 0x80)) \{\par
00080         t.hour = ((t.hour & 0x7F) + 12) % 24;\par
00081     \}\par
00082 \par
00083     {\cf20 // Build full year}\par
00084     {\cf19 if} (century != 0) \{\par
00085         t.year = (century * 100) + year;\par
00086     \}\par
00087     {\cf19 else} \{\par
00088         {\cf20 // Fallback: assume 20xx}\par
00089         t.year = 2000 + year;\par
00090     \}\par
00091 \par
00092     {\cf19 return} t;\par
00093 \}\par
00094 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/trace.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/trace.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/trace.h}
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "intrin/intrin.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LASTFUNC_HISTORY}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LASTFUNC_BUFFER_SIZE}\~ 128\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LASTFUNC_HISTORY_SIZE}\~ 10\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LASTFUNC_BUFFER_SIZE\:trace.h}
{\xe \v trace.h\:LASTFUNC_BUFFER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LASTFUNC_BUFFER_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b trace.h}.}\par
}
{\xe \v LASTFUNC_HISTORY_SIZE\:trace.h}
{\xe \v trace.h\:LASTFUNC_HISTORY_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LASTFUNC_HISTORY_SIZE\~ 10}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b trace.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
trace.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/trace.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/trace.h}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // trace.h}\par
00002 {\cf21 #ifndef TRACE_H}\par
00003 {\cf21 #define TRACE_H}\par
00004 \par
00005 {\cf21 #include <stddef.h>}\par
00006 {\cf21 #include <stdint.h>}\par
00007 {\cf21 #include <stdbool.h>}\par
00008 {\cf21 #include "intrin/intrin.h"}\par
00009 \par
00010 {\cf21 #define LASTFUNC_BUFFER_SIZE 128}\par
00011 {\cf21 #define LASTFUNC_HISTORY_SIZE 10}\par
00012 \par
00013 {\cf17 typedef} {\cf17 struct }\{\par
00014     uint8_t names[LASTFUNC_HISTORY_SIZE][LASTFUNC_BUFFER_SIZE];\par
00015     {\cf18 int}     current_index;\par
00016 \} LASTFUNC_HISTORY;\par
00017 \par
00018 {\cf20 // this stays `static inline` so every .c gets its own copy}\par
00019 {\cf17 static} {\cf17 inline} {\cf18 void} tracelast_func({\cf17 const} {\cf18 char}* function_name) \{\par
00020 {\cf21 #ifdef GDB}\par
00021     {\cf20 // if GDB is defined, we wont trace last functions, as it is VERY hard to debug with having to step 128 times.}\par
00022     UNREFERENCED_PARAMETER(function_name);\par
00023     {\cf19 return};\par
00024 {\cf21 #elif defined(DEBUG)}\par
00025     {\cf17 extern} {\cf18 bool} isBugChecking;\par
00026     {\cf17 extern} LASTFUNC_HISTORY lastfunc_history;\par
00027 \par
00028     {\cf19 if} (!function_name || isBugChecking) {\cf19 return};\par
00029 \par
00030     lastfunc_history.current_index =\par
00031         (lastfunc_history.current_index + 1) % LASTFUNC_HISTORY_SIZE;\par
00032 \par
00033     {\cf20 // Clear entire buffer slot to 0 to avoid leftover garbage}\par
00034     {\cf19 for} ({\cf18 size_t} j = 0; j < LASTFUNC_BUFFER_SIZE; j++) \{\par
00035         lastfunc_history.names[lastfunc_history.current_index][j] = 0;\par
00036     \}\par
00037 \par
00038     {\cf20 // Copy function_name safely}\par
00039     {\cf19 for} ({\cf18 size_t} i = 0; i < LASTFUNC_BUFFER_SIZE - 1 && function_name[i]; i++) \{\par
00040         lastfunc_history.names[lastfunc_history.current_index][i] =\par
00041             (uint8_t)function_name[i];\par
00042     \}\par
00043     {\cf20 // Explicit null terminator already guaranteed by zero clear}\par
00044 {\cf21 #else}\par
00045     UNREFERENCED_PARAMETER(function_name);\par
00046     {\cf19 return};\par
00047 {\cf21 #endif}\par
00048 \}\par
00049 \par
00050 {\cf21 #endif }{\cf20 // TRACE_H}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
