{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment My Project }My Project}
{\comment Generated by doxygen 1.14.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt My Project}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b __attribute__} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _ACPI_SDT_HEADER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _AHCI_PORT_CTX} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACXW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _APC_STATE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _BLOCK_DEVICE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _BOOT_INFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _CONTEXT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DBG_CALLBACK_INFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DEBUG_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DEBUG_REGISTERS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DOUBLY_LINKED_LIST} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DPC} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _DPC_DATA} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EFI_MEMORY_DESCRIPTOR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EPROCESS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADBR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _ETHREAD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EVENT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EX_FRAME_REGISTRATION} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADCZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EXCEPTION_RECORD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _EXCEPTION_REGISTRATION_RECORD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _FADT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADDN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _FAT32_FSINFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADFP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _FIS_REG_H2D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _GenericAddressStructure} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _GOP_PARAMS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HANDLE_TABLE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HANDLE_TABLE_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADHT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_CMD_HEADER} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADIB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_CMD_TBL} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_MEM} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_PORT} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _HBA_PRDT_ENTRY} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADJY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _IDT_ENTRY_64} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADKG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _IDT_PTR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _IPI_PARAMS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _IPROCESS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADKX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _ITHREAD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _MADT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _MM_PFN_DATABASE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADLU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _MM_PFN_LIST} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _MMPTE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _MMVAD} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _MUTEX} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADNW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _OBJECT_HEADER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _OBJECT_TYPE} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _OBJECT_TYPE_INITIALIZER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _PAGE_PARAMETERS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _PFN_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _POOL_DESCRIPTOR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _POOL_HEADER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADPU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _PROCESSOR} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADQC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _Queue} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADRS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _RSDP_Descriptor} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADRX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _RUNDOWN_REF} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _SINGLE_LINKED_LIST} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _SMP_BOOTINFO} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _SPINLOCK} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _STACK_REAPER_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADSY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _TRAP_FRAME} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADTD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _WAIT_BLOCK} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b _XSDT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FAT32_LFN_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FS_DRIVER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADUU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LFN_ENTRY_BUFFER} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MOUNTED_FS} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TIME_ENTRY} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAADVN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b assert.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b gen_offsets.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b kernel.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACSK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b kernel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b mtstatus.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACTW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b time.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACWO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/exp/{\b exception.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ht/{\b handle.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/md/{\b debugfunctions.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/{\b attach.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/{\b bugcheck.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/{\b dpc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/{\b irql.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAET \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/{\b meinit.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/{\b scheduler.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b acpi.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b ap_main.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b apic.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b handlers.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b idt.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b isr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b pit.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/{\b smp.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b fault.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b hypermap.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b map.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b mminit.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b mmio.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b mmproc.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b pfn.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b pool.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b va.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/{\b vad.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/{\b events.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/{\b mutex.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/{\b rundown.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/{\b spinlock.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ob/{\b ob.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/{\b cid.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/{\b process.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/{\b psmgr.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/{\b pswork.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/{\b thread.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAST \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/{\b block.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/{\b block.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/{\b font8x16.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/{\b gop.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/{\b gop.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b annotations.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b behavior.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b core.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b efi.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b exception.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ht.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b macros.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b md.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mg.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ms.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mtos.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ob.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACIU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ps.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b rtl.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b stdarg_myos.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/{\b atomic.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACNR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/{\b intrin.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
__attribute__ Struct Reference\par \pard\plain 
{\tc\tcl2 \v __attribute__}
{\xe \v __attribute__}
{\bkmkstart AAAAAAACWS}
{\bkmkend AAAAAAACWS}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AcpiProcessorId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ApicId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b IoApicId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b IoApicAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b GlobalSystemInterruptBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Bus}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Source}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b GlobalSystemInterrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Lint}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b Reserved}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b X2ApicId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b AcpiProcessorUid}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 306} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACWT}
{\bkmkend AAAAAAACWT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AcpiProcessorId\:__attribute__}
{\xe \v __attribute__\:AcpiProcessorId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AcpiProcessorId}}
\par
{\bkmkstart AAAAAAACWU}
{\bkmkend AAAAAAACWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 309} of file {\b mh.h}.}\par
}
{\xe \v AcpiProcessorUid\:__attribute__}
{\xe \v __attribute__\:AcpiProcessorUid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t AcpiProcessorUid}}
\par
{\bkmkstart AAAAAAACWV}
{\bkmkend AAAAAAACWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 346} of file {\b mh.h}.}\par
}
{\xe \v ApicId\:__attribute__}
{\xe \v __attribute__\:ApicId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ApicId}}
\par
{\bkmkstart AAAAAAACWW}
{\bkmkend AAAAAAACWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 310} of file {\b mh.h}.}\par
}
{\xe \v Bus\:__attribute__}
{\xe \v __attribute__\:Bus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Bus}}
\par
{\bkmkstart AAAAAAACWX}
{\bkmkend AAAAAAACWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 326} of file {\b mh.h}.}\par
}
{\xe \v Flags\:__attribute__}
{\xe \v __attribute__\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Flags}}
\par
{\bkmkstart AAAAAAACWY}
{\bkmkend AAAAAAACWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 311} of file {\b mh.h}.}\par
}
{\xe \v Flags\:__attribute__}
{\xe \v __attribute__\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Flags}}
\par
{\bkmkstart AAAAAAACWZ}
{\bkmkend AAAAAAACWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 329} of file {\b mh.h}.}\par
}
{\xe \v GlobalSystemInterrupt\:__attribute__}
{\xe \v __attribute__\:GlobalSystemInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GlobalSystemInterrupt}}
\par
{\bkmkstart AAAAAAACXA}
{\bkmkend AAAAAAACXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 328} of file {\b mh.h}.}\par
}
{\xe \v GlobalSystemInterruptBase\:__attribute__}
{\xe \v __attribute__\:GlobalSystemInterruptBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GlobalSystemInterruptBase}}
\par
{\bkmkstart AAAAAAACXB}
{\bkmkend AAAAAAACXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 320} of file {\b mh.h}.}\par
}
{\xe \v IoApicAddress\:__attribute__}
{\xe \v __attribute__\:IoApicAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t IoApicAddress}}
\par
{\bkmkstart AAAAAAACXC}
{\bkmkend AAAAAAACXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 319} of file {\b mh.h}.}\par
}
{\xe \v IoApicId\:__attribute__}
{\xe \v __attribute__\:IoApicId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t IoApicId}}
\par
{\bkmkstart AAAAAAACXD}
{\bkmkend AAAAAAACXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 317} of file {\b mh.h}.}\par
}
{\xe \v Length\:__attribute__}
{\xe \v __attribute__\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Length}}
\par
{\bkmkstart AAAAAAACXE}
{\bkmkend AAAAAAACXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 308} of file {\b mh.h}.}\par
}
{\xe \v Lint\:__attribute__}
{\xe \v __attribute__\:Lint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Lint}}
\par
{\bkmkstart AAAAAAACXF}
{\bkmkend AAAAAAACXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 337} of file {\b mh.h}.}\par
}
{\xe \v Reserved\:__attribute__}
{\xe \v __attribute__\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved}}
\par
{\bkmkstart AAAAAAACXG}
{\bkmkend AAAAAAACXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 318} of file {\b mh.h}.}\par
}
{\xe \v Reserved\:__attribute__}
{\xe \v __attribute__\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t Reserved}}
\par
{\bkmkstart AAAAAAACXH}
{\bkmkend AAAAAAACXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 343} of file {\b mh.h}.}\par
}
{\xe \v Source\:__attribute__}
{\xe \v __attribute__\:Source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Source}}
\par
{\bkmkstart AAAAAAACXI}
{\bkmkend AAAAAAACXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 327} of file {\b mh.h}.}\par
}
{\xe \v Type\:__attribute__}
{\xe \v __attribute__\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Type}}
\par
{\bkmkstart AAAAAAACXJ}
{\bkmkend AAAAAAACXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b mh.h}.}\par
}
{\xe \v X2ApicId\:__attribute__}
{\xe \v __attribute__\:X2ApicId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t X2ApicId}}
\par
{\bkmkstart AAAAAAACXK}
{\bkmkend AAAAAAACXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 344} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_ACPI_SDT_HEADER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER}
{\bkmkstart AAAAAAACXL}
{\bkmkend AAAAAAACXL}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Signature} [4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Revision}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Checksum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OemId} [6]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OemTableId} [8]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OemRevision}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b CreatorId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b CreatorRevision}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 206} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACXM}
{\bkmkend AAAAAAACXM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Checksum\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:Checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Checksum}}
\par
{\bkmkstart AAAAAAACXN}
{\bkmkend AAAAAAACXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b mh.h}.}\par
}
{\xe \v CreatorId\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:CreatorId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t CreatorId}}
\par
{\bkmkstart AAAAAAACXO}
{\bkmkend AAAAAAACXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b mh.h}.}\par
}
{\xe \v CreatorRevision\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:CreatorRevision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t CreatorRevision}}
\par
{\bkmkstart AAAAAAACXP}
{\bkmkend AAAAAAACXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b mh.h}.}\par
}
{\xe \v Length\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Length}}
\par
{\bkmkstart AAAAAAACXQ}
{\bkmkend AAAAAAACXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b mh.h}.}\par
}
{\xe \v OemId\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:OemId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OemId[6]}}
\par
{\bkmkstart AAAAAAACXR}
{\bkmkend AAAAAAACXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 211} of file {\b mh.h}.}\par
}
{\xe \v OemRevision\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:OemRevision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OemRevision}}
\par
{\bkmkstart AAAAAAACXS}
{\bkmkend AAAAAAACXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b mh.h}.}\par
}
{\xe \v OemTableId\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:OemTableId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OemTableId[8]}}
\par
{\bkmkstart AAAAAAACXT}
{\bkmkend AAAAAAACXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b mh.h}.}\par
}
{\xe \v Revision\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:Revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Revision}}
\par
{\bkmkstart AAAAAAACXU}
{\bkmkend AAAAAAACXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 209} of file {\b mh.h}.}\par
}
{\xe \v Signature\:_ACPI_SDT_HEADER}
{\xe \v _ACPI_SDT_HEADER\:Signature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Signature[4]}}
\par
{\bkmkstart AAAAAAACXV}
{\bkmkend AAAAAAACXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 207} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_AHCI_PORT_CTX Struct Reference\par \pard\plain 
{\tc\tcl2 \v _AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX}
{\bkmkstart AAAAAAACXW}
{\bkmkend AAAAAAACXW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HBA_PORT} * {\b port}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HBA_CMD_TBL} * {\b cmd_tbl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b clb}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b fis}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} {\b bdev}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 50} of file {\b ahci.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACXX}
{\bkmkend AAAAAAACXX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bdev\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:bdev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} bdev}}
\par
{\bkmkstart AAAAAAACXY}
{\bkmkend AAAAAAACXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b ahci.c}.}\par
}
{\xe \v clb\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:clb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* clb}}
\par
{\bkmkstart AAAAAAACXZ}
{\bkmkend AAAAAAACXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b ahci.c}.}\par
}
{\xe \v cmd_tbl\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:cmd_tbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HBA_CMD_TBL}* cmd_tbl}}
\par
{\bkmkstart AAAAAAACYA}
{\bkmkend AAAAAAACYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ahci.c}.}\par
}
{\xe \v fis\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:fis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* fis}}
\par
{\bkmkstart AAAAAAACYB}
{\bkmkend AAAAAAACYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ahci.c}.}\par
}
{\xe \v port\:_AHCI_PORT_CTX}
{\xe \v _AHCI_PORT_CTX\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HBA_PORT}* port}}
\par
{\bkmkstart AAAAAAACYC}
{\bkmkend AAAAAAACYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b ahci.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_APC_STATE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _APC_STATE}
{\xe \v _APC_STATE}
{\bkmkstart AAAAAAACYD}
{\bkmkend AAAAAAACYD}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b SavedCr3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PEPROCESS} {\b SavedApcProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b AttachedToProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IRQL} {\b PreviousIrql}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 247} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACYE}
{\bkmkend AAAAAAACYE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AttachedToProcess\:_APC_STATE}
{\xe \v _APC_STATE\:AttachedToProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AttachedToProcess}}
\par
{\bkmkstart AAAAAAACYF}
{\bkmkend AAAAAAACYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 250} of file {\b me.h}.}\par
}
{\xe \v PreviousIrql\:_APC_STATE}
{\xe \v _APC_STATE\:PreviousIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IRQL} PreviousIrql}}
\par
{\bkmkstart AAAAAAACYG}
{\bkmkend AAAAAAACYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b me.h}.}\par
}
{\xe \v SavedApcProcess\:_APC_STATE}
{\xe \v _APC_STATE\:SavedApcProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PEPROCESS} SavedApcProcess}}
\par
{\bkmkstart AAAAAAACYH}
{\bkmkend AAAAAAACYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b me.h}.}\par
}
{\xe \v SavedCr3\:_APC_STATE}
{\xe \v _APC_STATE\:SavedCr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t SavedCr3}}
\par
{\bkmkstart AAAAAAACYI}
{\bkmkend AAAAAAACYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_BLOCK_DEVICE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE}
{\bkmkstart AAAAAAACYJ}
{\bkmkend AAAAAAACYJ}
\par
{
{\f2 #include <block.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b read_sector} )(struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, void *buf, size_t bytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b write_sector} )(struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, const void *buf, size_t bytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b dev_data}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 11} of file {\b block.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACYK}
{\bkmkend AAAAAAACYK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dev_data\:_BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE\:dev_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* dev_data}}
\par
{\bkmkstart AAAAAAACYL}
{\bkmkend AAAAAAACYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b block.h}.}\par
}
{\xe \v read_sector\:_BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE\:read_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* read_sector) (struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, void *buf, size_t bytes)}}
\par
{\bkmkstart AAAAAAACYM}
{\bkmkend AAAAAAACYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b block.h}.}\par
}
{\xe \v write_sector\:_BLOCK_DEVICE}
{\xe \v _BLOCK_DEVICE\:write_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* write_sector) (struct {\b _BLOCK_DEVICE} *dev, uint32_t lba, const void *buf, size_t bytes)}}
\par
{\bkmkstart AAAAAAACYN}
{\bkmkend AAAAAAACYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b block.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/{\b block.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_BOOT_INFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v _BOOT_INFO}
{\xe \v _BOOT_INFO}
{\bkmkstart AAAAAAACYO}
{\bkmkend AAAAAAACYO}
\par
{
{\f2 #include <efi.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b Gop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EFI_MEMORY_DESCRIPTOR} * {\b MemoryMap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b MapSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b DescriptorSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b DescriptorVersion}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b AhciCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b AhciBarBases} [32]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b KernelStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b Pml4Phys}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b AcpiRsdpPhys}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 52} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACYP}
{\bkmkend AAAAAAACYP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AcpiRsdpPhys\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:AcpiRsdpPhys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t AcpiRsdpPhys}}
\par
{\bkmkstart AAAAAAACYQ}
{\bkmkend AAAAAAACYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b efi.h}.}\par
}
{\xe \v AhciBarBases\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:AhciBarBases}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t AhciBarBases[32]}}
\par
{\bkmkstart AAAAAAACYR}
{\bkmkend AAAAAAACYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b efi.h}.}\par
}
{\xe \v AhciCount\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:AhciCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t AhciCount}}
\par
{\bkmkstart AAAAAAACYS}
{\bkmkend AAAAAAACYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b efi.h}.}\par
}
{\xe \v DescriptorSize\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:DescriptorSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t DescriptorSize}}
\par
{\bkmkstart AAAAAAACYT}
{\bkmkend AAAAAAACYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b efi.h}.}\par
}
{\xe \v DescriptorVersion\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:DescriptorVersion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t DescriptorVersion}}
\par
{\bkmkstart AAAAAAACYU}
{\bkmkend AAAAAAACYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b efi.h}.}\par
}
{\xe \v Gop\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:Gop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} Gop}}
\par
{\bkmkstart AAAAAAACYV}
{\bkmkend AAAAAAACYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b efi.h}.}\par
}
{\xe \v KernelStackTop\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:KernelStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t KernelStackTop}}
\par
{\bkmkstart AAAAAAACYW}
{\bkmkend AAAAAAACYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b efi.h}.}\par
}
{\xe \v MapSize\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:MapSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t MapSize}}
\par
{\bkmkstart AAAAAAACYX}
{\bkmkend AAAAAAACYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b efi.h}.}\par
}
{\xe \v MemoryMap\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:MemoryMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EFI_MEMORY_DESCRIPTOR}* MemoryMap}}
\par
{\bkmkstart AAAAAAACYY}
{\bkmkend AAAAAAACYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b efi.h}.}\par
}
{\xe \v Pml4Phys\:_BOOT_INFO}
{\xe \v _BOOT_INFO\:Pml4Phys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t Pml4Phys}}
\par
{\bkmkstart AAAAAAACYZ}
{\bkmkend AAAAAAACYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b efi.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_CONTEXT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _CONTEXT}
{\xe \v _CONTEXT}
{\bkmkstart AAAAAAACZA}
{\bkmkend AAAAAAACZA}
\par
{
{\f2 #include <exception.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b RFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr6}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr7}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rax}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rcx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rdx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rbx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rsp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rbp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rsi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rdi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R9}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R10}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R11}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R12}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R13}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R14}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b R15}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Rip}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 50} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACZB}
{\bkmkend AAAAAAACZB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Dr0\:_CONTEXT}
{\xe \v _CONTEXT\:Dr0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr0}}
\par
{\bkmkstart AAAAAAACZC}
{\bkmkend AAAAAAACZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b exception.h}.}\par
}
{\xe \v Dr1\:_CONTEXT}
{\xe \v _CONTEXT\:Dr1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr1}}
\par
{\bkmkstart AAAAAAACZD}
{\bkmkend AAAAAAACZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b exception.h}.}\par
}
{\xe \v Dr2\:_CONTEXT}
{\xe \v _CONTEXT\:Dr2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr2}}
\par
{\bkmkstart AAAAAAACZE}
{\bkmkend AAAAAAACZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b exception.h}.}\par
}
{\xe \v Dr3\:_CONTEXT}
{\xe \v _CONTEXT\:Dr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr3}}
\par
{\bkmkstart AAAAAAACZF}
{\bkmkend AAAAAAACZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b exception.h}.}\par
}
{\xe \v Dr6\:_CONTEXT}
{\xe \v _CONTEXT\:Dr6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr6}}
\par
{\bkmkstart AAAAAAACZG}
{\bkmkend AAAAAAACZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b exception.h}.}\par
}
{\xe \v Dr7\:_CONTEXT}
{\xe \v _CONTEXT\:Dr7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr7}}
\par
{\bkmkstart AAAAAAACZH}
{\bkmkend AAAAAAACZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b exception.h}.}\par
}
{\xe \v R10\:_CONTEXT}
{\xe \v _CONTEXT\:R10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R10}}
\par
{\bkmkstart AAAAAAACZI}
{\bkmkend AAAAAAACZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b exception.h}.}\par
}
{\xe \v R11\:_CONTEXT}
{\xe \v _CONTEXT\:R11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R11}}
\par
{\bkmkstart AAAAAAACZJ}
{\bkmkend AAAAAAACZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b exception.h}.}\par
}
{\xe \v R12\:_CONTEXT}
{\xe \v _CONTEXT\:R12}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R12}}
\par
{\bkmkstart AAAAAAACZK}
{\bkmkend AAAAAAACZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b exception.h}.}\par
}
{\xe \v R13\:_CONTEXT}
{\xe \v _CONTEXT\:R13}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R13}}
\par
{\bkmkstart AAAAAAACZL}
{\bkmkend AAAAAAACZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b exception.h}.}\par
}
{\xe \v R14\:_CONTEXT}
{\xe \v _CONTEXT\:R14}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R14}}
\par
{\bkmkstart AAAAAAACZM}
{\bkmkend AAAAAAACZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b exception.h}.}\par
}
{\xe \v R15\:_CONTEXT}
{\xe \v _CONTEXT\:R15}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R15}}
\par
{\bkmkstart AAAAAAACZN}
{\bkmkend AAAAAAACZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b exception.h}.}\par
}
{\xe \v R8\:_CONTEXT}
{\xe \v _CONTEXT\:R8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R8}}
\par
{\bkmkstart AAAAAAACZO}
{\bkmkend AAAAAAACZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b exception.h}.}\par
}
{\xe \v R9\:_CONTEXT}
{\xe \v _CONTEXT\:R9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t R9}}
\par
{\bkmkstart AAAAAAACZP}
{\bkmkend AAAAAAACZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b exception.h}.}\par
}
{\xe \v Rax\:_CONTEXT}
{\xe \v _CONTEXT\:Rax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rax}}
\par
{\bkmkstart AAAAAAACZQ}
{\bkmkend AAAAAAACZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b exception.h}.}\par
}
{\xe \v Rbp\:_CONTEXT}
{\xe \v _CONTEXT\:Rbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rbp}}
\par
{\bkmkstart AAAAAAACZR}
{\bkmkend AAAAAAACZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b exception.h}.}\par
}
{\xe \v Rbx\:_CONTEXT}
{\xe \v _CONTEXT\:Rbx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rbx}}
\par
{\bkmkstart AAAAAAACZS}
{\bkmkend AAAAAAACZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b exception.h}.}\par
}
{\xe \v Rcx\:_CONTEXT}
{\xe \v _CONTEXT\:Rcx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rcx}}
\par
{\bkmkstart AAAAAAACZT}
{\bkmkend AAAAAAACZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b exception.h}.}\par
}
{\xe \v Rdi\:_CONTEXT}
{\xe \v _CONTEXT\:Rdi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rdi}}
\par
{\bkmkstart AAAAAAACZU}
{\bkmkend AAAAAAACZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b exception.h}.}\par
}
{\xe \v Rdx\:_CONTEXT}
{\xe \v _CONTEXT\:Rdx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rdx}}
\par
{\bkmkstart AAAAAAACZV}
{\bkmkend AAAAAAACZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b exception.h}.}\par
}
{\xe \v RFlags\:_CONTEXT}
{\xe \v _CONTEXT\:RFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t RFlags}}
\par
{\bkmkstart AAAAAAACZW}
{\bkmkend AAAAAAACZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b exception.h}.}\par
}
{\xe \v Rip\:_CONTEXT}
{\xe \v _CONTEXT\:Rip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rip}}
\par
{\bkmkstart AAAAAAACZX}
{\bkmkend AAAAAAACZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b exception.h}.}\par
}
{\xe \v Rsi\:_CONTEXT}
{\xe \v _CONTEXT\:Rsi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rsi}}
\par
{\bkmkstart AAAAAAACZY}
{\bkmkend AAAAAAACZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b exception.h}.}\par
}
{\xe \v Rsp\:_CONTEXT}
{\xe \v _CONTEXT\:Rsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Rsp}}
\par
{\bkmkstart AAAAAAACZZ}
{\bkmkend AAAAAAACZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b exception.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DBG_CALLBACK_INFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DBG_CALLBACK_INFO}
{\xe \v _DBG_CALLBACK_INFO}
{\bkmkstart AAAAAAADAA}
{\bkmkend AAAAAAADAA}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b Address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PTRAP_FRAME} {\b trap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b BreakIdx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Dr6}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 178} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADAB}
{\bkmkend AAAAAAADAB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Address\:_DBG_CALLBACK_INFO}
{\xe \v _DBG_CALLBACK_INFO\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* Address}}
\par
{\bkmkstart AAAAAAADAC}
{\bkmkend AAAAAAADAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b me.h}.}\par
}
{\xe \v BreakIdx\:_DBG_CALLBACK_INFO}
{\xe \v _DBG_CALLBACK_INFO\:BreakIdx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int BreakIdx}}
\par
{\bkmkstart AAAAAAADAD}
{\bkmkend AAAAAAADAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 181} of file {\b me.h}.}\par
}
{\xe \v Dr6\:_DBG_CALLBACK_INFO}
{\xe \v _DBG_CALLBACK_INFO\:Dr6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dr6}}
\par
{\bkmkstart AAAAAAADAE}
{\bkmkend AAAAAAADAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 182} of file {\b me.h}.}\par
}
{\xe \v trap\:_DBG_CALLBACK_INFO}
{\xe \v _DBG_CALLBACK_INFO\:trap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PTRAP_FRAME} trap}}
\par
{\bkmkstart AAAAAAADAF}
{\bkmkend AAAAAAADAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DEBUG_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DEBUG_ENTRY}
{\xe \v _DEBUG_ENTRY}
{\bkmkstart AAAAAAADAG}
{\bkmkend AAAAAAADAG}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b Address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugCallback} {\b Callback}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 141} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADAH}
{\bkmkend AAAAAAADAH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Address\:_DEBUG_ENTRY}
{\xe \v _DEBUG_ENTRY\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* Address}}
\par
{\bkmkstart AAAAAAADAI}
{\bkmkend AAAAAAADAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b me.h}.}\par
}
{\xe \v Callback\:_DEBUG_ENTRY}
{\xe \v _DEBUG_ENTRY\:Callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugCallback} Callback}}
\par
{\bkmkstart AAAAAAADAJ}
{\bkmkend AAAAAAADAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DEBUG_REGISTERS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DEBUG_REGISTERS}
{\xe \v _DEBUG_REGISTERS}
{\bkmkstart AAAAAAADAK}
{\bkmkend AAAAAAADAK}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b dr7}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DebugCallback} {\b callback}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 387} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADAL}
{\bkmkend AAAAAAADAL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v address\:_DEBUG_REGISTERS}
{\xe \v _DEBUG_REGISTERS\:address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t address}}
\par
{\bkmkstart AAAAAAADAM}
{\bkmkend AAAAAAADAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b mh.h}.}\par
}
{\xe \v callback\:_DEBUG_REGISTERS}
{\xe \v _DEBUG_REGISTERS\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DebugCallback} callback}}
\par
{\bkmkstart AAAAAAADAN}
{\bkmkend AAAAAAADAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 390} of file {\b mh.h}.}\par
}
{\xe \v dr7\:_DEBUG_REGISTERS}
{\xe \v _DEBUG_REGISTERS\:dr7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t dr7}}
\par
{\bkmkstart AAAAAAADAO}
{\bkmkend AAAAAAADAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 388} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DOUBLY_LINKED_LIST Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DOUBLY_LINKED_LIST}
{\xe \v _DOUBLY_LINKED_LIST}
{\bkmkstart AAAAAAADAP}
{\bkmkend AAAAAAADAP}
\par
{
{\f2 #include <core.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DOUBLY_LINKED_LIST} * {\b Blink}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DOUBLY_LINKED_LIST} * {\b Flink}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 27} of file {\b core.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADAQ}
{\bkmkend AAAAAAADAQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Blink\:_DOUBLY_LINKED_LIST}
{\xe \v _DOUBLY_LINKED_LIST\:Blink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DOUBLY_LINKED_LIST}* Blink}}
\par
{\bkmkstart AAAAAAADAR}
{\bkmkend AAAAAAADAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b core.h}.}\par
}
{\xe \v Flink\:_DOUBLY_LINKED_LIST}
{\xe \v _DOUBLY_LINKED_LIST\:Flink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DOUBLY_LINKED_LIST}* Flink}}
\par
{\bkmkstart AAAAAAADAS}
{\bkmkend AAAAAAADAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b core.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b core.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DPC Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DPC}
{\xe \v _DPC}
{\bkmkstart AAAAAAADAT}
{\bkmkend AAAAAAADAT}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b DpcListEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PDEFERRED_ROUTINE} {\b DeferredRoutine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b DeferredContext}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b SystemArgument1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b SystemArgument2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile void * {\b DpcData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _DPC_PRIORITY} {\b priority}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b CpuNumber}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 197} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADAU}
{\bkmkend AAAAAAADAU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v CpuNumber\:_DPC}
{\xe \v _DPC\:CpuNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CpuNumber}}
\par
{\bkmkstart AAAAAAADAV}
{\bkmkend AAAAAAADAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b me.h}.}\par
}
{\xe \v DeferredContext\:_DPC}
{\xe \v _DPC\:DeferredContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* DeferredContext}}
\par
{\bkmkstart AAAAAAADAW}
{\bkmkend AAAAAAADAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 203} of file {\b me.h}.}\par
}
{\xe \v DeferredRoutine\:_DPC}
{\xe \v _DPC\:DeferredRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PDEFERRED_ROUTINE} DeferredRoutine}}
\par
{\bkmkstart AAAAAAADAX}
{\bkmkend AAAAAAADAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b me.h}.}\par
}
{\xe \v DpcData\:_DPC}
{\xe \v _DPC\:DpcData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* DpcData}}
\par
{\bkmkstart AAAAAAADAY}
{\bkmkend AAAAAAADAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 209} of file {\b me.h}.}\par
}
{\xe \v DpcListEntry\:_DPC}
{\xe \v _DPC\:DpcListEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} DpcListEntry}}
\par
{\bkmkstart AAAAAAADAZ}
{\bkmkend AAAAAAADAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b me.h}.}\par
}
{\xe \v priority\:_DPC}
{\xe \v _DPC\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _DPC_PRIORITY} priority}}
\par
{\bkmkstart AAAAAAADBA}
{\bkmkend AAAAAAADBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b me.h}.}\par
}
{\xe \v SystemArgument1\:_DPC}
{\xe \v _DPC\:SystemArgument1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* SystemArgument1}}
\par
{\bkmkstart AAAAAAADBB}
{\bkmkend AAAAAAADBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 204} of file {\b me.h}.}\par
}
{\xe \v SystemArgument2\:_DPC}
{\xe \v _DPC\:SystemArgument2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* SystemArgument2}}
\par
{\bkmkstart AAAAAAADBC}
{\bkmkend AAAAAAADBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_DPC_DATA Struct Reference\par \pard\plain 
{\tc\tcl2 \v _DPC_DATA}
{\xe \v _DPC_DATA}
{\bkmkstart AAAAAAADBD}
{\bkmkend AAAAAAADBD}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b DpcListHead}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b DpcLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b DpcQueueDepth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b DpcCount}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 226} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADBE}
{\bkmkend AAAAAAADBE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v DpcCount\:_DPC_DATA}
{\xe \v _DPC_DATA\:DpcCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t DpcCount}}
\par
{\bkmkstart AAAAAAADBF}
{\bkmkend AAAAAAADBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b me.h}.}\par
}
{\xe \v DpcListHead\:_DPC_DATA}
{\xe \v _DPC_DATA\:DpcListHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} DpcListHead}}
\par
{\bkmkstart AAAAAAADBG}
{\bkmkend AAAAAAADBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b me.h}.}\par
}
{\xe \v DpcLock\:_DPC_DATA}
{\xe \v _DPC_DATA\:DpcLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} DpcLock}}
\par
{\bkmkstart AAAAAAADBH}
{\bkmkend AAAAAAADBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 228} of file {\b me.h}.}\par
}
{\xe \v DpcQueueDepth\:_DPC_DATA}
{\xe \v _DPC_DATA\:DpcQueueDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t DpcQueueDepth}}
\par
{\bkmkstart AAAAAAADBI}
{\bkmkend AAAAAAADBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EFI_MEMORY_DESCRIPTOR Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR}
{\bkmkstart AAAAAAADBJ}
{\bkmkend AAAAAAADBJ}
\par
{
{\f2 #include <efi.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Pad}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b PhysicalStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b VirtualStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b NumberOfPages}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Attribute}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 33} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADBK}
{\bkmkend AAAAAAADBK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Attribute\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:Attribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Attribute}}
\par
{\bkmkstart AAAAAAADBL}
{\bkmkend AAAAAAADBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b efi.h}.}\par
}
{\xe \v NumberOfPages\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:NumberOfPages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t NumberOfPages}}
\par
{\bkmkstart AAAAAAADBM}
{\bkmkend AAAAAAADBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b efi.h}.}\par
}
{\xe \v Pad\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:Pad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Pad}}
\par
{\bkmkstart AAAAAAADBN}
{\bkmkend AAAAAAADBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b efi.h}.}\par
}
{\xe \v PhysicalStart\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:PhysicalStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t PhysicalStart}}
\par
{\bkmkstart AAAAAAADBO}
{\bkmkend AAAAAAADBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b efi.h}.}\par
}
{\xe \v Type\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Type}}
\par
{\bkmkstart AAAAAAADBP}
{\bkmkend AAAAAAADBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b efi.h}.}\par
}
{\xe \v VirtualStart\:_EFI_MEMORY_DESCRIPTOR}
{\xe \v _EFI_MEMORY_DESCRIPTOR\:VirtualStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t VirtualStart}}
\par
{\bkmkstart AAAAAAADBQ}
{\bkmkend AAAAAAADBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b efi.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EPROCESS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EPROCESS}
{\xe \v _EPROCESS}
{\bkmkstart AAAAAAADBR}
{\bkmkend AAAAAAADBR}
\par
{
{\f2 #include <ps.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IPROCESS} {\b InternalProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b ImageName} [24]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b PID}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b ParentProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b priority}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b CreationTime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b FileBuffer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b ImageBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _RUNDOWN_REF} {\b ProcessRundown}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ETHREAD} * {\b MainThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b AllThreads}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b NumThreads}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b NextStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PHANDLE_TABLE} {\b ObjectTable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MMVAD} * {\b VadRoot}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b VadLock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 91} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADBS}
{\bkmkend AAAAAAADBS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AllThreads\:_EPROCESS}
{\xe \v _EPROCESS\:AllThreads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} AllThreads}}
\par
{\bkmkstart AAAAAAADBT}
{\bkmkend AAAAAAADBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b ps.h}.}\par
}
{\xe \v CreationTime\:_EPROCESS}
{\xe \v _EPROCESS\:CreationTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t CreationTime}}
\par
{\bkmkstart AAAAAAADBU}
{\bkmkend AAAAAAADBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b ps.h}.}\par
}
{\xe \v FileBuffer\:_EPROCESS}
{\xe \v _EPROCESS\:FileBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* FileBuffer}}
\par
{\bkmkstart AAAAAAADBV}
{\bkmkend AAAAAAADBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b ps.h}.}\par
}
{\xe \v ImageBase\:_EPROCESS}
{\xe \v _EPROCESS\:ImageBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t ImageBase}}
\par
{\bkmkstart AAAAAAADBW}
{\bkmkend AAAAAAADBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b ps.h}.}\par
}
{\xe \v ImageName\:_EPROCESS}
{\xe \v _EPROCESS\:ImageName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char ImageName[24]}}
\par
{\bkmkstart AAAAAAADBX}
{\bkmkend AAAAAAADBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b ps.h}.}\par
}
{\xe \v InternalProcess\:_EPROCESS}
{\xe \v _EPROCESS\:InternalProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _IPROCESS} InternalProcess}}
\par
{\bkmkstart AAAAAAADBY}
{\bkmkend AAAAAAADBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b ps.h}.}\par
}
{\xe \v MainThread\:_EPROCESS}
{\xe \v _EPROCESS\:MainThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ETHREAD}* MainThread}}
\par
{\bkmkstart AAAAAAADBZ}
{\bkmkend AAAAAAADBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b ps.h}.}\par
}
{\xe \v NextStackTop\:_EPROCESS}
{\xe \v _EPROCESS\:NextStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t NextStackTop}}
\par
{\bkmkstart AAAAAAADCA}
{\bkmkend AAAAAAADCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b ps.h}.}\par
}
{\xe \v NumThreads\:_EPROCESS}
{\xe \v _EPROCESS\:NumThreads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t NumThreads}}
\par
{\bkmkstart AAAAAAADCB}
{\bkmkend AAAAAAADCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b ps.h}.}\par
}
{\xe \v ObjectTable\:_EPROCESS}
{\xe \v _EPROCESS\:ObjectTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PHANDLE_TABLE} ObjectTable}}
\par
{\bkmkstart AAAAAAADCC}
{\bkmkend AAAAAAADCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b ps.h}.}\par
}
{\xe \v ParentProcess\:_EPROCESS}
{\xe \v _EPROCESS\:ParentProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} ParentProcess}}
\par
{\bkmkstart AAAAAAADCD}
{\bkmkend AAAAAAADCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b ps.h}.}\par
}
{\xe \v PID\:_EPROCESS}
{\xe \v _EPROCESS\:PID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} PID}}
\par
{\bkmkstart AAAAAAADCE}
{\bkmkend AAAAAAADCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b ps.h}.}\par
}
{\xe \v priority\:_EPROCESS}
{\xe \v _EPROCESS\:priority}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t priority}}
\par
{\bkmkstart AAAAAAADCF}
{\bkmkend AAAAAAADCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b ps.h}.}\par
}
{\xe \v ProcessRundown\:_EPROCESS}
{\xe \v _EPROCESS\:ProcessRundown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _RUNDOWN_REF} ProcessRundown}}
\par
{\bkmkstart AAAAAAADCG}
{\bkmkend AAAAAAADCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b ps.h}.}\par
}
{\xe \v VadLock\:_EPROCESS}
{\xe \v _EPROCESS\:VadLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} VadLock}}
\par
{\bkmkstart AAAAAAADCH}
{\bkmkend AAAAAAADCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b ps.h}.}\par
}
{\xe \v VadRoot\:_EPROCESS}
{\xe \v _EPROCESS\:VadRoot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _MMVAD}* VadRoot}}
\par
{\bkmkstart AAAAAAADCI}
{\bkmkend AAAAAAADCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ps.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_ETHREAD Struct Reference\par \pard\plain 
{\tc\tcl2 \v _ETHREAD}
{\xe \v _ETHREAD}
{\bkmkstart AAAAAAADCJ}
{\bkmkend AAAAAAADCJ}
\par
{
{\f2 #include <ps.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ITHREAD} {\b InternalThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EXCEPTION_REGISTRATION_RECORD} {\b ExceptionRegistration}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b TID}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EVENT} * {\b CurrentEvent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EPROCESS} * {\b ParentProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DOUBLY_LINKED_LIST} {\b ThreadListEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _RUNDOWN_REF} {\b ThreadRundown}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ExitStatus}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 121} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADCK}
{\bkmkend AAAAAAADCK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v CurrentEvent\:_ETHREAD}
{\xe \v _ETHREAD\:CurrentEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EVENT}* CurrentEvent}}
\par
{\bkmkstart AAAAAAADCL}
{\bkmkend AAAAAAADCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b ps.h}.}\par
}
{\xe \v ExceptionRegistration\:_ETHREAD}
{\xe \v _ETHREAD\:ExceptionRegistration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EXCEPTION_REGISTRATION_RECORD} ExceptionRegistration}}
\par
{\bkmkstart AAAAAAADCM}
{\bkmkend AAAAAAADCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b ps.h}.}\par
}
{\xe \v ExitStatus\:_ETHREAD}
{\xe \v _ETHREAD\:ExitStatus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ExitStatus}}
\par
{\bkmkstart AAAAAAADCN}
{\bkmkend AAAAAAADCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b ps.h}.}\par
}
{\xe \v InternalThread\:_ETHREAD}
{\xe \v _ETHREAD\:InternalThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ITHREAD} InternalThread}}
\par
{\bkmkstart AAAAAAADCO}
{\bkmkend AAAAAAADCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b ps.h}.}\par
}
{\xe \v ParentProcess\:_ETHREAD}
{\xe \v _ETHREAD\:ParentProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EPROCESS}* ParentProcess}}
\par
{\bkmkstart AAAAAAADCP}
{\bkmkend AAAAAAADCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b ps.h}.}\par
}
{\xe \v ThreadListEntry\:_ETHREAD}
{\xe \v _ETHREAD\:ThreadListEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DOUBLY_LINKED_LIST} ThreadListEntry}}
\par
{\bkmkstart AAAAAAADCQ}
{\bkmkend AAAAAAADCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b ps.h}.}\par
}
{\xe \v ThreadRundown\:_ETHREAD}
{\xe \v _ETHREAD\:ThreadRundown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _RUNDOWN_REF} ThreadRundown}}
\par
{\bkmkstart AAAAAAADCR}
{\bkmkend AAAAAAADCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b ps.h}.}\par
}
{\xe \v TID\:_ETHREAD}
{\xe \v _ETHREAD\:TID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} TID}}
\par
{\bkmkstart AAAAAAADCS}
{\bkmkend AAAAAAADCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 125} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ps.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EVENT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EVENT}
{\xe \v _EVENT}
{\bkmkstart AAAAAAADCT}
{\bkmkend AAAAAAADCT}
\par
{
{\f2 #include <ms.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _EVENT_TYPE} {\b type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b signaled}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SPINLOCK} {\b lock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _Queue} {\b waitingQueue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EVENT} - kernel event object{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Embedded {\b SPINLOCK} and {\b Queue} for waiting threads. \par}
\par
}{
Definition at line {\b 69} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADCU}
{\bkmkend AAAAAAADCU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v lock\:_EVENT}
{\xe \v _EVENT\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _SPINLOCK} lock}}
\par
{\bkmkstart AAAAAAADCV}
{\bkmkend AAAAAAADCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b ms.h}.}\par
}
{\xe \v signaled\:_EVENT}
{\xe \v _EVENT\:signaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool signaled}}
\par
{\bkmkstart AAAAAAADCW}
{\bkmkend AAAAAAADCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b ms.h}.}\par
}
{\xe \v type\:_EVENT}
{\xe \v _EVENT\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _EVENT_TYPE} type}}
\par
{\bkmkstart AAAAAAADCX}
{\bkmkend AAAAAAADCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b ms.h}.}\par
}
{\xe \v waitingQueue\:_EVENT}
{\xe \v _EVENT\:waitingQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _Queue} waitingQueue}}
\par
{\bkmkstart AAAAAAADCY}
{\bkmkend AAAAAAADCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ms.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EX_FRAME_REGISTRATION Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EX_FRAME_REGISTRATION}
{\xe \v _EX_FRAME_REGISTRATION}
{\bkmkstart AAAAAAADCZ}
{\bkmkend AAAAAAADCZ}
\par
{
{\f2 #include <exception.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b Thread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXCEPTION_REGISTRATION_RECORD} * {\b RegistrationPointer}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 82} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADDA}
{\bkmkend AAAAAAADDA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v RegistrationPointer\:_EX_FRAME_REGISTRATION}
{\xe \v _EX_FRAME_REGISTRATION\:RegistrationPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXCEPTION_REGISTRATION_RECORD}* RegistrationPointer}}
\par
{\bkmkstart AAAAAAADDB}
{\bkmkend AAAAAAADDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b exception.h}.}\par
}
{\xe \v Thread\:_EX_FRAME_REGISTRATION}
{\xe \v _EX_FRAME_REGISTRATION\:Thread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} Thread}}
\par
{\bkmkstart AAAAAAADDC}
{\bkmkend AAAAAAADDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b exception.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EXCEPTION_RECORD Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EXCEPTION_RECORD}
{\xe \v _EXCEPTION_RECORD}
{\bkmkstart AAAAAAADDD}
{\bkmkend AAAAAAADDD}
\par
{
{\f2 #include <exception.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ExceptionCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ExceptionFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EXCEPTION_RECORD} * {\b ExceptionRecord}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b ExceptionAddress}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 35} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADDE}
{\bkmkend AAAAAAADDE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ExceptionAddress\:_EXCEPTION_RECORD}
{\xe \v _EXCEPTION_RECORD\:ExceptionAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* ExceptionAddress}}
\par
{\bkmkstart AAAAAAADDF}
{\bkmkend AAAAAAADDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b exception.h}.}\par
}
{\xe \v ExceptionCode\:_EXCEPTION_RECORD}
{\xe \v _EXCEPTION_RECORD\:ExceptionCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ExceptionCode}}
\par
{\bkmkstart AAAAAAADDG}
{\bkmkend AAAAAAADDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b exception.h}.}\par
}
{\xe \v ExceptionFlags\:_EXCEPTION_RECORD}
{\xe \v _EXCEPTION_RECORD\:ExceptionFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ExceptionFlags}}
\par
{\bkmkstart AAAAAAADDH}
{\bkmkend AAAAAAADDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b exception.h}.}\par
}
{\xe \v ExceptionRecord\:_EXCEPTION_RECORD}
{\xe \v _EXCEPTION_RECORD\:ExceptionRecord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EXCEPTION_RECORD}* ExceptionRecord}}
\par
{\bkmkstart AAAAAAADDI}
{\bkmkend AAAAAAADDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b exception.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_EXCEPTION_REGISTRATION_RECORD Struct Reference\par \pard\plain 
{\tc\tcl2 \v _EXCEPTION_REGISTRATION_RECORD}
{\xe \v _EXCEPTION_REGISTRATION_RECORD}
{\bkmkstart AAAAAAADDJ}
{\bkmkend AAAAAAADDJ}
\par
{
{\f2 #include <exception.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EXCEPTION_REGISTRATION_RECORD} * {\b Next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _EXCEPTION_DISPOSITION}(* {\b Handler} )(struct {\b _EXCEPTION_RECORD} *arg1, void *Frame, struct {\b _CONTEXT} *arg2, void *DispCtx)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 77} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADDK}
{\bkmkend AAAAAAADDK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Handler\:_EXCEPTION_REGISTRATION_RECORD}
{\xe \v _EXCEPTION_REGISTRATION_RECORD\:Handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _EXCEPTION_DISPOSITION}(* Handler) (struct {\b _EXCEPTION_RECORD} *arg1, void *Frame, struct {\b _CONTEXT} *arg2, void *DispCtx)}}
\par
{\bkmkstart AAAAAAADDL}
{\bkmkend AAAAAAADDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b exception.h}.}\par
}
{\xe \v Next\:_EXCEPTION_REGISTRATION_RECORD}
{\xe \v _EXCEPTION_REGISTRATION_RECORD\:Next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EXCEPTION_REGISTRATION_RECORD}* Next}}
\par
{\bkmkstart AAAAAAADDM}
{\bkmkend AAAAAAADDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b exception.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_FADT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _FADT}
{\xe \v _FADT}
{\bkmkstart AAAAAAADDN}
{\bkmkend AAAAAAADDN}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ACPI_SDT_HEADER} {\b h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b FirmwareCtrl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Dsdt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PreferredPowerManagementProfile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b SCI_Interrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b SMI_CommandPort}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AcpiEnable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AcpiDisable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b S4BIOS_REQ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PSTATE_Control}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1aEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1bEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1aControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1bControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM2ControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PMTimerBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b GPE0Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b GPE1Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PM1EventLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PM1ControlLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PM2ControlLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PMTimerLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b GPE0Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b GPE1Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b GPE1Base}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b CStateControl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b WorstC2Latency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b WorstC3Latency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b FlushSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b FlushStride}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b DutyOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b DutyWidth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b DayAlarm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b MonthAlarm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Century}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b BootArchitectureFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b ResetReg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ResetValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved3} [3]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b X_FirmwareControl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b X_Dsdt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1aEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1bEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1aControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1bControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM2ControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PMTimerBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_GPE0Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_GPE1Block}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 232} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADDO}
{\bkmkend AAAAAAADDO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AcpiDisable\:_FADT}
{\xe \v _FADT\:AcpiDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AcpiDisable}}
\par
{\bkmkstart AAAAAAADDP}
{\bkmkend AAAAAAADDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b mh.h}.}\par
}
{\xe \v AcpiEnable\:_FADT}
{\xe \v _FADT\:AcpiEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AcpiEnable}}
\par
{\bkmkstart AAAAAAADDQ}
{\bkmkend AAAAAAADDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b mh.h}.}\par
}
{\xe \v BootArchitectureFlags\:_FADT}
{\xe \v _FADT\:BootArchitectureFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t BootArchitectureFlags}}
\par
{\bkmkstart AAAAAAADDR}
{\bkmkend AAAAAAADDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b mh.h}.}\par
}
{\xe \v Century\:_FADT}
{\xe \v _FADT\:Century}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Century}}
\par
{\bkmkstart AAAAAAADDS}
{\bkmkend AAAAAAADDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 272} of file {\b mh.h}.}\par
}
{\xe \v CStateControl\:_FADT}
{\xe \v _FADT\:CStateControl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CStateControl}}
\par
{\bkmkstart AAAAAAADDT}
{\bkmkend AAAAAAADDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 263} of file {\b mh.h}.}\par
}
{\xe \v DayAlarm\:_FADT}
{\xe \v _FADT\:DayAlarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t DayAlarm}}
\par
{\bkmkstart AAAAAAADDU}
{\bkmkend AAAAAAADDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 270} of file {\b mh.h}.}\par
}
{\xe \v Dsdt\:_FADT}
{\xe \v _FADT\:Dsdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Dsdt}}
\par
{\bkmkstart AAAAAAADDV}
{\bkmkend AAAAAAADDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 236} of file {\b mh.h}.}\par
}
{\xe \v DutyOffset\:_FADT}
{\xe \v _FADT\:DutyOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t DutyOffset}}
\par
{\bkmkstart AAAAAAADDW}
{\bkmkend AAAAAAADDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 268} of file {\b mh.h}.}\par
}
{\xe \v DutyWidth\:_FADT}
{\xe \v _FADT\:DutyWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t DutyWidth}}
\par
{\bkmkstart AAAAAAADDX}
{\bkmkend AAAAAAADDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b mh.h}.}\par
}
{\xe \v FirmwareCtrl\:_FADT}
{\xe \v _FADT\:FirmwareCtrl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t FirmwareCtrl}}
\par
{\bkmkstart AAAAAAADDY}
{\bkmkend AAAAAAADDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 235} of file {\b mh.h}.}\par
}
{\xe \v Flags\:_FADT}
{\xe \v _FADT\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Flags}}
\par
{\bkmkstart AAAAAAADDZ}
{\bkmkend AAAAAAADDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 278} of file {\b mh.h}.}\par
}
{\xe \v FlushSize\:_FADT}
{\xe \v _FADT\:FlushSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t FlushSize}}
\par
{\bkmkstart AAAAAAADEA}
{\bkmkend AAAAAAADEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 266} of file {\b mh.h}.}\par
}
{\xe \v FlushStride\:_FADT}
{\xe \v _FADT\:FlushStride}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t FlushStride}}
\par
{\bkmkstart AAAAAAADEB}
{\bkmkend AAAAAAADEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 267} of file {\b mh.h}.}\par
}
{\xe \v GPE0Block\:_FADT}
{\xe \v _FADT\:GPE0Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GPE0Block}}
\par
{\bkmkstart AAAAAAADEC}
{\bkmkend AAAAAAADEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 254} of file {\b mh.h}.}\par
}
{\xe \v GPE0Length\:_FADT}
{\xe \v _FADT\:GPE0Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t GPE0Length}}
\par
{\bkmkstart AAAAAAADED}
{\bkmkend AAAAAAADED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 260} of file {\b mh.h}.}\par
}
{\xe \v GPE1Base\:_FADT}
{\xe \v _FADT\:GPE1Base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t GPE1Base}}
\par
{\bkmkstart AAAAAAADEE}
{\bkmkend AAAAAAADEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 262} of file {\b mh.h}.}\par
}
{\xe \v GPE1Block\:_FADT}
{\xe \v _FADT\:GPE1Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GPE1Block}}
\par
{\bkmkstart AAAAAAADEF}
{\bkmkend AAAAAAADEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 255} of file {\b mh.h}.}\par
}
{\xe \v GPE1Length\:_FADT}
{\xe \v _FADT\:GPE1Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t GPE1Length}}
\par
{\bkmkstart AAAAAAADEG}
{\bkmkend AAAAAAADEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 261} of file {\b mh.h}.}\par
}
{\xe \v h\:_FADT}
{\xe \v _FADT\:h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ACPI_SDT_HEADER} h}}
\par
{\bkmkstart AAAAAAADEH}
{\bkmkend AAAAAAADEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b mh.h}.}\par
}
{\xe \v MonthAlarm\:_FADT}
{\xe \v _FADT\:MonthAlarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t MonthAlarm}}
\par
{\bkmkstart AAAAAAADEI}
{\bkmkend AAAAAAADEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 271} of file {\b mh.h}.}\par
}
{\xe \v PM1aControlBlock\:_FADT}
{\xe \v _FADT\:PM1aControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1aControlBlock}}
\par
{\bkmkstart AAAAAAADEJ}
{\bkmkend AAAAAAADEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 250} of file {\b mh.h}.}\par
}
{\xe \v PM1aEventBlock\:_FADT}
{\xe \v _FADT\:PM1aEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1aEventBlock}}
\par
{\bkmkstart AAAAAAADEK}
{\bkmkend AAAAAAADEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b mh.h}.}\par
}
{\xe \v PM1bControlBlock\:_FADT}
{\xe \v _FADT\:PM1bControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1bControlBlock}}
\par
{\bkmkstart AAAAAAADEL}
{\bkmkend AAAAAAADEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 251} of file {\b mh.h}.}\par
}
{\xe \v PM1bEventBlock\:_FADT}
{\xe \v _FADT\:PM1bEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1bEventBlock}}
\par
{\bkmkstart AAAAAAADEM}
{\bkmkend AAAAAAADEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b mh.h}.}\par
}
{\xe \v PM1ControlLength\:_FADT}
{\xe \v _FADT\:PM1ControlLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PM1ControlLength}}
\par
{\bkmkstart AAAAAAADEN}
{\bkmkend AAAAAAADEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 257} of file {\b mh.h}.}\par
}
{\xe \v PM1EventLength\:_FADT}
{\xe \v _FADT\:PM1EventLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PM1EventLength}}
\par
{\bkmkstart AAAAAAADEO}
{\bkmkend AAAAAAADEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 256} of file {\b mh.h}.}\par
}
{\xe \v PM2ControlBlock\:_FADT}
{\xe \v _FADT\:PM2ControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM2ControlBlock}}
\par
{\bkmkstart AAAAAAADEP}
{\bkmkend AAAAAAADEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 252} of file {\b mh.h}.}\par
}
{\xe \v PM2ControlLength\:_FADT}
{\xe \v _FADT\:PM2ControlLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PM2ControlLength}}
\par
{\bkmkstart AAAAAAADEQ}
{\bkmkend AAAAAAADEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 258} of file {\b mh.h}.}\par
}
{\xe \v PMTimerBlock\:_FADT}
{\xe \v _FADT\:PMTimerBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PMTimerBlock}}
\par
{\bkmkstart AAAAAAADER}
{\bkmkend AAAAAAADER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 253} of file {\b mh.h}.}\par
}
{\xe \v PMTimerLength\:_FADT}
{\xe \v _FADT\:PMTimerLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PMTimerLength}}
\par
{\bkmkstart AAAAAAADES}
{\bkmkend AAAAAAADES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 259} of file {\b mh.h}.}\par
}
{\xe \v PreferredPowerManagementProfile\:_FADT}
{\xe \v _FADT\:PreferredPowerManagementProfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PreferredPowerManagementProfile}}
\par
{\bkmkstart AAAAAAADET}
{\bkmkend AAAAAAADET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 241} of file {\b mh.h}.}\par
}
{\xe \v PSTATE_Control\:_FADT}
{\xe \v _FADT\:PSTATE_Control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PSTATE_Control}}
\par
{\bkmkstart AAAAAAADEU}
{\bkmkend AAAAAAADEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b mh.h}.}\par
}
{\xe \v Reserved\:_FADT}
{\xe \v _FADT\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved}}
\par
{\bkmkstart AAAAAAADEV}
{\bkmkend AAAAAAADEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b mh.h}.}\par
}
{\xe \v Reserved2\:_FADT}
{\xe \v _FADT\:Reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved2}}
\par
{\bkmkstart AAAAAAADEW}
{\bkmkend AAAAAAADEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 277} of file {\b mh.h}.}\par
}
{\xe \v Reserved3\:_FADT}
{\xe \v _FADT\:Reserved3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved3[3]}}
\par
{\bkmkstart AAAAAAADEX}
{\bkmkend AAAAAAADEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 284} of file {\b mh.h}.}\par
}
{\xe \v ResetReg\:_FADT}
{\xe \v _FADT\:ResetReg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure ResetReg}}
\par
{\bkmkstart AAAAAAADEY}
{\bkmkend AAAAAAADEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 281} of file {\b mh.h}.}\par
}
{\xe \v ResetValue\:_FADT}
{\xe \v _FADT\:ResetValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ResetValue}}
\par
{\bkmkstart AAAAAAADEZ}
{\bkmkend AAAAAAADEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 283} of file {\b mh.h}.}\par
}
{\xe \v S4BIOS_REQ\:_FADT}
{\xe \v _FADT\:S4BIOS_REQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t S4BIOS_REQ}}
\par
{\bkmkstart AAAAAAADFA}
{\bkmkend AAAAAAADFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 246} of file {\b mh.h}.}\par
}
{\xe \v SCI_Interrupt\:_FADT}
{\xe \v _FADT\:SCI_Interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SCI_Interrupt}}
\par
{\bkmkstart AAAAAAADFB}
{\bkmkend AAAAAAADFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 242} of file {\b mh.h}.}\par
}
{\xe \v SMI_CommandPort\:_FADT}
{\xe \v _FADT\:SMI_CommandPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t SMI_CommandPort}}
\par
{\bkmkstart AAAAAAADFC}
{\bkmkend AAAAAAADFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 243} of file {\b mh.h}.}\par
}
{\xe \v WorstC2Latency\:_FADT}
{\xe \v _FADT\:WorstC2Latency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t WorstC2Latency}}
\par
{\bkmkstart AAAAAAADFD}
{\bkmkend AAAAAAADFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 264} of file {\b mh.h}.}\par
}
{\xe \v WorstC3Latency\:_FADT}
{\xe \v _FADT\:WorstC3Latency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t WorstC3Latency}}
\par
{\bkmkstart AAAAAAADFE}
{\bkmkend AAAAAAADFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 265} of file {\b mh.h}.}\par
}
{\xe \v X_Dsdt\:_FADT}
{\xe \v _FADT\:X_Dsdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t X_Dsdt}}
\par
{\bkmkstart AAAAAAADFF}
{\bkmkend AAAAAAADFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 288} of file {\b mh.h}.}\par
}
{\xe \v X_FirmwareControl\:_FADT}
{\xe \v _FADT\:X_FirmwareControl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t X_FirmwareControl}}
\par
{\bkmkstart AAAAAAADFG}
{\bkmkend AAAAAAADFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 287} of file {\b mh.h}.}\par
}
{\xe \v X_GPE0Block\:_FADT}
{\xe \v _FADT\:X_GPE0Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_GPE0Block}}
\par
{\bkmkstart AAAAAAADFH}
{\bkmkend AAAAAAADFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 296} of file {\b mh.h}.}\par
}
{\xe \v X_GPE1Block\:_FADT}
{\xe \v _FADT\:X_GPE1Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_GPE1Block}}
\par
{\bkmkstart AAAAAAADFI}
{\bkmkend AAAAAAADFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 297} of file {\b mh.h}.}\par
}
{\xe \v X_PM1aControlBlock\:_FADT}
{\xe \v _FADT\:X_PM1aControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1aControlBlock}}
\par
{\bkmkstart AAAAAAADFJ}
{\bkmkend AAAAAAADFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b mh.h}.}\par
}
{\xe \v X_PM1aEventBlock\:_FADT}
{\xe \v _FADT\:X_PM1aEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1aEventBlock}}
\par
{\bkmkstart AAAAAAADFK}
{\bkmkend AAAAAAADFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 290} of file {\b mh.h}.}\par
}
{\xe \v X_PM1bControlBlock\:_FADT}
{\xe \v _FADT\:X_PM1bControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1bControlBlock}}
\par
{\bkmkstart AAAAAAADFL}
{\bkmkend AAAAAAADFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 293} of file {\b mh.h}.}\par
}
{\xe \v X_PM1bEventBlock\:_FADT}
{\xe \v _FADT\:X_PM1bEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1bEventBlock}}
\par
{\bkmkstart AAAAAAADFM}
{\bkmkend AAAAAAADFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 291} of file {\b mh.h}.}\par
}
{\xe \v X_PM2ControlBlock\:_FADT}
{\xe \v _FADT\:X_PM2ControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM2ControlBlock}}
\par
{\bkmkstart AAAAAAADFN}
{\bkmkend AAAAAAADFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 294} of file {\b mh.h}.}\par
}
{\xe \v X_PMTimerBlock\:_FADT}
{\xe \v _FADT\:X_PMTimerBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PMTimerBlock}}
\par
{\bkmkstart AAAAAAADFO}
{\bkmkend AAAAAAADFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 295} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_FAT32_FSINFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v _FAT32_FSINFO}
{\xe \v _FAT32_FSINFO}
{\bkmkstart AAAAAAADFP}
{\bkmkend AAAAAAADFP}
\par
{
{\f2 #include <fat32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b first_data_sector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b root_cluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sectors_per_fat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b bytes_per_sector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sectors_per_cluster}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fat_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b reserved_sector_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b total_sectors}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b total_clusters}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 95} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADFQ}
{\bkmkend AAAAAAADFQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bytes_per_sector\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:bytes_per_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bytes_per_sector}}
\par
{\bkmkstart AAAAAAADFR}
{\bkmkend AAAAAAADFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b fat32.h}.}\par
}
{\xe \v fat_start\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:fat_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fat_start}}
\par
{\bkmkstart AAAAAAADFS}
{\bkmkend AAAAAAADFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b fat32.h}.}\par
}
{\xe \v first_data_sector\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:first_data_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t first_data_sector}}
\par
{\bkmkstart AAAAAAADFT}
{\bkmkend AAAAAAADFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b fat32.h}.}\par
}
{\xe \v reserved_sector_count\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:reserved_sector_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t reserved_sector_count}}
\par
{\bkmkstart AAAAAAADFU}
{\bkmkend AAAAAAADFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b fat32.h}.}\par
}
{\xe \v root_cluster\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:root_cluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t root_cluster}}
\par
{\bkmkstart AAAAAAADFV}
{\bkmkend AAAAAAADFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b fat32.h}.}\par
}
{\xe \v sectors_per_cluster\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:sectors_per_cluster}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sectors_per_cluster}}
\par
{\bkmkstart AAAAAAADFW}
{\bkmkend AAAAAAADFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b fat32.h}.}\par
}
{\xe \v sectors_per_fat\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:sectors_per_fat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sectors_per_fat}}
\par
{\bkmkstart AAAAAAADFX}
{\bkmkend AAAAAAADFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b fat32.h}.}\par
}
{\xe \v total_clusters\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:total_clusters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t total_clusters}}
\par
{\bkmkstart AAAAAAADFY}
{\bkmkend AAAAAAADFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b fat32.h}.}\par
}
{\xe \v total_sectors\:_FAT32_FSINFO}
{\xe \v _FAT32_FSINFO\:total_sectors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t total_sectors}}
\par
{\bkmkstart AAAAAAADFZ}
{\bkmkend AAAAAAADFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_FIS_REG_H2D Struct Reference\par \pard\plain 
{\tc\tcl2 \v _FIS_REG_H2D}
{\xe \v _FIS_REG_H2D}
{\bkmkstart AAAAAAADGA}
{\bkmkend AAAAAAADGA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b fis_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b pmport}: 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv0}: 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b c}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b command}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b featurel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b device}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba3}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba4}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b lba5}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b featureh}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b countl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b counth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b icc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b control}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv1} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) \par
}{
Definition at line {\b 75} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADGB}
{\bkmkend AAAAAAADGB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v c\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t c}}
\par
{\bkmkstart AAAAAAADGC}
{\bkmkend AAAAAAADGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b ahci.h}.}\par
}
{\xe \v command\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t command}}
\par
{\bkmkstart AAAAAAADGD}
{\bkmkend AAAAAAADGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b ahci.h}.}\par
}
{\xe \v control\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t control}}
\par
{\bkmkstart AAAAAAADGE}
{\bkmkend AAAAAAADGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b ahci.h}.}\par
}
{\xe \v counth\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:counth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t counth}}
\par
{\bkmkstart AAAAAAADGF}
{\bkmkend AAAAAAADGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b ahci.h}.}\par
}
{\xe \v countl\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:countl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t countl}}
\par
{\bkmkstart AAAAAAADGG}
{\bkmkend AAAAAAADGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b ahci.h}.}\par
}
{\xe \v device\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t device}}
\par
{\bkmkstart AAAAAAADGH}
{\bkmkend AAAAAAADGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b ahci.h}.}\par
}
{\xe \v featureh\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:featureh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t featureh}}
\par
{\bkmkstart AAAAAAADGI}
{\bkmkend AAAAAAADGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b ahci.h}.}\par
}
{\xe \v featurel\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:featurel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t featurel}}
\par
{\bkmkstart AAAAAAADGJ}
{\bkmkend AAAAAAADGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b ahci.h}.}\par
}
{\xe \v fis_type\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:fis_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t fis_type}}
\par
{\bkmkstart AAAAAAADGK}
{\bkmkend AAAAAAADGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b ahci.h}.}\par
}
{\xe \v icc\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:icc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t icc}}
\par
{\bkmkstart AAAAAAADGL}
{\bkmkend AAAAAAADGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b ahci.h}.}\par
}
{\xe \v lba0\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba0}}
\par
{\bkmkstart AAAAAAADGM}
{\bkmkend AAAAAAADGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b ahci.h}.}\par
}
{\xe \v lba1\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba1}}
\par
{\bkmkstart AAAAAAADGN}
{\bkmkend AAAAAAADGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b ahci.h}.}\par
}
{\xe \v lba2\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba2}}
\par
{\bkmkstart AAAAAAADGO}
{\bkmkend AAAAAAADGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b ahci.h}.}\par
}
{\xe \v lba3\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba3}}
\par
{\bkmkstart AAAAAAADGP}
{\bkmkend AAAAAAADGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b ahci.h}.}\par
}
{\xe \v lba4\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba4}}
\par
{\bkmkstart AAAAAAADGQ}
{\bkmkend AAAAAAADGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b ahci.h}.}\par
}
{\xe \v lba5\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:lba5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t lba5}}
\par
{\bkmkstart AAAAAAADGR}
{\bkmkend AAAAAAADGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b ahci.h}.}\par
}
{\xe \v pmport\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:pmport}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t pmport}}
\par
{\bkmkstart AAAAAAADGS}
{\bkmkend AAAAAAADGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b ahci.h}.}\par
}
{\xe \v rsv0\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:rsv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv0}}
\par
{\bkmkstart AAAAAAADGT}
{\bkmkend AAAAAAADGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_FIS_REG_H2D}
{\xe \v _FIS_REG_H2D\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv1[4]}}
\par
{\bkmkstart AAAAAAADGU}
{\bkmkend AAAAAAADGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_GenericAddressStructure Struct Reference\par \pard\plain 
{\tc\tcl2 \v _GenericAddressStructure}
{\xe \v _GenericAddressStructure}
{\bkmkstart AAAAAAADGV}
{\bkmkend AAAAAAADGV}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AddressSpace}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b BitWidth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b BitOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AccessSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Address}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 223} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADGW}
{\bkmkend AAAAAAADGW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AccessSize\:_GenericAddressStructure}
{\xe \v _GenericAddressStructure\:AccessSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AccessSize}}
\par
{\bkmkstart AAAAAAADGX}
{\bkmkend AAAAAAADGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 228} of file {\b mh.h}.}\par
}
{\xe \v Address\:_GenericAddressStructure}
{\xe \v _GenericAddressStructure\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Address}}
\par
{\bkmkstart AAAAAAADGY}
{\bkmkend AAAAAAADGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b mh.h}.}\par
}
{\xe \v AddressSpace\:_GenericAddressStructure}
{\xe \v _GenericAddressStructure\:AddressSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AddressSpace}}
\par
{\bkmkstart AAAAAAADGZ}
{\bkmkend AAAAAAADGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b mh.h}.}\par
}
{\xe \v BitOffset\:_GenericAddressStructure}
{\xe \v _GenericAddressStructure\:BitOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BitOffset}}
\par
{\bkmkstart AAAAAAADHA}
{\bkmkend AAAAAAADHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b mh.h}.}\par
}
{\xe \v BitWidth\:_GenericAddressStructure}
{\xe \v _GenericAddressStructure\:BitWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BitWidth}}
\par
{\bkmkstart AAAAAAADHB}
{\bkmkend AAAAAAADHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_GOP_PARAMS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _GOP_PARAMS}
{\xe \v _GOP_PARAMS}
{\bkmkstart AAAAAAADHC}
{\bkmkend AAAAAAADHC}
\par
{
{\f2 #include <efi.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b FrameBufferBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b FrameBufferSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Width}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Height}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PixelsPerScanLine}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 42} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADHD}
{\bkmkend AAAAAAADHD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v FrameBufferBase\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:FrameBufferBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t FrameBufferBase}}
\par
{\bkmkstart AAAAAAADHE}
{\bkmkend AAAAAAADHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b efi.h}.}\par
}
{\xe \v FrameBufferSize\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:FrameBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t FrameBufferSize}}
\par
{\bkmkstart AAAAAAADHF}
{\bkmkend AAAAAAADHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b efi.h}.}\par
}
{\xe \v Height\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:Height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Height}}
\par
{\bkmkstart AAAAAAADHG}
{\bkmkend AAAAAAADHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b efi.h}.}\par
}
{\xe \v PixelsPerScanLine\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:PixelsPerScanLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PixelsPerScanLine}}
\par
{\bkmkstart AAAAAAADHH}
{\bkmkend AAAAAAADHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b efi.h}.}\par
}
{\xe \v Width\:_GOP_PARAMS}
{\xe \v _GOP_PARAMS\:Width}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Width}}
\par
{\bkmkstart AAAAAAADHI}
{\bkmkend AAAAAAADHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b efi.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HANDLE_TABLE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HANDLE_TABLE}
{\xe \v _HANDLE_TABLE}
{\bkmkstart AAAAAAADHJ}
{\bkmkend AAAAAAADHJ}
\par
{
{\f2 #include <ht.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b TableList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b TableLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b TableCode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PEPROCESS} {\b QuotaProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PHANDLE_TABLE_ENTRY} {\b LastFreeHandleEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b FirstFreeHandle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b NextHandleNeedingPool}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b HandleCount}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 41} of file {\b ht.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADHK}
{\bkmkend AAAAAAADHK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v FirstFreeHandle\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:FirstFreeHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t FirstFreeHandle}}
\par
{\bkmkstart AAAAAAADHL}
{\bkmkend AAAAAAADHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ht.h}.}\par
}
{\xe \v HandleCount\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:HandleCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t HandleCount}}
\par
{\bkmkstart AAAAAAADHM}
{\bkmkend AAAAAAADHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ht.h}.}\par
}
{\xe \v LastFreeHandleEntry\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:LastFreeHandleEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PHANDLE_TABLE_ENTRY} LastFreeHandleEntry}}
\par
{\bkmkstart AAAAAAADHN}
{\bkmkend AAAAAAADHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b ht.h}.}\par
}
{\xe \v NextHandleNeedingPool\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:NextHandleNeedingPool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t NextHandleNeedingPool}}
\par
{\bkmkstart AAAAAAADHO}
{\bkmkend AAAAAAADHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b ht.h}.}\par
}
{\xe \v QuotaProcess\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:QuotaProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PEPROCESS} QuotaProcess}}
\par
{\bkmkstart AAAAAAADHP}
{\bkmkend AAAAAAADHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b ht.h}.}\par
}
{\xe \v TableCode\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:TableCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t TableCode}}
\par
{\bkmkstart AAAAAAADHQ}
{\bkmkend AAAAAAADHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b ht.h}.}\par
}
{\xe \v TableList\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:TableList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} TableList}}
\par
{\bkmkstart AAAAAAADHR}
{\bkmkend AAAAAAADHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ht.h}.}\par
}
{\xe \v TableLock\:_HANDLE_TABLE}
{\xe \v _HANDLE_TABLE\:TableLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} TableLock}}
\par
{\bkmkstart AAAAAAADHS}
{\bkmkend AAAAAAADHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b ht.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ht.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HANDLE_TABLE_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HANDLE_TABLE_ENTRY}
{\xe \v _HANDLE_TABLE_ENTRY}
{\bkmkstart AAAAAAADHT}
{\bkmkend AAAAAAADHT}
\par
{
{\f2 #include <ht.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ void * {\b Object}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b Value}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint32_t {\b GrantedAccess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint32_t {\b NextFreeTableEntry}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 27} of file {\b ht.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADHU}
{\bkmkend AAAAAAADHU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \} }}
\par
{\bkmkstart AAAAAAADHV}
{\bkmkend AAAAAAADHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \} }}
\par
{\bkmkstart AAAAAAADHW}
{\bkmkend AAAAAAADHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GrantedAccess\:_HANDLE_TABLE_ENTRY}
{\xe \v _HANDLE_TABLE_ENTRY\:GrantedAccess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GrantedAccess}}
\par
{\bkmkstart AAAAAAADHX}
{\bkmkend AAAAAAADHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ht.h}.}\par
}
{\xe \v NextFreeTableEntry\:_HANDLE_TABLE_ENTRY}
{\xe \v _HANDLE_TABLE_ENTRY\:NextFreeTableEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t NextFreeTableEntry}}
\par
{\bkmkstart AAAAAAADHY}
{\bkmkend AAAAAAADHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b ht.h}.}\par
}
{\xe \v Object\:_HANDLE_TABLE_ENTRY}
{\xe \v _HANDLE_TABLE_ENTRY\:Object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* Object}}
\par
{\bkmkstart AAAAAAADHZ}
{\bkmkend AAAAAAADHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b ht.h}.}\par
}
{\xe \v Value\:_HANDLE_TABLE_ENTRY}
{\xe \v _HANDLE_TABLE_ENTRY\:Value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Value}}
\par
{\bkmkstart AAAAAAADIA}
{\bkmkend AAAAAAADIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b ht.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ht.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_CMD_HEADER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER}
{\bkmkstart AAAAAAADIB}
{\bkmkend AAAAAAADIB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b dw0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b prdbc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ctba}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ctbau}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv1} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) \par
}{
Definition at line {\b 128} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADIC}
{\bkmkend AAAAAAADIC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ctba\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:ctba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ctba}}
\par
{\bkmkstart AAAAAAADID}
{\bkmkend AAAAAAADID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b ahci.h}.}\par
}
{\xe \v ctbau\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:ctbau}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ctbau}}
\par
{\bkmkstart AAAAAAADIE}
{\bkmkend AAAAAAADIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b ahci.h}.}\par
}
{\xe \v dw0\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:dw0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t dw0}}
\par
{\bkmkstart AAAAAAADIF}
{\bkmkend AAAAAAADIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b ahci.h}.}\par
}
{\xe \v prdbc\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:prdbc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t prdbc}}
\par
{\bkmkstart AAAAAAADIG}
{\bkmkend AAAAAAADIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_HBA_CMD_HEADER}
{\xe \v _HBA_CMD_HEADER\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv1[4]}}
\par
{\bkmkstart AAAAAAADIH}
{\bkmkend AAAAAAADIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_CMD_TBL Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL}
{\bkmkstart AAAAAAADII}
{\bkmkend AAAAAAADII}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b cfis} [64]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b acmd} [16]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv} [48]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HBA_PRDT_ENTRY} {\b prdt_entry} [1]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. \par
}{
Definition at line {\b 110} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADIJ}
{\bkmkend AAAAAAADIJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v acmd\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:acmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t acmd[16]}}
\par
{\bkmkstart AAAAAAADIK}
{\bkmkend AAAAAAADIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b ahci.h}.}\par
}
{\xe \v cfis\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:cfis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t cfis[64]}}
\par
{\bkmkstart AAAAAAADIL}
{\bkmkend AAAAAAADIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 112} of file {\b ahci.h}.}\par
}
{\xe \v prdt_entry\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:prdt_entry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HBA_PRDT_ENTRY} prdt_entry[1]}}
\par
{\bkmkstart AAAAAAADIM}
{\bkmkend AAAAAAADIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b ahci.h}.}\par
}
{\xe \v rsv\:_HBA_CMD_TBL}
{\xe \v _HBA_CMD_TBL\:rsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv[48]}}
\par
{\bkmkstart AAAAAAADIN}
{\bkmkend AAAAAAADIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_MEM Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_MEM}
{\xe \v _HBA_MEM}
{\bkmkstart AAAAAAADIO}
{\bkmkend AAAAAAADIO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cap}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ghc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b is}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b pi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b vs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ccc_ctl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ccc_pts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b em_loc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b em_ctl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cap2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b bohc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b rsv} [0xA0 - 0x2C]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b venor} [0x100 - 0xA0]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) \par
}{
Definition at line {\b 31} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADIP}
{\bkmkend AAAAAAADIP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v bohc\:_HBA_MEM}
{\xe \v _HBA_MEM\:bohc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t bohc}}
\par
{\bkmkstart AAAAAAADIQ}
{\bkmkend AAAAAAADIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b ahci.h}.}\par
}
{\xe \v cap\:_HBA_MEM}
{\xe \v _HBA_MEM\:cap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cap}}
\par
{\bkmkstart AAAAAAADIR}
{\bkmkend AAAAAAADIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b ahci.h}.}\par
}
{\xe \v cap2\:_HBA_MEM}
{\xe \v _HBA_MEM\:cap2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cap2}}
\par
{\bkmkstart AAAAAAADIS}
{\bkmkend AAAAAAADIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ahci.h}.}\par
}
{\xe \v ccc_ctl\:_HBA_MEM}
{\xe \v _HBA_MEM\:ccc_ctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ccc_ctl}}
\par
{\bkmkstart AAAAAAADIT}
{\bkmkend AAAAAAADIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b ahci.h}.}\par
}
{\xe \v ccc_pts\:_HBA_MEM}
{\xe \v _HBA_MEM\:ccc_pts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ccc_pts}}
\par
{\bkmkstart AAAAAAADIU}
{\bkmkend AAAAAAADIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b ahci.h}.}\par
}
{\xe \v em_ctl\:_HBA_MEM}
{\xe \v _HBA_MEM\:em_ctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t em_ctl}}
\par
{\bkmkstart AAAAAAADIV}
{\bkmkend AAAAAAADIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b ahci.h}.}\par
}
{\xe \v em_loc\:_HBA_MEM}
{\xe \v _HBA_MEM\:em_loc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t em_loc}}
\par
{\bkmkstart AAAAAAADIW}
{\bkmkend AAAAAAADIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b ahci.h}.}\par
}
{\xe \v ghc\:_HBA_MEM}
{\xe \v _HBA_MEM\:ghc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ghc}}
\par
{\bkmkstart AAAAAAADIX}
{\bkmkend AAAAAAADIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ahci.h}.}\par
}
{\xe \v is\:_HBA_MEM}
{\xe \v _HBA_MEM\:is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t is}}
\par
{\bkmkstart AAAAAAADIY}
{\bkmkend AAAAAAADIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b ahci.h}.}\par
}
{\xe \v pi\:_HBA_MEM}
{\xe \v _HBA_MEM\:pi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t pi}}
\par
{\bkmkstart AAAAAAADIZ}
{\bkmkend AAAAAAADIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b ahci.h}.}\par
}
{\xe \v rsv\:_HBA_MEM}
{\xe \v _HBA_MEM\:rsv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t rsv[0xA0 - 0x2C]}}
\par
{\bkmkstart AAAAAAADJA}
{\bkmkend AAAAAAADJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ahci.h}.}\par
}
{\xe \v venor\:_HBA_MEM}
{\xe \v _HBA_MEM\:venor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t venor[0x100 - 0xA0]}}
\par
{\bkmkstart AAAAAAADJB}
{\bkmkend AAAAAAADJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b ahci.h}.}\par
}
{\xe \v vs\:_HBA_MEM}
{\xe \v _HBA_MEM\:vs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t vs}}
\par
{\bkmkstart AAAAAAADJC}
{\bkmkend AAAAAAADJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_PORT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_PORT}
{\xe \v _HBA_PORT}
{\bkmkstart AAAAAAADJD}
{\bkmkend AAAAAAADJD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b clb}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b clbu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fb}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fbu}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b is}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ie}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cmd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b tfd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sig}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ssts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sctl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b serr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sact}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ci}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b sntf}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b fbs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv1} [11]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b vendor} [4]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) \par
}{
Definition at line {\b 49} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADJE}
{\bkmkend AAAAAAADJE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ci\:_HBA_PORT}
{\xe \v _HBA_PORT\:ci}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ci}}
\par
{\bkmkstart AAAAAAADJF}
{\bkmkend AAAAAAADJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b ahci.h}.}\par
}
{\xe \v clb\:_HBA_PORT}
{\xe \v _HBA_PORT\:clb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t clb}}
\par
{\bkmkstart AAAAAAADJG}
{\bkmkend AAAAAAADJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ahci.h}.}\par
}
{\xe \v clbu\:_HBA_PORT}
{\xe \v _HBA_PORT\:clbu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t clbu}}
\par
{\bkmkstart AAAAAAADJH}
{\bkmkend AAAAAAADJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b ahci.h}.}\par
}
{\xe \v cmd\:_HBA_PORT}
{\xe \v _HBA_PORT\:cmd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cmd}}
\par
{\bkmkstart AAAAAAADJI}
{\bkmkend AAAAAAADJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b ahci.h}.}\par
}
{\xe \v fb\:_HBA_PORT}
{\xe \v _HBA_PORT\:fb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fb}}
\par
{\bkmkstart AAAAAAADJJ}
{\bkmkend AAAAAAADJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ahci.h}.}\par
}
{\xe \v fbs\:_HBA_PORT}
{\xe \v _HBA_PORT\:fbs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fbs}}
\par
{\bkmkstart AAAAAAADJK}
{\bkmkend AAAAAAADJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b ahci.h}.}\par
}
{\xe \v fbu\:_HBA_PORT}
{\xe \v _HBA_PORT\:fbu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t fbu}}
\par
{\bkmkstart AAAAAAADJL}
{\bkmkend AAAAAAADJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b ahci.h}.}\par
}
{\xe \v ie\:_HBA_PORT}
{\xe \v _HBA_PORT\:ie}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ie}}
\par
{\bkmkstart AAAAAAADJM}
{\bkmkend AAAAAAADJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b ahci.h}.}\par
}
{\xe \v is\:_HBA_PORT}
{\xe \v _HBA_PORT\:is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t is}}
\par
{\bkmkstart AAAAAAADJN}
{\bkmkend AAAAAAADJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ahci.h}.}\par
}
{\xe \v rsv0\:_HBA_PORT}
{\xe \v _HBA_PORT\:rsv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv0}}
\par
{\bkmkstart AAAAAAADJO}
{\bkmkend AAAAAAADJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_HBA_PORT}
{\xe \v _HBA_PORT\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv1[11]}}
\par
{\bkmkstart AAAAAAADJP}
{\bkmkend AAAAAAADJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b ahci.h}.}\par
}
{\xe \v sact\:_HBA_PORT}
{\xe \v _HBA_PORT\:sact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sact}}
\par
{\bkmkstart AAAAAAADJQ}
{\bkmkend AAAAAAADJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ahci.h}.}\par
}
{\xe \v sctl\:_HBA_PORT}
{\xe \v _HBA_PORT\:sctl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sctl}}
\par
{\bkmkstart AAAAAAADJR}
{\bkmkend AAAAAAADJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b ahci.h}.}\par
}
{\xe \v serr\:_HBA_PORT}
{\xe \v _HBA_PORT\:serr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t serr}}
\par
{\bkmkstart AAAAAAADJS}
{\bkmkend AAAAAAADJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b ahci.h}.}\par
}
{\xe \v sig\:_HBA_PORT}
{\xe \v _HBA_PORT\:sig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sig}}
\par
{\bkmkstart AAAAAAADJT}
{\bkmkend AAAAAAADJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ahci.h}.}\par
}
{\xe \v sntf\:_HBA_PORT}
{\xe \v _HBA_PORT\:sntf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t sntf}}
\par
{\bkmkstart AAAAAAADJU}
{\bkmkend AAAAAAADJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b ahci.h}.}\par
}
{\xe \v ssts\:_HBA_PORT}
{\xe \v _HBA_PORT\:ssts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ssts}}
\par
{\bkmkstart AAAAAAADJV}
{\bkmkend AAAAAAADJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b ahci.h}.}\par
}
{\xe \v tfd\:_HBA_PORT}
{\xe \v _HBA_PORT\:tfd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t tfd}}
\par
{\bkmkstart AAAAAAADJW}
{\bkmkend AAAAAAADJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b ahci.h}.}\par
}
{\xe \v vendor\:_HBA_PORT}
{\xe \v _HBA_PORT\:vendor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t vendor[4]}}
\par
{\bkmkstart AAAAAAADJX}
{\bkmkend AAAAAAADJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_HBA_PRDT_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v _HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY}
{\bkmkstart AAAAAAADJY}
{\bkmkend AAAAAAADJY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }}\par
{
{\f2 #include <ahci.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b dba}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b dbau}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b dbc}: 22\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b rsv1}: 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b i}: 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. \par
}{
Definition at line {\b 98} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADJZ}
{\bkmkend AAAAAAADJZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v dba\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:dba}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t dba}}
\par
{\bkmkstart AAAAAAADKA}
{\bkmkend AAAAAAADKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b ahci.h}.}\par
}
{\xe \v dbau\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:dbau}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t dbau}}
\par
{\bkmkstart AAAAAAADKB}
{\bkmkend AAAAAAADKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b ahci.h}.}\par
}
{\xe \v dbc\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:dbc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t dbc}}
\par
{\bkmkstart AAAAAAADKC}
{\bkmkend AAAAAAADKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b ahci.h}.}\par
}
{\xe \v i\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:i}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t i}}
\par
{\bkmkstart AAAAAAADKD}
{\bkmkend AAAAAAADKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b ahci.h}.}\par
}
{\xe \v rsv0\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:rsv0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv0}}
\par
{\bkmkstart AAAAAAADKE}
{\bkmkend AAAAAAADKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b ahci.h}.}\par
}
{\xe \v rsv1\:_HBA_PRDT_ENTRY}
{\xe \v _HBA_PRDT_ENTRY\:rsv1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t rsv1}}
\par
{\bkmkstart AAAAAAADKF}
{\bkmkend AAAAAAADKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/{\b ahci.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_IDT_ENTRY_64 Struct Reference\par \pard\plain 
{\tc\tcl2 \v _IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64}
{\bkmkstart AAAAAAADKG}
{\bkmkend AAAAAAADKG}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b offset_low}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b selector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ist}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b type_attr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b offset_mid}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b offset_high}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b zero}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 182} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADKH}
{\bkmkend AAAAAAADKH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ist\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:ist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ist}}
\par
{\bkmkstart AAAAAAADKI}
{\bkmkend AAAAAAADKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b mh.h}.}\par
}
{\xe \v offset_high\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:offset_high}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t offset_high}}
\par
{\bkmkstart AAAAAAADKJ}
{\bkmkend AAAAAAADKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b mh.h}.}\par
}
{\xe \v offset_low\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:offset_low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t offset_low}}
\par
{\bkmkstart AAAAAAADKK}
{\bkmkend AAAAAAADKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b mh.h}.}\par
}
{\xe \v offset_mid\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:offset_mid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t offset_mid}}
\par
{\bkmkstart AAAAAAADKL}
{\bkmkend AAAAAAADKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 187} of file {\b mh.h}.}\par
}
{\xe \v selector\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:selector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t selector}}
\par
{\bkmkstart AAAAAAADKM}
{\bkmkend AAAAAAADKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b mh.h}.}\par
}
{\xe \v type_attr\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:type_attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t type_attr}}
\par
{\bkmkstart AAAAAAADKN}
{\bkmkend AAAAAAADKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b mh.h}.}\par
}
{\xe \v zero\:_IDT_ENTRY_64}
{\xe \v _IDT_ENTRY_64\:zero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t zero}}
\par
{\bkmkstart AAAAAAADKO}
{\bkmkend AAAAAAADKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 189} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_IDT_PTR Struct Reference\par \pard\plain 
{\tc\tcl2 \v _IDT_PTR}
{\xe \v _IDT_PTR}
{\bkmkstart AAAAAAADKP}
{\bkmkend AAAAAAADKP}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b limit}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b base}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 177} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADKQ}
{\bkmkend AAAAAAADKQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v base\:_IDT_PTR}
{\xe \v _IDT_PTR\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t base}}
\par
{\bkmkstart AAAAAAADKR}
{\bkmkend AAAAAAADKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b mh.h}.}\par
}
{\xe \v limit\:_IDT_PTR}
{\xe \v _IDT_PTR\:limit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t limit}}
\par
{\bkmkstart AAAAAAADKS}
{\bkmkend AAAAAAADKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_IPI_PARAMS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _IPI_PARAMS}
{\xe \v _IPI_PARAMS}
{\bkmkstart AAAAAAADKT}
{\bkmkend AAAAAAADKT}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DEBUG_REGISTERS} {\b debugRegs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _PAGE_PARAMETERS} {\b pageParams}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 397} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADKU}
{\bkmkend AAAAAAADKU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v debugRegs\:_IPI_PARAMS}
{\xe \v _IPI_PARAMS\:debugRegs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DEBUG_REGISTERS} debugRegs}}
\par
{\bkmkstart AAAAAAADKV}
{\bkmkend AAAAAAADKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b mh.h}.}\par
}
{\xe \v pageParams\:_IPI_PARAMS}
{\xe \v _IPI_PARAMS\:pageParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _PAGE_PARAMETERS} pageParams}}
\par
{\bkmkstart AAAAAAADKW}
{\bkmkend AAAAAAADKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 399} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_IPROCESS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _IPROCESS}
{\xe \v _IPROCESS}
{\bkmkstart AAAAAAADKX}
{\bkmkend AAAAAAADKX}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b PageDirectoryPhysical}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t * {\b PageDirectoryVirtual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SPINLOCK} {\b ProcessLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ProcessState}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 254} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADKY}
{\bkmkend AAAAAAADKY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v PageDirectoryPhysical\:_IPROCESS}
{\xe \v _IPROCESS\:PageDirectoryPhysical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t PageDirectoryPhysical}}
\par
{\bkmkstart AAAAAAADKZ}
{\bkmkend AAAAAAADKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 255} of file {\b me.h}.}\par
}
{\xe \v PageDirectoryVirtual\:_IPROCESS}
{\xe \v _IPROCESS\:PageDirectoryVirtual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t* PageDirectoryVirtual}}
\par
{\bkmkstart AAAAAAADLA}
{\bkmkend AAAAAAADLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 256} of file {\b me.h}.}\par
}
{\xe \v ProcessLock\:_IPROCESS}
{\xe \v _IPROCESS\:ProcessLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _SPINLOCK} ProcessLock}}
\par
{\bkmkstart AAAAAAADLB}
{\bkmkend AAAAAAADLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 257} of file {\b me.h}.}\par
}
{\xe \v ProcessState\:_IPROCESS}
{\xe \v _IPROCESS\:ProcessState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ProcessState}}
\par
{\bkmkstart AAAAAAADLC}
{\bkmkend AAAAAAADLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 258} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_ITHREAD Struct Reference\par \pard\plain 
{\tc\tcl2 \v _ITHREAD}
{\xe \v _ITHREAD}
{\bkmkstart AAAAAAADLD}
{\bkmkend AAAAAAADLD}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _TRAP_FRAME} {\b TrapRegisters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ThreadState}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b StackBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsLargeStack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b KernelStack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _TimeSliceTicks} {\b TimeSlice}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _TimeSliceTicks} {\b TimeSliceAllocated}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PRIVILEGE_MODE} {\b PreviousMode}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _APC_STATE} {\b ApcState}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _WAIT_BLOCK} {\b WaitBlock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 261} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADLE}
{\bkmkend AAAAAAADLE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ApcState\:_ITHREAD}
{\xe \v _ITHREAD\:ApcState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _APC_STATE} ApcState}}
\par
{\bkmkstart AAAAAAADLF}
{\bkmkend AAAAAAADLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 270} of file {\b me.h}.}\par
}
{\xe \v IsLargeStack\:_ITHREAD}
{\xe \v _ITHREAD\:IsLargeStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool IsLargeStack}}
\par
{\bkmkstart AAAAAAADLG}
{\bkmkend AAAAAAADLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 265} of file {\b me.h}.}\par
}
{\xe \v KernelStack\:_ITHREAD}
{\xe \v _ITHREAD\:KernelStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* KernelStack}}
\par
{\bkmkstart AAAAAAADLH}
{\bkmkend AAAAAAADLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 266} of file {\b me.h}.}\par
}
{\xe \v PreviousMode\:_ITHREAD}
{\xe \v _ITHREAD\:PreviousMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PRIVILEGE_MODE} PreviousMode}}
\par
{\bkmkstart AAAAAAADLI}
{\bkmkend AAAAAAADLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b me.h}.}\par
}
{\xe \v StackBase\:_ITHREAD}
{\xe \v _ITHREAD\:StackBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* StackBase}}
\par
{\bkmkstart AAAAAAADLJ}
{\bkmkend AAAAAAADLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 264} of file {\b me.h}.}\par
}
{\xe \v ThreadState\:_ITHREAD}
{\xe \v _ITHREAD\:ThreadState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ThreadState}}
\par
{\bkmkstart AAAAAAADLK}
{\bkmkend AAAAAAADLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 263} of file {\b me.h}.}\par
}
{\xe \v TimeSlice\:_ITHREAD}
{\xe \v _ITHREAD\:TimeSlice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _TimeSliceTicks} TimeSlice}}
\par
{\bkmkstart AAAAAAADLL}
{\bkmkend AAAAAAADLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 267} of file {\b me.h}.}\par
}
{\xe \v TimeSliceAllocated\:_ITHREAD}
{\xe \v _ITHREAD\:TimeSliceAllocated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _TimeSliceTicks} TimeSliceAllocated}}
\par
{\bkmkstart AAAAAAADLM}
{\bkmkend AAAAAAADLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 268} of file {\b me.h}.}\par
}
{\xe \v TrapRegisters\:_ITHREAD}
{\xe \v _ITHREAD\:TrapRegisters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _TRAP_FRAME} TrapRegisters}}
\par
{\bkmkstart AAAAAAADLN}
{\bkmkend AAAAAAADLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 262} of file {\b me.h}.}\par
}
{\xe \v WaitBlock\:_ITHREAD}
{\xe \v _ITHREAD\:WaitBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _WAIT_BLOCK} WaitBlock}}
\par
{\bkmkstart AAAAAAADLO}
{\bkmkend AAAAAAADLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 271} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_MADT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _MADT}
{\xe \v _MADT}
{\bkmkstart AAAAAAADLP}
{\bkmkend AAAAAAADLP}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ACPI_SDT_HEADER} {\b h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapicAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b flags}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 300} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADLQ}
{\bkmkend AAAAAAADLQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v flags\:_MADT}
{\xe \v _MADT\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t flags}}
\par
{\bkmkstart AAAAAAADLR}
{\bkmkend AAAAAAADLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 303} of file {\b mh.h}.}\par
}
{\xe \v h\:_MADT}
{\xe \v _MADT\:h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ACPI_SDT_HEADER} h}}
\par
{\bkmkstart AAAAAAADLS}
{\bkmkend AAAAAAADLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 301} of file {\b mh.h}.}\par
}
{\xe \v lapicAddress\:_MADT}
{\xe \v _MADT\:lapicAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapicAddress}}
\par
{\bkmkstart AAAAAAADLT}
{\bkmkend AAAAAAADLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 302} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_MM_PFN_DATABASE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE}
{\bkmkstart AAAAAAADLU}
{\bkmkend AAAAAAADLU}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PPFN_ENTRY} {\b PfnEntries}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b TotalPageCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b PfnDatabaseLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_LIST} {\b FreePageList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_LIST} {\b ZeroedPageList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_LIST} {\b StandbyPageList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_LIST} {\b ModifiedPageList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_LIST} {\b BadPageList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile size_t {\b AvailablePages}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile size_t {\b TotalReserved}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 456} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADLV}
{\bkmkend AAAAAAADLV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v AvailablePages\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:AvailablePages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile size_t AvailablePages}}
\par
{\bkmkstart AAAAAAADLW}
{\bkmkend AAAAAAADLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 469} of file {\b mm.h}.}\par
}
{\xe \v BadPageList\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:BadPageList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_LIST} BadPageList}}
\par
{\bkmkstart AAAAAAADLX}
{\bkmkend AAAAAAADLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 466} of file {\b mm.h}.}\par
}
{\xe \v FreePageList\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:FreePageList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_LIST} FreePageList}}
\par
{\bkmkstart AAAAAAADLY}
{\bkmkend AAAAAAADLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 462} of file {\b mm.h}.}\par
}
{\xe \v ModifiedPageList\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:ModifiedPageList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_LIST} ModifiedPageList}}
\par
{\bkmkstart AAAAAAADLZ}
{\bkmkend AAAAAAADLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 465} of file {\b mm.h}.}\par
}
{\xe \v PfnDatabaseLock\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:PfnDatabaseLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} PfnDatabaseLock}}
\par
{\bkmkstart AAAAAAADMA}
{\bkmkend AAAAAAADMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 459} of file {\b mm.h}.}\par
}
{\xe \v PfnEntries\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:PfnEntries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PPFN_ENTRY} PfnEntries}}
\par
{\bkmkstart AAAAAAADMB}
{\bkmkend AAAAAAADMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 457} of file {\b mm.h}.}\par
}
{\xe \v StandbyPageList\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:StandbyPageList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_LIST} StandbyPageList}}
\par
{\bkmkstart AAAAAAADMC}
{\bkmkend AAAAAAADMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 464} of file {\b mm.h}.}\par
}
{\xe \v TotalPageCount\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:TotalPageCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t TotalPageCount}}
\par
{\bkmkstart AAAAAAADMD}
{\bkmkend AAAAAAADMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 458} of file {\b mm.h}.}\par
}
{\xe \v TotalReserved\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:TotalReserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile size_t TotalReserved}}
\par
{\bkmkstart AAAAAAADME}
{\bkmkend AAAAAAADME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 470} of file {\b mm.h}.}\par
}
{\xe \v ZeroedPageList\:_MM_PFN_DATABASE}
{\xe \v _MM_PFN_DATABASE\:ZeroedPageList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_LIST} ZeroedPageList}}
\par
{\bkmkstart AAAAAAADMF}
{\bkmkend AAAAAAADMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 463} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_MM_PFN_LIST Struct Reference\par \pard\plain 
{\tc\tcl2 \v _MM_PFN_LIST}
{\xe \v _MM_PFN_LIST}
{\bkmkstart AAAAAAADMG}
{\bkmkend AAAAAAADMG}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DOUBLY_LINKED_LIST} {\b ListEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint64_t {\b Count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b PfnListLock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 450} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADMH}
{\bkmkend AAAAAAADMH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Count\:_MM_PFN_LIST}
{\xe \v _MM_PFN_LIST\:Count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint64_t Count}}
\par
{\bkmkstart AAAAAAADMI}
{\bkmkend AAAAAAADMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 452} of file {\b mm.h}.}\par
}
{\xe \v ListEntry\:_MM_PFN_LIST}
{\xe \v _MM_PFN_LIST\:ListEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DOUBLY_LINKED_LIST} ListEntry}}
\par
{\bkmkstart AAAAAAADMJ}
{\bkmkend AAAAAAADMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 451} of file {\b mm.h}.}\par
}
{\xe \v PfnListLock\:_MM_PFN_LIST}
{\xe \v _MM_PFN_LIST\:PfnListLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} PfnListLock}}
\par
{\bkmkstart AAAAAAADMK}
{\bkmkend AAAAAAADMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 453} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_MMPTE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _MMPTE}
{\xe \v _MMPTE}
{\bkmkstart AAAAAAADML}
{\bkmkend AAAAAAADML}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b Value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Present}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Write}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b User}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b WriteThrough}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b CacheDisable}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Accessed}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Dirty}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b LargePage}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Global}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b CopyOnWrite}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Prototype}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Reserved0}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b PageFrameNumber}: 40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Reserved1}: 11\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b NoExecute}: 1\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b Hard}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Present}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Write}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Transition}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Prototype}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b PageFile}: 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b Reserved}: 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b PageFrameNumber}: 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b SoftwareFlags}: 20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint64_t {\b NoExecute}: 1\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b Soft}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 381} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADMM}
{\bkmkend AAAAAAADMM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \} }}
\par
{\bkmkstart AAAAAAADMN}
{\bkmkend AAAAAAADMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Accessed\:_MMPTE}
{\xe \v _MMPTE\:Accessed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Accessed}}
\par
{\bkmkstart AAAAAAADMO}
{\bkmkend AAAAAAADMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 397} of file {\b mm.h}.}\par
}
{\xe \v CacheDisable\:_MMPTE}
{\xe \v _MMPTE\:CacheDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t CacheDisable}}
\par
{\bkmkstart AAAAAAADMP}
{\bkmkend AAAAAAADMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 396} of file {\b mm.h}.}\par
}
{\xe \v CopyOnWrite\:_MMPTE}
{\xe \v _MMPTE\:CopyOnWrite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t CopyOnWrite}}
\par
{\bkmkstart AAAAAAADMQ}
{\bkmkend AAAAAAADMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 401} of file {\b mm.h}.}\par
}
{\xe \v Dirty\:_MMPTE}
{\xe \v _MMPTE\:Dirty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Dirty}}
\par
{\bkmkstart AAAAAAADMR}
{\bkmkend AAAAAAADMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 398} of file {\b mm.h}.}\par
}
{\xe \v Global\:_MMPTE}
{\xe \v _MMPTE\:Global}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Global}}
\par
{\bkmkstart AAAAAAADMS}
{\bkmkend AAAAAAADMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 400} of file {\b mm.h}.}\par
}
{\xe \v Hard\:_MMPTE}
{\xe \v _MMPTE\:Hard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct  \{ ... \}  Hard}}
\par
{\bkmkstart AAAAAAADMT}
{\bkmkend AAAAAAADMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v LargePage\:_MMPTE}
{\xe \v _MMPTE\:LargePage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t LargePage}}
\par
{\bkmkstart AAAAAAADMU}
{\bkmkend AAAAAAADMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 399} of file {\b mm.h}.}\par
}
{\xe \v NoExecute\:_MMPTE}
{\xe \v _MMPTE\:NoExecute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t NoExecute}}
\par
{\bkmkstart AAAAAAADMV}
{\bkmkend AAAAAAADMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 406} of file {\b mm.h}.}\par
}
{\xe \v PageFile\:_MMPTE}
{\xe \v _MMPTE\:PageFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t PageFile}}
\par
{\bkmkstart AAAAAAADMW}
{\bkmkend AAAAAAADMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 419} of file {\b mm.h}.}\par
}
{\xe \v PageFrameNumber\:_MMPTE}
{\xe \v _MMPTE\:PageFrameNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t PageFrameNumber}}
\par
{\bkmkstart AAAAAAADMX}
{\bkmkend AAAAAAADMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b mm.h}.}\par
}
{\xe \v Present\:_MMPTE}
{\xe \v _MMPTE\:Present}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Present}}
\par
{\bkmkstart AAAAAAADMY}
{\bkmkend AAAAAAADMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 392} of file {\b mm.h}.}\par
}
{\xe \v Prototype\:_MMPTE}
{\xe \v _MMPTE\:Prototype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Prototype}}
\par
{\bkmkstart AAAAAAADMZ}
{\bkmkend AAAAAAADMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 402} of file {\b mm.h}.}\par
}
{\xe \v Reserved\:_MMPTE}
{\xe \v _MMPTE\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Reserved}}
\par
{\bkmkstart AAAAAAADNA}
{\bkmkend AAAAAAADNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 420} of file {\b mm.h}.}\par
}
{\xe \v Reserved0\:_MMPTE}
{\xe \v _MMPTE\:Reserved0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Reserved0}}
\par
{\bkmkstart AAAAAAADNB}
{\bkmkend AAAAAAADNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 403} of file {\b mm.h}.}\par
}
{\xe \v Reserved1\:_MMPTE}
{\xe \v _MMPTE\:Reserved1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Reserved1}}
\par
{\bkmkstart AAAAAAADNC}
{\bkmkend AAAAAAADNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 405} of file {\b mm.h}.}\par
}
{\xe \v Soft\:_MMPTE}
{\xe \v _MMPTE\:Soft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct  \{ ... \}  Soft}}
\par
{\bkmkstart AAAAAAADND}
{\bkmkend AAAAAAADND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SoftwareFlags\:_MMPTE}
{\xe \v _MMPTE\:SoftwareFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t SoftwareFlags}}
\par
{\bkmkstart AAAAAAADNE}
{\bkmkend AAAAAAADNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 422} of file {\b mm.h}.}\par
}
{\xe \v Transition\:_MMPTE}
{\xe \v _MMPTE\:Transition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Transition}}
\par
{\bkmkstart AAAAAAADNF}
{\bkmkend AAAAAAADNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 417} of file {\b mm.h}.}\par
}
{\xe \v User\:_MMPTE}
{\xe \v _MMPTE\:User}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t User}}
\par
{\bkmkstart AAAAAAADNG}
{\bkmkend AAAAAAADNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 394} of file {\b mm.h}.}\par
}
{\xe \v Value\:_MMPTE}
{\xe \v _MMPTE\:Value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Value}}
\par
{\bkmkstart AAAAAAADNH}
{\bkmkend AAAAAAADNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b mm.h}.}\par
}
{\xe \v Write\:_MMPTE}
{\xe \v _MMPTE\:Write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Write}}
\par
{\bkmkstart AAAAAAADNI}
{\bkmkend AAAAAAADNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b mm.h}.}\par
}
{\xe \v WriteThrough\:_MMPTE}
{\xe \v _MMPTE\:WriteThrough}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t WriteThrough}}
\par
{\bkmkstart AAAAAAADNJ}
{\bkmkend AAAAAAADNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 395} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_MMVAD Struct Reference\par \pard\plain 
{\tc\tcl2 \v _MMVAD}
{\xe \v _MMVAD}
{\bkmkstart AAAAAAADNK}
{\bkmkend AAAAAAADNK}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b StartVa}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b EndVa}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b VAD_FLAGS} {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MMVAD} * {\b LeftChild}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MMVAD} * {\b RightChild}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MMVAD} * {\b Parent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Height}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct _FILE_OBJECT * {\b File}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b FileOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EPROCESS} * {\b OwningProcess}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 473} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADNL}
{\bkmkend AAAAAAADNL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v EndVa\:_MMVAD}
{\xe \v _MMVAD\:EndVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t EndVa}}
\par
{\bkmkstart AAAAAAADNM}
{\bkmkend AAAAAAADNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 475} of file {\b mm.h}.}\par
}
{\xe \v File\:_MMVAD}
{\xe \v _MMVAD\:File}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct _FILE_OBJECT* File}}
\par
{\bkmkstart AAAAAAADNN}
{\bkmkend AAAAAAADNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 487} of file {\b mm.h}.}\par
}
{\xe \v FileOffset\:_MMVAD}
{\xe \v _MMVAD\:FileOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t FileOffset}}
\par
{\bkmkstart AAAAAAADNO}
{\bkmkend AAAAAAADNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b mm.h}.}\par
}
{\xe \v Flags\:_MMVAD}
{\xe \v _MMVAD\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b VAD_FLAGS} Flags}}
\par
{\bkmkstart AAAAAAADNP}
{\bkmkend AAAAAAADNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 476} of file {\b mm.h}.}\par
}
{\xe \v Height\:_MMVAD}
{\xe \v _MMVAD\:Height}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Height}}
\par
{\bkmkstart AAAAAAADNQ}
{\bkmkend AAAAAAADNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 484} of file {\b mm.h}.}\par
}
{\xe \v LeftChild\:_MMVAD}
{\xe \v _MMVAD\:LeftChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _MMVAD}* LeftChild}}
\par
{\bkmkstart AAAAAAADNR}
{\bkmkend AAAAAAADNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 479} of file {\b mm.h}.}\par
}
{\xe \v OwningProcess\:_MMVAD}
{\xe \v _MMVAD\:OwningProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EPROCESS}* OwningProcess}}
\par
{\bkmkstart AAAAAAADNS}
{\bkmkend AAAAAAADNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b mm.h}.}\par
}
{\xe \v Parent\:_MMVAD}
{\xe \v _MMVAD\:Parent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _MMVAD}* Parent}}
\par
{\bkmkstart AAAAAAADNT}
{\bkmkend AAAAAAADNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 481} of file {\b mm.h}.}\par
}
{\xe \v RightChild\:_MMVAD}
{\xe \v _MMVAD\:RightChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _MMVAD}* RightChild}}
\par
{\bkmkstart AAAAAAADNU}
{\bkmkend AAAAAAADNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 480} of file {\b mm.h}.}\par
}
{\xe \v StartVa\:_MMVAD}
{\xe \v _MMVAD\:StartVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t StartVa}}
\par
{\bkmkstart AAAAAAADNV}
{\bkmkend AAAAAAADNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 474} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_MUTEX Struct Reference\par \pard\plain 
{\tc\tcl2 \v _MUTEX}
{\xe \v _MUTEX}
{\bkmkstart AAAAAAADNW}
{\bkmkend AAAAAAADNW}
\par
{
{\f2 #include <ms.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ownerTid}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EVENT} {\b SynchEvent}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b locked}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SPINLOCK} {\b lock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ETHREAD} * {\b ownerThread}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MUTEX} - Mutual exclusion.\par
Used to sleep instead of busy waiting, used in non critical paths (e.g {\b IRQL} < DISPATCH_LEVEL) \par
}{
Definition at line {\b 82} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADNX}
{\bkmkend AAAAAAADNX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v lock\:_MUTEX}
{\xe \v _MUTEX\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _SPINLOCK} lock}}
\par
{\bkmkstart AAAAAAADNY}
{\bkmkend AAAAAAADNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b ms.h}.}\par
}
{\xe \v locked\:_MUTEX}
{\xe \v _MUTEX\:locked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool locked}}
\par
{\bkmkstart AAAAAAADNZ}
{\bkmkend AAAAAAADNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b ms.h}.}\par
}
{\xe \v ownerThread\:_MUTEX}
{\xe \v _MUTEX\:ownerThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ETHREAD}* ownerThread}}
\par
{\bkmkstart AAAAAAADOA}
{\bkmkend AAAAAAADOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b ms.h}.}\par
}
{\xe \v ownerTid\:_MUTEX}
{\xe \v _MUTEX\:ownerTid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ownerTid}}
\par
{\bkmkstart AAAAAAADOB}
{\bkmkend AAAAAAADOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b ms.h}.}\par
}
{\xe \v SynchEvent\:_MUTEX}
{\xe \v _MUTEX\:SynchEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _EVENT} SynchEvent}}
\par
{\bkmkstart AAAAAAADOC}
{\bkmkend AAAAAAADOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ms.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_OBJECT_HEADER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _OBJECT_HEADER}
{\xe \v _OBJECT_HEADER}
{\bkmkstart AAAAAAADOD}
{\bkmkend AAAAAAADOD}
\par
{
{\f2 #include <ob.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b PointerCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b HandleCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ volatile void * {\b NextToFree}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b __attribute__}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POBJECT_TYPE} {\b Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Flags}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 56} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADOE}
{\bkmkend AAAAAAADOE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v __attribute__\:_OBJECT_HEADER}
{\xe \v _OBJECT_HEADER\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  {\b __attribute__}}}
\par
{\bkmkstart AAAAAAADOF}
{\bkmkend AAAAAAADOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Flags\:_OBJECT_HEADER}
{\xe \v _OBJECT_HEADER\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Flags}}
\par
{\bkmkstart AAAAAAADOG}
{\bkmkend AAAAAAADOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ob.h}.}\par
}
{\xe \v HandleCount\:_OBJECT_HEADER}
{\xe \v _OBJECT_HEADER\:HandleCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t HandleCount}}
\par
{\bkmkstart AAAAAAADOH}
{\bkmkend AAAAAAADOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ob.h}.}\par
}
{\xe \v NextToFree\:_OBJECT_HEADER}
{\xe \v _OBJECT_HEADER\:NextToFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* NextToFree}}
\par
{\bkmkstart AAAAAAADOI}
{\bkmkend AAAAAAADOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b ob.h}.}\par
}
{\xe \v PointerCount\:_OBJECT_HEADER}
{\xe \v _OBJECT_HEADER\:PointerCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t PointerCount}}
\par
{\bkmkstart AAAAAAADOJ}
{\bkmkend AAAAAAADOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b ob.h}.}\par
}
{\xe \v Type\:_OBJECT_HEADER}
{\xe \v _OBJECT_HEADER\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POBJECT_TYPE} Type}}
\par
{\bkmkstart AAAAAAADOK}
{\bkmkend AAAAAAADOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ob.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_OBJECT_TYPE Struct Reference\par \pard\plain 
{\tc\tcl2 \v _OBJECT_TYPE}
{\xe \v _OBJECT_TYPE}
{\bkmkstart AAAAAAADOL}
{\bkmkend AAAAAAADOL}
\par
{
{\f2 #include <ob.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b TypeList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Name} [32]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b TotalNumberOfObjects}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b TotalNumberOfHandles}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OBJECT_TYPE_INITIALIZER} {\b TypeInfo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 47} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADOM}
{\bkmkend AAAAAAADOM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Name\:_OBJECT_TYPE}
{\xe \v _OBJECT_TYPE\:Name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Name[32]}}
\par
{\bkmkstart AAAAAAADON}
{\bkmkend AAAAAAADON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b ob.h}.}\par
}
{\xe \v TotalNumberOfHandles\:_OBJECT_TYPE}
{\xe \v _OBJECT_TYPE\:TotalNumberOfHandles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t TotalNumberOfHandles}}
\par
{\bkmkstart AAAAAAADOO}
{\bkmkend AAAAAAADOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b ob.h}.}\par
}
{\xe \v TotalNumberOfObjects\:_OBJECT_TYPE}
{\xe \v _OBJECT_TYPE\:TotalNumberOfObjects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t TotalNumberOfObjects}}
\par
{\bkmkstart AAAAAAADOP}
{\bkmkend AAAAAAADOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b ob.h}.}\par
}
{\xe \v TypeInfo\:_OBJECT_TYPE}
{\xe \v _OBJECT_TYPE\:TypeInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OBJECT_TYPE_INITIALIZER} TypeInfo}}
\par
{\bkmkstart AAAAAAADOQ}
{\bkmkend AAAAAAADOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ob.h}.}\par
}
{\xe \v TypeList\:_OBJECT_TYPE}
{\xe \v _OBJECT_TYPE\:TypeList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} TypeList}}
\par
{\bkmkstart AAAAAAADOR}
{\bkmkend AAAAAAADOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ob.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_OBJECT_TYPE_INITIALIZER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _OBJECT_TYPE_INITIALIZER}
{\xe \v _OBJECT_TYPE_INITIALIZER}
{\bkmkstart AAAAAAADOS}
{\bkmkend AAAAAAADOS}
\par
{
{\f2 #include <ob.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POOL_TYPE} {\b PoolType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ValidAccessRights}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OB_DUMP_METHOD} {\b DumpProcedure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OB_DELETE_METHOD} {\b DeleteProcedure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b OB_CLOSE_METHOD} {\b CloseProcedure}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 38} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADOT}
{\bkmkend AAAAAAADOT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v CloseProcedure\:_OBJECT_TYPE_INITIALIZER}
{\xe \v _OBJECT_TYPE_INITIALIZER\:CloseProcedure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OB_CLOSE_METHOD} CloseProcedure}}
\par
{\bkmkstart AAAAAAADOU}
{\bkmkend AAAAAAADOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b ob.h}.}\par
}
{\xe \v DeleteProcedure\:_OBJECT_TYPE_INITIALIZER}
{\xe \v _OBJECT_TYPE_INITIALIZER\:DeleteProcedure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OB_DELETE_METHOD} DeleteProcedure}}
\par
{\bkmkstart AAAAAAADOV}
{\bkmkend AAAAAAADOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b ob.h}.}\par
}
{\xe \v DumpProcedure\:_OBJECT_TYPE_INITIALIZER}
{\xe \v _OBJECT_TYPE_INITIALIZER\:DumpProcedure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b OB_DUMP_METHOD} DumpProcedure}}
\par
{\bkmkstart AAAAAAADOW}
{\bkmkend AAAAAAADOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b ob.h}.}\par
}
{\xe \v PoolType\:_OBJECT_TYPE_INITIALIZER}
{\xe \v _OBJECT_TYPE_INITIALIZER\:PoolType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POOL_TYPE} PoolType}}
\par
{\bkmkstart AAAAAAADOX}
{\bkmkend AAAAAAADOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b ob.h}.}\par
}
{\xe \v ValidAccessRights\:_OBJECT_TYPE_INITIALIZER}
{\xe \v _OBJECT_TYPE_INITIALIZER\:ValidAccessRights}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ValidAccessRights}}
\par
{\bkmkstart AAAAAAADOY}
{\bkmkend AAAAAAADOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ob.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_PAGE_PARAMETERS Struct Reference\par \pard\plain 
{\tc\tcl2 \v _PAGE_PARAMETERS}
{\xe \v _PAGE_PARAMETERS}
{\bkmkstart AAAAAAADOZ}
{\bkmkend AAAAAAADOZ}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b addressToInvalidate}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 393} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADPA}
{\bkmkend AAAAAAADPA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v addressToInvalidate\:_PAGE_PARAMETERS}
{\xe \v _PAGE_PARAMETERS\:addressToInvalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t addressToInvalidate}}
\par
{\bkmkstart AAAAAAADPB}
{\bkmkend AAAAAAADPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 394} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_PFN_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v _PFN_ENTRY}
{\xe \v _PFN_ENTRY}
{\bkmkstart AAAAAAADPC}
{\bkmkend AAAAAAADPC}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b RefCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b State}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct {\b _DOUBLY_LINKED_LIST} {\b ListEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ struct {\b _MMVAD} * {\b Vad}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ {\b PMMPTE} {\b PteAddress}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} {\b Mapping}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b FileOffset}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b Descriptor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 428} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADPD}
{\bkmkend AAAAAAADPD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Descriptor\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:Descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  Descriptor}}
\par
{\bkmkstart AAAAAAADPE}
{\bkmkend AAAAAAADPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FileOffset\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:FileOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t FileOffset}}
\par
{\bkmkstart AAAAAAADPF}
{\bkmkend AAAAAAADPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 445} of file {\b mm.h}.}\par
}
{\xe \v Flags\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Flags}}
\par
{\bkmkstart AAAAAAADPG}
{\bkmkend AAAAAAADPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b mm.h}.}\par
}
{\xe \v ListEntry\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:ListEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DOUBLY_LINKED_LIST} ListEntry}}
\par
{\bkmkstart AAAAAAADPH}
{\bkmkend AAAAAAADPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 436} of file {\b mm.h}.}\par
}
{\xe \v Mapping\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:Mapping}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct  \{ ... \}  Mapping}}
\par
{\bkmkstart AAAAAAADPI}
{\bkmkend AAAAAAADPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PteAddress\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:PteAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} PteAddress}}
\par
{\bkmkstart AAAAAAADPJ}
{\bkmkend AAAAAAADPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 441} of file {\b mm.h}.}\par
}
{\xe \v RefCount\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:RefCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t RefCount}}
\par
{\bkmkstart AAAAAAADPK}
{\bkmkend AAAAAAADPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 429} of file {\b mm.h}.}\par
}
{\xe \v State\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:State}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t State}}
\par
{\bkmkstart AAAAAAADPL}
{\bkmkend AAAAAAADPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 430} of file {\b mm.h}.}\par
}
{\xe \v Vad\:_PFN_ENTRY}
{\xe \v _PFN_ENTRY\:Vad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _MMVAD}* Vad}}
\par
{\bkmkstart AAAAAAADPM}
{\bkmkend AAAAAAADPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 440} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_POOL_DESCRIPTOR Struct Reference\par \pard\plain 
{\tc\tcl2 \v _POOL_DESCRIPTOR}
{\xe \v _POOL_DESCRIPTOR}
{\bkmkstart AAAAAAADPN}
{\bkmkend AAAAAAADPN}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SINGLE_LINKED_LIST} {\b FreeListHead}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b BlockSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint64_t {\b FreeCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint64_t {\b TotalBlocks}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b PoolLock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 512} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADPO}
{\bkmkend AAAAAAADPO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v BlockSize\:_POOL_DESCRIPTOR}
{\xe \v _POOL_DESCRIPTOR\:BlockSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t BlockSize}}
\par
{\bkmkstart AAAAAAADPP}
{\bkmkend AAAAAAADPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 514} of file {\b mm.h}.}\par
}
{\xe \v FreeCount\:_POOL_DESCRIPTOR}
{\xe \v _POOL_DESCRIPTOR\:FreeCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint64_t FreeCount}}
\par
{\bkmkstart AAAAAAADPQ}
{\bkmkend AAAAAAADPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 515} of file {\b mm.h}.}\par
}
{\xe \v FreeListHead\:_POOL_DESCRIPTOR}
{\xe \v _POOL_DESCRIPTOR\:FreeListHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SINGLE_LINKED_LIST} FreeListHead}}
\par
{\bkmkstart AAAAAAADPR}
{\bkmkend AAAAAAADPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 513} of file {\b mm.h}.}\par
}
{\xe \v PoolLock\:_POOL_DESCRIPTOR}
{\xe \v _POOL_DESCRIPTOR\:PoolLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} PoolLock}}
\par
{\bkmkstart AAAAAAADPS}
{\bkmkend AAAAAAADPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 517} of file {\b mm.h}.}\par
}
{\xe \v TotalBlocks\:_POOL_DESCRIPTOR}
{\xe \v _POOL_DESCRIPTOR\:TotalBlocks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint64_t TotalBlocks}}
\par
{\bkmkstart AAAAAAADPT}
{\bkmkend AAAAAAADPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 516} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_POOL_HEADER Struct Reference\par \pard\plain 
{\tc\tcl2 \v _POOL_HEADER}
{\xe \v _POOL_HEADER}
{\bkmkstart AAAAAAADPU}
{\bkmkend AAAAAAADPU}
\par
{
{\f2 #include <mm.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PoolCanary}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ {\b SINGLE_LINKED_LIST} {\b FreeListEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ struct \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint16_t {\b BlockSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \~ uint16_t {\b PoolIndex}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ \} \par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\} {\b Metadata}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PoolTag}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 494} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADPV}
{\bkmkend AAAAAAADPV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v BlockSize\:_POOL_HEADER}
{\xe \v _POOL_HEADER\:BlockSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t BlockSize}}
\par
{\bkmkstart AAAAAAADPW}
{\bkmkend AAAAAAADPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 505} of file {\b mm.h}.}\par
}
{\xe \v FreeListEntry\:_POOL_HEADER}
{\xe \v _POOL_HEADER\:FreeListEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SINGLE_LINKED_LIST} FreeListEntry}}
\par
{\bkmkstart AAAAAAADPX}
{\bkmkend AAAAAAADPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 500} of file {\b mm.h}.}\par
}
{\xe \v Metadata\:_POOL_HEADER}
{\xe \v _POOL_HEADER\:Metadata}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \}  Metadata}}
\par
{\bkmkstart AAAAAAADPY}
{\bkmkend AAAAAAADPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PoolCanary\:_POOL_HEADER}
{\xe \v _POOL_HEADER\:PoolCanary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PoolCanary}}
\par
{\bkmkstart AAAAAAADPZ}
{\bkmkend AAAAAAADPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 496} of file {\b mm.h}.}\par
}
{\xe \v PoolIndex\:_POOL_HEADER}
{\xe \v _POOL_HEADER\:PoolIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t PoolIndex}}
\par
{\bkmkstart AAAAAAADQA}
{\bkmkend AAAAAAADQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 506} of file {\b mm.h}.}\par
}
{\xe \v PoolTag\:_POOL_HEADER}
{\xe \v _POOL_HEADER\:PoolTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PoolTag}}
\par
{\bkmkstart AAAAAAADQB}
{\bkmkend AAAAAAADQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 509} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mm.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_PROCESSOR Struct Reference\par \pard\plain 
{\tc\tcl2 \v _PROCESSOR}
{\xe \v _PROCESSOR}
{\bkmkstart AAAAAAADQC}
{\bkmkend AAAAAAADQC}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _PROCESSOR} * {\b self}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _IRQL} {\b currentIrql}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b schedulerEnabled}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ITHREAD} * {\b currentThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _Queue} {\b readyQueue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b ID}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapic_ID}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b VirtStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b tss}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b Rsp0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b IstPFStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b IstDFStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint64_t {\b flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b schedulePending}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t * {\b gdt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DPC} * {\b CurrentDeferredRoutine}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ETHREAD} * {\b idleThread}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint64_t {\b IpiSeq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _CPU_ACTION} {\b IpiAction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile {\b IPI_PARAMS} {\b IpiParameter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t * {\b LapicAddressVirt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b LapicAddressPhys}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DPC} {\b TimerExpirationDPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DPC} {\b ReaperDPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DPC_DATA} {\b DpcData}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b DpcRoutineActive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b TimerRequest}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b TimerHand}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b ApcRoutineActive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b MaximumDpcQueueDepth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b MinimumDpcRate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b DpcRequestRate}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b DpcInterruptRequested}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile bool {\b ApcInterruptRequested}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b SchedulerLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POOL_DESCRIPTOR} {\b LookasidePools} [{\b MAX_POOL_DESCRIPTORS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DEBUG_ENTRY} {\b DebugEntry} [4]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b IstTimerStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b IstIpiStackTop}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PITHREAD} {\b ZombieThread}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 274} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADQD}
{\bkmkend AAAAAAADQD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ApcInterruptRequested\:_PROCESSOR}
{\xe \v _PROCESSOR\:ApcInterruptRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool ApcInterruptRequested}}
\par
{\bkmkstart AAAAAAADQE}
{\bkmkend AAAAAAADQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 319} of file {\b me.h}.}\par
}
{\xe \v ApcRoutineActive\:_PROCESSOR}
{\xe \v _PROCESSOR\:ApcRoutineActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool ApcRoutineActive}}
\par
{\bkmkstart AAAAAAADQF}
{\bkmkend AAAAAAADQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 310} of file {\b me.h}.}\par
}
{\xe \v CurrentDeferredRoutine\:_PROCESSOR}
{\xe \v _PROCESSOR\:CurrentDeferredRoutine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DPC}* CurrentDeferredRoutine}}
\par
{\bkmkstart AAAAAAADQG}
{\bkmkend AAAAAAADQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 290} of file {\b me.h}.}\par
}
{\xe \v currentIrql\:_PROCESSOR}
{\xe \v _PROCESSOR\:currentIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _IRQL} currentIrql}}
\par
{\bkmkstart AAAAAAADQH}
{\bkmkend AAAAAAADQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 276} of file {\b me.h}.}\par
}
{\xe \v currentThread\:_PROCESSOR}
{\xe \v _PROCESSOR\:currentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ITHREAD}* currentThread}}
\par
{\bkmkstart AAAAAAADQI}
{\bkmkend AAAAAAADQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 278} of file {\b me.h}.}\par
}
{\xe \v DebugEntry\:_PROCESSOR}
{\xe \v _PROCESSOR\:DebugEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DEBUG_ENTRY} DebugEntry[4]}}
\par
{\bkmkstart AAAAAAADQJ}
{\bkmkend AAAAAAADQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 327} of file {\b me.h}.}\par
}
{\xe \v DpcData\:_PROCESSOR}
{\xe \v _PROCESSOR\:DpcData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DPC_DATA} DpcData}}
\par
{\bkmkstart AAAAAAADQK}
{\bkmkend AAAAAAADQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b me.h}.}\par
}
{\xe \v DpcInterruptRequested\:_PROCESSOR}
{\xe \v _PROCESSOR\:DpcInterruptRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool DpcInterruptRequested}}
\par
{\bkmkstart AAAAAAADQL}
{\bkmkend AAAAAAADQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 318} of file {\b me.h}.}\par
}
{\xe \v DpcRequestRate\:_PROCESSOR}
{\xe \v _PROCESSOR\:DpcRequestRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t DpcRequestRate}}
\par
{\bkmkstart AAAAAAADQM}
{\bkmkend AAAAAAADQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 315} of file {\b me.h}.}\par
}
{\xe \v DpcRoutineActive\:_PROCESSOR}
{\xe \v _PROCESSOR\:DpcRoutineActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool DpcRoutineActive}}
\par
{\bkmkstart AAAAAAADQN}
{\bkmkend AAAAAAADQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 305} of file {\b me.h}.}\par
}
{\xe \v flags\:_PROCESSOR}
{\xe \v _PROCESSOR\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint64_t flags}}
\par
{\bkmkstart AAAAAAADQO}
{\bkmkend AAAAAAADQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 287} of file {\b me.h}.}\par
}
{\xe \v gdt\:_PROCESSOR}
{\xe \v _PROCESSOR\:gdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t* gdt}}
\par
{\bkmkstart AAAAAAADQP}
{\bkmkend AAAAAAADQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 289} of file {\b me.h}.}\par
}
{\xe \v ID\:_PROCESSOR}
{\xe \v _PROCESSOR\:ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t ID}}
\par
{\bkmkstart AAAAAAADQQ}
{\bkmkend AAAAAAADQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 280} of file {\b me.h}.}\par
}
{\xe \v idleThread\:_PROCESSOR}
{\xe \v _PROCESSOR\:idleThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ETHREAD}* idleThread}}
\par
{\bkmkstart AAAAAAADQR}
{\bkmkend AAAAAAADQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 291} of file {\b me.h}.}\par
}
{\xe \v IpiAction\:_PROCESSOR}
{\xe \v _PROCESSOR\:IpiAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _CPU_ACTION} IpiAction}}
\par
{\bkmkstart AAAAAAADQS}
{\bkmkend AAAAAAADQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 293} of file {\b me.h}.}\par
}
{\xe \v IpiParameter\:_PROCESSOR}
{\xe \v _PROCESSOR\:IpiParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile {\b IPI_PARAMS} IpiParameter}}
\par
{\bkmkstart AAAAAAADQT}
{\bkmkend AAAAAAADQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 294} of file {\b me.h}.}\par
}
{\xe \v IpiSeq\:_PROCESSOR}
{\xe \v _PROCESSOR\:IpiSeq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint64_t IpiSeq}}
\par
{\bkmkstart AAAAAAADQU}
{\bkmkend AAAAAAADQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b me.h}.}\par
}
{\xe \v IstDFStackTop\:_PROCESSOR}
{\xe \v _PROCESSOR\:IstDFStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* IstDFStackTop}}
\par
{\bkmkstart AAAAAAADQV}
{\bkmkend AAAAAAADQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 286} of file {\b me.h}.}\par
}
{\xe \v IstIpiStackTop\:_PROCESSOR}
{\xe \v _PROCESSOR\:IstIpiStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* IstIpiStackTop}}
\par
{\bkmkstart AAAAAAADQW}
{\bkmkend AAAAAAADQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 329} of file {\b me.h}.}\par
}
{\xe \v IstPFStackTop\:_PROCESSOR}
{\xe \v _PROCESSOR\:IstPFStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* IstPFStackTop}}
\par
{\bkmkstart AAAAAAADQX}
{\bkmkend AAAAAAADQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 285} of file {\b me.h}.}\par
}
{\xe \v IstTimerStackTop\:_PROCESSOR}
{\xe \v _PROCESSOR\:IstTimerStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* IstTimerStackTop}}
\par
{\bkmkstart AAAAAAADQY}
{\bkmkend AAAAAAADQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 328} of file {\b me.h}.}\par
}
{\xe \v lapic_ID\:_PROCESSOR}
{\xe \v _PROCESSOR\:lapic_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapic_ID}}
\par
{\bkmkstart AAAAAAADQZ}
{\bkmkend AAAAAAADQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 281} of file {\b me.h}.}\par
}
{\xe \v LapicAddressPhys\:_PROCESSOR}
{\xe \v _PROCESSOR\:LapicAddressPhys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t LapicAddressPhys}}
\par
{\bkmkstart AAAAAAADRA}
{\bkmkend AAAAAAADRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 296} of file {\b me.h}.}\par
}
{\xe \v LapicAddressVirt\:_PROCESSOR}
{\xe \v _PROCESSOR\:LapicAddressVirt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t* LapicAddressVirt}}
\par
{\bkmkstart AAAAAAADRB}
{\bkmkend AAAAAAADRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 295} of file {\b me.h}.}\par
}
{\xe \v LookasidePools\:_PROCESSOR}
{\xe \v _PROCESSOR\:LookasidePools}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POOL_DESCRIPTOR} LookasidePools[{\b MAX_POOL_DESCRIPTORS}]}}
\par
{\bkmkstart AAAAAAADRC}
{\bkmkend AAAAAAADRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 325} of file {\b me.h}.}\par
}
{\xe \v MaximumDpcQueueDepth\:_PROCESSOR}
{\xe \v _PROCESSOR\:MaximumDpcQueueDepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t MaximumDpcQueueDepth}}
\par
{\bkmkstart AAAAAAADRD}
{\bkmkend AAAAAAADRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 313} of file {\b me.h}.}\par
}
{\xe \v MinimumDpcRate\:_PROCESSOR}
{\xe \v _PROCESSOR\:MinimumDpcRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t MinimumDpcRate}}
\par
{\bkmkstart AAAAAAADRE}
{\bkmkend AAAAAAADRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 314} of file {\b me.h}.}\par
}
{\xe \v readyQueue\:_PROCESSOR}
{\xe \v _PROCESSOR\:readyQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _Queue} readyQueue}}
\par
{\bkmkstart AAAAAAADRF}
{\bkmkend AAAAAAADRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 279} of file {\b me.h}.}\par
}
{\xe \v ReaperDPC\:_PROCESSOR}
{\xe \v _PROCESSOR\:ReaperDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DPC} ReaperDPC}}
\par
{\bkmkstart AAAAAAADRG}
{\bkmkend AAAAAAADRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 300} of file {\b me.h}.}\par
}
{\xe \v Rsp0\:_PROCESSOR}
{\xe \v _PROCESSOR\:Rsp0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* Rsp0}}
\par
{\bkmkstart AAAAAAADRH}
{\bkmkend AAAAAAADRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 284} of file {\b me.h}.}\par
}
{\xe \v schedulePending\:_PROCESSOR}
{\xe \v _PROCESSOR\:schedulePending}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool schedulePending}}
\par
{\bkmkstart AAAAAAADRI}
{\bkmkend AAAAAAADRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 288} of file {\b me.h}.}\par
}
{\xe \v schedulerEnabled\:_PROCESSOR}
{\xe \v _PROCESSOR\:schedulerEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile bool schedulerEnabled}}
\par
{\bkmkstart AAAAAAADRJ}
{\bkmkend AAAAAAADRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 277} of file {\b me.h}.}\par
}
{\xe \v SchedulerLock\:_PROCESSOR}
{\xe \v _PROCESSOR\:SchedulerLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} SchedulerLock}}
\par
{\bkmkstart AAAAAAADRK}
{\bkmkend AAAAAAADRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 322} of file {\b me.h}.}\par
}
{\xe \v self\:_PROCESSOR}
{\xe \v _PROCESSOR\:self}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _PROCESSOR}* self}}
\par
{\bkmkstart AAAAAAADRL}
{\bkmkend AAAAAAADRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b me.h}.}\par
}
{\xe \v TimerExpirationDPC\:_PROCESSOR}
{\xe \v _PROCESSOR\:TimerExpirationDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _DPC} TimerExpirationDPC}}
\par
{\bkmkstart AAAAAAADRM}
{\bkmkend AAAAAAADRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 299} of file {\b me.h}.}\par
}
{\xe \v TimerHand\:_PROCESSOR}
{\xe \v _PROCESSOR\:TimerHand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t TimerHand}}
\par
{\bkmkstart AAAAAAADRN}
{\bkmkend AAAAAAADRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b me.h}.}\par
}
{\xe \v TimerRequest\:_PROCESSOR}
{\xe \v _PROCESSOR\:TimerRequest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t TimerRequest}}
\par
{\bkmkstart AAAAAAADRO}
{\bkmkend AAAAAAADRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 306} of file {\b me.h}.}\par
}
{\xe \v tss\:_PROCESSOR}
{\xe \v _PROCESSOR\:tss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* tss}}
\par
{\bkmkstart AAAAAAADRP}
{\bkmkend AAAAAAADRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 283} of file {\b me.h}.}\par
}
{\xe \v VirtStackTop\:_PROCESSOR}
{\xe \v _PROCESSOR\:VirtStackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* VirtStackTop}}
\par
{\bkmkstart AAAAAAADRQ}
{\bkmkend AAAAAAADRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 282} of file {\b me.h}.}\par
}
{\xe \v ZombieThread\:_PROCESSOR}
{\xe \v _PROCESSOR\:ZombieThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PITHREAD} ZombieThread}}
\par
{\bkmkstart AAAAAAADRR}
{\bkmkend AAAAAAADRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 332} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_Queue Struct Reference\par \pard\plain 
{\tc\tcl2 \v _Queue}
{\xe \v _Queue}
{\bkmkstart AAAAAAADRS}
{\bkmkend AAAAAAADRS}
\par
{
{\f2 #include <ms.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b head}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b tail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SPINLOCK} {\b lock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 51} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADRT}
{\bkmkend AAAAAAADRT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v head\:_Queue}
{\xe \v _Queue\:head}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} head}}
\par
{\bkmkstart AAAAAAADRU}
{\bkmkend AAAAAAADRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b ms.h}.}\par
}
{\xe \v lock\:_Queue}
{\xe \v _Queue\:lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _SPINLOCK} lock}}
\par
{\bkmkstart AAAAAAADRV}
{\bkmkend AAAAAAADRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b ms.h}.}\par
}
{\xe \v tail\:_Queue}
{\xe \v _Queue\:tail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} tail}}
\par
{\bkmkstart AAAAAAADRW}
{\bkmkend AAAAAAADRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ms.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_RSDP_Descriptor Struct Reference\par \pard\plain 
{\tc\tcl2 \v _RSDP_Descriptor}
{\xe \v _RSDP_Descriptor}
{\bkmkstart AAAAAAADRX}
{\bkmkend AAAAAAADRX}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Signature} [8]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Checksum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OemId} [6]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Revision}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b RsdtAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b XsdtAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ExtendedChecksum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved} [3]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 193} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADRY}
{\bkmkend AAAAAAADRY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Checksum\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:Checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Checksum}}
\par
{\bkmkstart AAAAAAADRZ}
{\bkmkend AAAAAAADRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b mh.h}.}\par
}
{\xe \v ExtendedChecksum\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:ExtendedChecksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ExtendedChecksum}}
\par
{\bkmkstart AAAAAAADSA}
{\bkmkend AAAAAAADSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 202} of file {\b mh.h}.}\par
}
{\xe \v Length\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Length}}
\par
{\bkmkstart AAAAAAADSB}
{\bkmkend AAAAAAADSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b mh.h}.}\par
}
{\xe \v OemId\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:OemId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OemId[6]}}
\par
{\bkmkstart AAAAAAADSC}
{\bkmkend AAAAAAADSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b mh.h}.}\par
}
{\xe \v Reserved\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved[3]}}
\par
{\bkmkstart AAAAAAADSD}
{\bkmkend AAAAAAADSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 203} of file {\b mh.h}.}\par
}
{\xe \v Revision\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:Revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Revision}}
\par
{\bkmkstart AAAAAAADSE}
{\bkmkend AAAAAAADSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b mh.h}.}\par
}
{\xe \v RsdtAddress\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:RsdtAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t RsdtAddress}}
\par
{\bkmkstart AAAAAAADSF}
{\bkmkend AAAAAAADSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b mh.h}.}\par
}
{\xe \v Signature\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:Signature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Signature[8]}}
\par
{\bkmkstart AAAAAAADSG}
{\bkmkend AAAAAAADSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b mh.h}.}\par
}
{\xe \v XsdtAddress\:_RSDP_Descriptor}
{\xe \v _RSDP_Descriptor\:XsdtAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t XsdtAddress}}
\par
{\bkmkstart AAAAAAADSH}
{\bkmkend AAAAAAADSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_RUNDOWN_REF Struct Reference\par \pard\plain 
{\tc\tcl2 \v _RUNDOWN_REF}
{\xe \v _RUNDOWN_REF}
{\bkmkstart AAAAAAADSI}
{\bkmkend AAAAAAADSI}
\par
{
{\f2 #include <ms.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Count}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rundown Reference Protection.\par
Used to protect current acquisition of destruction, for example, acquiring a rundown protection on a PROCESS or a Thread to assert they will not be destroyed during modification. \par
}{
Definition at line {\b 47} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADSJ}
{\bkmkend AAAAAAADSJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Count\:_RUNDOWN_REF}
{\xe \v _RUNDOWN_REF\:Count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Count}}
\par
{\bkmkstart AAAAAAADSK}
{\bkmkend AAAAAAADSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ms.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_SINGLE_LINKED_LIST Struct Reference\par \pard\plain 
{\tc\tcl2 \v _SINGLE_LINKED_LIST}
{\xe \v _SINGLE_LINKED_LIST}
{\bkmkstart AAAAAAADSL}
{\bkmkend AAAAAAADSL}
\par
{
{\f2 #include <core.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SINGLE_LINKED_LIST} * {\b Next}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 23} of file {\b core.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADSM}
{\bkmkend AAAAAAADSM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Next\:_SINGLE_LINKED_LIST}
{\xe \v _SINGLE_LINKED_LIST\:Next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _SINGLE_LINKED_LIST}* Next}}
\par
{\bkmkstart AAAAAAADSN}
{\bkmkend AAAAAAADSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b core.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b core.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_SMP_BOOTINFO Struct Reference\par \pard\plain 
{\tc\tcl2 \v _SMP_BOOTINFO}
{\xe \v _SMP_BOOTINFO}
{\bkmkstart AAAAAAADSO}
{\bkmkend AAAAAAADSO}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b magic}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b kernel_pml4_phys}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b ap_entry_virt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cpu_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapic_base}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 349} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADSP}
{\bkmkend AAAAAAADSP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v ap_entry_virt\:_SMP_BOOTINFO}
{\xe \v _SMP_BOOTINFO\:ap_entry_virt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t ap_entry_virt}}
\par
{\bkmkstart AAAAAAADSQ}
{\bkmkend AAAAAAADSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 352} of file {\b mh.h}.}\par
}
{\xe \v cpu_count\:_SMP_BOOTINFO}
{\xe \v _SMP_BOOTINFO\:cpu_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cpu_count}}
\par
{\bkmkstart AAAAAAADSR}
{\bkmkend AAAAAAADSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b mh.h}.}\par
}
{\xe \v kernel_pml4_phys\:_SMP_BOOTINFO}
{\xe \v _SMP_BOOTINFO\:kernel_pml4_phys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t kernel_pml4_phys}}
\par
{\bkmkstart AAAAAAADSS}
{\bkmkend AAAAAAADSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 351} of file {\b mh.h}.}\par
}
{\xe \v lapic_base\:_SMP_BOOTINFO}
{\xe \v _SMP_BOOTINFO\:lapic_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapic_base}}
\par
{\bkmkstart AAAAAAADST}
{\bkmkend AAAAAAADST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b mh.h}.}\par
}
{\xe \v magic\:_SMP_BOOTINFO}
{\xe \v _SMP_BOOTINFO\:magic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t magic}}
\par
{\bkmkstart AAAAAAADSU}
{\bkmkend AAAAAAADSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_SPINLOCK Struct Reference\par \pard\plain 
{\tc\tcl2 \v _SPINLOCK}
{\xe \v _SPINLOCK}
{\bkmkstart AAAAAAADSV}
{\bkmkend AAAAAAADSV}
\par
{
{\f2 #include <ms.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile uint32_t {\b locked}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SPINLOCK} - a tiny embedded spinlock representation.\par
Implementation note: keep this embedded (not a pointer) inside structures. \par
}{
Definition at line {\b 36} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADSW}
{\bkmkend AAAAAAADSW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v locked\:_SPINLOCK}
{\xe \v _SPINLOCK\:locked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile uint32_t locked}}
\par
{\bkmkstart AAAAAAADSX}
{\bkmkend AAAAAAADSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ms.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_STACK_REAPER_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v _STACK_REAPER_ENTRY}
{\xe \v _STACK_REAPER_ENTRY}
{\bkmkstart AAAAAAADSY}
{\bkmkend AAAAAAADSY}
\par
{
{\f2 #include <ps.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _STACK_REAPER_ENTRY} * {\b Next}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b StackBase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsLarge}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 134} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADSZ}
{\bkmkend AAAAAAADSZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v IsLarge\:_STACK_REAPER_ENTRY}
{\xe \v _STACK_REAPER_ENTRY\:IsLarge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool IsLarge}}
\par
{\bkmkstart AAAAAAADTA}
{\bkmkend AAAAAAADTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b ps.h}.}\par
}
{\xe \v Next\:_STACK_REAPER_ENTRY}
{\xe \v _STACK_REAPER_ENTRY\:Next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _STACK_REAPER_ENTRY}* Next}}
\par
{\bkmkstart AAAAAAADTB}
{\bkmkend AAAAAAADTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b ps.h}.}\par
}
{\xe \v StackBase\:_STACK_REAPER_ENTRY}
{\xe \v _STACK_REAPER_ENTRY\:StackBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* StackBase}}
\par
{\bkmkstart AAAAAAADTC}
{\bkmkend AAAAAAADTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b ps.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_TRAP_FRAME Struct Reference\par \pard\plain 
{\tc\tcl2 \v _TRAP_FRAME}
{\xe \v _TRAP_FRAME}
{\bkmkstart AAAAAAADTD}
{\bkmkend AAAAAAADTD}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r15}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r14}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r13}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r12}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r11}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r10}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r9}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b r8}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rbp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rdi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rsi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rdx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rcx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rbx}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rax}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b vector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b error_code}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rip}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b cs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rflags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b rsp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b ss}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 152} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADTE}
{\bkmkend AAAAAAADTE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v cs\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:cs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t cs}}
\par
{\bkmkstart AAAAAAADTF}
{\bkmkend AAAAAAADTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b me.h}.}\par
}
{\xe \v error_code\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:error_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t error_code}}
\par
{\bkmkstart AAAAAAADTG}
{\bkmkend AAAAAAADTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b me.h}.}\par
}
{\xe \v r10\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r10}}
\par
{\bkmkstart AAAAAAADTH}
{\bkmkend AAAAAAADTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r11\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r11}}
\par
{\bkmkstart AAAAAAADTI}
{\bkmkend AAAAAAADTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r12\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r12}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r12}}
\par
{\bkmkstart AAAAAAADTJ}
{\bkmkend AAAAAAADTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r13\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r13}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r13}}
\par
{\bkmkstart AAAAAAADTK}
{\bkmkend AAAAAAADTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r14\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r14}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r14}}
\par
{\bkmkstart AAAAAAADTL}
{\bkmkend AAAAAAADTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r15\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r15}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r15}}
\par
{\bkmkstart AAAAAAADTM}
{\bkmkend AAAAAAADTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r8\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r8}}
\par
{\bkmkstart AAAAAAADTN}
{\bkmkend AAAAAAADTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v r9\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:r9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t r9}}
\par
{\bkmkstart AAAAAAADTO}
{\bkmkend AAAAAAADTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b me.h}.}\par
}
{\xe \v rax\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rax}}
\par
{\bkmkstart AAAAAAADTP}
{\bkmkend AAAAAAADTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rbp\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rbp}}
\par
{\bkmkstart AAAAAAADTQ}
{\bkmkend AAAAAAADTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rbx\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rbx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rbx}}
\par
{\bkmkstart AAAAAAADTR}
{\bkmkend AAAAAAADTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rcx\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rcx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rcx}}
\par
{\bkmkstart AAAAAAADTS}
{\bkmkend AAAAAAADTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rdi\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rdi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rdi}}
\par
{\bkmkstart AAAAAAADTT}
{\bkmkend AAAAAAADTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rdx\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rdx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rdx}}
\par
{\bkmkstart AAAAAAADTU}
{\bkmkend AAAAAAADTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rflags\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rflags}}
\par
{\bkmkstart AAAAAAADTV}
{\bkmkend AAAAAAADTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b me.h}.}\par
}
{\xe \v rip\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rip}}
\par
{\bkmkstart AAAAAAADTW}
{\bkmkend AAAAAAADTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b me.h}.}\par
}
{\xe \v rsi\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rsi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rsi}}
\par
{\bkmkstart AAAAAAADTX}
{\bkmkend AAAAAAADTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b me.h}.}\par
}
{\xe \v rsp\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:rsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t rsp}}
\par
{\bkmkstart AAAAAAADTY}
{\bkmkend AAAAAAADTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b me.h}.}\par
}
{\xe \v ss\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:ss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t ss}}
\par
{\bkmkstart AAAAAAADTZ}
{\bkmkend AAAAAAADTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b me.h}.}\par
}
{\xe \v vector\:_TRAP_FRAME}
{\xe \v _TRAP_FRAME\:vector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t vector}}
\par
{\bkmkstart AAAAAAADUA}
{\bkmkend AAAAAAADUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_WAIT_BLOCK Struct Reference\par \pard\plain 
{\tc\tcl2 \v _WAIT_BLOCK}
{\xe \v _WAIT_BLOCK}
{\bkmkstart AAAAAAADUB}
{\bkmkend AAAAAAADUB}
\par
{
{\f2 #include <me.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SINGLE_LINKED_LIST} {\b WaitBlockList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b Object}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _WAIT_REASON} {\b WaitReason}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 146} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADUC}
{\bkmkend AAAAAAADUC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Object\:_WAIT_BLOCK}
{\xe \v _WAIT_BLOCK\:Object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* Object}}
\par
{\bkmkstart AAAAAAADUD}
{\bkmkend AAAAAAADUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b me.h}.}\par
}
{\xe \v WaitBlockList\:_WAIT_BLOCK}
{\xe \v _WAIT_BLOCK\:WaitBlockList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _SINGLE_LINKED_LIST} WaitBlockList}}
\par
{\bkmkstart AAAAAAADUE}
{\bkmkend AAAAAAADUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b me.h}.}\par
}
{\xe \v WaitReason\:_WAIT_BLOCK}
{\xe \v _WAIT_BLOCK\:WaitReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _WAIT_REASON} WaitReason}}
\par
{\bkmkstart AAAAAAADUF}
{\bkmkend AAAAAAADUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b me.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_XSDT Struct Reference\par \pard\plain 
{\tc\tcl2 \v _XSDT}
{\xe \v _XSDT}
{\bkmkstart AAAAAAADUG}
{\bkmkend AAAAAAADUG}
\par
{
{\f2 #include <mh.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ACPI_SDT_HEADER} {\b h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Entries} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 218} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADUH}
{\bkmkend AAAAAAADUH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v Entries\:_XSDT}
{\xe \v _XSDT\:Entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Entries[]}}
\par
{\bkmkstart AAAAAAADUI}
{\bkmkend AAAAAAADUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b mh.h}.}\par
}
{\xe \v h\:_XSDT}
{\xe \v _XSDT\:h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ACPI_SDT_HEADER} h}}
\par
{\bkmkstart AAAAAAADUJ}
{\bkmkend AAAAAAADUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/{\b mh.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FAT32_LFN_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY}
{\bkmkstart AAAAAAADUK}
{\bkmkend AAAAAAADUK}
\par
{
{\f2 #include <fat32.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b LDIR_Ord}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LDIR_Name1} [5]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b LDIR_Attr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b LDIR_Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b LDIR_Chksum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LDIR_Name2} [6]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LDIR_FstClusLO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b LDIR_Name3} [2]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 83} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADUL}
{\bkmkend AAAAAAADUL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v LDIR_Attr\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Attr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t LDIR_Attr}}
\par
{\bkmkstart AAAAAAADUM}
{\bkmkend AAAAAAADUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_Chksum\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Chksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t LDIR_Chksum}}
\par
{\bkmkstart AAAAAAADUN}
{\bkmkend AAAAAAADUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_FstClusLO\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_FstClusLO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LDIR_FstClusLO}}
\par
{\bkmkstart AAAAAAADUO}
{\bkmkend AAAAAAADUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_Name1\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Name1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LDIR_Name1[5]}}
\par
{\bkmkstart AAAAAAADUP}
{\bkmkend AAAAAAADUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_Name2\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Name2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LDIR_Name2[6]}}
\par
{\bkmkstart AAAAAAADUQ}
{\bkmkend AAAAAAADUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_Name3\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Name3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t LDIR_Name3[2]}}
\par
{\bkmkstart AAAAAAADUR}
{\bkmkend AAAAAAADUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_Ord\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Ord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t LDIR_Ord}}
\par
{\bkmkstart AAAAAAADUS}
{\bkmkend AAAAAAADUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b fat32.h}.}\par
}
{\xe \v LDIR_Type\:FAT32_LFN_ENTRY}
{\xe \v FAT32_LFN_ENTRY\:LDIR_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t LDIR_Type}}
\par
{\bkmkstart AAAAAAADUT}
{\bkmkend AAAAAAADUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FS_DRIVER Struct Reference\par \pard\plain 
{\tc\tcl2 \v FS_DRIVER}
{\xe \v FS_DRIVER}
{\bkmkstart AAAAAAADUU}
{\bkmkend AAAAAAADUU}
\par
{
{\f2 #include <vfs.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b init} )(uint8_t device_id)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b read} )(const char *filename, uint32_t *file_size_out, void **buffer_out)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b write} )(const char *path, const void *data, uint32_t size, uint32_t mode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b delete} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b mkdir} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b rmdir} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool(* {\b is_dir_empty} )(const char *path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS}(* {\b listdir} )(const char *path, char *listings, size_t max_len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b listrootdir} )(void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 18} of file {\b vfs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADUV}
{\bkmkend AAAAAAADUV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v delete\:FS_DRIVER}
{\xe \v FS_DRIVER\:delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* delete) (const char *path)}}
\par
{\bkmkstart AAAAAAADUW}
{\bkmkend AAAAAAADUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b vfs.h}.}\par
}
{\xe \v init\:FS_DRIVER}
{\xe \v FS_DRIVER\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* init) (uint8_t device_id)}}
\par
{\bkmkstart AAAAAAADUX}
{\bkmkend AAAAAAADUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b vfs.h}.}\par
}
{\xe \v is_dir_empty\:FS_DRIVER}
{\xe \v FS_DRIVER\:is_dir_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool(* is_dir_empty) (const char *path)}}
\par
{\bkmkstart AAAAAAADUY}
{\bkmkend AAAAAAADUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b vfs.h}.}\par
}
{\xe \v listdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:listdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* listdir) (const char *path, char *listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAADUZ}
{\bkmkend AAAAAAADUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b vfs.h}.}\par
}
{\xe \v listrootdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:listrootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* listrootdir) (void)}}
\par
{\bkmkstart AAAAAAADVA}
{\bkmkend AAAAAAADVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b vfs.h}.}\par
}
{\xe \v mkdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:mkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* mkdir) (const char *path)}}
\par
{\bkmkstart AAAAAAADVB}
{\bkmkend AAAAAAADVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b vfs.h}.}\par
}
{\xe \v read\:FS_DRIVER}
{\xe \v FS_DRIVER\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* read) (const char *filename, uint32_t *file_size_out, void **buffer_out)}}
\par
{\bkmkstart AAAAAAADVC}
{\bkmkend AAAAAAADVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b vfs.h}.}\par
}
{\xe \v rmdir\:FS_DRIVER}
{\xe \v FS_DRIVER\:rmdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* rmdir) (const char *path)}}
\par
{\bkmkstart AAAAAAADVD}
{\bkmkend AAAAAAADVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b vfs.h}.}\par
}
{\xe \v write\:FS_DRIVER}
{\xe \v FS_DRIVER\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS}(* write) (const char *path, const void *data, uint32_t size, uint32_t mode)}}
\par
{\bkmkstart AAAAAAADVE}
{\bkmkend AAAAAAADVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b vfs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LFN_ENTRY_BUFFER Struct Reference\par \pard\plain 
{\tc\tcl2 \v LFN_ENTRY_BUFFER}
{\xe \v LFN_ENTRY_BUFFER}
{\bkmkstart AAAAAAADVF}
{\bkmkend AAAAAAADVF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b name_chars} [13]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 42} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADVG}
{\bkmkend AAAAAAADVG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v name_chars\:LFN_ENTRY_BUFFER}
{\xe \v LFN_ENTRY_BUFFER\:name_chars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t name_chars[13]}}
\par
{\bkmkstart AAAAAAADVH}
{\bkmkend AAAAAAADVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/{\b fat32.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MOUNTED_FS Struct Reference\par \pard\plain 
{\tc\tcl2 \v MOUNTED_FS}
{\xe \v MOUNTED_FS}
{\bkmkstart AAAAAAADVI}
{\bkmkend AAAAAAADVI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FS_DRIVER} * {\b driver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b device_id}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b mount_point}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADVJ}
{\bkmkend AAAAAAADVJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v device_id\:MOUNTED_FS}
{\xe \v MOUNTED_FS\:device_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t device_id}}
\par
{\bkmkstart AAAAAAADVK}
{\bkmkend AAAAAAADVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b vfs.c}.}\par
}
{\xe \v driver\:MOUNTED_FS}
{\xe \v MOUNTED_FS\:driver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FS_DRIVER}* driver}}
\par
{\bkmkstart AAAAAAADVL}
{\bkmkend AAAAAAADVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b vfs.c}.}\par
}
{\xe \v mount_point\:MOUNTED_FS}
{\xe \v MOUNTED_FS\:mount_point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* mount_point}}
\par
{\bkmkstart AAAAAAADVM}
{\bkmkend AAAAAAADVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/{\b vfs.c}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TIME_ENTRY Struct Reference\par \pard\plain 
{\tc\tcl2 \v TIME_ENTRY}
{\xe \v TIME_ENTRY}
{\bkmkstart AAAAAAADVN}
{\bkmkend AAAAAAADVN}
\par
{
{\f2 #include <time.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b second}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b minute}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b hour}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b day}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b month}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b year}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 18} of file {\b time.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAADVO}
{\bkmkend AAAAAAADVO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v day\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t day}}
\par
{\bkmkstart AAAAAAADVP}
{\bkmkend AAAAAAADVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b time.h}.}\par
}
{\xe \v hour\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t hour}}
\par
{\bkmkstart AAAAAAADVQ}
{\bkmkend AAAAAAADVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b time.h}.}\par
}
{\xe \v minute\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t minute}}
\par
{\bkmkstart AAAAAAADVR}
{\bkmkend AAAAAAADVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b time.h}.}\par
}
{\xe \v month\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t month}}
\par
{\bkmkstart AAAAAAADVS}
{\bkmkend AAAAAAADVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b time.h}.}\par
}
{\xe \v second\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t second}}
\par
{\bkmkstart AAAAAAADVT}
{\bkmkend AAAAAAADVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b time.h}.}\par
}
{\xe \v year\:TIME_ENTRY}
{\xe \v TIME_ENTRY\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t year}}
\par
{\bkmkstart AAAAAAADVU}
{\bkmkend AAAAAAADVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b time.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/{\b time.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b assert}(...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v assert\:assert.h}
{\xe \v assert.h\:assert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define assert( ...)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 do} \{ \} {\cf19 while}(0)\par
}
{
Definition at line {\b 57} of file {\b assert.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
assert.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/assert.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Runtime Assertion Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_ASSERT_H}\par
00008 {\cf21 #define X86_ASSERT_H}\par
00009 \par
00010 {\cf21 #ifdef DEBUG}\par
00011 {\cf21 #include <stddef.h>}\par
00012 {\cf21 #include <stdbool.h>}\par
00013 {\cf21 #include <stdint.h>}\par
00014 {\cf21 #include "includes/me.h"}\par
00015 {\cf21 #include "includes/mg.h"}\par
00016 \par
00017 __attribute__((noreturn))\par
00018 {\cf17 static} {\cf18 void} assert_fail({\cf17 const} {\cf18 char}* expr, {\cf17 const} {\cf18 char}* reason, {\cf17 const} {\cf18 char}* file, {\cf17 const} {\cf18 char}* func, {\cf18 int} line) \{\par
00019     {\cf20 // Getting here means a runtime assertion has failed (assert())}\par
00020     (void)(func);\par
00021 \par
00022     {\cf20 // Check if expr is 0 or 1 (only) to make it true/false for readability.}\par
00023     {\cf19 if} (!kstrcmp(expr, {\cf22 "0"})) \{\par
00024         expr = {\cf22 "false"};\par
00025     \}\par
00026     {\cf19 if} (!kstrcmp(expr, {\cf22 "1"})) \{\par
00027         expr = {\cf22 "true"};\par
00028     \}\par
00029 \par
00030     {\cf20 // It can be versatile, with a reason or not.}\par
00031     {\cf19 if} (reason) \{\par
00032         MeBugCheckEx(ASSERTION_FAILURE, ({\cf18 void}*)expr, ({\cf18 void}*)reason, ({\cf18 void}*)file, ({\cf18 void}*)(uintptr_t)line);\par
00033     \}\par
00034     {\cf19 else} \{\par
00035         reason = {\cf22 "NO_REASON_SPECIFIED"};\par
00036         MeBugCheckEx(ASSERTION_FAILURE, ({\cf18 void}*)expr, ({\cf18 void}*)reason, ({\cf18 void}*)file, ({\cf18 void}*)(uintptr_t)line);\par
00037     \}\par
00038 \par
00039     __builtin_unreachable();\par
00040 \}\par
00041 \par
00042 {\cf20 // Helper macros for argument counting}\par
00043 {\cf21 #define GET_MACRO(_1,_2,NAME,...) NAME}\par
00044 \par
00045 {\cf20 // Base macros}\par
00046 {\cf21 #define ASSERT1(expr) \\}\par
00047 {\cf21     ((expr) ? (void)0 : assert_fail(#expr, NULL, __FILE__, __func__, __LINE__))}\par
00048 \par
00049 {\cf21 #define ASSERT2(expr, reason) \\}\par
00050 {\cf21     ((expr) ? (void)0 : assert_fail(#expr, reason, __FILE__, __func__, __LINE__))}\par
00051 \par
00052 {\cf20 // assert(expression) OR assert(expression, "expression must be true")}\par
00053 {\cf21 #define assert(...) GET_MACRO(__VA_ARGS__, ASSERT2, ASSERT1)(__VA_ARGS__)}\par
00054 \par
00055 {\cf21 #else}\par
00056 {\cf20 // assert(expression) OR assert(expression, "expression must be true")}\par
00057 {\cf21 #define assert(...) do \{ \} while(0)}\par
00058 {\cf21 #endif}\par
00059 \par
00060 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/exp/exception.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/exp/exception.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/exp/exception.c}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/exception.h"}\par
{\f2 #include "../../includes/ps.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ExpIsExceptionHandlerPresent} ({\b IN} {\b PETHREAD} Thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ExpDispatchException} ({\b IN} {\b PTRAP_FRAME} TrapFrame, {\b IN} {\b PCONTEXT} ContextRecord, {\b IN} {\b PEXCEPTION_RECORD} ExceptionRecord)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ExpDispatchException\:exception.c}
{\xe \v exception.c\:ExpDispatchException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExpDispatchException ({\b IN} {\b PTRAP_FRAME} TrapFrame, {\b IN} {\b PCONTEXT} ContextRecord, {\b IN} {\b PEXCEPTION_RECORD} ExceptionRecord)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b exception.c}.}\par
}
{\xe \v ExpIsExceptionHandlerPresent\:exception.c}
{\xe \v exception.c\:ExpIsExceptionHandlerPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExpIsExceptionHandlerPresent ({\b IN} {\b PETHREAD} Thread)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b exception.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
exception.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/exp/exception.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/exp/exception.c}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     exception.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of exception checking & handling in MatanelOS (_try _except macros)}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/exception.h"}\par
00020 {\cf21 #include "../../includes/ps.h"}\par
00021 \par
00022 {\cf18 bool}\par
00023 ExpIsExceptionHandlerPresent(\par
00024     IN PETHREAD Thread\par
00025 )\par
00026 \par
00027 {\cf20 /*++}\par
00028 {\cf20 }\par
00029 {\cf20     Routine description:}\par
00030 {\cf20 }\par
00031 {\cf20         Checks if an exception handler is present in the current thread context.}\par
00032 {\cf20 }\par
00033 {\cf20     Arguments:}\par
00034 {\cf20 }\par
00035 {\cf20         [IN] PETHREAD Thread - The thread to check on.}\par
00036 {\cf20 }\par
00037 {\cf20     Return Values:}\par
00038 {\cf20 }\par
00039 {\cf20         True if present, false otherwise.}\par
00040 {\cf20 }\par
00041 {\cf20 --*/}\par
00042 \par
00043 \{\par
00044     {\cf19 if} (Thread) \{\par
00045         {\cf19 if} (Thread->ExceptionRegistration.Handler != NULL) \{\par
00046             {\cf19 return} {\cf17 true};\par
00047         \}\par
00048         {\cf19 else} \{\par
00049             {\cf19 return} {\cf17 false};\par
00050         \}\par
00051     \}\par
00052     {\cf19 return} {\cf17 false};\par
00053 \}\par
00054 \par
00055 {\cf18 void}\par
00056 ExpDispatchException(\par
00057     IN PTRAP_FRAME TrapFrame,\par
00058     IN PCONTEXT ContextRecord,\par
00059     IN PEXCEPTION_RECORD ExceptionRecord\par
00060 )\par
00061 \par
00062 {\cf20 /*++}\par
00063 {\cf20 }\par
00064 {\cf20     Routine description:}\par
00065 {\cf20         (UNUSED)}\par
00066 {\cf20         Changes the trap frame to point to the _except handler of the thread.}\par
00067 {\cf20 }\par
00068 {\cf20     Arguments:}\par
00069 {\cf20 }\par
00070 {\cf20         [IN] PTRAP_FRAME trap - Pointer to Trap frame of the thread.}\par
00071 {\cf20         [IN] PCONTEXT ContextRecord - Pointer to Context record of the thread (saved in _try by thread)}\par
00072 {\cf20         [IN] PEXCEPTION_RECORD ExceptionRecord - Pointer to Exception record of the thread}\par
00073 {\cf20 }\par
00074 {\cf20     Return Values:}\par
00075 {\cf20 }\par
00076 {\cf20         None.}\par
00077 {\cf20 }\par
00078 {\cf20 --*/}\par
00079 \par
00080 \{\par
00081     {\cf19 if} (ExpIsExceptionHandlerPresent(PsGetCurrentThread())) \{\par
00082         {\cf20 // Change trap frame to context record set by thread. (except RIP)}\par
00083         TrapFrame->rsp = ContextRecord->Rsp;\par
00084         TrapFrame->rflags = ContextRecord->RFlags;\par
00085 \par
00086         {\cf20 // General-purpose registers from the context frame}\par
00087         TrapFrame->r15 = ContextRecord->R15;\par
00088         TrapFrame->r14 = ContextRecord->R14;\par
00089         TrapFrame->r13 = ContextRecord->R13;\par
00090         TrapFrame->r12 = ContextRecord->R12;\par
00091 \par
00092         TrapFrame->r11 = ContextRecord->R11;\par
00093         TrapFrame->r10 = ContextRecord->R10;\par
00094         TrapFrame->r9 = ContextRecord->R9;\par
00095         TrapFrame->r8 = ContextRecord->R8;\par
00096 \par
00097         TrapFrame->rbp = ContextRecord->Rbp;\par
00098         TrapFrame->rdi = ContextRecord->Rdi;\par
00099         TrapFrame->rsi = ContextRecord->Rsi;\par
00100 \par
00101         TrapFrame->rcx = ContextRecord->Rcx;\par
00102         TrapFrame->rbx = ContextRecord->Rbx;\par
00103         TrapFrame->rdx = ContextRecord->Rdx;\par
00104         TrapFrame->rax = ContextRecord->Rax;\par
00105 \par
00106         {\cf20 // Enumerate all handlers, if one returned FIXME TODO (Decide between return value approach or completely different approach, i scrapped the exception handling idea for now, too complicated and messy, id rather work on memory}\par
00107     \}\par
00108 \par
00109 \par
00110 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ht/handle.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ht/handle.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ht/handle.c}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ht.h"}\par
{\f2 #include "../../includes/ob.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PHANDLE_TABLE} {\b HtCreateHandleTable} ({\b IN} {\b PEPROCESS} Process)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b HtCreateHandle} ({\b PHANDLE_TABLE} Table, void *Object, uint32_t Access)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HtDeleteHandle} ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b HtGetObject} ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle, {\b PHANDLE_TABLE_ENTRY} *OutEntry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HtDeleteHandleTable} ({\b IN} {\b PHANDLE_TABLE} Table)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b HandleTableList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b HandleTableLock}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v HtCreateHandle\:handle.c}
{\xe \v handle.c\:HtCreateHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} HtCreateHandle ({\b PHANDLE_TABLE} Table, void * Object, uint32_t Access)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b handle.c}.}\par
}
{\xe \v HtCreateHandleTable\:handle.c}
{\xe \v handle.c\:HtCreateHandleTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PHANDLE_TABLE} HtCreateHandleTable ({\b IN} {\b PEPROCESS} Process)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b handle.c}.}\par
}
{\xe \v HtDeleteHandle\:handle.c}
{\xe \v handle.c\:HtDeleteHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HtDeleteHandle ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 333} of file {\b handle.c}.}\par
}
{\xe \v HtDeleteHandleTable\:handle.c}
{\xe \v handle.c\:HtDeleteHandleTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HtDeleteHandleTable ({\b IN} {\b PHANDLE_TABLE} Table)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 434} of file {\b handle.c}.}\par
}
{\xe \v HtGetObject\:handle.c}
{\xe \v handle.c\:HtGetObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * HtGetObject ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle, {\b PHANDLE_TABLE_ENTRY} * OutEntry)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b handle.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v HandleTableList\:handle.c}
{\xe \v handle.c\:HandleTableList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} HandleTableList}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b handle.c}.}\par
}
{\xe \v HandleTableLock\:handle.c}
{\xe \v handle.c\:HandleTableLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} HandleTableLock}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b handle.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
handle.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ht/handle.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ht/handle.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     handle.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This module contains the implementation of MatanelOS's Handle Table.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/ht.h"}\par
00020 {\cf21 #include "../../includes/ob.h"}\par
00021 {\cf21 #include "../../assert.h"}\par
00022 \par
00023 {\cf20 // ->>>>> The handle table handles are accessed in pageable memory, we cannot be at DISPATCH_LEVEL or above.}\par
00024 {\cf20 // FIXME FIXME Implement Push locks to use in PASSIVE_LEVEL in order to use the handle table at Pageable memory, because using spinlocks raises to DISPATCH.}\par
00025 \par
00026 DOUBLY_LINKED_LIST HandleTableList;\par
00027 SPINLOCK HandleTableLock;\par
00028 \par
00029 {\cf17 static}\par
00030 PHANDLE_TABLE_ENTRY\par
00031 HtpLookupEntry(\par
00032     IN  PHANDLE_TABLE Table,\par
00033     IN  HANDLE Handle\par
00034 )\par
00035 \par
00036 {\cf20 /*++}\par
00037 {\cf20 }\par
00038 {\cf20     Routine description:}\par
00039 {\cf20 }\par
00040 {\cf20        Lookups the entry in the given handle table from supplied handle.}\par
00041 {\cf20 }\par
00042 {\cf20     Arguments:}\par
00043 {\cf20 }\par
00044 {\cf20         [IN] PHANDLE_TABLE Table - Pointer to the handle table.}\par
00045 {\cf20         [IN] HANDLE Handle - The handle.}\par
00046 {\cf20 }\par
00047 {\cf20     Return Values:}\par
00048 {\cf20 }\par
00049 {\cf20         The entry on success, or NULL on invalid table/handle.}\par
00050 {\cf20 }\par
00051 {\cf20 --*/}\par
00052 \par
00053 \{\par
00054     {\cf19 if} (!Table || !Handle || ((uint64_t)Handle & 3)) {\cf19 return} NULL;\par
00055 \par
00056     uint64_t TableCode = Table->TableCode;\par
00057     uint64_t Level = TableCode & TABLE_LEVEL_MASK;\par
00058     {\cf18 void}* TableBase = ({\cf18 void}*)(TableCode & ~TABLE_LEVEL_MASK);\par
00059 \par
00060     {\cf20 // Handles are multiples of 4, so we divide by 4 to get actual index}\par
00061     uint64_t Index = (uint64_t)(Handle) >> 2;\par
00062 \par
00063     {\cf19 if} (Level == 0) \{\par
00064         {\cf20 // Direct Array}\par
00065         PHANDLE_TABLE_ENTRY Entries = (PHANDLE_TABLE_ENTRY)TableBase;\par
00066         {\cf19 return} &Entries[Index];\par
00067     \}\par
00068     {\cf19 else} {\cf19 if} (Level == 1) \{\par
00069         {\cf20 // TableBase points to an array of pointers to pages}\par
00070         {\cf20 // We need to find WHICH page, and then WHICH entry in that page.}\par
00071         uint64_t MaxEntriesPerLevel = LOW_LEVEL_ENTRIES;\par
00072         uint64_t PageIndex = Index / MaxEntriesPerLevel;\par
00073         uint64_t EntryIndex = Index % MaxEntriesPerLevel;\par
00074 \par
00075         PHANDLE_TABLE_ENTRY* PageTable = (PHANDLE_TABLE_ENTRY*)TableBase;\par
00076         PHANDLE_TABLE_ENTRY ActualPage = PageTable[PageIndex];\par
00077         {\cf19 if} (ActualPage) \{\par
00078             {\cf19 return} &ActualPage[EntryIndex];\par
00079         \}\par
00080     \}\par
00081 \par
00082     {\cf20 // We dont really support millions of handles, so. (level 2 support needed.)}\par
00083     {\cf19 return} NULL;\par
00084 \}\par
00085 \par
00086 PHANDLE_TABLE\par
00087 HtCreateHandleTable(\par
00088     IN  PEPROCESS Process\par
00089 )\par
00090 \par
00091 {\cf20 /*++}\par
00092 {\cf20 }\par
00093 {\cf20     Routine description:}\par
00094 {\cf20 }\par
00095 {\cf20         Create a handle table for the given process.}\par
00096 {\cf20 }\par
00097 {\cf20     Arguments:}\par
00098 {\cf20 }\par
00099 {\cf20         [IN] PEPROCESS Process - Pointer to process.}\par
00100 {\cf20 }\par
00101 {\cf20     Return Values:}\par
00102 {\cf20 }\par
00103 {\cf20         Pointer to table on success, or NULL on failure.}\par
00104 {\cf20 }\par
00105 {\cf20 --*/}\par
00106 \par
00107 \{\par
00108     PHANDLE_TABLE Table = MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(HANDLE_TABLE), {\cf22 'bTtH'}); {\cf20 // HtTb - Handle Table.}\par
00109     \par
00110     {\cf20 // Allocate the first page of the entries (level 0) (switched to paged pool now)}\par
00111     PHANDLE_TABLE_ENTRY Level0 = MmAllocatePoolWithTag(NonPagedPool, VirtualPageSize, {\cf22 'egaP'}); {\cf20 // Page}\par
00112 \par
00113     {\cf20 // Initialize the free list in the new page.}\par
00114     {\cf19 for} (uint64_t i = 1; i < LOW_LEVEL_ENTRIES - 1; i++) \{\par
00115         Level0[i].NextFreeTableEntry = (i + 1) * 4; {\cf20 // Store as a handle value.}\par
00116     \}\par
00117     Level0[LOW_LEVEL_ENTRIES - 1].NextFreeTableEntry = 0; {\cf20 // End of the list.}\par
00118     {\cf20 // The first index is NULL, always.}\par
00119     Level0[0].Object = NULL;\par
00120 \par
00121     Table->TableCode = (uint64_t)Level0; {\cf20 // Level is 0, so bottom bits are 0}\par
00122     Table->FirstFreeHandle = 4;\par
00123     Table->QuotaProcess = Process;\par
00124 \par
00125     {\cf19 return} Table;\par
00126 \}\par
00127 \par
00128 {\cf17 static} \par
00129 PHANDLE_TABLE_ENTRY \par
00130 HtpAllocateAndInitHandlePage(\par
00131     IN  PHANDLE_TABLE Table,\par
00132     IN  uint32_t BaseHandleIndex\par
00133 )\par
00134 \par
00135 {\cf20 /*++}\par
00136 {\cf20 }\par
00137 {\cf20     Routine description:}\par
00138 {\cf20 }\par
00139 {\cf20         Creates a HANDLE_TABLE_ENTRY for the given Table (does not insert).}\par
00140 {\cf20 }\par
00141 {\cf20     Arguments:}\par
00142 {\cf20 }\par
00143 {\cf20         [IN]    PHANDLE_TABLE Table - The table to create the entry for.}\par
00144 {\cf20         [IN]    uint32_t BaseHandleIndex - The base index to create the starting handle table entry for. (e.g if last index was 16, then supply it, :))}\par
00145 {\cf20 }\par
00146 {\cf20     Return Values:}\par
00147 {\cf20 }\par
00148 {\cf20         Pointer to allocated table entry on success, or NULL on failure.}\par
00149 {\cf20 }\par
00150 {\cf20 --*/}\par
00151 \par
00152 \{\par
00153     PHANDLE_TABLE_ENTRY NewPage = MmAllocatePoolWithTag(NonPagedPool, VirtualPageSize, {\cf22 'egaP'});\par
00154     {\cf19 if} (!NewPage) {\cf19 return} NULL;\par
00155 \par
00156     {\cf20 // Link all entries in this new page together}\par
00157     uint32_t i;\par
00158     {\cf19 for} (i = 0; i < LOW_LEVEL_ENTRIES - 1; i++) \{\par
00159         {\cf20 // Calculate the actual handle value for the *next* entry}\par
00160         NewPage[i].NextFreeTableEntry = (BaseHandleIndex + i + 1) * 4;\par
00161     \}\par
00162 \par
00163     {\cf20 // The last entry in this new page points to the CURRENT FirstFreeHandle.}\par
00164     NewPage[LOW_LEVEL_ENTRIES - 1].NextFreeTableEntry = Table->FirstFreeHandle;\par
00165     NewPage[0].Object = NULL;\par
00166 \par
00167     {\cf19 return} NewPage;\par
00168 \}\par
00169 \par
00170 {\cf17 static}\par
00171 {\cf18 void} \par
00172 HtpExpandTable(\par
00173     PHANDLE_TABLE Table\par
00174 )\par
00175 \par
00176 {\cf20 /*++}\par
00177 {\cf20 }\par
00178 {\cf20     Routine description:}\par
00179 {\cf20 }\par
00180 {\cf20         Expands a HANDLE_TABLE to its next intended level.}\par
00181 {\cf20 }\par
00182 {\cf20     Arguments:}\par
00183 {\cf20 }\par
00184 {\cf20         [IN]    PHANDLE_TABLE Table - The table to expand.}\par
00185 {\cf20 }\par
00186 {\cf20     Return Values:}\par
00187 {\cf20 }\par
00188 {\cf20         None.}\par
00189 {\cf20 }\par
00190 {\cf20     Notes:}\par
00191 {\cf20 }\par
00192 {\cf20         Any level above 1 is not supported.}\par
00193 {\cf20 }\par
00194 {\cf20 --*/}\par
00195 \par
00196 \{\par
00197     uint64_t TableCode = Table->TableCode;\par
00198     uint64_t CurrentLevel = TableCode & TABLE_LEVEL_MASK;\par
00199     {\cf18 void}* TableBase = ({\cf18 void}*)(TableCode & ~TABLE_LEVEL_MASK);\par
00200 \par
00201     PHANDLE_TABLE_ENTRY NewFreePage = NULL;\par
00202     uint32_t NewBaseIndex = 0;\par
00203 \par
00204     {\cf20 //}\par
00205     {\cf20 // Case 1: Promoting from Level 0 to Level 1}\par
00206     {\cf20 //}\par
00207     {\cf19 if} (CurrentLevel == 0) \{\par
00208         {\cf20 // Allocate the "Directory" page (holds pointers, not entries)}\par
00209         PHANDLE_TABLE_ENTRY* Directory = MmAllocatePoolWithTag(NonPagedPool, VirtualPageSize, {\cf22 'riD'});\par
00210         {\cf19 if} (!Directory) {\cf19 return}; {\cf20 // OOM}\par
00211 \par
00212         {\cf20 // The existing Level 0 page becomes the first entry in the directory}\par
00213         Directory[0] = (PHANDLE_TABLE_ENTRY)TableBase;\par
00214 \par
00215         {\cf20 // Allocate a NEW Level 0 page for the second slot}\par
00216         NewBaseIndex = LOW_LEVEL_ENTRIES; {\cf20 // The index starts where the first page left off}\par
00217         NewFreePage = HtpAllocateAndInitHandlePage(Table, NewBaseIndex);\par
00218 \par
00219         {\cf19 if} (!NewFreePage) \{\par
00220             MmFreePool(Directory);\par
00221             {\cf19 return};\par
00222         \}\par
00223 \par
00224         Directory[1] = NewFreePage;\par
00225 \par
00226         {\cf20 // Update TableCode: Pointer to Directory | Level 1}\par
00227         Table->TableCode = ((uint64_t)Directory) | 1;\par
00228 \par
00229         {\cf20 // Update the free list to point to the start of our new page}\par
00230         {\cf20 // (NewFreePage[0] corresponds to NewBaseIndex)}\par
00231         Table->FirstFreeHandle = NewBaseIndex * 4;\par
00232     \}\par
00233     {\cf20 //}\par
00234     {\cf20 // Case 2: Already Level 1, need to add a new page}\par
00235     {\cf20 //}\par
00236     {\cf19 else} {\cf19 if} (CurrentLevel == 1) \{\par
00237         PHANDLE_TABLE_ENTRY* Directory = (PHANDLE_TABLE_ENTRY*)TableBase;\par
00238 \par
00239         {\cf20 // Find the first empty slot in the directory}\par
00240         uint32_t DirectoryIndex = 0;\par
00241         {\cf19 for} (DirectoryIndex = 0; DirectoryIndex < LOW_LEVEL_ENTRIES; DirectoryIndex++) \{\par
00242             {\cf19 if} (Directory[DirectoryIndex] == NULL) {\cf19 break};\par
00243         \}\par
00244 \par
00245         {\cf19 if} (DirectoryIndex >= LOW_LEVEL_ENTRIES) \{\par
00246             {\cf20 // Level 1 is full, no level 2 yet.}\par
00247             {\cf19 goto} Level2Setup;\par
00248         \}\par
00249 \par
00250         {\cf20 // Calculate the Handle Index base for this new page}\par
00251         NewBaseIndex = DirectoryIndex * LOW_LEVEL_ENTRIES;\par
00252 \par
00253         {\cf20 // Allocate the new page}\par
00254         NewFreePage = HtpAllocateAndInitHandlePage(Table, NewBaseIndex);\par
00255         {\cf19 if} (!NewFreePage) {\cf19 return};\par
00256 \par
00257         {\cf20 // Link it into the directory}\par
00258         Directory[DirectoryIndex] = NewFreePage;\par
00259 \par
00260         {\cf20 // Update Free List}\par
00261         Table->FirstFreeHandle = NewBaseIndex * 4;\par
00262     \}\par
00263 \par
00264 Level2Setup:\par
00265     {\cf19 return};\par
00266 \}\par
00267 \par
00268 HANDLE\par
00269 HtCreateHandle(\par
00270     PHANDLE_TABLE Table,\par
00271     {\cf18 void}* Object,\par
00272     uint32_t Access\par
00273 )\par
00274 \par
00275 {\cf20 /*++}\par
00276 {\cf20 }\par
00277 {\cf20     Routine description:}\par
00278 {\cf20 }\par
00279 {\cf20         Creates a HANDLE for specified Object. (Ob)}\par
00280 {\cf20 }\par
00281 {\cf20     Arguments:}\par
00282 {\cf20 }\par
00283 {\cf20         [IN]    PHANDLE_TABLE Table - The table to insert the handle in.}\par
00284 {\cf20         [IN]    void* Object - The Object to create the handle for.}\par
00285 {\cf20         [IN]    uint32_t Access - The maximum access the handle should have.}\par
00286 {\cf20 }\par
00287 {\cf20     Return Values:}\par
00288 {\cf20 }\par
00289 {\cf20         The HANDLE number, or MT_INVALID_HANDLE on new handle allocation failure.}\par
00290 {\cf20 }\par
00291 {\cf20 --*/}\par
00292 \par
00293 \{\par
00294     IRQL oldIrql;\par
00295     MsAcquireSpinlock(&Table->TableLock, &oldIrql);\par
00296 \par
00297     {\cf20 // Is there a free handle in the list?}\par
00298     {\cf19 if} (Table->FirstFreeHandle == 0)\par
00299     \{\par
00300 \par
00301         {\cf20 // Expand table, no free handles.}\par
00302         HtpExpandTable(Table);\par
00303 \par
00304         {\cf20 // Check again. If it is STILL 0, expansion failed (OOM).}\par
00305         {\cf19 if} (Table->FirstFreeHandle == 0) \{\par
00306             MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00307             {\cf19 return} MT_INVALID_HANDLE; {\cf20 // Return NULL/0}\par
00308         \}\par
00309     \}\par
00310 \par
00311     {\cf20 // Pop from Free List}\par
00312     uint32_t FreeIndex = Table->FirstFreeHandle;\par
00313     PHANDLE_TABLE_ENTRY Entry = HtpLookupEntry(Table, (HANDLE)FreeIndex);\par
00314 \par
00315     {\cf20 // Sanity check (Should never happen if FirstFreeHandle != 0)}\par
00316     {\cf19 if} (!Entry) \{\par
00317         MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00318         {\cf19 return} MT_INVALID_HANDLE;\par
00319     \}\par
00320 \par
00321     {\cf20 // Update head of free list}\par
00322     Table->FirstFreeHandle = Entry->NextFreeTableEntry;\par
00323 \par
00324     {\cf20 // Setup the Entry}\par
00325     Entry->Object = Object;\par
00326     Entry->GrantedAccess = Access;\par
00327     MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00328 \par
00329     {\cf19 return} (HANDLE)FreeIndex;\par
00330 \}\par
00331 \par
00332 {\cf18 void} \par
00333 HtDeleteHandle(\par
00334     PHANDLE_TABLE Table,\par
00335     HANDLE Handle\par
00336 )\par
00337 \par
00338 {\cf20 /*++}\par
00339 {\cf20 }\par
00340 {\cf20     Routine description:}\par
00341 {\cf20 }\par
00342 {\cf20         Delets a HANDLE from the table.}\par
00343 {\cf20 }\par
00344 {\cf20     Arguments:}\par
00345 {\cf20 }\par
00346 {\cf20         [IN]    PHANDLE_TABLE Table - The table to delete the handle from.}\par
00347 {\cf20         [IN]    HANDLE Handle - The handle to delete.}\par
00348 {\cf20 }\par
00349 {\cf20     Return Values:}\par
00350 {\cf20 }\par
00351 {\cf20         None.}\par
00352 {\cf20 }\par
00353 {\cf20 --*/}\par
00354 \par
00355 \{\par
00356     IRQL oldIrql;\par
00357     MsAcquireSpinlock(&Table->TableLock, &oldIrql);\par
00358 \par
00359     {\cf20 // Validate Handle}\par
00360     {\cf20 // Ensure it's not 0 (if 0 is invalid) and is a multiple of 4}\par
00361     {\cf19 if} (!Handle || ((uint64_t)Handle & 3)) \{\par
00362         MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00363         {\cf19 return};\par
00364     \}\par
00365 \par
00366     {\cf20 // Lookup the entry}\par
00367     PHANDLE_TABLE_ENTRY Entry = HtpLookupEntry(Table, Handle);\par
00368 \par
00369     {\cf20 // Check if entry is actually in use}\par
00370     {\cf19 if} (!Entry || !Entry->Object) \{\par
00371         {\cf20 // Handle is already free or invalid}\par
00372         MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00373         {\cf19 return};\par
00374     \}\par
00375 \par
00376     {\cf20 // 4. Invalidate the Entry}\par
00377     Entry->Object = NULL;\par
00378     Entry->GrantedAccess = 0;\par
00379 \par
00380     {\cf20 // Push onto Free List (LIFO - Stack)}\par
00381     {\cf20 // The current head of the list becomes the next for this entry.}\par
00382     Entry->NextFreeTableEntry = Table->FirstFreeHandle;\par
00383     {\cf20 // This entry becomes the new head.}\par
00384     Table->FirstFreeHandle = (uint32_t)Handle;\par
00385     MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00386 \}\par
00387 \par
00388 {\cf18 void}* \par
00389 HtGetObject (\par
00390     PHANDLE_TABLE Table, \par
00391     HANDLE Handle,\par
00392     PHANDLE_TABLE_ENTRY* OutEntry\par
00393 )\par
00394 \par
00395 {\cf20 /*++}\par
00396 {\cf20 }\par
00397 {\cf20     Routine description:}\par
00398 {\cf20 }\par
00399 {\cf20         Retrieves the object for the specified Handle.}\par
00400 {\cf20 }\par
00401 {\cf20     Arguments:}\par
00402 {\cf20 }\par
00403 {\cf20         [IN]    PHANDLE_TABLE Table - The table to enumerate the handle in.}\par
00404 {\cf20         [IN]    HANDLE Handle - The Object's handle.}\par
00405 {\cf20         [OUT OPTIONAL]    PHANDLE_TABLE_ENTRY* OutEntry - The table entry for the handle.}\par
00406 {\cf20 }\par
00407 {\cf20     Return Values:}\par
00408 {\cf20 }\par
00409 {\cf20         The Object found for the handle.}\par
00410 {\cf20 }\par
00411 {\cf20 --*/}\par
00412 \par
00413 \{\par
00414     IRQL oldIrql;\par
00415     {\cf18 void}* Object = NULL;\par
00416 \par
00417     MsAcquireSpinlock(&Table->TableLock, &oldIrql);\par
00418 \par
00419     PHANDLE_TABLE_ENTRY Entry = HtpLookupEntry(Table, Handle);\par
00420 \par
00421     {\cf20 // Check if valid and allocated}\par
00422     {\cf19 if} (Entry && Entry->Object) \{\par
00423         Object = Entry->Object;\par
00424     \}\par
00425 \par
00426     MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00427     {\cf19 if} (Entry) \{\par
00428         {\cf19 if} (OutEntry) *OutEntry = Entry;\par
00429     \}\par
00430     {\cf19 return} Object;\par
00431 \}\par
00432 \par
00433 {\cf18 void}\par
00434 HtDeleteHandleTable(\par
00435     IN PHANDLE_TABLE Table\par
00436 )\par
00437 \par
00438 {\cf20 /*++}\par
00439 {\cf20 }\par
00440 {\cf20     Routine description:}\par
00441 {\cf20 }\par
00442 {\cf20         Deletes the handle table allocated. (Dereferences any objects that are still alive, frees directory and other)}\par
00443 {\cf20 }\par
00444 {\cf20     Arguments:}\par
00445 {\cf20 }\par
00446 {\cf20         [IN]    PHANDLE_TABLE Table - The table to delete.}\par
00447 {\cf20 }\par
00448 {\cf20     Return Values:}\par
00449 {\cf20 }\par
00450 {\cf20         None.}\par
00451 {\cf20 }\par
00452 {\cf20 --*/}\par
00453 \par
00454 \{\par
00455     {\cf20 // We just free all of the levels and the table itself.}\par
00456     {\cf19 if} (!Table) {\cf19 return};\par
00457 \par
00458     {\cf20 // Grab the table lock.}\par
00459     IRQL oldIrql;\par
00460     MsAcquireSpinlock(&Table->TableLock, &oldIrql);\par
00461 \par
00462     uint64_t TableCode = Table->TableCode;\par
00463     uint64_t Level = TableCode & TABLE_LEVEL_MASK;\par
00464     {\cf18 void}* TableBase = ({\cf18 void}*)(TableCode & ~TABLE_LEVEL_MASK);\par
00465 \par
00466     {\cf19 if} (Level == 0) \{\par
00467         {\cf20 // Single contigious page of entries}\par
00468         PHANDLE_TABLE_ENTRY Entries = (PHANDLE_TABLE_ENTRY)TableBase;\par
00469         {\cf19 if} (Entries) \{\par
00470             {\cf20 // Walk and dereference any live objects that are alive.}\par
00471             {\cf19 for} (uint64_t i = 0; i < LOW_LEVEL_ENTRIES; i++) \{\par
00472                 {\cf18 void}* Object = Entries[i].Object;\par
00473                 {\cf19 if} (Object) \{\par
00474                     Entries[i].Object = NULL;\par
00475                     ObDereferenceObject(Object);\par
00476                 \}\par
00477             \}\par
00478         \}\par
00479 \par
00480         {\cf20 // No more live handles \'97 release lock and free the page}\par
00481         MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00482         {\cf19 if} (Entries) MmFreePool(Entries);\par
00483     \}\par
00484 \par
00485     {\cf19 else} {\cf19 if} (Level == 1) \{\par
00486         {\cf20 // Directory of page pointers.}\par
00487         PHANDLE_TABLE_ENTRY* Directory = (PHANDLE_TABLE_ENTRY*)TableBase;\par
00488         {\cf19 if} (Directory) \{\par
00489             {\cf20 // Walk every allocated page.}\par
00490             {\cf19 for} (uint64_t dir = 0; dir < LOW_LEVEL_ENTRIES; dir++) \{\par
00491                 PHANDLE_TABLE_ENTRY Page = Directory[dir];\par
00492                 {\cf19 if} (!Page) {\cf19 continue};\par
00493 \par
00494                 {\cf19 for} (uint64_t i = 0; i < LOW_LEVEL_ENTRIES; i++) \{\par
00495                     {\cf18 void}* Object = Page[i].Object;\par
00496                     {\cf19 if} (Object) \{\par
00497                         Page[i].Object = NULL;\par
00498                         ObDereferenceObject(Object);\par
00499                     \}\par
00500                 \}\par
00501 \par
00502                 {\cf20 // Free this page of handles.}\par
00503                 MmFreePool(Page);\par
00504             \}\par
00505         \}\par
00506 \par
00507         {\cf20 // Release spinlock and free the directory itself.}\par
00508         MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00509         {\cf19 if} (Directory) MmFreePool(Directory);\par
00510     \}\par
00511 \par
00512     {\cf19 else} \{\par
00513         {\cf20 // Unsupported level, release lock and get out.}\par
00514         assert({\cf17 false}, {\cf22 "Unsupported level encountered on handle table free."});\par
00515         MsReleaseSpinlock(&Table->TableLock, oldIrql);\par
00516     \}\par
00517 \par
00518     {\cf20 // Finally, free our table itself.}\par
00519     MmFreePool(Table);\par
00520 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/md/debugfunctions.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/md/debugfunctions.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/md/debugfunctions.c}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/md.h"}\par
{\f2 #include "../../includes/mh.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b find_available_debug_reg} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MdSetHardwareBreakpoint} ({\b DebugCallback} CallbackFunction, void *BreakpointAddress, {\b DEBUG_ACCESS_MODE} AccessMode, {\b DEBUG_LENGTH} {\b Length})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MdClearHardwareBreakpointByIndex} (int index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MdClearHardwareBreakpointByAddress} (void *BreakpointAddress)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v find_available_debug_reg\:debugfunctions.c}
{\xe \v debugfunctions.c\:find_available_debug_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int find_available_debug_reg (void )}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b debugfunctions.c}.}\par
}
{\xe \v MdClearHardwareBreakpointByAddress\:debugfunctions.c}
{\xe \v debugfunctions.c\:MdClearHardwareBreakpointByAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MdClearHardwareBreakpointByAddress (void * BreakpointAddress)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b debugfunctions.c}.}\par
}
{\xe \v MdClearHardwareBreakpointByIndex\:debugfunctions.c}
{\xe \v debugfunctions.c\:MdClearHardwareBreakpointByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MdClearHardwareBreakpointByIndex (int index)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b debugfunctions.c}.}\par
}
{\xe \v MdSetHardwareBreakpoint\:debugfunctions.c}
{\xe \v debugfunctions.c\:MdSetHardwareBreakpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MdSetHardwareBreakpoint ({\b DebugCallback} CallbackFunction, void * BreakpointAddress, {\b DEBUG_ACCESS_MODE} AccessMode, {\b DEBUG_LENGTH} Length)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b debugfunctions.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
debugfunctions.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/md/debugfunctions.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/md/debugfunctions.c}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     Debugging Functions Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/md.h"}\par
00008 {\cf21 #include "../../includes/mh.h"}\par
00009 \par
00010  {\cf20 /* Find a free debug slot (0..3) or -1 if none */}\par
00011 {\cf18 int} find_available_debug_reg({\cf18 void}) \{\par
00012     {\cf19 for} ({\cf18 int} i = 0; i < 4; ++i) \{\par
00013         {\cf19 if} (MeGetCurrentProcessor()->DebugEntry[i].Callback == NULL) {\cf19 return} i;\par
00014     \}\par
00015     {\cf19 return} -1;\par
00016 \}\par
00017 \par
00018 {\cf17 static} {\cf17 inline} {\cf18 void} write_dr_idx({\cf18 int} idx, uint64_t value) \{\par
00019     __write_dr(idx, value);\par
00020 \}\par
00021 {\cf17 static} {\cf17 inline} uint64_t read_dr7({\cf18 void}) \{ {\cf19 return} __read_dr(7); \}\par
00022 {\cf17 static} {\cf17 inline} {\cf18 void} write_dr7(uint64_t v) \{ __write_dr(7, v); \}\par
00023 {\cf17 static} {\cf17 inline} {\cf18 void} write_dr6(uint64_t v) \{ __write_dr(6, v); \}\par
00024 \par
00025 {\cf20 // PUBLIC API}\par
00026 MTSTATUS MdSetHardwareBreakpoint(DebugCallback CallbackFunction, {\cf18 void}* BreakpointAddress, DEBUG_ACCESS_MODE AccessMode, DEBUG_LENGTH Length) \{\par
00027     {\cf19 if} (!CallbackFunction || !BreakpointAddress) {\cf19 return} MT_INVALID_PARAM;\par
00028     {\cf19 if} (AccessMode == DEBUG_ACCESS_IO) {\cf19 return} MT_NOT_IMPLEMENTED; {\cf20 /* legacy / not handled */}\par
00029 {\cf21 #ifdef DEBUG}\par
00030     {\cf20 /* Validate length */}\par
00031     {\cf19 if} (Length != DEBUG_LEN_BYTE && Length != DEBUG_LEN_DWORD && Length != DEBUG_LEN_WORD && Length != DEBUG_LEN_QWORD)\par
00032         {\cf19 return} MT_INVALID_PARAM;\par
00033 \par
00034     {\cf18 int} idx = find_available_debug_reg();\par
00035     {\cf19 if} (idx == -1) {\cf19 return} MT_NO_RESOURCES;\par
00036 \par
00037     uint64_t addr = (uint64_t)BreakpointAddress;\par
00038 \par
00039     {\cf20 /* Write address into DRx */}\par
00040     write_dr_idx(idx, addr);\par
00041 \par
00042     {\cf20 /* Clear DR6 status before enabling */}\par
00043     write_dr6(0);\par
00044 \par
00045     {\cf20 /* Modify DR7 safely: only change bits for our breakpoint index and the local-enable bit */}\par
00046     uint64_t dr7 = read_dr7();\par
00047 \par
00048     {\cf20 /* set local enable bit Lx (bit 0,2,4,6 for idx 0..3) */}\par
00049     dr7 |= (1ULL << (idx * 2));\par
00050 \par
00051     {\cf20 /* Build the 4-bit RW/LEN field value: low 2 bits = RW, high 2 bits = LEN */}\par
00052     uint64_t group_val = ((((uint64_t)Length) & 0x3ULL) << 2) | (((uint64_t)AccessMode) & 0x3ULL);\par
00053 \par
00054     {\cf20 /* Clear existing 4-bit group and set new one at bits (16 + 4*idx .. 19 + 4*idx) */}\par
00055     uint64_t mask = 0xFULL << (16 + 4 * idx);\par
00056     dr7 &= ~mask;\par
00057     dr7 |= (group_val << (16 + 4 * idx));\par
00058 \par
00059     write_dr7(dr7);\par
00060 \par
00061     {\cf20 // Save in the DEBUG db so the INT1 will handle it.}\par
00062     MeGetCurrentProcessor()->DebugEntry[idx].Address = BreakpointAddress;\par
00063     MeGetCurrentProcessor()->DebugEntry[idx].Callback = CallbackFunction;\par
00064 \par
00065     IPI_PARAMS params;\par
00066     kmemset(&params, 0, {\cf17 sizeof}(IPI_PARAMS));\par
00067     params.debugRegs.address = addr;\par
00068     params.debugRegs.dr7 = dr7;\par
00069     params.debugRegs.callback = CallbackFunction;\par
00070 \par
00071     MhSendActionToCpusAndWait(CPU_ACTION_WRITE_DEBUG_REGS, params);\par
00072 \par
00073     {\cf19 return} MT_SUCCESS;\par
00074 {\cf21 #else}\par
00075     {\cf19 return} MT_NOT_IMPLEMENTED; {\cf20 // On release builds, this should be toggled off, as the system is in a controlled environment, plus this would corrupt user debug registers.}\par
00076 {\cf21 #endif}\par
00077 \}\par
00078 \par
00079 MTSTATUS MdClearHardwareBreakpointByIndex({\cf18 int} index) \{\par
00080     {\cf19 if} (index < 0 || index > 3) {\cf19 return} MT_INVALID_PARAM;\par
00081     {\cf19 if} (MeGetCurrentProcessor()->DebugEntry[index].Callback == NULL && MeGetCurrentProcessor()->DebugEntry[index].Address == NULL) {\cf19 return} MT_NOT_FOUND;\par
00082 \par
00083     {\cf20 /* Clear DRx address */}\par
00084     write_dr_idx(index, 0);\par
00085 \par
00086     {\cf20 /* Clear DR7 bits for this index (local enable and RW/LEN group) */}\par
00087     uint64_t dr7 = read_dr7();\par
00088     {\cf20 /* clear local enable bit */}\par
00089     dr7 &= ~(1ULL << (index * 2));\par
00090     {\cf20 /* clear RW/LEN 4-bit group */}\par
00091     uint64_t mask = 0xFULL << (16 + 4 * index);\par
00092     dr7 &= ~mask;\par
00093     write_dr7(dr7);\par
00094 \par
00095     {\cf20 /* Clear status DR6 too */}\par
00096     write_dr6(0);\par
00097 \par
00098     IPI_PARAMS params;\par
00099     params.debugRegs.address = (uint64_t)MeGetCurrentProcessor()->DebugEntry[index].Address;\par
00100 \par
00101     {\cf20 /* Clear table entry */}\par
00102     MeGetCurrentProcessor()->DebugEntry[index].Callback = NULL;\par
00103     MeGetCurrentProcessor()->DebugEntry[index].Address = NULL;\par
00104 \par
00105     MhSendActionToCpusAndWait(CPU_ACTION_CLEAR_DEBUG_REGS, params);\par
00106 \par
00107     {\cf19 return} MT_SUCCESS;\par
00108 \}\par
00109 \par
00110 MTSTATUS MdClearHardwareBreakpointByAddress({\cf18 void}* BreakpointAddress) \{\par
00111     {\cf19 if} (!BreakpointAddress) {\cf19 return} MT_INVALID_PARAM;\par
00112     {\cf19 for} ({\cf18 int} i = 0; i < 4; ++i) \{\par
00113         {\cf19 if} (MeGetCurrentProcessor()->DebugEntry[i].Address == BreakpointAddress) \{\par
00114             {\cf19 return} MdClearHardwareBreakpointByIndex(i);\par
00115         \}\par
00116     \}\par
00117     {\cf19 return} MT_NOT_FOUND;\par
00118 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/attach.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/attach.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/attach.c}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/ps.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeAttachProcess} ({\b IN} {\b PIPROCESS} Process, {\b OUT} {\b PAPC_STATE} ApcState)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeDetachProcess} ({\b IN} {\b PAPC_STATE} ApcState)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MeAttachProcess\:attach.c}
{\xe \v attach.c\:MeAttachProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeAttachProcess ({\b IN} {\b PIPROCESS} Process, {\b OUT} {\b PAPC_STATE} ApcState)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b attach.c}.}\par
}
{\xe \v MeDetachProcess\:attach.c}
{\xe \v attach.c\:MeDetachProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeDetachProcess ({\b IN} {\b PAPC_STATE} ApcState)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b attach.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
attach.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/attach.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/attach.c}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     attach.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This module contains the implementation of process attaching.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/me.h"}\par
00020 {\cf21 #include "../../includes/ps.h"}\par
00021 \par
00022 {\cf18 void}\par
00023 MeAttachProcess(\par
00024     IN PIPROCESS Process,\par
00025     OUT PAPC_STATE ApcState\par
00026 )\par
00027 \par
00028 {\cf20 /*++}\par
00029 {\cf20 }\par
00030 {\cf20     Routine description:}\par
00031 {\cf20 }\par
00032 {\cf20         Attach to a process address space, this routine should be managed carefully, and have simple code between the attaching and detaching.}\par
00033 {\cf20         }\par
00034 {\cf20 }\par
00035 {\cf20     Arguments:}\par
00036 {\cf20 }\par
00037 {\cf20         [IN]    PIPROCESS Process - Pointer to process to attach to (IPROCESS)}\par
00038 {\cf20         [OUT]   PAPC_STATE - Pointer to store the state in resident memory.}\par
00039 {\cf20 }\par
00040 {\cf20     Return Values:}\par
00041 {\cf20 }\par
00042 {\cf20         None.}\par
00043 {\cf20 }\par
00044 {\cf20     Notes:}\par
00045 {\cf20 }\par
00046 {\cf20         DPCs CANNOT attach to a different process.}\par
00047 {\cf20 }\par
00048 {\cf20 --*/}\par
00049 \par
00050 \{\par
00051     {\cf19 if} (MeIsExecutingDpc()) \{\par
00052         {\cf20 // CANNOT Attach to a process while executing a DPC.}\par
00053         MeBugCheckEx(\par
00054             INVALID_PROCESS_ATTACH_ATTEMPT,\par
00055             ({\cf18 void}*)Process,\par
00056             ({\cf18 void}*)(uintptr_t)RETADDR(0),\par
00057             ({\cf18 void}*)MeIsExecutingDpc(),\par
00058             NULL\par
00059         );\par
00060     \}\par
00061 \par
00062     PITHREAD CurrentThread = MeGetCurrentThread();\par
00063     {\cf19 if} (unlikely(!CurrentThread)) {\cf19 return};\par
00064 \par
00065     {\cf20 // Save the process we were running on.}\par
00066     ApcState->SavedApcProcess = CurrentThread->ApcState.SavedApcProcess;\par
00067     ApcState->SavedCr3 = __read_cr3();\par
00068     ApcState->AttachedToProcess = {\cf17 true};\par
00069 \par
00070     {\cf20 // Raise to SYNCH and lock scheduler.}\par
00071     {\cf20 // TODO SYNCH}\par
00072     MeAcquireSchedulerLock();\par
00073 \par
00074     {\cf20 // Switch identity to new process.}\par
00075     CurrentThread->ApcState.SavedApcProcess = PsGetEProcessFromIProcess(Process);\par
00076     CurrentThread->ApcState.AttachedToProcess = {\cf17 true};\par
00077 \par
00078     {\cf20 // Switch CR3s.}\par
00079     uint64_t TargetCr3 = Process->PageDirectoryPhysical;\par
00080     {\cf19 if} (ApcState->SavedCr3 != TargetCr3) \{\par
00081         __write_cr3(TargetCr3);\par
00082     \}\par
00083 \}\par
00084 \par
00085 {\cf18 void}\par
00086 MeDetachProcess(\par
00087     IN PAPC_STATE ApcState\par
00088 )\par
00089 \par
00090 {\cf20 /*++}\par
00091 {\cf20 }\par
00092 {\cf20     Routine description:}\par
00093 {\cf20 }\par
00094 {\cf20         Detach from a process address space.}\par
00095 {\cf20 }\par
00096 {\cf20     Arguments:}\par
00097 {\cf20 }\par
00098 {\cf20         [IN]    PAPC_STATE ApcState - The APC_STATE stored by MeAttachProcess.}\par
00099 {\cf20 }\par
00100 {\cf20     Return Values:}\par
00101 {\cf20 }\par
00102 {\cf20         None.}\par
00103 {\cf20 }\par
00104 {\cf20 --*/}\par
00105 \par
00106 \{\par
00107     PITHREAD CurrentThread = MeGetCurrentThread();\par
00108     {\cf19 if} (unlikely(!CurrentThread)) {\cf19 return};\par
00109     {\cf19 if} (!ApcState->AttachedToProcess) {\cf19 return};\par
00110 \par
00111     {\cf20 // Restore original CR3.}\par
00112     uint64_t CurrentCr3 = __read_cr3();\par
00113     {\cf19 if} (CurrentCr3 != ApcState->SavedCr3) \{\par
00114         __write_cr3(ApcState->SavedCr3);\par
00115     \}\par
00116 \par
00117     {\cf20 // Restore thread's identity to original process.}\par
00118     CurrentThread->ApcState.SavedApcProcess = ApcState->SavedApcProcess;\par
00119     CurrentThread->ApcState.AttachedToProcess = ApcState->AttachedToProcess;\par
00120 \par
00121     {\cf20 // Restore scheduler lock / IRQL.}\par
00122     {\cf20 // TODO SYNCH LEVEL}\par
00123     MeReleaseSchedulerLock();\par
00124 \par
00125     {\cf20 // Clear attached state.}\par
00126     ApcState->AttachedToProcess = {\cf17 false};\par
00127 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/bugcheck.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/bugcheck.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/bugcheck.c}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../intrinsics/intrin.h"}\par
{\f2 #include "../../intrinsics/atomic.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/ps.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUG}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MeBugCheck} ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MeBugCheckEx} ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode, {\b IN} void *BugCheckParameter1, {\b IN} void *BugCheckParameter2, {\b IN} void *BugCheckParameter3, {\b IN} void *BugCheckParameter4)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBugChecking}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b smpInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_y}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEBUG\:bugcheck.c}
{\xe \v bugcheck.c\:DEBUG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUG}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b bugcheck.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MeBugCheck\:bugcheck.c}
{\xe \v bugcheck.c\:MeBugCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MeBugCheck ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b bugcheck.c}.}\par
}
{\xe \v MeBugCheckEx\:bugcheck.c}
{\xe \v bugcheck.c\:MeBugCheckEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MeBugCheckEx ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode, {\b IN} void * BugCheckParameter1, {\b IN} void * BugCheckParameter2, {\b IN} void * BugCheckParameter3, {\b IN} void * BugCheckParameter4)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 305} of file {\b bugcheck.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cursor_x\:bugcheck.c}
{\xe \v bugcheck.c\:cursor_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_x{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b gop.c}.}\par
}
{\xe \v cursor_y\:bugcheck.c}
{\xe \v bugcheck.c\:cursor_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_y{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b gop.c}.}\par
}
{\xe \v gop_local\:bugcheck.c}
{\xe \v bugcheck.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b gop.c}.}\par
}
{\xe \v isBugChecking\:bugcheck.c}
{\xe \v bugcheck.c\:isBugChecking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBugChecking{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global variables initialization \par
}{
Definition at line {\b 19} of file {\b kernel.c}.}\par
}
{\xe \v smpInitialized\:bugcheck.c}
{\xe \v bugcheck.c\:smpInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool smpInitialized{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bugcheck.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/bugcheck.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/bugcheck.c}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     Bugcheck functions implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/me.h"}\par
00008 {\cf21 #include "../../includes/mg.h"}\par
00009 {\cf21 #include "../../intrinsics/intrin.h"}\par
00010 {\cf21 #include "../../intrinsics/atomic.h"}\par
00011 {\cf21 #include "../../includes/mh.h"}\par
00012 {\cf21 #include "../../includes/ps.h"}\par
00013 \par
00014 {\cf21 #ifndef DEBUG}\par
00015 {\cf21 #define DEBUG}\par
00016 {\cf21 #endif}\par
00017 \par
00018  {\cf20 // We require GOP, so we extern it.}\par
00019 {\cf17 extern} GOP_PARAMS gop_local;\par
00020 {\cf17 extern} {\cf18 bool} isBugChecking;\par
00021 {\cf17 extern} {\cf18 bool} smpInitialized;\par
00022 \par
00023 {\cf17 extern} uint32_t cursor_x;\par
00024 {\cf17 extern} uint32_t cursor_y;\par
00025 \par
00026 {\cf20 // switched to uint64_t and not BUGCHECK_CODES since the custom ones arent in that enum, and compiler throws an error.}\par
00027 {\cf17 static} {\cf18 void} resolveStopCode({\cf18 char}** s, uint64_t stopcode) \{\par
00028     {\cf19 switch} (stopcode) \{\par
00029     {\cf19 case} DIVIDE_BY_ZERO:\par
00030         *s = {\cf22 "DIVIDE_BY_ZERO"};\par
00031         {\cf19 break};\par
00032     {\cf19 case} SINGLE_STEP:\par
00033         *s = {\cf22 "SINGLE_STEP"};\par
00034         {\cf19 break};\par
00035     {\cf19 case} NON_MASKABLE_INTERRUPT:\par
00036         *s = {\cf22 "NON_MASKABLE_INTERRUPT"};\par
00037         {\cf19 break};\par
00038     {\cf19 case} BREAKPOINT:\par
00039         *s = {\cf22 "BREAKPOINT"};\par
00040         {\cf19 break};\par
00041     {\cf19 case} OVERFLOW:\par
00042         *s = {\cf22 "OVERFLOW"};\par
00043         {\cf19 break};\par
00044     {\cf19 case} BOUNDS_CHECK:\par
00045         *s = {\cf22 "BOUNDS_CHECK"};\par
00046         {\cf19 break};\par
00047     {\cf19 case} INVALID_OPCODE:\par
00048         *s = {\cf22 "INVALID_OPCODE"};\par
00049         {\cf19 break};\par
00050     {\cf19 case} NO_COPROCESSOR:\par
00051         *s = {\cf22 "NO_COPROCESSOR"};\par
00052         {\cf19 break};\par
00053     {\cf19 case} DOUBLE_FAULT:\par
00054         *s = {\cf22 "DOUBLE_FAULT"};\par
00055         {\cf19 break};\par
00056     {\cf19 case} COPROCESSOR_SEGMENT_OVERRUN:\par
00057         *s = {\cf22 "COPROCESSOR_SEGMENT_OVERRUN"};\par
00058         {\cf19 break};\par
00059     {\cf19 case} INVALID_TSS:\par
00060         *s = {\cf22 "INVALID_TSS"};\par
00061         {\cf19 break};\par
00062     {\cf19 case} SEGMENT_SELECTOR_NOTPRESENT:\par
00063         *s = {\cf22 "SEGMENT_SELECTOR_NOTPRESENT"};\par
00064         {\cf19 break};\par
00065     {\cf19 case} STACK_SEGMENT_OVERRUN:\par
00066         *s = {\cf22 "STACK_SEGMENT_OVERRUN"};\par
00067         {\cf19 break};\par
00068     {\cf19 case} GENERAL_PROTECTION_FAULT:\par
00069         *s = {\cf22 "GENERAL_PROTECTION_FAULT"};\par
00070         {\cf19 break};\par
00071     {\cf19 case} PAGE_FAULT:\par
00072         *s = {\cf22 "PAGE_FAULT"};\par
00073         {\cf19 break};\par
00074     {\cf19 case} RESERVED:\par
00075         *s = {\cf22 "RESERVED"};\par
00076         {\cf19 break};\par
00077     {\cf19 case} FLOATING_POINT_ERROR:\par
00078         *s = {\cf22 "FLOATING_POINT_ERROR"};\par
00079         {\cf19 break};\par
00080     {\cf19 case} ALIGNMENT_CHECK:\par
00081         *s = {\cf22 "ALIGNMENT_CHECK"};\par
00082         {\cf19 break};\par
00083     {\cf19 case} SEVERE_MACHINE_CHECK:\par
00084         *s = {\cf22 "SEVERE_MACHINE_CHECK"};\par
00085         {\cf19 break};\par
00086     {\cf19 case} MEMORY_MAP_SIZE_OVERRUN:\par
00087         *s = {\cf22 "MEMORY_MAP_SIZE_OVERRUN"};\par
00088         {\cf19 break};\par
00089     {\cf19 case} MANUALLY_INITIATED_CRASH:\par
00090         *s = {\cf22 "MANUALLY_INITIATED_CRASH"};\par
00091         {\cf19 break};\par
00092     {\cf19 case} BAD_PAGING:\par
00093         *s = {\cf22 "BAD_PAGING"};\par
00094         {\cf19 break};\par
00095     {\cf19 case} BLOCK_DEVICE_LIMIT_REACHED:\par
00096         *s = {\cf22 "BLOCK_DEVICE_LIMIT_REACHED"};\par
00097         {\cf19 break};\par
00098     {\cf19 case} NULL_POINTER_DEREFERENCE:\par
00099         *s = {\cf22 "NULL_POINTER_DEREFERENCE"};\par
00100         {\cf19 break};\par
00101     {\cf19 case} FILESYSTEM_PANIC:\par
00102         *s = {\cf22 "FILESYSTEM_PANIC"};\par
00103         {\cf19 break};\par
00104     {\cf19 case} UNABLE_TO_INIT_TRACELASTFUNC:\par
00105         *s = {\cf22 "UNABLE_TO_INIT_TRACELASTFUNC"};\par
00106         {\cf19 break};\par
00107     {\cf19 case} FRAME_LIMIT_REACHED:\par
00108         *s = {\cf22 "FRAME_LIMIT_REACHED"};\par
00109         {\cf19 break};\par
00110     {\cf19 case} IRQL_NOT_LESS_OR_EQUAL:\par
00111         *s = {\cf22 "IRQL_NOT_LESS_OR_EQUAL"};\par
00112         {\cf19 break};\par
00113     {\cf19 case} INVALID_IRQL_SUPPLIED:\par
00114         *s = {\cf22 "INVALID_IRQL_SUPPLIED"};\par
00115         {\cf19 break};\par
00116     {\cf19 case} NULL_CTX_RECEIVED:\par
00117         *s = {\cf22 "NULL_CTX_RECEIVED"};\par
00118         {\cf19 break};\par
00119     {\cf19 case} THREAD_EXIT_FAILURE:\par
00120         *s = {\cf22 "THREAD_EXIT_FAILURE"};\par
00121         {\cf19 break};\par
00122     {\cf19 case} BAD_AHCI_COUNT:\par
00123         *s = {\cf22 "BAD_AHCI_COUNT"};\par
00124         {\cf19 break};\par
00125     {\cf19 case} AHCI_INIT_FAILED:\par
00126         *s = {\cf22 "AHCI_INIT_FAILED"};\par
00127         {\cf19 break};\par
00128     {\cf19 case} MEMORY_LIMIT_REACHED:\par
00129         *s = {\cf22 "MEMORY_LIMIT_REACHED"};\par
00130         {\cf19 break};\par
00131     {\cf19 case} HEAP_ALLOCATION_FAILED:\par
00132         *s = {\cf22 "HEAP_ALLOCATION_FAILED"};\par
00133         {\cf19 break};\par
00134     {\cf19 case} NULL_THREAD:\par
00135         *s = {\cf22 "NULL_THREAD"};\par
00136         {\cf19 break};\par
00137     {\cf19 case} FATAL_IRQL_CORRUPTION:\par
00138         *s = {\cf22 "FATAL_IRQL_CORRUPTION"};\par
00139         {\cf19 break};\par
00140     {\cf19 case} THREAD_ID_CREATION_FAILURE:\par
00141         *s = {\cf22 "THREAD_ID_CREATION_FAILURE"};\par
00142         {\cf19 break};\par
00143     {\cf19 case} ASSERTION_FAILURE:\par
00144         *s = {\cf22 "ASSERTION_FAILURE"};\par
00145         {\cf19 break};\par
00146     {\cf19 case} FRAME_ALLOCATION_FAILED:\par
00147         *s = {\cf22 "FRAME_ALLOCATION_FAILED"};\par
00148         {\cf19 break};\par
00149     {\cf19 case} FRAME_BITMAP_CREATION_FAILURE:\par
00150         *s = {\cf22 "FRAME_BITMAP_CREATION_FAILURE"};\par
00151         {\cf19 break};\par
00152     {\cf19 case} MEMORY_INVALID_FREE:\par
00153         *s = {\cf22 "MEMORY_INVALID_FREE"};\par
00154         {\cf19 break};\par
00155     {\cf19 case} MEMORY_CORRUPT_HEADER:\par
00156         *s = {\cf22 "MEMORY_CORRUPT_HEADER"};\par
00157         {\cf19 break};\par
00158     {\cf19 case} MEMORY_DOUBLE_FREE:\par
00159         *s = {\cf22 "MEMORY_DOUBLE_FREE"};\par
00160         {\cf19 break};\par
00161     {\cf19 case} MEMORY_CORRUPT_FOOTER:\par
00162         *s = {\cf22 "MEMORY_CORRUPT_FOOTER"};\par
00163         {\cf19 break};\par
00164     {\cf19 case} GUARD_PAGE_DEREFERENCE:\par
00165         *s = {\cf22 "GUARD_PAGE_DEREFERENCE"};\par
00166         {\cf19 break};\par
00167     {\cf19 case} IRQL_NOT_GREATER_OR_EQUAL:\par
00168         *s = {\cf22 "IRQL_NOT_GREATER_OR_EQUAL"};\par
00169         {\cf19 break};\par
00170     {\cf19 case} KERNEL_STACK_OVERFLOWN:\par
00171         *s = {\cf22 "KERNEL_STACK_OVERFLOWN"};\par
00172         {\cf19 break};\par
00173     {\cf19 case} BAD_POOL_CALLER:\par
00174         *s = {\cf22 "BAD_POOL_CALLER"};\par
00175         {\cf19 break};\par
00176     {\cf19 case} KMODE_EXCEPTION_NOT_HANDLED:\par
00177         *s = {\cf22 "KMODE_EXCEPTION_NOT_HANDLED"};\par
00178         {\cf19 break};\par
00179     {\cf19 case} ATTEMPTED_SWITCH_FROM_DPC:\par
00180         *s = {\cf22 "ATTEMPTED_SWITCH_FROM_DPC"};\par
00181         {\cf19 break};\par
00182     {\cf19 case} ATTEMPTED_WRITE_TO_READONLY_MEMORY:\par
00183         *s = {\cf22 "ATTEMPTED_WRITE_TO_READONLY_MEMORY"};\par
00184         {\cf19 break};\par
00185     {\cf19 case} PSMGR_INIT_FAILED:\par
00186         *s = {\cf22 "PSMGR_INIT_FAILED"};\par
00187         {\cf19 break};\par
00188     {\cf19 case} PAGE_FAULT_IN_FREED_NONPAGED_POOL:\par
00189         *s = {\cf22 "PAGE_FAULT_IN_FREED_NONPAGED_POOL"};\par
00190         {\cf19 break};\par
00191     {\cf19 case} PAGE_FAULT_IN_FREED_PAGED_POOL:\par
00192         *s = {\cf22 "PAGE_FAULT_IN_FREED_PAGED_POOL"};\par
00193         {\cf19 break};\par
00194     {\cf19 case} PSWORKER_INIT_FAILED:\par
00195         *s = {\cf22 "PSWORKER_INIT_FAILED"};\par
00196         {\cf19 break};\par
00197     {\cf19 case} MANUALLY_INITIATED_CRASH2:\par
00198         *s = {\cf22 "MANUALLY_INITIATED_CRASH2"};\par
00199         {\cf19 break};\par
00200     {\cf19 case} DPC_NOT_INITIALIZED:\par
00201         *s = {\cf22 "DPC_NOT_INITIALIZED"};\par
00202         {\cf19 break};\par
00203     {\cf19 case} INVALID_PROCESS_ATTACH_ATTEMPT:\par
00204         *s = {\cf22 "INVALID_PROCESS_ATTACH_ATTEMPT"};\par
00205         {\cf19 break};\par
00206     {\cf19 default}:\par
00207         *s = {\cf22 "UNKNOWN_BUGCHECK_CODE"};\par
00208         {\cf19 break};\par
00209     \}\par
00210 \}\par
00211 \par
00212 NORETURN\par
00213 {\cf18 void}\par
00214 MeBugCheck(\par
00215     IN {\cf17 enum} _BUGCHECK_CODES BugCheckCode\par
00216 )\par
00217 \par
00218 {\cf20 /*++}\par
00219 {\cf20 }\par
00220 {\cf20     Routine description : Gracefully crashes the system.}\par
00221 {\cf20 }\par
00222 {\cf20     Arguments:}\par
00223 {\cf20 }\par
00224 {\cf20         [IN]    enum _BUGCHECK_CODES BugCheckCode}\par
00225 {\cf20 }\par
00226 {\cf20     Return Values:}\par
00227 {\cf20 }\par
00228 {\cf20         None - This function does not return to caller.}\par
00229 {\cf20 }\par
00230 {\cf20 --*/}\par
00231 \par
00232 \{\par
00233     {\cf20 // Critical system error, instead of triple faulting, we hang the system with specified error codes.}\par
00234     {\cf19 if} (smpInitialized) \{\par
00235         {\cf20 // If all other cores are online, we obviously want to stop them.}\par
00236         IPI_PARAMS dummy = \{ 0 \};\par
00237         MhSendActionToCpusAndWait(CPU_ACTION_STOP, dummy);\par
00238     \}\par
00239     {\cf20 // Disable interrupts if they werent disabled before.}\par
00240     __cli();\par
00241 \par
00242     {\cf20 // atomically check & set isBugChecking}\par
00243     {\cf18 bool} prev = InterlockedExchangeBool(&isBugChecking, {\cf17 true});\par
00244 \par
00245     {\cf19 if} (prev == 1) \{\par
00246         __hlt();   {\cf20 // someone set isBugChecking before us, we just halt, let em do their thing.}\par
00247     \}\par
00248 \par
00249     {\cf20 // Acquire exclusive ownership to this processor for framebuffer access.}\par
00250     MgAcquireExclusiveGopOwnerShip();\par
00251 \par
00252 {\cf21 #ifdef DEBUG}\par
00253     IRQL recordedIrql = MeGetCurrentProcessor()->currentIrql;\par
00254 {\cf21 #endif}\par
00255     {\cf20 // Force to be redrawn from the top, instead of last place.}\par
00256     cursor_x = 0;\par
00257     cursor_y = 0;\par
00258     _MeSetIrql(HIGH_LEVEL); {\cf20 // SET the irql to high level (not raise) (we could raise, but this takes less cycles and so is faster) (previous comment was setting an IRQL to each CPU Core, instead, we send an IPI up top)}\par
00259 \par
00260     {\cf20 // Clear the screen to blue (bsod windows style)}\par
00261     gop_clear_screen(&gop_local, 0xFF0035b8);\par
00262     {\cf20 // Write some debugging and an error message}\par
00263     gop_printf(0xFFFFFFFF, {\cf22 "FATAL ERROR: Your system has encountered a fatal error.\\n\\n"});\par
00264     gop_printf(0xFFFFFFFF, {\cf22 "Your system has been stopped for safety.\\n\\n"});\par
00265     {\cf18 char}* stopCodeToStr = {\cf22 ""}; {\cf20 // empty at first.}\par
00266     resolveStopCode(&stopCodeToStr, BugCheckCode);\par
00267     gop_printf(0xFFFFFFFF, {\cf22 "**STOP CODE: "});\par
00268     gop_printf(0xFF8B0000, {\cf22 "%s"}, stopCodeToStr);\par
00269     gop_printf(0xFF00FF00, {\cf22 " (numerical: %d)**\\n"}, BugCheckCode);\par
00270 {\cf21 #ifdef DEBUG}\par
00271     gop_printf(0xFFFFA500, {\cf22 "**Last IRQL: %d**\\n"}, recordedIrql);\par
00272     gop_printf(0xFFFFA500, {\cf22 "DPC Active: %s\\n"}, (MeGetCurrentProcessor()->DpcRoutineActive) ? {\cf22 "Yes"} : {\cf22 "No"});\par
00273 {\cf21 #endif}\par
00274     HANDLE currTid = (MeGetCurrentProcessor()->currentThread) ? PsGetCurrentThread()->TID : (HANDLE)-1;\par
00275     gop_printf(0xFFFFFF00, {\cf22 "Current Thread ID: %d\\n"}, currTid);\par
00276     {\cf19 if} (smpInitialized) \{\par
00277         gop_printf(COLOR_LIME, {\cf22 "Sent IPI To all CPUs to HALT.\\n"});\par
00278         gop_printf(COLOR_LIME, {\cf22 "Current Executing CPU: %d\\n"}, MeGetCurrentProcessor()->lapic_ID);\par
00279     \}\par
00280 {\cf21 #ifdef DEBUG}\par
00281     {\cf20 // Thread information}\par
00282     PETHREAD CurrentThread = PsGetCurrentThread();\par
00283     {\cf19 if} (CurrentThread) \{\par
00284         {\cf20 // Display thread debug info}\par
00285         uintptr_t StackBase = (uintptr_t)CurrentThread->InternalThread.StackBase; {\cf20 // high address}\par
00286         uintptr_t StackSize = (CurrentThread->InternalThread.IsLargeStack) ? MI_LARGE_STACK_SIZE : MI_STACK_SIZE;\par
00287         uintptr_t StackLimit = StackBase - StackSize; {\cf20 // low address (bottom of stack)}\par
00288         uintptr_t ThreadTop = (uintptr_t)CurrentThread->InternalThread.TrapRegisters.rsp;\par
00289         gop_printf(COLOR_WHITE, {\cf22 "Thread Stack Range | %p - %p | Last saved top: %p\\n"}, ({\cf18 void}*)StackLimit, ({\cf18 void}*)StackBase, ({\cf18 void}*)ThreadTop);\par
00290         gop_printf(COLOR_YELLOW, {\cf22 "PreviousMode: %s\\n"}, (MeGetPreviousMode() == KernelMode) ? {\cf22 "KernelMode"} : {\cf22 "UserMode"});\par
00291     \}\par
00292 {\cf21 #endif}\par
00293     gop_printf(COLOR_YELLOW, {\cf22 "Current CR3: %p\\n"}, ({\cf18 void}*)(uintptr_t)__read_cr3());\par
00294     gop_printf(COLOR_YELLOW, {\cf22 "Current stack top: %p\\n"}, ({\cf18 void}*)(uintptr_t)__read_rsp());\par
00295     __cli();\par
00296     {\cf19 while} (1) \{\par
00297         __hlt();\par
00298         __pause();\par
00299     \}\par
00300 \}\par
00301 \par
00302 \par
00303 NORETURN\par
00304 {\cf18 void} \par
00305 MeBugCheckEx (\par
00306     IN {\cf17 enum} _BUGCHECK_CODES    BugCheckCode,\par
00307     IN {\cf18 void}* BugCheckParameter1,\par
00308     IN {\cf18 void}* BugCheckParameter2,\par
00309     IN {\cf18 void}* BugCheckParameter3,\par
00310     IN {\cf18 void}* BugCheckParameter4\par
00311 ) \par
00312 \par
00313 {\cf20 /*++}\par
00314 {\cf20 }\par
00315 {\cf20     Routine description : Gracefully crashes the system, supplies parameters for debugging by the developer.}\par
00316 {\cf20 }\par
00317 {\cf20     Arguments:}\par
00318 {\cf20 }\par
00319 {\cf20         [IN]    enum _BUGCHECK_CODES BugCheckCode}\par
00320 {\cf20         [IN]    void* BugCheckParameter1}\par
00321 {\cf20         [IN]    void* BugCheckParameter2}\par
00322 {\cf20         [IN]    void* BugCheckParameter3}\par
00323 {\cf20         [IN]    void* BugCheckParameter4}\par
00324 {\cf20 }\par
00325 {\cf20     Return Values:}\par
00326 {\cf20 }\par
00327 {\cf20         None - This function does not return to caller.}\par
00328 {\cf20 }\par
00329 {\cf20     TODO:}\par
00330 {\cf20 }\par
00331 {\cf20         Add minidumps if the filesystem is initialized.}\par
00332 {\cf20 }\par
00333 {\cf20 --*/}\par
00334 \par
00335 \{\par
00336     {\cf20 // Critical system error, instead of triple faulting, we hang the system with specified error codes.}\par
00337     {\cf20 // Disable interrupts if they werent disabled before.}\par
00338     __cli();\par
00339     {\cf19 if} (smpInitialized) \{\par
00340         {\cf20 // If all other cores are online, we obviously want to stop them.}\par
00341         IPI_PARAMS dummy = \{ 0 \};\par
00342         MhSendActionToCpusAndWait(CPU_ACTION_STOP, dummy);\par
00343     \}\par
00344 \par
00345     {\cf20 // atomically check & set isBugChecking}\par
00346     {\cf18 bool} prev = InterlockedExchangeBool(&isBugChecking, {\cf17 true});\par
00347 \par
00348     {\cf19 if} (prev == 1) \{\par
00349         {\cf19 while} (1) __hlt();\par
00350     \}\par
00351 \par
00352     {\cf20 // Acquire exclusive ownership to this processor for framebuffer access.}\par
00353     MgAcquireExclusiveGopOwnerShip();\par
00354 \par
00355 {\cf21 #ifdef DEBUG}\par
00356     IRQL recordedIrql = MeGetCurrentProcessor()->currentIrql;\par
00357 {\cf21 #endif}\par
00358     {\cf20 // Force to be redrawn from the top, instead of last place.}\par
00359     cursor_x = 0;\par
00360     cursor_y = 0;\par
00361     _MeSetIrql(HIGH_LEVEL); {\cf20 // SET the irql to high level (not raise) (we could raise, but this takes less cycles and so is faster)}\par
00362 \par
00363     {\cf20 // Clear the screen to blue (bsod windows style)}\par
00364     gop_clear_screen(&gop_local, 0xFF0035b8);\par
00365     {\cf20 // Write some debugging and an error message}\par
00366     gop_printf(0xFFFFFFFF, {\cf22 "FATAL ERROR: Your system has encountered a fatal error.\\n\\n"});\par
00367     gop_printf(0xFFFFFFFF, {\cf22 "Your system has been stopped for safety.\\n\\n"});\par
00368     {\cf18 char}* stopCodeToStr = {\cf22 ""}; {\cf20 // empty at first.}\par
00369     resolveStopCode(&stopCodeToStr, BugCheckCode);\par
00370     gop_printf(0xFFFFFFFF, {\cf22 "**STOP CODE: "});\par
00371     gop_printf(0xFF8B0000, {\cf22 "%s"}, stopCodeToStr);\par
00372     gop_printf(0xFF00FF00, {\cf22 " (numerical: %d)**\\n"}, BugCheckCode);\par
00373     \{\par
00374 {\cf21 #ifdef DEBUG}\par
00375         {\cf19 if} (BugCheckCode == ASSERTION_FAILURE) \{\par
00376             {\cf20 // Print expression, reason, file, line.}\par
00377             gop_printf(COLOR_WHITE,\par
00378                 {\cf22 "Expression: %s\\n"}\par
00379                 {\cf22 "Reason: %s\\n"}\par
00380                 {\cf22 "File: %s\\n"}\par
00381                 {\cf22 "Line: %lld\\n"}, {\cf20 // Changed to %d since assert_fail passes a decimal number and not a char ptr.}\par
00382                 ({\cf18 char}*)BugCheckParameter1,\par
00383                 ({\cf18 char}*)BugCheckParameter2,\par
00384                 ({\cf18 char}*)BugCheckParameter3,\par
00385                 ({\cf18 long} {\cf18 long})(intptr_t)BugCheckParameter4);\par
00386         \}\par
00387         {\cf19 else} \{\par
00388 {\cf21 #endif}\par
00389             {\cf20 // Print parameters.}\par
00390             gop_printf(COLOR_WHITE,\par
00391                 {\cf22 "Parameter 1: (Pointer: %p | Decimal: %lld | Pure Hex: %llx)\\n"}\par
00392                 {\cf22 "Parameter 2: (Pointer: %p | Decimal: %lld | Pure Hex: %llx)\\n"}\par
00393                 {\cf22 "Parameter 3: (Pointer: %p | Decimal: %lld | Pure Hex: %llx)\\n"}\par
00394                 {\cf22 "Parameter 4: (Pointer: %p | Decimal: %lld | Pure Hex: %llx)\\n"},\par
00395                 ({\cf18 void}*)(uintptr_t)BugCheckParameter1, ({\cf18 long} {\cf18 long})(intptr_t)BugCheckParameter1, ({\cf18 unsigned} {\cf18 long} {\cf18 long})(uintptr_t)BugCheckParameter1,\par
00396                 ({\cf18 void}*)(uintptr_t)BugCheckParameter2, ({\cf18 long} {\cf18 long})(intptr_t)BugCheckParameter2, ({\cf18 unsigned} {\cf18 long} {\cf18 long})(uintptr_t)BugCheckParameter2,\par
00397                 ({\cf18 void}*)(uintptr_t)BugCheckParameter3, ({\cf18 long} {\cf18 long})(intptr_t)BugCheckParameter3, ({\cf18 unsigned} {\cf18 long} {\cf18 long})(uintptr_t)BugCheckParameter3,\par
00398                 ({\cf18 void}*)(uintptr_t)BugCheckParameter4, ({\cf18 long} {\cf18 long})(intptr_t)BugCheckParameter4, ({\cf18 unsigned} {\cf18 long} {\cf18 long})(uintptr_t)BugCheckParameter4);\par
00399 {\cf21 #ifdef DEBUG}\par
00400         \}\par
00401 {\cf21 #endif}\par
00402     \}\par
00403 {\cf21 #ifdef DEBUG}\par
00404     gop_printf(0xFFFFA500, {\cf22 "**Last IRQL: %d**\\n"}, recordedIrql);\par
00405     gop_printf(0xFFFFA500, {\cf22 "DPC Active: %s\\n"}, (MeGetCurrentProcessor()->DpcRoutineActive) ? {\cf22 "Yes"} : {\cf22 "No"});\par
00406 {\cf21 #endif}\par
00407     HANDLE currTid = (MeGetCurrentProcessor()->currentThread) ? PsGetCurrentThread()->TID : (HANDLE)-1;\par
00408     gop_printf(0xFFFFFF00, {\cf22 "Current Thread ID: %d\\n"}, currTid);\par
00409     {\cf19 if} (smpInitialized) \{\par
00410         gop_printf(COLOR_LIME, {\cf22 "Sent IPI To all CPUs to HALT.\\n"});\par
00411         gop_printf(COLOR_LIME, {\cf22 "Current Executing CPU: %d\\n"}, MeGetCurrentProcessor()->lapic_ID);\par
00412     \}\par
00413 {\cf21 #ifdef DEBUG}\par
00414     {\cf20 // Thread information}\par
00415     PETHREAD CurrentThread = PsGetCurrentThread();\par
00416     {\cf19 if} (CurrentThread) \{\par
00417         {\cf20 // Display thread debug info}\par
00418         uintptr_t StackBase = (uintptr_t)CurrentThread->InternalThread.StackBase; {\cf20 // high address}\par
00419         uintptr_t StackSize = (CurrentThread->InternalThread.IsLargeStack) ? MI_LARGE_STACK_SIZE : MI_STACK_SIZE;\par
00420         uintptr_t StackLimit = StackBase - StackSize; {\cf20 // low address (bottom of stack)}\par
00421         uintptr_t ThreadTop = (uintptr_t)CurrentThread->InternalThread.TrapRegisters.rsp;\par
00422         gop_printf(COLOR_WHITE, {\cf22 "Thread Stack Range | %p - %p | Last saved top: %p\\n"}, ({\cf18 void}*)StackLimit, ({\cf18 void}*)StackBase, ({\cf18 void}*)ThreadTop);\par
00423         gop_printf(COLOR_YELLOW, {\cf22 "PreviousMode: %s\\n"}, (MeGetPreviousMode() == KernelMode) ? {\cf22 "KernelMode"} : {\cf22 "UserMode"});\par
00424     \}\par
00425     gop_printf(COLOR_YELLOW, {\cf22 "Current CR3: %p\\n"}, ({\cf18 void}*)(uintptr_t)__read_cr3());\par
00426     gop_printf(COLOR_YELLOW, {\cf22 "Current stack top: %p\\n"}, ({\cf18 void}*)(uintptr_t)__read_rsp());\par
00427 {\cf21 #endif}\par
00428     __cli();\par
00429     {\cf19 while} (1) \{\par
00430         __hlt();\par
00431         __pause();\par
00432     \}\par
00433 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/dpc.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/dpc.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/dpc.c}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/ob.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReapOb} ({\b DPC} *dpc, void *DeferredContext, void *SystemArgument1, void *SystemArgument2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeInsertQueueDpc} ({\b IN} {\b PDPC} Dpc, {\b IN} void *SystemArgument1, {\b IN} void *SystemArgument2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeRemoveQueueDpc} ({\b IN} {\b PDPC} Dpc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeRetireDPCs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeSetTargetProcessorDpc} ({\b IN} {\b PDPC} Dpc, {\b IN} uint32_t CpuNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeInitializeDpc} ({\b IN} {\b PDPC} DpcAllocated, {\b IN} {\b PDEFERRED_ROUTINE} DeferredRoutine, {\b IN} void *DeferredContext, {\b IN} {\b DPC_PRIORITY} DeferredPriority)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile void * {\b ObpReaperList}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MeInitializeDpc\:dpc.c}
{\xe \v dpc.c\:MeInitializeDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeInitializeDpc ({\b IN} {\b PDPC} DpcAllocated, {\b IN} {\b PDEFERRED_ROUTINE} DeferredRoutine, {\b IN} void * DeferredContext, {\b IN} {\b DPC_PRIORITY} DeferredPriority)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 384} of file {\b dpc.c}.}\par
}
{\xe \v MeInsertQueueDpc\:dpc.c}
{\xe \v dpc.c\:MeInsertQueueDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeInsertQueueDpc ({\b IN} {\b PDPC} Dpc, {\b IN} void * SystemArgument1, {\b IN} void * SystemArgument2)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b dpc.c}.}\par
}
{\xe \v MeRemoveQueueDpc\:dpc.c}
{\xe \v dpc.c\:MeRemoveQueueDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeRemoveQueueDpc ({\b IN} {\b PDPC} Dpc)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b dpc.c}.}\par
}
{\xe \v MeRetireDPCs\:dpc.c}
{\xe \v dpc.c\:MeRetireDPCs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeRetireDPCs (void )}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 222} of file {\b dpc.c}.}\par
}
{\xe \v MeSetTargetProcessorDpc\:dpc.c}
{\xe \v dpc.c\:MeSetTargetProcessorDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeSetTargetProcessorDpc ({\b IN} {\b PDPC} Dpc, {\b IN} uint32_t CpuNumber)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b dpc.c}.}\par
}
{\xe \v ReapOb\:dpc.c}
{\xe \v dpc.c\:ReapOb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ReapOb ({\b DPC} * dpc, void * DeferredContext, void * SystemArgument1, void * SystemArgument2)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b dpc.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ObpReaperList\:dpc.c}
{\xe \v dpc.c\:ObpReaperList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* ObpReaperList{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ob.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dpc.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/dpc.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/dpc.c}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      DPC Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/me.h"}\par
00008 {\cf21 #include "../../includes/mg.h"}\par
00009 {\cf21 #include "../../includes/ps.h"}\par
00010 {\cf21 #include "../../includes/mh.h"}\par
00011 {\cf21 #include "../../assert.h"}\par
00012 {\cf21 #include "../../includes/ob.h"}\par
00013 \par
00014 {\cf20 //Statically made DPC Routines.}\par
00015 \par
00016 {\cf17 extern} {\cf17 volatile} {\cf18 void}* ObpReaperList;\par
00017 \par
00018 {\cf18 void} ReapOb(DPC* dpc, {\cf18 void}* DeferredContext, {\cf18 void}* SystemArgument1, {\cf18 void}* SystemArgument2) \{\par
00019     {\cf20 /*}\par
00020 {\cf20     DeferredContext - Ignored}\par
00021 {\cf20     SystemArgument1 - Ignored}\par
00022 {\cf20     SystemArgument2 - Ignored}\par
00023 {\cf20     */}\par
00024 \par
00025     POBJECT_HEADER head, cur;\par
00026 \par
00027     UNREFERENCED_PARAMETER(DeferredContext);\par
00028     UNREFERENCED_PARAMETER(SystemArgument1);\par
00029     UNREFERENCED_PARAMETER(SystemArgument2);\par
00030     UNREFERENCED_PARAMETER(dpc); {\cf20 // Switched to global, freeing this would cause in MEMORY_CORRUPT_HEADER.}\par
00031 \par
00032     {\cf20 // Atomically take the list}\par
00033     head = (POBJECT_HEADER)InterlockedExchangePointer(&ObpReaperList, NULL);\par
00034 \par
00035     {\cf20 // Walk the captured chain and free each header}\par
00036     {\cf19 while} (head) \{\par
00037         cur = head;\par
00038         head = (POBJECT_HEADER)head->NextToFree;\par
00039         MmFreePool(cur); {\cf20 // Free the header (frees object as well, header + sizeof(header) = object)}\par
00040     \}\par
00041 \par
00042 \}\par
00043 \par
00044 {\cf20 //End}\par
00045 \par
00046 {\cf18 bool}\par
00047 MeInsertQueueDpc(\par
00048     IN PDPC Dpc,\par
00049     IN {\cf18 void}* SystemArgument1,\par
00050     IN {\cf18 void}* SystemArgument2\par
00051 )\par
00052 \par
00053 {\cf20 /*++}\par
00054 {\cf20 }\par
00055 {\cf20     Routine description:}\par
00056 {\cf20 }\par
00057 {\cf20         This function inserts the DPC object into the DPC queue.}\par
00058 {\cf20         If the DPC object is already in the queue, nothing is performed.}\par
00059 {\cf20         Else, the DPC Object is inserted in the queue, and a software interrupt is generated based on the DPC priority & current depth.}\par
00060 {\cf20 }\par
00061 {\cf20         For setting a certain CPU to run this DPC, use the MeSetTargetProcessorDpc function before calling this one.}\par
00062 {\cf20 }\par
00063 {\cf20     Arguments:}\par
00064 {\cf20 }\par
00065 {\cf20         [IN]    PDPC Dpc - The DPC Object to queue.}\par
00066 {\cf20         [IN]    void* SystemArgument1 - Optional Argument for the DPC to receive.}\par
00067 {\cf20         [IN]    void* SystemArgument2 - Optional Argument for the DPC to receive.}\par
00068 {\cf20 }\par
00069 {\cf20     Return Values:}\par
00070 {\cf20 }\par
00071 {\cf20         If the DPC objeect is already in the queue, false is returned.}\par
00072 {\cf20         Otherwise, true is returned.}\par
00073 {\cf20 }\par
00074 {\cf20 --*/}\par
00075 \par
00076 \{\par
00077     {\cf20 // Declarations}\par
00078     PDPC_DATA DpcData;\par
00079     PPROCESSOR Cpu;\par
00080     {\cf18 bool} Inserted = {\cf17 false};\par
00081     IRQL OldIrql;\par
00082 \par
00083     {\cf19 if} (!Dpc->DeferredRoutine) \{\par
00084 {\cf21 #ifdef DEBUG}\par
00085         MeBugCheckEx(DPC_NOT_INITIALIZED,\par
00086             ({\cf18 void}*)(uintptr_t)RETADDR(0),\par
00087             ({\cf18 void}*)Dpc,\par
00088             NULL,\par
00089             NULL\par
00090         );\par
00091 {\cf21 #else}\par
00092         MeBugCheckEx(DPC_NOT_INITIALIZED,\par
00093             ({\cf18 void}*)Dpc,\par
00094             NULL,\par
00095             NULL,\par
00096             NULL\par
00097         );\par
00098 {\cf21 #endif}\par
00099     \}\par
00100 \par
00101     {\cf20 // Raise IRQL to HIGH_LEVEL to prevent all interrupts while we touch the processor DPC queue. (prevent corruption)}\par
00102     MeRaiseIrql(HIGH_LEVEL, &OldIrql);\par
00103 \par
00104     {\cf19 if} (Dpc->CpuNumber < MeGetActiveProcessorCount()) \{\par
00105         Cpu = MeGetProcessorBlock(Dpc->CpuNumber);\par
00106     \}\par
00107     {\cf19 else} \{\par
00108         Cpu = MeGetCurrentProcessor();\par
00109     \}\par
00110 \par
00111     DpcData = &Cpu->DpcData;\par
00112 \par
00113     {\cf20 // Acquire the DpcData lock for the current processor.}\par
00114     MsAcquireSpinlockAtDpcLevel(&DpcData->DpcLock);\par
00115 \par
00116     {\cf20 // Atomic operation to check if this DPC is already queued.}\par
00117     {\cf19 if} (InterlockedCompareExchangePointer(&Dpc->DpcData, DpcData, NULL) == NULL) \{\par
00118 \par
00119         {\cf20 // Success: It was not queued.}\par
00120         DpcData->DpcQueueDepth += 1;\par
00121         DpcData->DpcCount += 1;\par
00122         Dpc->SystemArgument1 = SystemArgument1;\par
00123         Dpc->SystemArgument2 = SystemArgument2;\par
00124 \par
00125         {\cf20 // Insert Head (High Priority) or Tail (Normal)}\par
00126         {\cf19 if} (Dpc->priority == HIGH_PRIORITY) \{\par
00127             InsertHeadList(&DpcData->DpcListHead, &Dpc->DpcListEntry);\par
00128         \}\par
00129         {\cf19 else} \{\par
00130             InsertTailList(&DpcData->DpcListHead, &Dpc->DpcListEntry);\par
00131         \}\par
00132 \par
00133         Inserted = {\cf17 true};\par
00134         {\cf20 // Increment request rate}\par
00135         Cpu->DpcRequestRate++;\par
00136 \par
00137         {\cf20 // Check if we need to request an interurpt}\par
00138         {\cf20 // We only request if a DPC isnt currently running.}\par
00139         {\cf20 // And we haven't already requested an interrupt for a DPC.}\par
00140         {\cf19 if} ((Cpu->DpcRoutineActive == {\cf17 false}) &&\par
00141             (Cpu->DpcInterruptRequested == {\cf17 false})) \{\par
00142 \par
00143             {\cf20 // If the DPC priority is higher than lowest, or we are to deep in the queue depth, retire DPCs immediately.}\par
00144             {\cf19 if} ((Dpc->priority != LOW_PRIORITY) ||\par
00145                 (DpcData->DpcQueueDepth >= Cpu->MaximumDpcQueueDepth)) \{\par
00146 \par
00147                 {\cf20 // Always mark that an interrupt is needed eventually}\par
00148                 Cpu->DpcInterruptRequested = {\cf17 true};\par
00149 \par
00150                 {\cf20 // Cannot request an interrupt on DISPATCH_LEVEL already.}\par
00151                 {\cf19 if} (MeGetCurrentIrql() < DISPATCH_LEVEL) \{\par
00152                     {\cf20 // Request an interrupt from HAL.}\par
00153                     MhRequestSoftwareInterrupt(DISPATCH_LEVEL);\par
00154                 \}\par
00155             \}\par
00156         \}\par
00157     \}\par
00158 \par
00159     {\cf20 // Release Lock and Restore IRQL}\par
00160     MsReleaseSpinlockFromDpcLevel(&DpcData->DpcLock);\par
00161     MeLowerIrql(OldIrql);\par
00162 \par
00163     {\cf19 return} Inserted;\par
00164 \}\par
00165 \par
00166 {\cf18 bool}\par
00167 MeRemoveQueueDpc(\par
00168     IN PDPC Dpc\par
00169 )\par
00170 \par
00171 {\cf20 /*++}\par
00172 {\cf20 }\par
00173 {\cf20     Routine description:}\par
00174 {\cf20 }\par
00175 {\cf20         This function removes the Dpc object from the DPC Queue.}\par
00176 {\cf20         If the DPC object is NOT in the DPC queue, nothing is performed.}\par
00177 {\cf20         Otherwise, the DPC object is removed from the queue, and its inserted state (DpcData), is NULL (false).}\par
00178 {\cf20 }\par
00179 {\cf20     Arguments:}\par
00180 {\cf20 }\par
00181 {\cf20         [IN]    PDPC Dpc - The DPC Object to remove from queue.}\par
00182 {\cf20 }\par
00183 {\cf20     Return Values:}\par
00184 {\cf20 }\par
00185 {\cf20         If the DPC object is not in the queue, false is returned.}\par
00186 {\cf20         Otherwise, true is returned.}\par
00187 {\cf20 }\par
00188 {\cf20 --*/}\par
00189 \par
00190 \{\par
00191     PDPC_DATA DpcData;\par
00192     {\cf18 bool} Enable;\par
00193     {\cf18 bool} Removed = {\cf17 false};\par
00194 \par
00195     {\cf20 // Disable interrupts manually since we aren't raising IRQL yet}\par
00196     Enable = MeDisableInterrupts();\par
00197 \par
00198     DpcData = (PDPC_DATA)Dpc->DpcData;\par
00199 \par
00200     {\cf19 if} (DpcData != NULL) \{\par
00201         {\cf20 // Acquire Lock}\par
00202         MsAcquireSpinlockAtDpcLevel(&DpcData->DpcLock);\par
00203 \par
00204         {\cf20 // Check if still queued}\par
00205         {\cf19 if} (DpcData == Dpc->DpcData) \{\par
00206             DpcData->DpcQueueDepth -= 1;\par
00207             RemoveEntryList(&Dpc->DpcListEntry);\par
00208             Dpc->DpcData = NULL; {\cf20 // Mark as not queued}\par
00209             Removed = {\cf17 true};\par
00210         \}\par
00211 \par
00212         {\cf20 // Release Lock}\par
00213         MsReleaseSpinlockFromDpcLevel(&DpcData->DpcLock);\par
00214     \}\par
00215 \par
00216     {\cf20 // Restore Interrupts}\par
00217     MeEnableInterrupts(Enable);\par
00218     {\cf19 return} Removed;\par
00219 \}\par
00220 \par
00221 {\cf18 void}\par
00222 MeRetireDPCs(\par
00223     {\cf18 void}\par
00224 )\par
00225 \par
00226 {\cf20 /*++}\par
00227 {\cf20 }\par
00228 {\cf20     Routine description:}\par
00229 {\cf20 }\par
00230 {\cf20         This function retires the DPC list for the current processor, and also processes timer expiration (first).}\par
00231 {\cf20 }\par
00232 {\cf20     Arguments:}\par
00233 {\cf20 }\par
00234 {\cf20         None.}\par
00235 {\cf20 }\par
00236 {\cf20     Return Values:}\par
00237 {\cf20 }\par
00238 {\cf20         None.}\par
00239 {\cf20 }\par
00240 {\cf20     Notes:}\par
00241 {\cf20         }\par
00242 {\cf20         This function is entered with interrupts disabled ( __cli() ), and exits with interrupts disabled.}\par
00243 {\cf20 }\par
00244 {\cf20 --*/}\par
00245 \par
00246 \{\par
00247 {\cf21 #ifdef DEBUG}\par
00248     gop_printf(COLOR_WHITE, {\cf22 "Retiring DPCs!\\n"});\par
00249 {\cf21 #endif}\par
00250     {\cf20 // Few assertions.}\par
00251     assert(MeGetCurrentIrql() == DISPATCH_LEVEL);\par
00252     assert(MeAreInterruptsEnabled() == {\cf17 false});\par
00253 \par
00254     {\cf20 // Declarations}\par
00255     PDPC Dpc;\par
00256     PDPC_DATA DpcData;\par
00257     PDOUBLY_LINKED_LIST Entry;\par
00258     PDEFERRED_ROUTINE DeferredRoutine;\par
00259     {\cf18 void}* DeferredContext;\par
00260     {\cf18 void}* SystemArgument1;\par
00261     {\cf18 void}* SystemArgument2;\par
00262     uintptr_t TimerHand;\par
00263     PPROCESSOR Cpu = MeGetCurrentProcessor();\par
00264 \par
00265     DpcData = &Cpu->DpcData;\par
00266 \par
00267     {\cf20 // Outer Loop: Process until queue is empty}\par
00268     {\cf19 do} \{\par
00269         Cpu->DpcRoutineActive = {\cf17 true};\par
00270 \par
00271         {\cf20 // Process Timer Expiration -- Unused for now, until we introduce MsWaitForSingleObject (will replace MsWaitForEvent n stuff), and also MeDelayExecutionThread}\par
00272         {\cf20 /*}\par
00273 {\cf20         if (Cpu->TimerRequest != 0) \{}\par
00274 {\cf20             TimerHand = Cpu->TimerHand;}\par
00275 {\cf20             Cpu->TimerRequest = 0;}\par
00276 {\cf20 }\par
00277 {\cf20             __sti(); // Enable interrupts for timer processing}\par
00278 {\cf20             MeTimerExpiration(TimerHand);}\par
00279 {\cf20             __cli(); // Disable again}\par
00280 {\cf20         \}}\par
00281 {\cf20         */}\par
00282         UNREFERENCED_PARAMETER(TimerHand);\par
00283 \par
00284         {\cf20 // Process DPC Queue}\par
00285         {\cf19 if} (DpcData->DpcQueueDepth != 0) \{\par
00286 \par
00287             {\cf20 // Inner Loop: Pop one, run one}\par
00288             {\cf19 do} \{\par
00289                 {\cf20 // Lock}\par
00290                 MsAcquireSpinlockAtDpcLevel(&DpcData->DpcLock);\par
00291 \par
00292                 Entry = DpcData->DpcListHead.Flink;\par
00293 \par
00294                 {\cf19 if} (Entry != &DpcData->DpcListHead) \{\par
00295                     {\cf20 // Remove from List}\par
00296                     RemoveEntryList(Entry);\par
00297                     Dpc = CONTAINING_RECORD(Entry, DPC, DpcListEntry);\par
00298                     {\cf20 // Capture Context}\par
00299                     DeferredRoutine = Dpc->DeferredRoutine;\par
00300                     DeferredContext = Dpc->DeferredContext;\par
00301                     SystemArgument1 = Dpc->SystemArgument1;\par
00302                     SystemArgument2 = Dpc->SystemArgument2;\par
00303 \par
00304                     {\cf20 // Changes must be set before others can modify.}\par
00305                     MmFullBarrier();\par
00306 \par
00307                     {\cf20 // Clear DpcData so it can be re-queued inside its own routine}\par
00308                     Dpc->DpcData = NULL;\par
00309                     DpcData->DpcQueueDepth -= 1;\par
00310 \par
00311                     {\cf20 // Release Lock}\par
00312                     MsReleaseSpinlockFromDpcLevel(&DpcData->DpcLock);\par
00313 \par
00314                     {\cf20 // Enable Interrupts for execution}\par
00315                     __sti();\par
00316 \par
00317                     {\cf20 // Execute}\par
00318                     Cpu->CurrentDeferredRoutine = Dpc;\par
00319 {\cf21 #ifdef DEBUG}\par
00320                     gop_printf(COLOR_WHITE, {\cf22 "I'm about to execute DPC %p | Routine: %p | SysArg1: %p | SysArg2: %p | Priority: %d\\n"}, Dpc, Dpc->DeferredRoutine, Dpc->SystemArgument1, Dpc->SystemArgument2, Dpc->priority);\par
00321 {\cf21 #endif}\par
00322                     DeferredRoutine(Dpc, DeferredContext, SystemArgument1, SystemArgument2);\par
00323                     Cpu->CurrentDeferredRoutine = NULL;\par
00324 \par
00325                     {\cf20 // Assertion, incase the DPC changed the IRQL level.}\par
00326                     assert(MeGetCurrentIrql() == DISPATCH_LEVEL);\par
00327 \par
00328                     {\cf20 // Disable Interrupts for next loop iteration}\par
00329                     __cli();\par
00330 \par
00331                 \}\par
00332                 {\cf19 else} \{\par
00333                     {\cf20 // List was empty}\par
00334                     MsReleaseSpinlockFromDpcLevel(&DpcData->DpcLock);\par
00335                 \}\par
00336 \par
00337             \} {\cf19 while} (DpcData->DpcQueueDepth != 0);\par
00338         \}\par
00339 \par
00340         Cpu->DpcRoutineActive = {\cf17 false};\par
00341         Cpu->DpcInterruptRequested = {\cf17 false};\par
00342 \par
00343     \} {\cf19 while} (DpcData->DpcQueueDepth != 0);\par
00344 \par
00345     {\cf20 // Return statement, assert that interrupts are disabled.}\par
00346     assert(MeAreInterruptsEnabled() == {\cf17 false}, {\cf22 "Interrupts must not enabled at DPC Retirement exit"});\par
00347 \}\par
00348 \par
00349 {\cf18 void}\par
00350 MeSetTargetProcessorDpc(\par
00351     IN PDPC Dpc,\par
00352     IN uint32_t CpuNumber\par
00353 )\par
00354 \par
00355 {\cf20 /*++}\par
00356 {\cf20 }\par
00357 {\cf20     Routine description:}\par
00358 {\cf20 }\par
00359 {\cf20         This function ensures that the DPC executes only on the CPU}\par
00360 {\cf20         corresponding to the supplied LAPIC ID.}\par
00361 {\cf20 }\par
00362 {\cf20     Arguments:}\par
00363 {\cf20 }\par
00364 {\cf20         [IN] PDPC DpcAllocated - Pointer to DPC allocated in resident memory (e.g, pool alloc)}\par
00365 {\cf20         [IN] uint32_t CpuNumber - LAPIC ID Of the certain CPU Core to be ran on.}\par
00366 {\cf20 }\par
00367 {\cf20     Return Values:}\par
00368 {\cf20 }\par
00369 {\cf20         None.}\par
00370 {\cf20 }\par
00371 {\cf20     Notes:}\par
00372 {\cf20 }\par
00373 {\cf20         This function call must be made before MeInsertQueueDpc.}\par
00374 {\cf20 }\par
00375 {\cf20 --*/}\par
00376 \par
00377 \{\par
00378     assert(CpuNumber < MeGetActiveProcessorCount());\par
00379 \par
00380     Dpc->CpuNumber = CpuNumber;\par
00381 \}\par
00382 \par
00383 {\cf18 void}\par
00384 MeInitializeDpc(\par
00385     IN PDPC DpcAllocated,\par
00386     IN PDEFERRED_ROUTINE DeferredRoutine,\par
00387     IN {\cf18 void}* DeferredContext,\par
00388     IN DPC_PRIORITY DeferredPriority\par
00389 )\par
00390 \par
00391 {\cf20 /*++}\par
00392 {\cf20 }\par
00393 {\cf20     Routine description:}\par
00394 {\cf20 }\par
00395 {\cf20         This function initializes a DPC to be used for queueing.}\par
00396 {\cf20 }\par
00397 {\cf20     Arguments:}\par
00398 {\cf20 }\par
00399 {\cf20         [IN] PDPC DpcAllocated - Pointer to DPC allocated in resident memory (e.g, pool alloc)}\par
00400 {\cf20         [IN] PDEFERRED_ROUTINE DeferredRoutine - Pointer to deferred routine for the DPC to execute.}\par
00401 {\cf20         [IN] void* DeferredContext - Opaque pointer to deferred context, passed to the DeferredRoutine function as a parameter.}\par
00402 {\cf20         [IN] DPC_PRIORITY DeferredPriority - Supplies the priority of the DPC. A DPC of LOW_PRIORITY will not be executed at queue time unless the depth is full, or a software interrupt occurs.}\par
00403 {\cf20 }\par
00404 {\cf20     Return Values:}\par
00405 {\cf20 }\par
00406 {\cf20         None.}\par
00407 {\cf20 }\par
00408 {\cf20 --*/}\par
00409 \par
00410 \{\par
00411     {\cf20 // Initialize standard DPC headers.}\par
00412     DpcAllocated->priority = DeferredPriority;\par
00413     \par
00414     {\cf20 // Initialize address of routine and context param.}\par
00415     DpcAllocated->DeferredRoutine = DeferredRoutine;\par
00416     DpcAllocated->DeferredContext = DeferredContext;\par
00417     DpcAllocated->DpcData = NULL;\par
00418     \par
00419     {\cf20 // Set to current CPU. (the driver can modify his CPU)}\par
00420     DpcAllocated->CpuNumber = DPC_TARGET_CURRENT;\par
00421 \par
00422     {\cf20 // Initialize list head for DPC.}\par
00423     InitializeListHead(&DpcAllocated->DpcListEntry);\par
00424 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/irql.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/irql.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/irql.c}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../intrinsics/atomic.h"}\par
{\f2 #include "../../intrinsics/intrin.h"}\par
{\f2 #include <stdatomic.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeRaiseIrql} ({\b IN} {\b IRQL} NewIrql, {\b OUT} {\b PIRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeLowerIrql} ({\b IN} {\b IRQL} NewIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _MeSetIrql} ({\b IN} {\b IRQL} NewIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeDisableInterrupts} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeEnableInterrupts} ({\b IN} bool EnabledBefore)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeAreInterruptsEnabled} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _MeSetIrql\:irql.c}
{\xe \v irql.c\:_MeSetIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _MeSetIrql ({\b IN} {\b IRQL} NewIrql)}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b irql.c}.}\par
}
{\xe \v MeAreInterruptsEnabled\:irql.c}
{\xe \v irql.c\:MeAreInterruptsEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeAreInterruptsEnabled (void )}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b irql.c}.}\par
}
{\xe \v MeDisableInterrupts\:irql.c}
{\xe \v irql.c\:MeDisableInterrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeDisableInterrupts (void )}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b irql.c}.}\par
}
{\xe \v MeEnableInterrupts\:irql.c}
{\xe \v irql.c\:MeEnableInterrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeEnableInterrupts ({\b IN} bool EnabledBefore)}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b irql.c}.}\par
}
{\xe \v MeLowerIrql\:irql.c}
{\xe \v irql.c\:MeLowerIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeLowerIrql ({\b IN} {\b IRQL} NewIrql)}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b irql.c}.}\par
}
{\xe \v MeRaiseIrql\:irql.c}
{\xe \v irql.c\:MeRaiseIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeRaiseIrql ({\b IN} {\b IRQL} NewIrql, {\b OUT} {\b PIRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b irql.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
irql.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/irql.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/irql.c}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      IRQL Implementation (Fixed with Dispatch Level scheduling toggle)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/me.h"}\par
00008 {\cf21 #include "../../intrinsics/atomic.h"}\par
00009 {\cf21 #include "../../intrinsics/intrin.h"}\par
00010 {\cf21 #include <stdatomic.h>}\par
00011 \par
00012 {\cf17 static} {\cf17 inline} {\cf18 bool} interrupts_enabled({\cf18 void}) \{\par
00013     {\cf18 unsigned} {\cf18 long} flags;\par
00014     __asm__ __volatile__({\cf22 "pushfq; popq %0"} : {\cf22 "=r"}(flags));\par
00015     {\cf19 return} (flags & (1UL << 9)) != 0; {\cf20 // IF is bit 9}\par
00016 \}\par
00017 \par
00018 {\cf17 static} {\cf18 void} update_apic_irqs(IRQL newLevel) \{\par
00019     uint8_t tpr = 0;\par
00020 \par
00021     {\cf19 switch} (newLevel) \{\par
00022     {\cf19 case} HIGH_LEVEL:\par
00023     {\cf19 case} POWER_LEVEL:\par
00024     {\cf19 case} IPI_LEVEL:\par
00025         tpr = 15; {\cf20 // block everything}\par
00026         {\cf19 break};\par
00027 \par
00028     {\cf19 case} CLOCK_LEVEL:\par
00029     {\cf19 case} PROFILE_LEVEL:\par
00030         tpr = TPR_PROFILE; {\cf20 // 10}\par
00031         {\cf19 break};\par
00032 \par
00033     {\cf19 case} DISPATCH_LEVEL:\par
00034         tpr = TPR_DPC; {\cf20 // 6}\par
00035         {\cf19 break};\par
00036     {\cf19 case} APC_LEVEL:\par
00037         tpr = TPR_APC; {\cf20 // 3}\par
00038         {\cf19 break}; \par
00039 \par
00040     {\cf19 case} PASSIVE_LEVEL:\par
00041     {\cf19 default}:\par
00042         tpr = TPR_PASSIVE; {\cf20 // allow everything.}\par
00043         {\cf19 break};\par
00044     \}\par
00045 \par
00046     __write_cr8(({\cf18 unsigned} {\cf18 long})tpr);\par
00047 \}\par
00048 \par
00049 {\cf17 static} {\cf17 inline} {\cf18 void} toggle_scheduler({\cf18 void}) \{\par
00050     {\cf20 // schedulerEnabled should be true only at IRQL < DISPATCH_LEVEL}\par
00051     MeGetCurrentProcessor()->schedulerEnabled = (MeGetCurrentIrql() < DISPATCH_LEVEL);\par
00052 \}\par
00053 \par
00054 {\cf20 // PUBLIC API}\par
00055 \par
00056 {\cf18 void} \par
00057 MeRaiseIrql (\par
00058     IN IRQL NewIrql,\par
00059     OUT PIRQL OldIrql\par
00060 ) \par
00061 \par
00062 {\cf20 /*++}\par
00063 {\cf20 }\par
00064 {\cf20     Routine description : This function raises the current IRQL of the CPU to the specified 'NewIrql', and updates IRQL rules along with it (scheduler, APIC masks...).}\par
00065 {\cf20 }\par
00066 {\cf20     Arguments:}\par
00067 {\cf20         }\par
00068 {\cf20         [IN]    IRQL NewIrql: The new IRQL to set.}\par
00069 {\cf20         [OUT]   PIRQL OldIrql: The old IRQL variable address.}\par
00070 {\cf20 }\par
00071 {\cf20     Return Values:}\par
00072 {\cf20         }\par
00073 {\cf20         None.}\par
00074 {\cf20 }\par
00075 {\cf20 --*/}\par
00076 \par
00077 \{\par
00078     {\cf18 bool} prev_if = interrupts_enabled();\par
00079     __cli();\par
00080 \par
00081     {\cf19 if} (OldIrql) \{\par
00082         *OldIrql = MeGetCurrentProcessor()->currentIrql;\par
00083     \}\par
00084 \par
00085     IRQL curr = MeGetCurrentIrql();\par
00086     {\cf19 if} (NewIrql < curr) \{\par
00087         MeBugCheck(IRQL_NOT_GREATER_OR_EQUAL);\par
00088     \}\par
00089 \par
00090     MeGetCurrentProcessor()->currentIrql = NewIrql;\par
00091     toggle_scheduler();\par
00092     update_apic_irqs(NewIrql);\par
00093     {\cf19 if} (prev_if) __sti();\par
00094 \}\par
00095 \par
00096 {\cf18 void}\par
00097 MeLowerIrql (\par
00098    IN IRQL NewIrql\par
00099 ) \par
00100 \par
00101 {\cf20 /*++}\par
00102 {\cf20 }\par
00103 {\cf20     Routine description : }\par
00104 {\cf20     }\par
00105 {\cf20         This function lowers the current IRQL of the CPU to the specified 'NewIrql', and updates IRQL rules along with it (scheduler, APIC masks...).}\par
00106 {\cf20         }\par
00107 {\cf20         N.B: The function checks if a software interrupt is pending AND that the interrupt IRQL pending is LOWER or EQUAL to current IRQL,}\par
00108 {\cf20              if so, it will generate the interrupt, even on interrupts disabled.}\par
00109 {\cf20 }\par
00110 {\cf20     Arguments:}\par
00111 {\cf20 }\par
00112 {\cf20         [IN]    IRQL NewIrql: The new IRQL to set.}\par
00113 {\cf20 }\par
00114 {\cf20     Return Values:}\par
00115 {\cf20 }\par
00116 {\cf20         None.}\par
00117 {\cf20 }\par
00118 {\cf20 --*/}\par
00119 \par
00120 \{\par
00121     {\cf18 bool} prev_if = interrupts_enabled();\par
00122     __cli();\par
00123 \par
00124     IRQL curr = MeGetCurrentIrql();\par
00125     {\cf19 if} (NewIrql > curr) \{\par
00126         MeBugCheck(IRQL_NOT_LESS_OR_EQUAL);\par
00127     \}\par
00128 \par
00129     MeGetCurrentProcessor()->currentIrql = NewIrql;\par
00130 \par
00131     toggle_scheduler();\par
00132     update_apic_irqs(NewIrql);\par
00133 \par
00134     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00135     MmFullBarrier();\par
00136     \par
00137     {\cf20 // First check for DPC Interrupts.}\par
00138 \par
00139     {\cf19 if} (prev_if && cpu->DpcInterruptRequested && !cpu->DpcRoutineActive && NewIrql <= DISPATCH_LEVEL) \{\par
00140         MhRequestSoftwareInterrupt(DISPATCH_LEVEL);\par
00141     \}\par
00142 \par
00143     {\cf20 // Now APC Interrupts.}\par
00144     {\cf19 if} (prev_if && cpu->ApcInterruptRequested && !cpu->ApcRoutineActive && NewIrql <= APC_LEVEL) \{\par
00145         MhRequestSoftwareInterrupt(APC_LEVEL);\par
00146     \}\par
00147 \par
00148     {\cf19 if} (prev_if) __sti();\par
00149 \}\par
00150 \par
00151 {\cf20 // This function should be used sparingly, only during initialization.}\par
00152 {\cf18 void} \par
00153 _MeSetIrql (\par
00154     IN IRQL NewIrql\par
00155 )\par
00156 \par
00157 {\cf20 /*++}\par
00158 {\cf20 }\par
00159 {\cf20     Routine description : This function forcefully SETS (ignores bugcheck rules) the current IRQL of the CPU to the specified 'NewIrql', and updates IRQL rules along with it (scheduler, APIC masks...).}\par
00160 {\cf20 }\par
00161 {\cf20     Arguments:}\par
00162 {\cf20 }\par
00163 {\cf20         [IN]    IRQL NewIrql: The new IRQL to set.}\par
00164 {\cf20 }\par
00165 {\cf20     Return Values:}\par
00166 {\cf20 }\par
00167 {\cf20         None.}\par
00168 {\cf20         }\par
00169 {\cf20     Notes: }\par
00170 {\cf20 }\par
00171 {\cf20         Use sparingly, this function ignores bugcheck IRQL rules.}\par
00172 {\cf20 }\par
00173 {\cf20 --*/}\par
00174 \par
00175 \{\par
00176     {\cf18 bool} prev_if = interrupts_enabled();\par
00177     __cli();\par
00178 \par
00179     MeGetCurrentProcessor()->currentIrql = NewIrql;\par
00180     toggle_scheduler();\par
00181     update_apic_irqs(NewIrql);\par
00182     {\cf19 if} (prev_if) __sti();\par
00183 \}\par
00184 \par
00185 {\cf18 bool}\par
00186 MeDisableInterrupts(\par
00187     {\cf18 void}\par
00188 )\par
00189 \par
00190 {\cf20 // Short Desc: Will disable interrupts, and returns if interrupts were enabled before.}\par
00191 \par
00192 \{\par
00193     {\cf18 bool} prev_if = interrupts_enabled();\par
00194     __cli();\par
00195     {\cf19 return} prev_if;\par
00196 \}\par
00197 \par
00198 {\cf18 void}\par
00199 MeEnableInterrupts(\par
00200     IN {\cf18 bool} EnabledBefore\par
00201 )\par
00202 \par
00203 {\cf20 // Short Desc: Will enable interrupts ONLY if EnabledBefore is true. (given from return value of MeDisableInterrupts)}\par
00204 \par
00205 \{\par
00206     {\cf19 if} (EnabledBefore) __sti();\par
00207 \}\par
00208 \par
00209 {\cf18 bool}\par
00210 MeAreInterruptsEnabled(\par
00211     {\cf18 void}\par
00212 )\par
00213 \par
00214 {\cf20 // Short Desc: Will return if interrupts are currently enabled on the processor.}\par
00215 \par
00216 \{\par
00217     {\cf19 return} interrupts_enabled();\par
00218 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/meinit.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/meinit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/meinit.c}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR0_MP}\~ (1UL << 1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR0_EM}\~ (1UL << 2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR0_WP}\~ (1UL << 16)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR0_CD}\~ (1UL << 30)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR4_OSFXSR}\~ (1UL << 9)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR4_OSXMMEXCPT}\~ (1UL << 10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR4_UMIP}\~ (1UL << 11)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR4_FSGSBASE}\~ (1UL << 16)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR4_SMEP}\~ (1UL << 20)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CR4_SMAP}\~ (1UL << 21)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_1_EDX_SSE}\~ (1UL << 25)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_1_EDX_SSE2}\~ (1UL << 26)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_7_EBX_SMEP}\~ (1UL << 7)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_7_EBX_SMAP}\~ (1UL << 20)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeInitializeProcessor} ({\b IN} {\b PPROCESSOR} CPU, {\b IN} bool InitializeStandardRoutine, {\b IN} bool AreYouAP)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_ENTRY64} {\b IDT} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_PTR} {\b PIDT}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CPUID_1_EDX_SSE\:meinit.c}
{\xe \v meinit.c\:CPUID_1_EDX_SSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_1_EDX_SSE\~ (1UL << 25)}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b meinit.c}.}\par
}
{\xe \v CPUID_1_EDX_SSE2\:meinit.c}
{\xe \v meinit.c\:CPUID_1_EDX_SSE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_1_EDX_SSE2\~ (1UL << 26)}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b meinit.c}.}\par
}
{\xe \v CPUID_7_EBX_SMAP\:meinit.c}
{\xe \v meinit.c\:CPUID_7_EBX_SMAP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_7_EBX_SMAP\~ (1UL << 20)}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b meinit.c}.}\par
}
{\xe \v CPUID_7_EBX_SMEP\:meinit.c}
{\xe \v meinit.c\:CPUID_7_EBX_SMEP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_7_EBX_SMEP\~ (1UL << 7)}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b meinit.c}.}\par
}
{\xe \v CR0_CD\:meinit.c}
{\xe \v meinit.c\:CR0_CD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR0_CD\~ (1UL << 30)}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b meinit.c}.}\par
}
{\xe \v CR0_EM\:meinit.c}
{\xe \v meinit.c\:CR0_EM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR0_EM\~ (1UL << 2)}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b meinit.c}.}\par
}
{\xe \v CR0_MP\:meinit.c}
{\xe \v meinit.c\:CR0_MP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR0_MP\~ (1UL << 1)}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b meinit.c}.}\par
}
{\xe \v CR0_WP\:meinit.c}
{\xe \v meinit.c\:CR0_WP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR0_WP\~ (1UL << 16)}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b meinit.c}.}\par
}
{\xe \v CR4_FSGSBASE\:meinit.c}
{\xe \v meinit.c\:CR4_FSGSBASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR4_FSGSBASE\~ (1UL << 16)}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b meinit.c}.}\par
}
{\xe \v CR4_OSFXSR\:meinit.c}
{\xe \v meinit.c\:CR4_OSFXSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR4_OSFXSR\~ (1UL << 9)}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b meinit.c}.}\par
}
{\xe \v CR4_OSXMMEXCPT\:meinit.c}
{\xe \v meinit.c\:CR4_OSXMMEXCPT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR4_OSXMMEXCPT\~ (1UL << 10)}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b meinit.c}.}\par
}
{\xe \v CR4_SMAP\:meinit.c}
{\xe \v meinit.c\:CR4_SMAP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR4_SMAP\~ (1UL << 21)}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b meinit.c}.}\par
}
{\xe \v CR4_SMEP\:meinit.c}
{\xe \v meinit.c\:CR4_SMEP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR4_SMEP\~ (1UL << 20)}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b meinit.c}.}\par
}
{\xe \v CR4_UMIP\:meinit.c}
{\xe \v meinit.c\:CR4_UMIP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CR4_UMIP\~ (1UL << 11)}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b meinit.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MeInitializeProcessor\:meinit.c}
{\xe \v meinit.c\:MeInitializeProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeInitializeProcessor ({\b IN} {\b PPROCESSOR} CPU, {\b IN} bool InitializeStandardRoutine, {\b IN} bool AreYouAP)}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b meinit.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v IDT\:meinit.c}
{\xe \v meinit.c\:IDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_ENTRY64} IDT[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b idt.c}.}\par
}
{\xe \v PIDT\:meinit.c}
{\xe \v meinit.c\:PIDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_PTR} PIDT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b idt.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
meinit.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/meinit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/meinit.c}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     meinit.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of core system init routines (executive).}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/me.h"}\par
00020 {\cf21 #include "../../includes/mh.h"}\par
00021 {\cf21 #include "../../includes/mg.h"}\par
00022 {\cf21 #include "../../assert.h"}\par
00023 \par
00024 {\cf20 /* Register Bit Definitions */}\par
00025 {\cf21 #define CR0_MP              (1UL << 1)   }{\cf20 // Monitor Coprocessor}\par
00026 {\cf21 #define CR0_EM              (1UL << 2)   }{\cf20 // Emulation}\par
00027 {\cf21 #define CR0_WP              (1UL << 16)  }{\cf20 // Write Protect}\par
00028 {\cf21 #define CR0_CD              (1UL << 30)  }{\cf20 // Cache Disable}\par
00029 \par
00030 {\cf21 #define CR4_OSFXSR          (1UL << 9)   }{\cf20 // OS FXSAVE/FXRSTOR Support}\par
00031 {\cf21 #define CR4_OSXMMEXCPT      (1UL << 10)  }{\cf20 // OS Unmasked Exception Support}\par
00032 {\cf21 #define CR4_UMIP            (1UL << 11)  }{\cf20 // User Mode Instruction Prevention}\par
00033 {\cf21 #define CR4_FSGSBASE        (1UL << 16)  }{\cf20 // Enable RDFSBASE/RDGSBASE/etc}\par
00034 {\cf21 #define CR4_SMEP            (1UL << 20)  }{\cf20 // Supervisor Mode Execution Prevention}\par
00035 {\cf21 #define CR4_SMAP            (1UL << 21)  }{\cf20 // Supervisor Mode Access Prevention}\par
00036 \par
00037 {\cf20 /* CPUID Feature Bits */}\par
00038 {\cf21 #define CPUID_1_EDX_SSE     (1UL << 25)}\par
00039 {\cf21 #define CPUID_1_EDX_SSE2    (1UL << 26)}\par
00040 {\cf21 #define CPUID_7_EBX_SMEP    (1UL << 7)}\par
00041 {\cf21 #define CPUID_7_EBX_SMAP    (1UL << 20)}\par
00042 \par
00043 \par
00044 {\cf17 static} {\cf18 void} InitialiseControlRegisters({\cf18 void}) \{\par
00045     {\cf18 unsigned} {\cf18 long} cr0 = __read_cr0();\par
00046     {\cf18 unsigned} {\cf18 long} cr4 = __read_cr4();\par
00047     {\cf18 unsigned} {\cf18 int} eax, ebx, ecx, edx;\par
00048 \par
00049     {\cf20 // Prepare CR0 Configuration}\par
00050     cr0 |= CR0_WP; {\cf20 // Write Protect}\par
00051 {\cf21 #ifdef DISABLE_CACHE}\par
00052     cr0 |= CR0_CD; {\cf20 // Cache Disable}\par
00053 {\cf21 #endif}\par
00054 \par
00055     {\cf20 // Prepare CR4 Configuration}\par
00056     cr4 |= CR4_UMIP; {\cf20 // User Mode Instruction Prevention}\par
00057 \par
00058     {\cf20 // Clear Debug Registers}\par
00059     {\cf19 for} ({\cf18 int} i = 0; i < 7; i++) __write_dr(i, 0);\par
00060 \par
00061     {\cf20 // Detect & Setup SSE/FPU Bits}\par
00062     __asm__ {\cf17 volatile}({\cf22 "cpuid"} : {\cf22 "=a"}(eax), {\cf22 "=b"}(ebx), {\cf22 "=c"}(ecx), {\cf22 "=d"}(edx) : {\cf22 "a"}(1), {\cf22 "c"}(0));\par
00063 \par
00064     {\cf18 int} has_sse = (edx & CPUID_1_EDX_SSE) || (edx & CPUID_1_EDX_SSE2);\par
00065 \par
00066     {\cf19 if} (has_sse) \{\par
00067         cr0 &= ~CR0_EM; {\cf20 // Clear Emulation}\par
00068         cr0 |= CR0_MP;  {\cf20 // Set Monitor Coprocessor}\par
00069         cr4 |= (CR4_OSFXSR | CR4_OSXMMEXCPT); {\cf20 // Enable SSE/Exceptions}\par
00070         cr4 |= CR4_FSGSBASE; {\cf20 // Enable FSGSBASE}\par
00071     \}\par
00072     {\cf19 else} \{\par
00073         gop_printf(COLOR_RED, {\cf22 "**CPU does not support SSE. Halting.**\\n"});\par
00074         FREEZE();\par
00075     \}\par
00076 \par
00077     {\cf20 // Detect & Setup SMAP/SMEP Bits}\par
00078     __asm__ {\cf17 volatile}({\cf22 "cpuid"} : {\cf22 "=a"}(eax), {\cf22 "=b"}(ebx), {\cf22 "=c"}(ecx), {\cf22 "=d"}(edx) : {\cf22 "a"}(7), {\cf22 "c"}(0));\par
00079 \par
00080     {\cf19 if} (ebx & CPUID_7_EBX_SMEP) cr4 |= CR4_SMEP;\par
00081     {\cf19 else} gop_printf(COLOR_YELLOW, {\cf22 "SMEP not available.\\n"});\par
00082 \par
00083     {\cf19 if} (ebx & CPUID_7_EBX_SMAP) cr4 |= CR4_SMAP;\par
00084     {\cf19 else} gop_printf(COLOR_YELLOW, {\cf22 "SMAP not available.\\n"});\par
00085 \par
00086     {\cf20 // COMMIT REGISTERS TO CPU}\par
00087     {\cf20 // We MUST write these before executing LDMXCSR below.}\par
00088     __write_cr0(cr0);\par
00089     __write_cr4(cr4);\par
00090 \par
00091     {\cf20 // Initialize SSE Hardware}\par
00092     {\cf20 // Now that CR4.OSFXSR is set in hardware, this instruction is valid.}\par
00093     {\cf19 if} (has_sse) \{\par
00094         {\cf18 unsigned} {\cf18 int} mxcsr = 0x1f80;\par
00095         __asm__ {\cf17 volatile} (\par
00096             {\cf22 "fninit\\n\\t"}\par
00097             {\cf22 "ldmxcsr %0\\n\\t"}\par
00098             : : {\cf22 "m"}(mxcsr) : {\cf22 "memory"}\par
00099             );\par
00100     \}\par
00101 \}\par
00102 \par
00103 {\cf17 static} {\cf18 void} MeInitGdtTssForCurrentProcessor({\cf18 void}) \{\par
00104     PPROCESSOR cur = MeGetCurrentProcessor();\par
00105     TSS* tss = cur->tss;\par
00106     uint64_t* gdt = cur->gdt;\par
00107     {\cf20 // gdt is uint64_t gdt[7];}\par
00108     gdt[0] = 0;\par
00109     gdt[1] = 0x00AF9A000000FFFF;\par
00110     gdt[2] = 0x00CF92000000FFFF;\par
00111     {\cf20 // user code & data}\par
00112     gdt[3] = 0x00AFFA000000FFFF;\par
00113     gdt[4] = 0x00CFF2000000FFFF;\par
00114     uint64_t tss_base = (uint64_t)tss;\par
00115     uint32_t limit = {\cf17 sizeof}(TSS) - 1;\par
00116 \par
00117     {\cf20 // tss entry}\par
00118     kmemset(tss, 0, {\cf17 sizeof}(TSS));\par
00119     {\cf20 // Stack and IST's have been moved to MeInitProcessor.}\par
00120     tss->io_map_base = {\cf17 sizeof}(TSS);\par
00121     tss->rsp0 = (uint64_t)cur->Rsp0;\par
00122     tss->ist[0] = (uint64_t)cur->IstPFStackTop; {\cf20 // IDT.ist = 1}\par
00123     tss->ist[1] = (uint64_t)cur->IstDFStackTop; {\cf20 // IDT.ist = 2}\par
00124     tss->ist[2] = (uint64_t)cur->IstTimerStackTop; {\cf20 // IDT.ist = 3}\par
00125     tss->ist[3] = (uint64_t)cur->IstIpiStackTop; {\cf20 // IDT.ist = 4}\par
00126 \par
00127     uint64_t tss_limit = (uint64_t)limit; {\cf20 // sizeof(TSS)-1}\par
00128     {\cf20 // gdt tss descriptor}\par
00129     uint64_t low = (tss_limit & 0xFFFFULL)\par
00130         | ((tss_base & 0xFFFFFFULL) << 16)\par
00131         | (0x89ULL << 40)                             {\cf20 // P=1, type=0x9 (available 64-bit TSS)}\par
00132         | (((tss_limit >> 16) & 0xFULL) << 48)       {\cf20 // limit high nibble -> bits 48..51}\par
00133         | (((tss_base >> 24) & 0xFFULL) << 56);      {\cf20 // base bits 24..31 -> bits 56..63}\par
00134 \par
00135     {\cf20 // high qword}\par
00136     uint64_t high = (tss_base >> 32) & 0xFFFFFFFFULL; {\cf20 // base >> 32 in low 32 bits of high qword}\par
00137 \par
00138     {\cf20 /* copy two qwords into GDT */}\par
00139     gdt[5] = low;\par
00140     gdt[6] = high;\par
00141     {\cf17 const} {\cf18 int} GDT_ENTRIES = 7;\par
00142 \par
00143     GDTPtr gdtr = \{ .limit = (GDT_ENTRIES * {\cf17 sizeof}(uint64_t)) - 1, .base = (uint64_t)gdt \};\par
00144     __asm__ {\cf17 volatile}({\cf22 "lgdt %0"} : : {\cf22 "m"}(gdtr));\par
00145     __asm__ {\cf17 volatile}(\par
00146         {\cf22 "pushq $0x08\\n\\t"}                 {\cf20 /* kernel code selector */}\par
00147         {\cf22 "leaq 1f(%%rip), %%rax\\n\\t"}     {\cf20 /*load ret*/}\par
00148         {\cf22 "pushq %%rax\\n\\t"} {\cf20 /*push ret*/}\par
00149         {\cf22 "lretq\\n\\t"} {\cf20 /*return*/}\par
00150         {\cf22 "1:\\n\\t"}\par
00151         : : : {\cf22 "rax"}, {\cf22 "memory"}\par
00152         );\par
00153 \par
00154 \par
00155     {\cf20 // tss selector is 16 bit operand}\par
00156     {\cf18 unsigned} {\cf18 short} sel = 0x28; {\cf20 // index 5 * 8}\par
00157     __asm__ {\cf17 volatile}({\cf22 "ltr %w0"} :: {\cf22 "r"}(sel));\par
00158 \}\par
00159 \par
00160 {\cf17 extern} IDT_ENTRY64 IDT[];\par
00161 {\cf17 extern} IDT_PTR  PIDT;\par
00162 \par
00163 {\cf18 void}\par
00164 MeInitializeProcessor(\par
00165     IN PPROCESSOR CPU,\par
00166     IN {\cf18 bool} InitializeStandardRoutine,\par
00167     IN {\cf18 bool} AreYouAP\par
00168 )\par
00169 \par
00170 {\cf20 /*++}\par
00171 {\cf20 }\par
00172 {\cf20     Routine description:}\par
00173 {\cf20 }\par
00174 {\cf20         Initializes the current PROCESSOR struct to default values.}\par
00175 {\cf20 }\par
00176 {\cf20     Arguments:}\par
00177 {\cf20 }\par
00178 {\cf20         [IN]    PPROCESSOR CPU - Pointer to current PROCESSOR struct.}\par
00179 {\cf20         [IN]    bool InitializeStandardRoutine - Boolean value indicating if to initialize the TSS & GDT & New IDT of system.}\par
00180 {\cf20         [IN]    bool AreYouAP - Boolean value indicating the caller of this function is an AP Processor and not the BSP.}\par
00181 {\cf20 }\par
00182 {\cf20     Return Values:}\par
00183 {\cf20 }\par
00184 {\cf20         None.}\par
00185 {\cf20 }\par
00186 {\cf20     Note:}\par
00187 {\cf20 }\par
00188 {\cf20         This routine is ran by every CPU on the system on its startup.}\par
00189 {\cf20 }\par
00190 {\cf20 --*/}\par
00191 \par
00192 \{\par
00193     {\cf19 if} (InitializeStandardRoutine && !AreYouAP) {\cf19 goto} StartInit; {\cf20 // If we are BSP, and we want to run the routines, go to them immediately and skip the basic init. If we are AP, we do basic init and start routines anyway.}\par
00194     {\cf20 // Initialize the CR registers.}\par
00195     InitialiseControlRegisters();\par
00196 \par
00197     CPU->self = CPU;\par
00198     CPU->currentIrql = PASSIVE_LEVEL;\par
00199     CPU->schedulerEnabled = NULL; {\cf20 // since NULL is 0, it would be false.}\par
00200     CPU->currentThread = NULL;\par
00201     CPU->readyQueue.head = CPU->readyQueue.tail = NULL;\par
00202     {\cf20 // Initialize the DPC Lock & list head.}\par
00203     CPU->DpcData.DpcLock.locked = 0;\par
00204     InitializeListHead(&CPU->DpcData.DpcListHead);\par
00205 \par
00206     {\cf20 // Initialize DPC Fields.}\par
00207     CPU->MaximumDpcQueueDepth = 4; {\cf20 // Baseline.}\par
00208     CPU->MinimumDpcRate = 1000; {\cf20 // 1000 DPCs per second baseline (TODO DPC Throttling)}\par
00209     CPU->DpcRequestRate = 0; {\cf20 // Initialized to zero.}\par
00210     CPU->DpcRoutineActive = {\cf17 false};\par
00211     CPU->DpcInterruptRequested = {\cf17 false};\par
00212     {\cf19 if} (!InitializeStandardRoutine && !AreYouAP) {\cf19 return}; {\cf20 // If we are BSP, and we do not want to run the routines below, return. If we are AP, we run it none the less.}\par
00213 \par
00214 StartInit: \{\par
00215     {\cf20 // Initialize CPU RSP0 and IST Stacks.}\par
00216     {\cf20 // RSP0 Is used on anything else that the IST already own.}\par
00217     {\cf20 // If we have an IST for IDT 14 (Page Fault), RSP0 will not be taken.}\par
00218     {\cf20 // If we don't RSP0 will be taken.}\par
00219     {\cf20 // RSP0 Is also taken in syscall instructions, but it is immediately replaced by ITHREAD.KernelStack.}\par
00220 \par
00221     {\cf20 // Create RSP0 and ISTs for processor.}\par
00222     {\cf18 void}* Rsp0 = MiCreateKernelStack({\cf17 false});\par
00223     {\cf18 void}* IstPf = MiCreateKernelStack({\cf17 true});\par
00224     {\cf18 void}* IstDf = MiCreateKernelStack({\cf17 true});\par
00225     {\cf18 void}* IstIpi = MiCreateKernelStack({\cf17 false});\par
00226     {\cf18 void}* IstTimer = MiCreateKernelStack({\cf17 false});\par
00227     {\cf18 bool} exists = (IstTimer && IstIpi && IstDf && IstPf && Rsp0) != 0;\par
00228     assert(exists == {\cf17 true});\par
00229     CPU->Rsp0 = Rsp0;\par
00230     CPU->IstPFStackTop = IstPf;\par
00231     CPU->IstDFStackTop = IstDf;\par
00232     CPU->IstIpiStackTop = IstIpi;\par
00233     CPU->IstTimerStackTop = IstTimer;\par
00234 \par
00235     {\cf20 // Create new GDT and TSS For Processor.}\par
00236     {\cf20 // Allocate TSS.}\par
00237     {\cf18 void}* tss = MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(TSS), {\cf22 ' ssT'}); {\cf20 // If fails on here, check alignment (16 byte)}\par
00238     CPU->tss = tss;\par
00239 \par
00240     {\cf20 // Allocate GDT.}\par
00241     uint64_t* gdt = MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(uint64_t) * 7, {\cf22 ' TDG'});\par
00242     CPU->gdt = gdt;\par
00243 \par
00244     MeInitGdtTssForCurrentProcessor();\par
00245 \par
00246     {\cf20 // ISTs}\par
00247     IDT[14].ist = 1; {\cf20 // First one is page fault.}\par
00248     IDT[8].ist = 2; {\cf20 // Second one is double fault.}\par
00249     IDT[LAPIC_TIMER_VECTOR].ist = 3; {\cf20 // Third one is the LAPIC Timer.}\par
00250     IDT[VECTOR_IPI].ist = 4; {\cf20 // Fourth one is the LAPIC IPI.}\par
00251 \par
00252     {\cf20 // Reload IDT with set stacks.}\par
00253     __lidt(&PIDT);\par
00254     \}\par
00255 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/scheduler.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/scheduler.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/scheduler.c}
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/ob.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IDLE_STACK_SIZE}\~ 4096\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b restore_context} ({\b TRAP_FRAME} *regs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b restore_user_context} ({\b PETHREAD} thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_idle_checks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitScheduler} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b Schedule} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PROCESSOR} {\b cpus} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPROCESS} {\b PsInitialSystemProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b g_cpuCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b smpInitialized}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IDLE_STACK_SIZE\:scheduler.c}
{\xe \v scheduler.c\:IDLE_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IDLE_STACK_SIZE\~ 4096}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b scheduler.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitScheduler\:scheduler.c}
{\xe \v scheduler.c\:InitScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitScheduler (void )}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b scheduler.c}.}\par
}
{\xe \v kernel_idle_checks\:scheduler.c}
{\xe \v scheduler.c\:kernel_idle_checks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_idle_checks (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b kernel.c}.}\par
}
{\xe \v restore_context\:scheduler.c}
{\xe \v scheduler.c\:restore_context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void restore_context ({\b TRAP_FRAME} * regs){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v restore_user_context\:scheduler.c}
{\xe \v scheduler.c\:restore_user_context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void restore_user_context ({\b PETHREAD} thread){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Schedule\:scheduler.c}
{\xe \v scheduler.c\:Schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void Schedule (void )}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b scheduler.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cpus\:scheduler.c}
{\xe \v scheduler.c\:cpus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PROCESSOR} cpus[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b smp.c}.}\par
}
{\xe \v g_cpuCount\:scheduler.c}
{\xe \v scheduler.c\:g_cpuCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t g_cpuCount{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b smp.c}.}\par
}
{\xe \v PsInitialSystemProcess\:scheduler.c}
{\xe \v scheduler.c\:PsInitialSystemProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPROCESS} PsInitialSystemProcess{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Stack Overflow check only checks for minor overflows, that don't completely smash the stack, yet do change the canaries (since it only checks in function epilogue) Complete stack smashes are guarded with the guard page in MiCreateKernelStack. \par
}{
Definition at line {\b 162} of file {\b kernel.c}.}\par
}
{\xe \v smpInitialized\:scheduler.c}
{\xe \v scheduler.c\:smpInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool smpInitialized{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
scheduler.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/scheduler.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/me/scheduler.c}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20     * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20     * LICENSE:      GPLv3}\par
00004 {\cf20     * PURPOSE:      Scheduler Implementation.}\par
00005 {\cf20     */}\par
00006 \par
00007 {\cf21 #include "../../includes/me.h"}\par
00008 {\cf21 #include "../../assert.h"}\par
00009 {\cf21 #include "../../includes/ps.h"}\par
00010 {\cf21 #include "../../includes/mg.h"}\par
00011 {\cf21 #include "../../includes/ob.h"}\par
00012 {\cf17 extern} PROCESSOR cpus[];\par
00013 \par
00014 {\cf20 // assembly stubs to save and restore register contexts.}\par
00015 {\cf17 extern} {\cf18 void} restore_context(TRAP_FRAME* regs);\par
00016 {\cf17 extern} {\cf18 void} restore_user_context(PETHREAD thread);\par
00017 \par
00018 {\cf20 // Idle thread, runs when no other is ready.}\par
00019 {\cf20 // Stack for idle thread}\par
00020 {\cf17 extern} {\cf18 void} kernel_idle_checks({\cf18 void});\par
00021 {\cf21 #define IDLE_STACK_SIZE 4096}\par
00022 \par
00023 {\cf17 extern} EPROCESS PsInitialSystemProcess;\par
00024 \par
00025 {\cf20 // In Scheduler.c}\par
00026 {\cf18 void} InitScheduler({\cf18 void}) \{\par
00027     MeGetCurrentProcessor()->schedulerEnabled = {\cf17 true};\par
00028     MeGetCurrentProcessor()->idleThread = MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(ETHREAD), {\cf22 'ELDI'});\par
00029     PETHREAD idleThread = MeGetCurrentProcessor()->idleThread;\par
00030     \par
00031     TRAP_FRAME cfm;\par
00032     kmemset(&cfm, 0, {\cf17 sizeof}(cfm)); {\cf20 // Start with a clean, all-zero context}\par
00033 \par
00034     {\cf20 // Set only the essential registers for starting the thread}\par
00035     {\cf18 void}* idleStack = MiCreateKernelStack({\cf17 false});\par
00036     assert(idleStack != NULL);\par
00037     cfm.rsp = (uint64_t)idleStack;\par
00038     cfm.rip = (uint64_t)kernel_idle_checks;\par
00039 \par
00040     {\cf20 // Enable Interrupts on its RFLAGS.}\par
00041     cfm.rflags |= (1 << 9ULL);\par
00042 \par
00043     {\cf20 // Assign the clean context to the idle thread}\par
00044     idleThread->InternalThread.TrapRegisters = cfm;\par
00045     idleThread->InternalThread.ThreadState = THREAD_READY;\par
00046     idleThread->InternalThread.TimeSlice = 1; {\cf20 // 1ms}\par
00047     idleThread->InternalThread.TimeSliceAllocated = 1;\par
00048     InitializeListHead(&idleThread->ThreadListEntry);\par
00049     idleThread->TID = 0; {\cf20 // Idle thread, TID is 0.}\par
00050     idleThread->InternalThread.StackBase = ({\cf18 void}*)cfm.rsp;\par
00051     idleThread->InternalThread.IsLargeStack = {\cf17 false};\par
00052     MeGetCurrentProcessor()->currentThread = NULL; {\cf20 // The idle thread would be chosen}\par
00053     idleThread->CurrentEvent = NULL; {\cf20 // No event.}\par
00054     idleThread->ParentProcess = &PsInitialSystemProcess;\par
00055     PsInitialSystemProcess.MainThread = idleThread;\par
00056     InsertHeadList(&PsInitialSystemProcess.AllThreads, &idleThread->ThreadListEntry);\par
00057 \par
00058     {\cf20 // The ready queue starts empty}\par
00059     MeGetCurrentProcessor()->readyQueue.head = MeGetCurrentProcessor()->readyQueue.tail = NULL;\par
00060 \}\par
00061 \par
00062 {\cf20 // Enqueue the thread if it's still RUNNING.}\par
00063 {\cf17 static} {\cf18 void} enqueue_runnable(PITHREAD t) \{\par
00064     assert((t) != 0);\par
00065     {\cf19 if} (t->ThreadState == THREAD_RUNNING) \{\par
00066         t->ThreadState = THREAD_READY;\par
00067         t->TimeSlice = t->TimeSliceAllocated;\par
00068         MeEnqueueThreadWithLock(&MeGetCurrentProcessor()->readyQueue, PsGetEThreadFromIThread(t)); {\cf20 // Insert into CPU ready queue}\par
00069     \}\par
00070 \}\par
00071 \par
00072 {\cf17 extern} uint32_t g_cpuCount; {\cf20 // extern the global cpu count. (gotten from smp)}\par
00073 {\cf17 extern} {\cf18 bool} smpInitialized;\par
00074 \par
00075 {\cf20 // The following function uses CPU Work stealing to steal other CPUs thread (in a queue), if the current thread has no scheduled threads in the queue.}\par
00076 {\cf17 static} PITHREAD MeAcquireNextScheduledThread({\cf18 void}) \{\par
00077     {\cf20 // First, lets try to get from our own queue.}\par
00078     PETHREAD chosenThread = MeDequeueThreadWithLock(&MeGetCurrentProcessor()->readyQueue);\par
00079     {\cf19 if} (chosenThread) {\cf19 return} &chosenThread->InternalThread;\par
00080 \par
00081 {\cf21 #ifndef MT_UP}\par
00082     {\cf19 if} (smpInitialized) \{\par
00083         {\cf20 // Our own CPU queue is empty, steal from others.}\par
00084         {\cf19 for} (uint32_t i = 0; i < g_cpuCount; i++) \{\par
00085             {\cf19 if} (cpus[i].lapic_ID == MeGetCurrentProcessor()->lapic_ID) {\cf19 continue}; {\cf20 // skip ourselves.}\par
00086 \par
00087             {\cf20 // The reason I used the self pointer here, is because the BSP in the cpus array, is empty except for 4 fields, as its main struct is cpu0, }\par
00088             {\cf20 // which is defined at the kernel main, so we access it through self, view SMP.C prepare_percpu for more info.}\par
00089             Queue* victimQueue = &cpus[i].self->readyQueue;\par
00090             {\cf19 if} (!victimQueue->head) {\cf19 continue}; {\cf20 // skip empty queues}\par
00091 \par
00092             chosenThread = MeDequeueThreadWithLock(victimQueue);\par
00093             {\cf20 // Found a suitable thread, return it.}\par
00094             {\cf19 if} (chosenThread) {\cf19 return} &chosenThread->InternalThread;\par
00095         \}\par
00096     \}\par
00097 {\cf21 #endif}\par
00098 \par
00099     {\cf20 // No thread found.}\par
00100     {\cf19 return} NULL;\par
00101 \}\par
00102 \par
00103 NORETURN\par
00104 {\cf18 void} \par
00105 Schedule({\cf18 void}) \{\par
00106     {\cf20 //gop_printf(COLOR_PURPLE, "**In scheduler, IRQL: %d**\\n", MeGetCurrentIrql());}\par
00107     IRQL oldIrql;\par
00108     MeRaiseIrql(DISPATCH_LEVEL, &oldIrql); {\cf20 // Prevents scheduling re-entrance.}\par
00109 \par
00110     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00111     PITHREAD prev = MeGetCurrentProcessor()->currentThread;\par
00112     PITHREAD IdleThread = &MeGetCurrentProcessor()->idleThread->InternalThread;\par
00113 \par
00114     {\cf20 // Check if we need to delete another thread's (safe now, we are at a separate stack)}\par
00115     {\cf19 if} (cpu->ZombieThread) \{\par
00116         {\cf20 // Drop the reference, we are on another thread's stack.}\par
00117         ObDereferenceObject(({\cf18 void}*)cpu->ZombieThread);\par
00118         cpu->ZombieThread = NULL;\par
00119     \}\par
00120 \par
00121     {\cf20 // All thread's that weren't RUNNING are ignored by the Scheduler. (like BLOCKED threads when waiting or an event, ZOMBIE threads, TERMINATED, etc..)}\par
00122     {\cf19 if} (prev && prev != IdleThread && prev->ThreadState == THREAD_TERMINATING) \{\par
00123         cpu->ZombieThread = prev;\par
00124         prev = NULL;\par
00125     \}\par
00126     {\cf19 else} {\cf19 if} (prev && prev != IdleThread && prev->ThreadState == THREAD_RUNNING) \{\par
00127         {\cf20 // The current thread's registers were already saved in isr_stub. (look after the pushes) (also saved in MtSleepCurrentThread)}\par
00128         enqueue_runnable(prev);\par
00129     \}\par
00130 \par
00131     PITHREAD next = MeAcquireNextScheduledThread();\par
00132 \par
00133     {\cf19 if} (!next) \{\par
00134         next = IdleThread;\par
00135     \}\par
00136 \par
00137     next->ThreadState = THREAD_RUNNING;\par
00138     MeGetCurrentProcessor()->currentThread = next;\par
00139     MeLowerIrql(oldIrql);\par
00140     {\cf19 if} (PsIsKernelThread(PsGetEThreadFromIThread(next))) \{\par
00141         restore_context(&next->TrapRegisters);\par
00142     \}\par
00143     {\cf19 else} \{\par
00144         {\cf20 // User thread}\par
00145         restore_user_context(PsGetEThreadFromIThread(next));\par
00146     \}\par
00147     __builtin_unreachable();\par
00148 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/acpi.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/acpi.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/acpi.c}
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/efi.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhRebootComputer} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MhParseLAPICs} (uint8_t *buffer, size_t maxCPUs, uint32_t *cpuCount, uint32_t *{\b lapicAddress})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MhInitializeACPI} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FADT * {\b fadt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MADT * {\b madt}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MhInitializeACPI\:acpi.c}
{\xe \v acpi.c\:MhInitializeACPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MhInitializeACPI (void )}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b acpi.c}.}\par
}
{\xe \v MhParseLAPICs\:acpi.c}
{\xe \v acpi.c\:MhParseLAPICs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MhParseLAPICs (uint8_t * buffer, size_t maxCPUs, uint32_t * cpuCount, uint32_t * lapicAddress)}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b acpi.c}.}\par
}
{\xe \v MhRebootComputer\:acpi.c}
{\xe \v acpi.c\:MhRebootComputer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhRebootComputer (void )}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b acpi.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v boot_info_local\:acpi.c}
{\xe \v acpi.c\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b kernel.c}.}\par
}
{\xe \v fadt\:acpi.c}
{\xe \v acpi.c\:fadt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FADT* fadt}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b acpi.c}.}\par
}
{\xe \v madt\:acpi.c}
{\xe \v acpi.c\:madt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MADT* madt}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b acpi.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
acpi.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/acpi.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/acpi.c}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      ACPI Parsing & Implementation.}\par
00005 {\cf20  * DEVELOPER:    https://github.com/slep2-0}\par
00006 {\cf20  */}\par
00007 \par
00008 {\cf21 #include "../../includes/mh.h"}\par
00009 {\cf21 #include "../../includes/mg.h"}\par
00010 {\cf21 #include "../../includes/efi.h"}\par
00011 \par
00012 {\cf17 static} {\cf18 bool} validate_acpi_chksum(uint8_t* data, {\cf18 size_t} len) \{\par
00013     uint8_t sum = 0;\par
00014     {\cf20 // acpi checksums work by 8 bit addition, if it results 0, the checksum is valid.}\par
00015     {\cf19 for} ({\cf18 size_t} i = 0; i < len; i++) \{\par
00016         sum += data[i];\par
00017     \}\par
00018     {\cf19 return} sum == 0;\par
00019 \}\par
00020 \par
00021 {\cf17 extern} BOOT_INFO boot_info_local;\par
00022 \par
00023 {\cf17 static} {\cf18 void} map_physical_range(uint64_t phys, {\cf18 size_t} length, uint32_t flags) \{\par
00024     uint64_t start = phys & 0xFFFULL;\par
00025     uint64_t end = ((phys + length) + VirtualPageSize - 1) & 0xFFFULL;\par
00026     {\cf19 for} (uint64_t p = start; p < end; p += VirtualPageSize) \{\par
00027         uintptr_t v = (p + PhysicalMemoryOffset);\par
00028         PMMPTE pte = MiGetPtePointer(v);\par
00029         MI_WRITE_PTE(pte, v, p, flags);\par
00030     \}\par
00031 \}\par
00032 \par
00033 {\cf17 static} {\cf18 void}* MiFindACPIHeader(XSDT* xsdt, {\cf17 const} {\cf18 char}* headerSignature) \{\par
00034     uint32_t xsdt_len = xsdt->h.Length;\par
00035     {\cf19 if} (xsdt_len < {\cf17 sizeof}(ACPI_SDT_HEADER)) {\cf19 return} NULL;\par
00036     uint32_t entries = (xsdt_len - {\cf17 sizeof}(ACPI_SDT_HEADER)) / {\cf17 sizeof}(uint64_t);\par
00037 {\cf21 #ifdef DEBUG}\par
00038     gop_printf(COLOR_RED, {\cf22 "Amount of ACPI Entries: %d\\n"}, entries);\par
00039 {\cf21 #endif}\par
00040     {\cf19 for} (uint32_t i = 0; i < entries; ++i) \{\par
00041         uint64_t headerPhys = xsdt->Entries[i]; \par
00042         map_physical_range(headerPhys, {\cf17 sizeof}(ACPI_SDT_HEADER), PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00043         ACPI_SDT_HEADER* hdr = (ACPI_SDT_HEADER*)(headerPhys + PhysicalMemoryOffset);\par
00044 \par
00045         {\cf20 // check signature quickly}\par
00046         {\cf19 if} (kmemcmp(hdr->Signature, headerSignature, 4) == 0) \{\par
00047 {\cf21 #ifdef DEBUG}\par
00048             gop_printf(COLOR_RED, {\cf22 "Iteration %d, signature valid.\\n"}, i);\par
00049 {\cf21 #endif}\par
00050             uint32_t table_len = hdr->Length;\par
00051             {\cf19 if} (table_len < {\cf17 sizeof}(ACPI_SDT_HEADER)) \{\par
00052 {\cf21 #ifdef DEBUG}\par
00053                 gop_printf(COLOR_RED, {\cf22 "Iteration %d, table_len < sizeof(ACPI_SDT_HEADER), continuing...\\n"}, i); \par
00054 {\cf21 #endif}\par
00055                 {\cf19 continue}; {\cf20 // invalid length}\par
00056             \}\par
00057             {\cf20 // map full table}\par
00058             map_physical_range(headerPhys, table_len, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00059             {\cf20 // validate table checksum}\par
00060             {\cf19 if} (!validate_acpi_chksum((uint8_t*)hdr, table_len)) \{ gop_printf(COLOR_RED, {\cf22 "ACPI Checksum invalid..\\n"}); {\cf19 continue}; \}\par
00061 {\cf21 #ifdef DEBUG}\par
00062             gop_printf(COLOR_LIME, {\cf22 "Returning specified header at pointer %p\\n"}, hdr);\par
00063 {\cf21 #endif}\par
00064             {\cf19 return} ({\cf18 void}*)hdr;\par
00065         \}\par
00066 {\cf21 #ifdef DEBUG}\par
00067         {\cf19 else} \{\par
00068             gop_printf(COLOR_RED, {\cf22 "Signature for iteration %d isn't valid... Pointer (physical): %p\\n"}, i, ({\cf18 void}*)(uintptr_t)headerPhys);\par
00069         \}\par
00070 {\cf21 #endif}\par
00071     \}\par
00072 {\cf21 #ifdef DEBUG}\par
00073     gop_printf(COLOR_RED, {\cf22 "Exhausted all iterations, returning NULL.\\n"});\par
00074 {\cf21 #endif}\par
00075     {\cf19 return} NULL;\par
00076 \}\par
00077 \par
00078 {\cf20 // Global table definitions}\par
00079 FADT* fadt;\par
00080 MADT* madt;\par
00081 \par
00082 {\cf18 void} \par
00083 MhRebootComputer (\par
00084     {\cf18 void}\par
00085 ) \par
00086 \par
00087 {\cf20 /*++}\par
00088 {\cf20 }\par
00089 {\cf20     Routine description : This function cold resets the computer, it does not return. Call appropriate cleanup functions before calling this function.}\par
00090 {\cf20 }\par
00091 {\cf20     Arguments:}\par
00092 {\cf20 }\par
00093 {\cf20         None.}\par
00094 {\cf20 }\par
00095 {\cf20     Return Values:}\par
00096 {\cf20 }\par
00097 {\cf20         None.}\par
00098 {\cf20 }\par
00099 {\cf20 --*/}\par
00100 \par
00101 \{\par
00102     {\cf19 if} (!fadt) {\cf19 return};\par
00103     {\cf19 if} (fadt->ResetReg.Address == 0) \{\par
00104         gop_printf(COLOR_RED, {\cf22 "No ACPI Reset Register present.\\n"});\par
00105         {\cf19 return};\par
00106     \}\par
00107     uint16_t port;\par
00108     uint64_t phys;\par
00109     {\cf19 switch} (fadt->ResetReg.AddressSpace) \{\par
00110     {\cf19 case} 1: {\cf20 // System I/O}\par
00111         port = (uint16_t)fadt->ResetReg.Address;\par
00112         __outbyte(port, fadt->ResetValue);\par
00113         {\cf19 break};\par
00114     {\cf19 case} 0: {\cf20 // Memory mapped (MMIO)}\par
00115         phys = fadt->ResetReg.Address;\par
00116         {\cf20 // Map one page containing the reset register itself.}\par
00117         PMMPTE pte = MiGetPtePointer((uintptr_t)phys);\par
00118         MI_WRITE_PTE(pte, phys, phys, PAGE_PRESENT | PAGE_RW | PAGE_PWT | PAGE_PCD);\par
00119         {\cf17 volatile} uint8_t* reg = ({\cf17 volatile} uint8_t*)phys;\par
00120         *reg = fadt->ResetValue;\par
00121         {\cf19 break};\par
00122     {\cf19 default}:\par
00123         gop_printf(COLOR_RED, {\cf22 "Unsupported ACPI reset AddressSpace: %d\\n"},\par
00124             fadt->ResetReg.AddressSpace);\par
00125         {\cf19 break};\par
00126     \}\par
00127 \par
00128 \}\par
00129 \par
00130 MTSTATUS MhParseLAPICs(uint8_t* buffer, {\cf18 size_t} maxCPUs, uint32_t* cpuCount, uint32_t* lapicAddress) \{\par
00131     {\cf19 if} (!madt) {\cf19 return} MT_NO_RESOURCES;\par
00132     {\cf20 // Deference the lapicAddress ptr and put the lapic address for each CPU there.}\par
00133     *lapicAddress = madt->lapicAddress;\par
00134     {\cf18 size_t} count = 0;\par
00135     {\cf20 // The pointer right after the MADT table (according to the spec)}\par
00136     uint8_t* ptr = (uint8_t*)madt + {\cf17 sizeof}(MADT);\par
00137     {\cf20 // The end of pointer is the length of the whole table itself.}\par
00138     uint8_t* end = (uint8_t*)madt + madt->h.Length;\par
00139 \par
00140     {\cf19 while} (ptr < end && count < maxCPUs) \{\par
00141         uint8_t type = ptr[0];\par
00142         uint8_t len = ptr[1];\par
00143 \par
00144         {\cf19 if} (type == MADT_LAPIC) \{\par
00145             {\cf20 // Found a LAPIC table.}\par
00146             MADT_LOCAL_APIC* lapic = (MADT_LOCAL_APIC*)ptr;\par
00147             {\cf19 if} (lapic->Flags & 1) \{\par
00148                 {\cf20 // Enabled}\par
00149                 gop_printf(COLOR_LIME, {\cf22 "Found a CPU with LAPIC ID %d\\n"}, lapic->ApicId);\par
00150                 buffer[count++] = lapic->ApicId; {\cf20 // Store the APIC ID.}\par
00151             \}\par
00152         \}\par
00153 \par
00154         ptr += len;\par
00155     \}\par
00156 \par
00157     {\cf19 if} (count > 0) \{\par
00158         *cpuCount = count;\par
00159         {\cf19 return} MT_SUCCESS;\par
00160     \}\par
00161     {\cf19 else} {\cf19 return} MT_GENERAL_FAILURE;\par
00162 \}\par
00163 \par
00164 MTSTATUS MhInitializeACPI({\cf18 void}) \{\par
00165     uintptr_t rsdpPhys = boot_info_local.AcpiRsdpPhys;\par
00166     {\cf19 if} (!rsdpPhys) {\cf19 return} MT_INVALID_ADDRESS;\par
00167     map_physical_range(rsdpPhys, {\cf17 sizeof}(RSDP_Descriptor), PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00168     RSDP_Descriptor* rsdp = (RSDP_Descriptor*)(rsdpPhys + PhysicalMemoryOffset);\par
00169 \par
00170     {\cf20 // Validate signatures and checksums.}\par
00171     {\cf19 if} (kmemcmp(rsdp->Signature, {\cf22 "RSD PTR "}, 8) != 0) {\cf19 return} (MTSTATUS)0xC000BABE;\par
00172     {\cf19 if} (!validate_acpi_chksum((uint8_t*)rsdp, 20)) {\cf19 return} MT_INVALID_CHECK;\par
00173     uint64_t xsdtPhys = 0;\par
00174     {\cf19 if} (rsdp->Revision >= 2 && rsdp->Length >= {\cf17 sizeof}(RSDP_Descriptor)) \{\par
00175         {\cf20 // map whole RSDP length}\par
00176         map_physical_range(rsdpPhys, rsdp->Length, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00177         {\cf19 if} (!validate_acpi_chksum((uint8_t*)rsdp, rsdp->Length)) {\cf19 return} MT_INVALID_CHECK;\par
00178         xsdtPhys = rsdp->XsdtAddress;\par
00179     \}\par
00180     {\cf19 if} (!xsdtPhys) {\cf19 return} (MTSTATUS)0xC000BEEF;\par
00181 \par
00182     {\cf20 // Map XSDT header first so we can read its Length}\par
00183     map_physical_range(xsdtPhys, {\cf17 sizeof}(ACPI_SDT_HEADER), PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00184     XSDT* xsdt = (XSDT*)(xsdtPhys + PhysicalMemoryOffset);\par
00185     {\cf19 if} (xsdt->h.Length < {\cf17 sizeof}(ACPI_SDT_HEADER)) {\cf19 return} MT_INVALID_STATE;\par
00186 \par
00187     {\cf20 // Map the entire XSDT table}\par
00188     map_physical_range(xsdtPhys, xsdt->h.Length, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00189 \par
00190     {\cf20 // Now find FACP (FADT) (the function checks for checksum automatically)}\par
00191     ACPI_SDT_HEADER* facp = (ACPI_SDT_HEADER*)MiFindACPIHeader(xsdt, {\cf22 "FACP"});\par
00192     {\cf19 if} (!facp) {\cf19 return} MT_NOT_FOUND;\par
00193 \par
00194     {\cf20 // put in the global FADT ptr}\par
00195     fadt = (FADT*)facp;\par
00196 \par
00197     {\cf20 // Find MADT}\par
00198     ACPI_SDT_HEADER* madtACPI = (ACPI_SDT_HEADER*)MiFindACPIHeader(xsdt, {\cf22 "APIC"});\par
00199     {\cf19 if} (!madtACPI) {\cf19 return} MT_NOT_FOUND;\par
00200 \par
00201     madt = (MADT*)madtACPI;\par
00202 \par
00203     {\cf19 return} MT_SUCCESS;\par
00204 \}\par
00205 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/ap_main.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/ap_main.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/ap_main.c}
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b APMain} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
---------------\'97 FUNCTIONS ---------------\'97 }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SMP_BOOTINFO} {\b bootInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PROCESSOR} {\b cpus} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_PTR} {\b PIDT}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v APMain\:ap_main.c}
{\xe \v ap_main.c\:APMain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void APMain (void )}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
---------------\'97 FUNCTIONS ---------------\'97 }}\par
{
Definition at line {\b 35} of file {\b ap_main.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v bootInfo\:ap_main.c}
{\xe \v ap_main.c\:bootInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SMP_BOOTINFO} bootInfo{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b smp.c}.}\par
}
{\xe \v cpus\:ap_main.c}
{\xe \v ap_main.c\:cpus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PROCESSOR} cpus[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b smp.c}.}\par
}
{\xe \v PIDT\:ap_main.c}
{\xe \v ap_main.c\:PIDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_PTR} PIDT{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b idt.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ap_main.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/ap_main.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/ap_main.c}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "../../includes/mh.h"}\par
00002 {\cf21 #include "../../includes/mg.h"}\par
00003 {\cf21 #include "../../includes/me.h"}\par
00004 {\cf21 #include "../../assert.h"}\par
00005 \par
00006 {\cf17 extern} SMP_BOOTINFO bootInfo;\par
00007 {\cf17 extern} PROCESSOR cpus[];\par
00008 \par
00009 {\cf17 extern} IDT_PTR PIDT;\par
00010 \par
00011 {\cf17 static} {\cf17 inline} uint64_t build_seg(uint32_t base, uint32_t limit, uint8_t access, uint8_t gran) \{\par
00012     uint64_t desc = 0;\par
00013     desc = (limit & 0xFFFFull);\par
00014     desc |= (uint64_t)(base & 0xFFFFull) << 16;\par
00015     desc |= (uint64_t)((base >> 16) & 0xFFull) << 32;\par
00016     desc |= (uint64_t)access << 40;\par
00017     uint8_t gran_byte = (uint8_t)(((limit >> 16) & 0x0Fu) | (gran & 0xF0u));\par
00018     desc |= (uint64_t)gran_byte << 48;\par
00019     desc |= (uint64_t)((base >> 24) & 0xFFull) << 56;\par
00020     {\cf19 return} desc;\par
00021 \}\par
00022 \par
00023 {\cf17 static} {\cf17 inline} uint8_t get_initial_apic_id({\cf18 void}) \{\par
00024     uint32_t eax, ebx, ecx, edx;\par
00025 \par
00026     {\cf20 // When EAX=1, CPUID returns processor info.}\par
00027     {\cf20 // The initial APIC ID is in bits 31-24 of the EBX register.}\par
00028     __asm__ {\cf17 volatile}({\cf22 "cpuid"}\par
00029         : {\cf22 "=a"}(eax), {\cf22 "=b"}(ebx), {\cf22 "=c"}(ecx), {\cf22 "=d"}(edx)\par
00030         : {\cf22 "a"}(1), {\cf22 "c"}(0));\par
00031 \par
00032     {\cf19 return} (uint8_t)(ebx >> 24);\par
00033 \}\par
00034 \par
00035 {\cf18 void} APMain({\cf18 void}) \{\par
00036     {\cf20 // First, setup the GDT&TSS, then IDT.}\par
00037     {\cf18 int} idx = -1;\par
00038     {\cf20 // early map lapic mmio (lapic_init_cpu maps it).}\par
00039     uint8_t {\cf18 id} = get_initial_apic_id();\par
00040 \par
00041     {\cf19 for} ({\cf18 int} i = 0; i < (int)bootInfo.cpu_count && i < MAX_CPUS; i++) \{\par
00042         {\cf19 if} (cpus[i].lapic_ID == {\cf18 id}) \{ idx = i; {\cf19 break}; \}\par
00043     \}\par
00044 \par
00045     {\cf19 if} (idx < 0) \{\par
00046         assert({\cf17 false}, {\cf22 "All APs must be initialized fully and successfully."});\par
00047         gop_printf(COLOR_RED, {\cf22 "**Fatal error, AP Failed to initialize, index below 0.**\\n"});\par
00048         __hlt();\par
00049     \}\par
00050     __writemsr(IA32_GS_BASE, (uint64_t)&cpus[idx]);\par
00051 \par
00052     {\cf20 // Self invalidate all TLBs}\par
00053     __write_cr3(__read_cr3());\par
00054 \par
00055     {\cf20 // Now setup the IDT for the CPU. (load the one setupped by the smp func)}\par
00056     __lidt(&PIDT);\par
00057 \par
00058     {\cf20 // Initiate per cpu functions.}\par
00059     MeInitializeProcessor(MeGetCurrentProcessor(), {\cf17 true}, {\cf17 true});\par
00060     \par
00061     {\cf20 // Initialize the MM For current core (init PAT)}\par
00062     MmInitSystem(SYSTEM_PHASE_INITIALIZE_PAT_ONLY, NULL);\par
00063 \par
00064     {\cf20 // Initialize the idle thread.}\par
00065     InitScheduler();\par
00066 \par
00067     {\cf20 // mark as online and clear being unavailable}\par
00068     InterlockedOrU64(&cpus[idx].flags, CPU_ONLINE); \par
00069     InterlockedAndU64(&cpus[idx].flags, ~CPU_UNAVAILABLE);   {\cf20 // clear unavailable}\par
00070     gop_printf(COLOR_ORANGE, {\cf22 "**Hello From AP CPU! - I'm ID: %d | StackTop: %p | CPU Ptr: %p**\\n"}, {\cf18 id}, MeGetCurrentProcessor()->VirtStackTop, MeGetCurrentProcessor());\par
00071     {\cf20 // enable interupts, initiate timer and join scheduler queue}\par
00072     lapic_init_cpu();\par
00073     lapic_enable();\par
00074     init_lapic_timer(100);\par
00075     __sti();\par
00076     Schedule();\par
00077     {\cf19 for} (;;) __hlt();\par
00078 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/apic.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/apic.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/apic.c}
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IA32_APIC_BASE_MSR}\~ 0x1BULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APIC_BASE_RESERVED}\~ 0xFFF0000000000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_PAGE_SIZE}\~ 0x1000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_MAP_FLAGS}\~ ({\b PAGE_PRESENT} | {\b PAGE_RW} | {\b PAGE_PCD})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APIC_LVT_TIMER_PERIODIC}\~ (1U << 17)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b APIC_TIMER_MASKED}\~ (1U << 16)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b LAPIC_VERSION} = 0x030
, {\b LAPIC_TPR} = 0x080
, {\b LAPIC_EOI} = 0x0B0
, {\b LAPIC_SVR} = 0x0F0
, {\b LAPIC_ESR} = 0x280
, {\b LAPIC_ICR_LOW} = 0x300
, {\b LAPIC_ICR_HIGH} = 0x310
, {\b LAPIC_LVT_TIMER} = 0x320
, {\b LAPIC_LVT_THERMAL} = 0x330
, {\b LAPIC_LVT_PCC} = 0x340
, {\b LAPIC_LVT_LINT0} = 0x350
, {\b LAPIC_LVT_LINT1} = 0x360
, {\b LAPIC_LVT_ERROR} = 0x370
, {\b LAPIC_TIMER_INITCNT} = 0x380
, {\b LAPIC_TIMER_CURRCNT} = 0x390
, {\b LAPIC_TIMER_DIV} = 0x3E0
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapic_mmio_read} (uint32_t off)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_mmio_write} (uint32_t off, uint32_t val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_init_siv} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_enable} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_init_cpu} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_send_ipi} (uint8_t apic_id, uint8_t vector, uint32_t {\b flags})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_timer_calibrate} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b init_lapic_timer} (uint32_t hz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhRequestSoftwareInterrupt} ({\b IN} {\b IRQL} RequestIrql)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v APIC_BASE_RESERVED\:apic.c}
{\xe \v apic.c\:APIC_BASE_RESERVED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APIC_BASE_RESERVED\~ 0xFFF0000000000000ULL}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b apic.c}.}\par
}
{\xe \v APIC_LVT_TIMER_PERIODIC\:apic.c}
{\xe \v apic.c\:APIC_LVT_TIMER_PERIODIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APIC_LVT_TIMER_PERIODIC\~ (1U << 17)}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b apic.c}.}\par
}
{\xe \v APIC_TIMER_MASKED\:apic.c}
{\xe \v apic.c\:APIC_TIMER_MASKED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define APIC_TIMER_MASKED\~ (1U << 16)}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b apic.c}.}\par
}
{\xe \v IA32_APIC_BASE_MSR\:apic.c}
{\xe \v apic.c\:IA32_APIC_BASE_MSR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IA32_APIC_BASE_MSR\~ 0x1BULL}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b apic.c}.}\par
}
{\xe \v LAPIC_MAP_FLAGS\:apic.c}
{\xe \v apic.c\:LAPIC_MAP_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_MAP_FLAGS\~ ({\b PAGE_PRESENT} | {\b PAGE_RW} | {\b PAGE_PCD})}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b apic.c}.}\par
}
{\xe \v LAPIC_PAGE_SIZE\:apic.c}
{\xe \v apic.c\:LAPIC_PAGE_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_PAGE_SIZE\~ 0x1000}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b apic.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LAPIC_VERSION\:apic.c}
{\xe \v apic.c\:LAPIC_VERSION}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_VERSION{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
\cell }{\cell }{\row }
{\xe \v LAPIC_TPR\:apic.c}
{\xe \v apic.c\:LAPIC_TPR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TPR{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
\cell }{\cell }{\row }
{\xe \v LAPIC_EOI\:apic.c}
{\xe \v apic.c\:LAPIC_EOI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_EOI{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
\cell }{\cell }{\row }
{\xe \v LAPIC_SVR\:apic.c}
{\xe \v apic.c\:LAPIC_SVR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_SVR{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
\cell }{\cell }{\row }
{\xe \v LAPIC_ESR\:apic.c}
{\xe \v apic.c\:LAPIC_ESR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ESR{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
\cell }{\cell }{\row }
{\xe \v LAPIC_ICR_LOW\:apic.c}
{\xe \v apic.c\:LAPIC_ICR_LOW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ICR_LOW{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
\cell }{\cell }{\row }
{\xe \v LAPIC_ICR_HIGH\:apic.c}
{\xe \v apic.c\:LAPIC_ICR_HIGH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_ICR_HIGH{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_TIMER\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_TIMER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_TIMER{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_THERMAL\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_THERMAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_THERMAL{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_PCC\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_PCC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_PCC{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_LINT0\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_LINT0}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_LINT0{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_LINT1\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_LINT1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_LINT1{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
\cell }{\cell }{\row }
{\xe \v LAPIC_LVT_ERROR\:apic.c}
{\xe \v apic.c\:LAPIC_LVT_ERROR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_LVT_ERROR{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\cell }{\cell }{\row }
{\xe \v LAPIC_TIMER_INITCNT\:apic.c}
{\xe \v apic.c\:LAPIC_TIMER_INITCNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TIMER_INITCNT{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
\cell }{\cell }{\row }
{\xe \v LAPIC_TIMER_CURRCNT\:apic.c}
{\xe \v apic.c\:LAPIC_TIMER_CURRCNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TIMER_CURRCNT{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
\cell }{\cell }{\row }
{\xe \v LAPIC_TIMER_DIV\:apic.c}
{\xe \v apic.c\:LAPIC_TIMER_DIV}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_TIMER_DIV{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 16} of file {\b apic.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_lapic_timer\:apic.c}
{\xe \v apic.c\:init_lapic_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int init_lapic_timer (uint32_t hz)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b apic.c}.}\par
}
{\xe \v lapic_enable\:apic.c}
{\xe \v apic.c\:lapic_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_enable (void )}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b apic.c}.}\par
}
{\xe \v lapic_eoi\:apic.c}
{\xe \v apic.c\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void )}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b apic.c}.}\par
}
{\xe \v lapic_init_cpu\:apic.c}
{\xe \v apic.c\:lapic_init_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_init_cpu (void )}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b apic.c}.}\par
}
{\xe \v lapic_init_siv\:apic.c}
{\xe \v apic.c\:lapic_init_siv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_init_siv (void )}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b apic.c}.}\par
}
{\xe \v lapic_mmio_read\:apic.c}
{\xe \v apic.c\:lapic_mmio_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapic_mmio_read (uint32_t off)}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b apic.c}.}\par
}
{\xe \v lapic_mmio_write\:apic.c}
{\xe \v apic.c\:lapic_mmio_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_mmio_write (uint32_t off, uint32_t val)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b apic.c}.}\par
}
{\xe \v lapic_send_ipi\:apic.c}
{\xe \v apic.c\:lapic_send_ipi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_send_ipi (uint8_t apic_id, uint8_t vector, uint32_t flags)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b apic.c}.}\par
}
{\xe \v lapic_timer_calibrate\:apic.c}
{\xe \v apic.c\:lapic_timer_calibrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_timer_calibrate (void )}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b apic.c}.}\par
}
{\xe \v MhRequestSoftwareInterrupt\:apic.c}
{\xe \v apic.c\:MhRequestSoftwareInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhRequestSoftwareInterrupt ({\b IN} {\b IRQL} RequestIrql)}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b apic.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
apic.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/apic.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/apic.c}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "../../includes/me.h"}\par
00002 {\cf21 #include "../../includes/mh.h"}\par
00003 {\cf21 #include "../../includes/mm.h"}\par
00004 {\cf21 #include "../../includes/mg.h"}\par
00005 {\cf21 #include "../../assert.h"}\par
00006 {\cf21 #include <stddef.h>}\par
00007 {\cf21 #include <stdint.h>}\par
00008 \par
00009 {\cf21 #define IA32_APIC_BASE_MSR     0x1BULL}\par
00010 {\cf21 #define APIC_BASE_RESERVED     0xFFF0000000000000ULL}\par
00011 \par
00012 {\cf21 #define LAPIC_PAGE_SIZE    0x1000}\par
00013 {\cf21 #define LAPIC_MAP_FLAGS (PAGE_PRESENT | PAGE_RW | PAGE_PCD)}\par
00014 \par
00015 {\cf20 // LAPIC register offsets (32-bit registers)}\par
00016 {\cf17 enum} \{\par
00017     LAPIC_VERSION = 0x030,\par
00018     LAPIC_TPR = 0x080,\par
00019     LAPIC_EOI = 0x0B0,\par
00020     LAPIC_SVR = 0x0F0,\par
00021     LAPIC_ESR = 0x280,\par
00022     LAPIC_ICR_LOW = 0x300,\par
00023     LAPIC_ICR_HIGH = 0x310,\par
00024     LAPIC_LVT_TIMER = 0x320,\par
00025     LAPIC_LVT_THERMAL = 0x330,\par
00026     LAPIC_LVT_PCC = 0x340,\par
00027     LAPIC_LVT_LINT0 = 0x350,\par
00028     LAPIC_LVT_LINT1 = 0x360,\par
00029     LAPIC_LVT_ERROR = 0x370,\par
00030     LAPIC_TIMER_INITCNT = 0x380,\par
00031     LAPIC_TIMER_CURRCNT = 0x390,\par
00032     LAPIC_TIMER_DIV = 0x3E0\par
00033 \};\par
00034 \par
00035 {\cf20 // --- low-level mmio helpers (assumes lapic mapped to virtual memory) ---}\par
00036 uint32_t lapic_mmio_read(uint32_t off) \{\par
00037     {\cf20 // Hi matanel, if you ever encounter enormous page faults in this area, with MmAccessFault not even bugchecking.}\par
00038     {\cf20 // It is because an IPI was sent from an AP that hasn't been fully initialized.}\par
00039     {\cf20 // Thus somehow in gods existence corrupting stuff.}\par
00040     {\cf20 // Like in the case of MI_WRITE_PTE, it sent an IPI when it was used in map_lapic, and caused like a chain reaction that formed into a black hole.}\par
00041     {\cf20 // So I added another flag allApsInitialized, so that MI_WRITE_PTE will not send an IPI if they are not init yet.}\par
00042     {\cf19 return} MeGetCurrentProcessor()->LapicAddressVirt[off / 4];\par
00043 \}\par
00044 \par
00045 {\cf18 void} lapic_mmio_write(uint32_t off, uint32_t val) \{\par
00046     {\cf20 // Read my lapic_mmio_read comment if page faults ever happen here.}\par
00047     MeGetCurrentProcessor()->LapicAddressVirt[off / 4] = val;\par
00048     (void)MeGetCurrentProcessor()->LapicAddressVirt[0]; {\cf20 // Serializing read}\par
00049 \}\par
00050 \par
00051 {\cf20 // Wait for ICR delivery to complete (ICR low: bit 12 = Delivery Status)}\par
00052 {\cf17 static} {\cf18 void} lapic_wait_icr({\cf18 void}) \{\par
00053     {\cf19 while} (lapic_mmio_read(LAPIC_ICR_LOW) & (1 << 12)) \{\par
00054         {\cf20 /* spin */}\par
00055         __pause();\par
00056     \}\par
00057 \}\par
00058 \par
00059 {\cf20 // Initialize the Spurious Interrupt Vector}\par
00060 {\cf18 void} lapic_init_siv({\cf18 void}) \{\par
00061     uint32_t svr = lapic_mmio_read(LAPIC_SVR);\par
00062     uint32_t vector = 0xFF; {\cf20 // IDT Entry}\par
00063     svr = (svr & 0xFFFFFF00) | vector; {\cf20 // preserve enable bit, update vector.}\par
00064     lapic_mmio_write(LAPIC_SVR, svr);\par
00065 \}\par
00066 \par
00067 {\cf17 static} {\cf18 void} map_lapic(uint64_t lapicPhysicalAddr) \{\par
00068     {\cf19 if} (MeGetCurrentProcessor()->LapicAddressVirt) {\cf19 return};\par
00069 \par
00070     {\cf18 void}* virt = ({\cf18 void}*)(lapicPhysicalAddr + PhysicalMemoryOffset);\par
00071 \par
00072     {\cf20 // Map the single LAPIC page (phys -> virt)}\par
00073     PMMPTE pte = MiGetPtePointer((uintptr_t)virt);\par
00074     assert(pte != NULL);\par
00075     {\cf19 if} (!pte) {\cf19 return};\par
00076     MI_WRITE_PTE(pte, virt, lapicPhysicalAddr, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00077 \par
00078     {\cf20 // store the mmio base pointer}\par
00079     MeGetCurrentProcessor()->LapicAddressVirt = ({\cf17 volatile} uint32_t*)virt;\par
00080     MeGetCurrentProcessor()->LapicAddressPhys = lapicPhysicalAddr;\par
00081 \}\par
00082 \par
00083 {\cf17 static} {\cf17 inline} uint64_t get_lapic_base_address({\cf18 void}) \{\par
00084     uint32_t eax, edx;\par
00085 \par
00086     {\cf20 // The 'rdmsr' instruction reads a 64-bit MSR into the EDX:EAX registers.}\par
00087     __asm__ {\cf17 volatile}({\cf22 "rdmsr"} : {\cf22 "=a"}(eax), {\cf22 "=d"}(edx) : {\cf22 "c"}(IA32_APIC_BASE_MSR));\par
00088 \par
00089     {\cf20 // Combine the high (edx) and low (eax) parts into a 64-bit value.}\par
00090     uint64_t msr_value = ((uint64_t)edx << 32) | eax;\par
00091 \par
00092     {\cf20 // The address is in bits 12 through the most significant bit.}\par
00093     {\cf20 // We must mask off the lower 12 bits which contain flags.}\par
00094     {\cf19 return} msr_value & ~0xFFFULL;\par
00095 \}\par
00096 \par
00097 {\cf20 // Enable local APIC via IA32_APIC_BASE MSR and set SVR}\par
00098 {\cf18 void} lapic_enable({\cf18 void}) \{\par
00099     uint64_t apic_msr = __readmsr(IA32_APIC_BASE_MSR);\par
00100     {\cf19 if} (!(apic_msr & (1ULL << 11))) \{\par
00101         {\cf20 // set APIC global enable}\par
00102         apic_msr |= (1ULL << 11);\par
00103         __writemsr(IA32_APIC_BASE_MSR, apic_msr);\par
00104     \}\par
00105     map_lapic(get_lapic_base_address());\par
00106 \par
00107     {\cf20 // Set Spurious Vector Register and enable (bit 8 = APIC enable)}\par
00108     uint32_t svr = (0xFF) | (1 << 8);\par
00109     lapic_mmio_write(LAPIC_SVR, svr);\par
00110 \}\par
00111 \par
00112 {\cf20 // Initialize CPU's LAPIC (call early from kernel init on BSP, and from each ap)}\par
00113 {\cf18 void} lapic_init_cpu({\cf18 void}) \{\par
00114     map_lapic(get_lapic_base_address());\par
00115 \par
00116     lapic_enable();\par
00117 \par
00118     {\cf20 // mask LINT0/LINT1 as appropriate, clear error status, etc.}\par
00119     lapic_mmio_write(LAPIC_LVT_LINT0, (1U << 16)); {\cf20 // mask}\par
00120     lapic_mmio_write(LAPIC_LVT_LINT1, (1U << 16)); {\cf20 // mask}\par
00121     lapic_mmio_write(LAPIC_LVT_ERROR, (1U << 16)); {\cf20 // mask (until handler in place)}\par
00122     lapic_mmio_write(LAPIC_EOI, 0);\par
00123 \}\par
00124 \par
00125 {\cf20 // send IPI to APIC id }\par
00126 {\cf20 // apic_id - APICId of the CPU.}\par
00127 {\cf20 // vector - IDT Vector number}\par
00128 {\cf20 // flags - specified cpu flags, 0 for none.}\par
00129 {\cf18 void} lapic_send_ipi(uint8_t apic_id, uint8_t vector, uint32_t flags) \{\par
00130     uint32_t high = ((uint32_t)apic_id) << 24;\par
00131     lapic_mmio_write(LAPIC_ICR_HIGH, high);\par
00132     lapic_mmio_write(LAPIC_ICR_LOW, (uint32_t)vector | flags);\par
00133     lapic_wait_icr();\par
00134 \}\par
00135 \par
00136 {\cf18 void} lapic_eoi({\cf18 void}) \{\par
00137     lapic_mmio_write(LAPIC_EOI, 0);\par
00138 \}\par
00139 \par
00140 {\cf20 // --- Timer calibration and init ---}\par
00141 {\cf20 // NOTE: the APIC timer is a downward counter. Strategy:}\par
00142 {\cf20 //  1. Set divide to known divisor.}\par
00143 {\cf20 //  2. Write initcount = 0xFFFFFFFF.}\par
00144 {\cf20 //  3. Wait EXACTLY 100 ms via PIT/HPET.}\par
00145 {\cf20 //  4. curr = read current count -> ticks_in_100ms = start - curr}\par
00146 {\cf20 //  5. ticks_per_period(10ms) = ticks_in_100ms / 10}\par
00147 {\cf20 //  6. Program LVT timer to periodic and initial count = ticks_per_period}\par
00148 {\cf20 //}\par
00149 {\cf21 #define APIC_LVT_TIMER_PERIODIC (1U << 17)}\par
00150 {\cf21 #define APIC_TIMER_MASKED        (1U << 16)}\par
00151 \par
00152 {\cf17 static} uint32_t calibrate_lapic_ticks_per_10ms({\cf18 void}) \{\par
00153     {\cf20 // choose divide config: here set encode 0x3 (divide by 16). Adjust if needed.}\par
00154     lapic_mmio_write(LAPIC_TIMER_DIV, 0x3);\par
00155 \par
00156     {\cf17 const} uint32_t start = 0xFFFFFFFFU;\par
00157     lapic_mmio_write(LAPIC_TIMER_INITCNT, start);\par
00158 \par
00159     pit_sleep_ms(100);\par
00160 \par
00161     uint32_t curr = lapic_mmio_read(LAPIC_TIMER_CURRCNT);\par
00162     uint32_t ticks = start - curr;\par
00163     {\cf19 if} (ticks == 0) {\cf19 return} 0;\par
00164     {\cf19 return} ticks / 10; {\cf20 // ticks per 10ms -> for 100Hz (10ms period)}\par
00165 \}\par
00166 \par
00167 {\cf20 // Make the global variable static to this file}\par
00168 {\cf17 static} uint32_t g_apic_ticks_per_10ms = 0;\par
00169 \par
00170 {\cf20 // BSP-only calibration function}\par
00171 {\cf18 void} lapic_timer_calibrate({\cf18 void}) \{\par
00172     {\cf20 // Only calibrate if it hasn't been done. This is the single entry point.}\par
00173     {\cf19 if} (g_apic_ticks_per_10ms == 0) \{\par
00174         g_apic_ticks_per_10ms = calibrate_lapic_ticks_per_10ms();\par
00175     \}\par
00176 \}\par
00177 \par
00178 {\cf20 // Renamed and simplified init function}\par
00179 {\cf18 int} init_lapic_timer(uint32_t hz) \{\par
00180     {\cf19 if} (hz == 0) {\cf19 return} -1;\par
00181 \par
00182     {\cf20 // This now assumes calibration is already done!}\par
00183     {\cf19 if} (g_apic_ticks_per_10ms == 0) \{\par
00184         {\cf20 // Calibration failed or wasn't run, this is an error.}\par
00185         {\cf19 return} -2;\par
00186     \}\par
00187 \par
00188     uint32_t period_ms = 1000 / hz;\par
00189     uint64_t initial = ((uint64_t)g_apic_ticks_per_10ms * (uint64_t)period_ms) / 10ULL;\par
00190     {\cf19 if} (initial == 0) initial = 1;\par
00191 \par
00192     {\cf20 // Program THIS CPU's timer using the shared calibration value}\par
00193     lapic_mmio_write(LAPIC_LVT_TIMER, APIC_LVT_TIMER_PERIODIC | 0xEF {\cf20 /* vector */});\par
00194     lapic_mmio_write(LAPIC_TIMER_INITCNT, (uint32_t)initial);\par
00195     {\cf19 return} 0;\par
00196 \}\par
00197 \par
00198 {\cf18 void}\par
00199 MhRequestSoftwareInterrupt(\par
00200     IN IRQL RequestIrql\par
00201 )\par
00202 \par
00203 {\cf20 /*++}\par
00204 {\cf20 }\par
00205 {\cf20     Routine description : }\par
00206 {\cf20 }\par
00207 {\cf20         This function is used to request a software interrupt to the current processor.}\par
00208 {\cf20 }\par
00209 {\cf20         N.B: The function will 100% have the interrupt executed when it returns.}\par
00210 {\cf20 }\par
00211 {\cf20     Arguments:}\par
00212 {\cf20 }\par
00213 {\cf20         [IN]    IRQL RequstIrql - The IRQL value to request an interrupt for.}\par
00214 {\cf20 }\par
00215 {\cf20     Return Values:}\par
00216 {\cf20 }\par
00217 {\cf20         None.}\par
00218 {\cf20 }\par
00219 {\cf20     Notes:}\par
00220 {\cf20 }\par
00221 {\cf20         The only IRQLs supported currently are DISPATCH_LEVEL and APC_LEVEL}\par
00222 {\cf20 }\par
00223 {\cf20         To have this function serviced for a DPC or an APC, set the flag in the CPU accordingly and wait for IRQL to be equal or below to IRQL requested.}\par
00224 {\cf20 }\par
00225 {\cf20 --*/}\par
00226 \par
00227 \{\par
00228     {\cf18 bool} prev_if;\par
00229     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00230     assert(cpu->DpcInterruptRequested == {\cf17 true});\par
00231 \par
00232     {\cf20 // We only support DISPATCH_LEVEL.}\par
00233     assert(RequestIrql == DISPATCH_LEVEL || RequestIrql == APC_LEVEL);\par
00234     {\cf19 if} (RequestIrql != DISPATCH_LEVEL && RequestIrql != APC_LEVEL) MeBugCheckEx(INVALID_INTERRUPT_REQUEST, ({\cf18 void}*)RETADDR(0), ({\cf18 void}*)RequestIrql, NULL, NULL);\par
00235 \par
00236     {\cf20 // Disable interrupts, and save IF flag.}\par
00237     prev_if = MeDisableInterrupts();\par
00238 \par
00239     {\cf20 // Clear the flag.}\par
00240     {\cf19 if} (RequestIrql == DISPATCH_LEVEL) \{\par
00241         cpu->DpcInterruptRequested = {\cf17 false};\par
00242     \}\par
00243     {\cf19 else} \{\par
00244         cpu->ApcInterruptRequested = {\cf17 false};\par
00245     \}\par
00246 \par
00247     {\cf20 // wait until previous ICR is not busy}\par
00248     lapic_wait_icr();\par
00249 \par
00250     {\cf20 // For a self IPI we can use the destination shorthand}\par
00251     uint32_t icr_low;\par
00252     {\cf19 if} (RequestIrql == DISPATCH_LEVEL) \{\par
00253         icr_low = (uint32_t)VECTOR_DPC | (1U << 18);\par
00254     \}\par
00255     {\cf19 else} \{\par
00256         icr_low = (uint32_t)VECTOR_APC | (1U << 18);\par
00257     \}\par
00258 \par
00259     {\cf20 // ICR high is ignored when shorthand is used, but zero it for clarity.}\par
00260     lapic_mmio_write(LAPIC_ICR_HIGH, 0);\par
00261     lapic_mmio_write(LAPIC_ICR_LOW, icr_low);\par
00262 \par
00263     {\cf20 // wait for delivery to complete}\par
00264     lapic_wait_icr();\par
00265 \par
00266     {\cf20 // restore interrupts}\par
00267     MeEnableInterrupts(prev_if);\par
00268 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/handlers.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/handlers.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/handlers.c}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/md.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PRINT_ALL_REGS_AND_HALT}(ctxptr,  intfrptr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiLapicInterrupt} (bool schedulerEnabled, {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInterprocessorInterrupt} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiPageFault} ({\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MiDoubleFault} ({\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiDivideByZero} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiDebugTrap} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MiNonMaskableInterrupt} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiBreakpoint} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiOverflow} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiBoundsCheck} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInvalidOpcode} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiNoCoprocessor} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiCoprocessorSegmentOverrun} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInvalidTss} ({\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiSegmentSelectorNotPresent} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiStackSegmentOverrun} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiGeneralProtectionFault} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiFloatingPointError} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiAlignmentCheck} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiMachineCheck} ({\b PTRAP_FRAME} trap)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PRINT_ALL_REGS_AND_HALT\:handlers.c}
{\xe \v handlers.c\:PRINT_ALL_REGS_AND_HALT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PRINT_ALL_REGS_AND_HALT( ctxptr,  intfrptr)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{                                                             \\\par
        gop_printf(COLOR_RED,                                         \\\par
            {\cf22 "RAX=%p RBX=%p RCX=%p RDX=%p\\n"}           \\\par
            {\cf22 "RSI=%p RDI=%p RBP=%p RSP=%p\\n"}           \\\par
            {\cf22 "R8 =%p R9 =%p R10=%p R11=%p\\n"}           \\\par
            {\cf22 "R12=%p R13=%p R14=%p R15=%p\\n"}           \\\par
            {\cf22 "RIP=%p RFLAGS=%p\\n"},                               \\\par
            (ctxptr)->rax, (ctxptr)->rbx, (ctxptr)->rcx, (ctxptr)->rdx, \\\par
            (ctxptr)->rsi, (ctxptr)->rdi, (ctxptr)->rbp, (intfrptr)->rsp, \\\par
            (ctxptr)->r8, (ctxptr)->r9, (ctxptr)->r10, (ctxptr)->r11,    \\\par
            (ctxptr)->r12, (ctxptr)->r13, (ctxptr)->r14, (ctxptr)->r15, \\\par
            (intfrptr)->rip, (intfrptr)->rflags);                       \\\par
        __hlt();                                                      \\\par
    \} {\cf19 while} (0)\par
}
{
Definition at line {\b 13} of file {\b handlers.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v lapic_eoi\:handlers.c}
{\xe \v handlers.c\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b apic.c}.}\par
}
{\xe \v MiAlignmentCheck\:handlers.c}
{\xe \v handlers.c\:MiAlignmentCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiAlignmentCheck ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 468} of file {\b handlers.c}.}\par
}
{\xe \v MiBoundsCheck\:handlers.c}
{\xe \v handlers.c\:MiBoundsCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiBoundsCheck ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 420} of file {\b handlers.c}.}\par
}
{\xe \v MiBreakpoint\:handlers.c}
{\xe \v handlers.c\:MiBreakpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiBreakpoint ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 392} of file {\b handlers.c}.}\par
}
{\xe \v MiCoprocessorSegmentOverrun\:handlers.c}
{\xe \v handlers.c\:MiCoprocessorSegmentOverrun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiCoprocessorSegmentOverrun ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 434} of file {\b handlers.c}.}\par
}
{\xe \v MiDebugTrap\:handlers.c}
{\xe \v handlers.c\:MiDebugTrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiDebugTrap ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 298} of file {\b handlers.c}.}\par
}
{\xe \v MiDivideByZero\:handlers.c}
{\xe \v handlers.c\:MiDivideByZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiDivideByZero ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 258} of file {\b handlers.c}.}\par
}
{\xe \v MiDoubleFault\:handlers.c}
{\xe \v handlers.c\:MiDoubleFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MiDoubleFault ({\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b handlers.c}.}\par
}
{\xe \v MiFloatingPointError\:handlers.c}
{\xe \v handlers.c\:MiFloatingPointError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiFloatingPointError ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 462} of file {\b handlers.c}.}\par
}
{\xe \v MiGeneralProtectionFault\:handlers.c}
{\xe \v handlers.c\:MiGeneralProtectionFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiGeneralProtectionFault ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 457} of file {\b handlers.c}.}\par
}
{\xe \v MiInterprocessorInterrupt\:handlers.c}
{\xe \v handlers.c\:MiInterprocessorInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInterprocessorInterrupt (void )}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b handlers.c}.}\par
}
{\xe \v MiInvalidOpcode\:handlers.c}
{\xe \v handlers.c\:MiInvalidOpcode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInvalidOpcode ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 425} of file {\b handlers.c}.}\par
}
{\xe \v MiInvalidTss\:handlers.c}
{\xe \v handlers.c\:MiInvalidTss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInvalidTss ({\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 439} of file {\b handlers.c}.}\par
}
{\xe \v MiLapicInterrupt\:handlers.c}
{\xe \v handlers.c\:MiLapicInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiLapicInterrupt (bool schedulerEnabled, {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b handlers.c}.}\par
}
{\xe \v MiMachineCheck\:handlers.c}
{\xe \v handlers.c\:MiMachineCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiMachineCheck ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b handlers.c}.}\par
}
{\xe \v MiNoCoprocessor\:handlers.c}
{\xe \v handlers.c\:MiNoCoprocessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiNoCoprocessor ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 429} of file {\b handlers.c}.}\par
}
{\xe \v MiNonMaskableInterrupt\:handlers.c}
{\xe \v handlers.c\:MiNonMaskableInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MiNonMaskableInterrupt ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 362} of file {\b handlers.c}.}\par
}
{\xe \v MiOverflow\:handlers.c}
{\xe \v handlers.c\:MiOverflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiOverflow ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b handlers.c}.}\par
}
{\xe \v MiPageFault\:handlers.c}
{\xe \v handlers.c\:MiPageFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiPageFault ({\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b handlers.c}.}\par
}
{\xe \v MiSegmentSelectorNotPresent\:handlers.c}
{\xe \v handlers.c\:MiSegmentSelectorNotPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiSegmentSelectorNotPresent ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 445} of file {\b handlers.c}.}\par
}
{\xe \v MiStackSegmentOverrun\:handlers.c}
{\xe \v handlers.c\:MiStackSegmentOverrun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiStackSegmentOverrun ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 451} of file {\b handlers.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cursor_x\:handlers.c}
{\xe \v handlers.c\:cursor_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_x{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b gop.c}.}\par
}
{\xe \v cursor_y\:handlers.c}
{\xe \v handlers.c\:cursor_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_y{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b gop.c}.}\par
}
{\xe \v gop_local\:handlers.c}
{\xe \v handlers.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
handlers.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/handlers.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/handlers.c}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Implementation of handler functions for interrupts.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/mh.h"}\par
00008 {\cf21 #include "../../includes/me.h"}\par
00009 {\cf21 #include "../../includes/mg.h"}\par
00010 {\cf21 #include "../../includes/ps.h"}\par
00011 {\cf21 #include "../../includes/md.h"}\par
00012 \par
00013 {\cf21 #define PRINT_ALL_REGS_AND_HALT(ctxptr, intfrptr)                     \\}\par
00014 {\cf21     do \{                                                             \\}\par
00015 {\cf21         gop_printf(COLOR_RED,                                         \\}\par
00016 {\cf21             "RAX=%p RBX=%p RCX=%p RDX=%p\\n"           \\}\par
00017 {\cf21             "RSI=%p RDI=%p RBP=%p RSP=%p\\n"           \\}\par
00018 {\cf21             "R8 =%p R9 =%p R10=%p R11=%p\\n"           \\}\par
00019 {\cf21             "R12=%p R13=%p R14=%p R15=%p\\n"           \\}\par
00020 {\cf21             "RIP=%p RFLAGS=%p\\n",                               \\}\par
00021 {\cf21             (ctxptr)->rax, (ctxptr)->rbx, (ctxptr)->rcx, (ctxptr)->rdx, \\}\par
00022 {\cf21             (ctxptr)->rsi, (ctxptr)->rdi, (ctxptr)->rbp, (intfrptr)->rsp, \\}\par
00023 {\cf21             (ctxptr)->r8, (ctxptr)->r9, (ctxptr)->r10, (ctxptr)->r11,    \\}\par
00024 {\cf21             (ctxptr)->r12, (ctxptr)->r13, (ctxptr)->r14, (ctxptr)->r15, \\}\par
00025 {\cf21             (intfrptr)->rip, (intfrptr)->rflags);                       \\}\par
00026 {\cf21         __hlt();                                                      \\}\par
00027 {\cf21     \} while (0)}\par
00028 \par
00029 {\cf20 // NOTE TO SELF: DO NOT PUT TRACELAST_FUNC HERE, THESE ARE INTERRUPT/EXCEPTION HANDLERS!}\par
00030 \par
00031 \par
00032 {\cf17 extern} uint32_t cursor_x;\par
00033 {\cf17 extern} uint32_t cursor_y;\par
00034 {\cf17 extern} GOP_PARAMS gop_local;\par
00035 \par
00036 {\cf17 static} {\cf18 void} MiHandleTimer({\cf18 bool} schedulerEnabled, PTRAP_FRAME trap) \{\par
00037     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00038 \par
00039     {\cf20 // Do not decrement if a schedule is already pending.}\par
00040     {\cf19 if} (cpu->schedulePending) {\cf19 return};\par
00041 \par
00042     {\cf20 // If scheduler is locked or no thread is running, return.}\par
00043     {\cf19 if} (!schedulerEnabled || !cpu->currentThread) {\cf19 return};\par
00044 \par
00045     PITHREAD currentThread = cpu->currentThread;\par
00046 \par
00047     {\cf20 // Atomic decrement, if there is still time, return.}\par
00048     {\cf19 if} (__sync_sub_and_fetch(&currentThread->TimeSlice, 1) > 0) \{\par
00049         {\cf19 return};\par
00050     \}\par
00051 \par
00052     {\cf20 // Time slice has expired}\par
00053     {\cf20 // Reset Quantum}\par
00054     currentThread->TimeSlice = currentThread->TimeSliceAllocated;\par
00055 \par
00056     {\cf20 // Save the thread's context.}\par
00057     currentThread->TrapRegisters = *trap;\par
00058 \par
00059     {\cf20 // Request schedule.}\par
00060     cpu->schedulePending = {\cf17 true};\par
00061 \}\par
00062 \par
00063 {\cf17 extern} {\cf18 void} lapic_eoi({\cf18 void});\par
00064 \par
00065 {\cf18 void} MiLapicInterrupt({\cf18 bool} schedulerEnabled, PTRAP_FRAME trap) \{\par
00066     MiHandleTimer(schedulerEnabled, trap);\par
00067     lapic_eoi(); {\cf20 // Signal end of interrupt.}\par
00068 \}\par
00069 \par
00070 {\cf18 void} MiInterprocessorInterrupt (\par
00071     {\cf18 void}\par
00072 ) \par
00073 \par
00074 {\cf20 /*++}\par
00075 {\cf20 }\par
00076 {\cf20     Routine description : Handles an interprocessor interupt.}\par
00077 {\cf20 }\par
00078 {\cf20     Arguments:}\par
00079 {\cf20 }\par
00080 {\cf20         None. (arguments to IPI's are taken from the PROCESSOR struct, accessed in MeGetCurrentProcessor)}\par
00081 {\cf20 }\par
00082 {\cf20     Return Values:}\par
00083 {\cf20 }\par
00084 {\cf20         None.}\par
00085 {\cf20 }\par
00086 {\cf20 --*/}\par
00087 \par
00088 \{\par
00089     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00090     InterlockedOrU64(&cpu->flags, CPU_DOING_IPI);\par
00091     uint64_t addr = cpu->IpiParameter.debugRegs.address;\par
00092     CPU_ACTION action = cpu->IpiAction;\par
00093     {\cf18 int} idx = find_available_debug_reg();\par
00094     {\cf19 switch} (action) \{\par
00095     {\cf19 case} CPU_ACTION_STOP:\par
00096         {\cf20 // explicit action to halt, since we are in an interrupt, unless an NMI somehow comes, we will stay stopped.}\par
00097         {\cf20 // clear the flag before we halt so BSP can continue iterations}\par
00098         cpu->IpiSeq = 0;\par
00099         MmFullBarrier();\par
00100         InterlockedAndU64(&cpu->flags, ~CPU_DOING_IPI);\par
00101         {\cf19 for} (;;) __hlt();\par
00102     {\cf19 case} CPU_ACTION_PERFORM_TLB_SHOOTDOWN:\par
00103         invlpg(({\cf18 void}*)cpu->IpiParameter.pageParams.addressToInvalidate);\par
00104         {\cf19 break};\par
00105     {\cf19 case} CPU_ACTION_PRINT_ID:\par
00106         gop_printf(COLOR_RED, {\cf22 "[CPU-IPI] Hello from CPU ID: %d\\n"}, cpu->lapic_ID);\par
00107         {\cf19 break};\par
00108     {\cf19 case} CPU_ACTION_WRITE_DEBUG_REGS:\par
00109         {\cf19 if} (idx == -1) {\cf19 break};\par
00110         __write_dr(7, cpu->IpiParameter.debugRegs.dr7);\par
00111         __write_dr(idx, cpu->IpiParameter.debugRegs.address);\par
00112         MeGetCurrentProcessor()->DebugEntry[idx].Address = ({\cf18 void}*)cpu->IpiParameter.debugRegs.address;\par
00113         MeGetCurrentProcessor()->DebugEntry[idx].Callback = cpu->IpiParameter.debugRegs.callback;\par
00114         {\cf19 break};\par
00115     {\cf19 case} CPU_ACTION_CLEAR_DEBUG_REGS:\par
00116         {\cf19 for} ({\cf18 int} i = 0; i < 4; i++) \{\par
00117             {\cf19 if} ((uint64_t)MeGetCurrentProcessor()->DebugEntry[i].Address == addr) \{\par
00118                 __write_dr(i, 0);\par
00119 \par
00120                 {\cf20 /* Clear DR7 bits for this index (local enable and RW/LEN group) */}\par
00121                 uint64_t dr7 = __read_dr(7);\par
00122                 {\cf20 /* clear local enable bit */}\par
00123                 dr7 &= ~(1ULL << (i * 2));\par
00124                 {\cf20 /* clear RW/LEN 4-bit group */}\par
00125                 uint64_t mask = 0xFULL << (16 + 4 * i);\par
00126                 dr7 &= ~mask;\par
00127                 __write_dr(7, dr7);\par
00128 \par
00129                 {\cf20 /* Clear status DR6 too */}\par
00130                 __write_dr(6, 0);\par
00131                 MeGetCurrentProcessor()->DebugEntry[i].Address = NULL;\par
00132                 MeGetCurrentProcessor()->DebugEntry[i].Callback = NULL;\par
00133                 {\cf19 break};\par
00134             \}\par
00135         \}\par
00136     {\cf19 case} CPU_ACTION_DO_DEFERRED_ROUTINES:\par
00137         {\cf20 // This is a NO-OP, since DPCs WILL be executed when we just return.}\par
00138         {\cf20 // unused.}\par
00139         {\cf19 break};\par
00140     {\cf19 case} CPU_ACTION_FLUSH_CR3:\par
00141         __write_cr3(__read_cr3());\par
00142         {\cf19 break};\par
00143     \}\par
00144 \par
00145     InterlockedAndU64(&cpu->flags, ~CPU_DOING_IPI);\par
00146     {\cf19 if} (action != CPU_ACTION_STOP) \{\par
00147         InterlockedAndU64(&cpu->flags, ~CPU_DOING_IPI);\par
00148         cpu->IpiSeq = 0; {\cf20 // Signal completion for non-halting actions.}\par
00149     \}\par
00150 \par
00151     {\cf20 // End of Interrupt for LAPIC is signaled at function return.}\par
00152 \}\par
00153 \par
00154 {\cf18 void} \par
00155 MiPageFault (\par
00156     IN  PTRAP_FRAME trap\par
00157 ) \par
00158 \par
00159 {\cf20 /*++}\par
00160 {\cf20 }\par
00161 {\cf20     Routine description : Handles a page fault that occured in the current CPU.}\par
00162 {\cf20 }\par
00163 {\cf20     Arguments:}\par
00164 {\cf20 }\par
00165 {\cf20         Pointer to the current TRAP_FRAME.}\par
00166 {\cf20 }\par
00167 {\cf20     Return Values:}\par
00168 {\cf20 }\par
00169 {\cf20         None. Function would bugcheck/return if conditions are met.}\par
00170 {\cf20 }\par
00171 {\cf20 --*/}\par
00172 \par
00173 \{\par
00174     uint64_t fault_addr;\par
00175     {\cf20 // cr2 holds the faulty address that caused the page fault.}\par
00176     \par
00177     __asm__ __volatile__ (\par
00178     {\cf22 "movq %%cr2, %0"}\par
00179     : {\cf22 "=r"}(fault_addr)\par
00180     );\par
00181 \par
00182     {\cf20 /*++}\par
00183 {\cf20     }\par
00184 {\cf20     Page fault bugcheck parameters:}\par
00185 {\cf20 }\par
00186 {\cf20     Parameter 1: Memory address referenced. (CR2)}\par
00187 {\cf20     Parameter 2: (decimal) 0 - Read Operation, 2 - Write Operation, 10 - Execute operation (unused for now, NX hasn't been turned on for now)}\par
00188 {\cf20     Parameter 3: Address that referenced memory (RIP)}\par
00189 {\cf20     Parameter 4: CPU Error code pushed.}\par
00190 {\cf20 }\par
00191 {\cf20     --*/}\par
00192 \par
00193     \par
00194 \par
00195     MTSTATUS status = MmAccessFault(trap->error_code, fault_addr, MeGetPreviousMode(), trap);\par
00196 {\cf21 #ifdef DEBUG}\par
00197     gop_printf(COLOR_RED, {\cf22 "I have returned from MmAccessFault with status %x\\n"}, status);\par
00198 {\cf21 #endif}\par
00199 \par
00200     {\cf19 if} (MT_FAILURE(status)) \{\par
00201         {\cf20 // If MmAccessFault returned a failire (e.g MT_ACCESS_VIOLATION), but hasn't bugchecked, we check for exception handlers in the current thread}\par
00202         {\cf20 // If there are no exceptions handlers (for SEH, we use the default one for user mode, TODO SEH USER MODE)}\par
00203         {\cf20 //if (ExpIsExceptionHandlerPresent(PsGetCurrentThread())) \{}\par
00204         {\cf20 //    ExpDispatchException(trap);}\par
00205         {\cf20 //    return;}\par
00206         {\cf20 //\}}\par
00207 \par
00208         {\cf20 //else \{}\par
00209             {\cf20 // No kernel exception handler present, bugcheck.}\par
00210             MeBugCheckEx(\par
00211                 KMODE_EXCEPTION_NOT_HANDLED,\par
00212                 ({\cf18 void}*)(uintptr_t)status,\par
00213                 ({\cf18 void}*)fault_addr,\par
00214                 ({\cf18 void}*)trap->rip,\par
00215                 ({\cf18 void}*)trap->error_code\par
00216             );\par
00217         {\cf20 //\}}\par
00218     \}\par
00219 \par
00220     {\cf20 // MmAccessFault returned MT_SUCCESS, that means it handled the fault (filled the PTE, etc.), we return to original instruction and re-run.}\par
00221     {\cf19 return};\par
00222 \}\par
00223 \par
00224 NORETURN\par
00225 {\cf18 void} \par
00226 MiDoubleFault(\par
00227     IN  PTRAP_FRAME trap\par
00228 ) \par
00229 \par
00230 {\cf20 /*++}\par
00231 {\cf20 }\par
00232 {\cf20     Routine description : Handles a double fault exception that has happened on the current CPU.}\par
00233 {\cf20 }\par
00234 {\cf20     Arguments:}\par
00235 {\cf20 }\par
00236 {\cf20         Pointer to the current TRAP_FRAME.}\par
00237 {\cf20 }\par
00238 {\cf20     Return Values:}\par
00239 {\cf20 }\par
00240 {\cf20         None. This function will never return to caller.}\par
00241 {\cf20 }\par
00242 {\cf20 --*/}\par
00243 \par
00244 \{\par
00245     {\cf20 /*++}\par
00246 {\cf20 }\par
00247 {\cf20     Double Fault bugcheck parameters:}\par
00248 {\cf20 }\par
00249 {\cf20     Parameter 1: Address at the time of the fault.}\par
00250 {\cf20     Parameter 2,3,4: NULL.}\par
00251 {\cf20 }\par
00252 {\cf20     --*/}\par
00253 \par
00254     MeBugCheckEx(DOUBLE_FAULT, ({\cf18 void}*)(uintptr_t)trap->rip, NULL, NULL, NULL);\par
00255 \}\par
00256 \par
00257 {\cf18 void} \par
00258 MiDivideByZero (\par
00259     PTRAP_FRAME trap\par
00260 ) \par
00261 \par
00262 {\cf20 /*++}\par
00263 {\cf20 }\par
00264 {\cf20     Routine description : Handles a divide by zero on the current CPU.}\par
00265 {\cf20 }\par
00266 {\cf20     Arguments:}\par
00267 {\cf20 }\par
00268 {\cf20         Pointer to the current TRAP_FRAME.}\par
00269 {\cf20 }\par
00270 {\cf20     Return Values:}\par
00271 {\cf20 }\par
00272 {\cf20         None. This function currently does not return to caller.}\par
00273 {\cf20 }\par
00274 {\cf20 --*/}\par
00275 \par
00276 \{\par
00277 \par
00278     {\cf20 /*++}\par
00279 {\cf20 }\par
00280 {\cf20     Divide By Zero bugcheck parameters:}\par
00281 {\cf20 }\par
00282 {\cf20     Parameter 1: Address at the time of the fault.}\par
00283 {\cf20     Parameter 2,3,4: NULL.}\par
00284 {\cf20 }\par
00285 {\cf20     --*/}\par
00286     \par
00287     {\cf20 // When user mode processes and threads are fully established, this should generate an ACCESS_VIOLATION. TODO}\par
00288     {\cf19 if} (MeGetPreviousMode() == UserMode) \{\par
00289         {\cf20 // guard it for now.}\par
00290         MeBugCheckEx(ASSERTION_FAILURE, ({\cf18 void}*){\cf22 "MiDivideByZero"}, ({\cf18 void}*){\cf22 "A Fault in user mode occured, division error, implement."}, NULL, NULL);\par
00291     \}\par
00292 \par
00293     MeBugCheckEx(DIVIDE_BY_ZERO, ({\cf18 void}*)(uintptr_t)trap->rip, NULL, NULL, NULL);\par
00294 \par
00295 \}\par
00296 \par
00297 {\cf18 void} \par
00298 MiDebugTrap (\par
00299     PTRAP_FRAME trap\par
00300 ) \par
00301 \par
00302 {\cf20 /*++}\par
00303 {\cf20 }\par
00304 {\cf20     Routine description : Handles a debug trap (either a single step from a debugger, or a debug register has been hit)}\par
00305 {\cf20 }\par
00306 {\cf20     Arguments:}\par
00307 {\cf20 }\par
00308 {\cf20         Pointer to the current TRAP_FRAME.}\par
00309 {\cf20 }\par
00310 {\cf20     Return Values:}\par
00311 {\cf20 }\par
00312 {\cf20         None.}\par
00313 {\cf20 }\par
00314 {\cf20 --*/}\par
00315 \par
00316 \{\par
00317 {\cf21 #ifndef GDB}\par
00318     {\cf20 /* read debug status */}\par
00319     uint64_t dr6 = __read_dr(6);\par
00320     \par
00321     {\cf19 if} (dr6 & 0xF) \{\par
00322         {\cf20 /* For each possible debug register 0..3 check B0..B3 */}\par
00323         {\cf19 for} ({\cf18 int} i = 0; i < 4; ++i) \{\par
00324             {\cf19 if} (dr6 & (1ULL << i)) \{\par
00325                 {\cf20 /* If a callback is registered, call it. Provide both address and context. */}\par
00326                 {\cf19 if} (MeGetCurrentProcessor()->DebugEntry[i].Callback) \{\par
00327                     DBG_CALLBACK_INFO info = \{\par
00328                         .Address = MeGetCurrentProcessor()->DebugEntry[i].Address,\par
00329                         .trap = trap,\par
00330                         .BreakIdx = i,\par
00331                         .Dr6 = dr6\par
00332                     \};\par
00333 \par
00334                     {\cf20 /* Call the user-registered callback. It receives &info (void*). */}\par
00335                     MeGetCurrentProcessor()->DebugEntry[i].Callback(&info);\par
00336                 \}\par
00337                 {\cf19 else} \{\par
00338                     {\cf20 /* no callback registered for this DRx: print for debug and continue */}\par
00339                     gop_printf(0xFFFFFF00, {\cf22 "DEBUG: DR%d fired at addr %p but no callback\\n"}, i, ({\cf18 void}*)__read_dr(i));\par
00340                 \}\par
00341             \}\par
00342         \}\par
00343 \par
00344         {\cf20 /* Clear the status bits in DR6 so INT1 won't fire again for the same event.}\par
00345 {\cf20            Writing zero clears B0..B3 and other status bits per Intel spec. */}\par
00346         __write_dr(6, 0);\par
00347         {\cf19 return};\par
00348     \}\par
00349     {\cf19 else} {\cf19 if} (dr6 & (1 << 14)) \{\par
00350         {\cf20 // Single Step. -- Ignore for now, we don't have a custom debugger yet, and QEMU sets its own.}\par
00351         {\cf19 return};\par
00352     \}\par
00353 {\cf21 #else}\par
00354     UNREFERENCED_PARAMETER(trap);\par
00355     __write_DR(6, 0);\par
00356     {\cf19 return};\par
00357 {\cf21 #endif}\par
00358 \}\par
00359 \par
00360 NORETURN\par
00361 {\cf18 void} \par
00362 MiNonMaskableInterrupt ( \par
00363     PTRAP_FRAME trap\par
00364 ) \par
00365 \par
00366 {\cf20 /*++}\par
00367 {\cf20 }\par
00368 {\cf20     Routine description : Handles an NMI (Non Maskable Interrupt), generated by the CPU.}\par
00369 {\cf20 }\par
00370 {\cf20     Arguments:}\par
00371 {\cf20 }\par
00372 {\cf20         Pointer to the current TRAP_FRAME.}\par
00373 {\cf20 }\par
00374 {\cf20     Return Values:}\par
00375 {\cf20 }\par
00376 {\cf20         None. This function will never return.}\par
00377 {\cf20 }\par
00378 {\cf20 --*/}\par
00379 \par
00380 \{\par
00381     {\cf20 /*++}\par
00382 {\cf20 }\par
00383 {\cf20     NMI bugcheck parameters:}\par
00384 {\cf20 }\par
00385 {\cf20     No Parameters.}\par
00386 {\cf20 }\par
00387 {\cf20     --*/}\par
00388     UNREFERENCED_PARAMETER(trap);\par
00389     MeBugCheck(NON_MASKABLE_INTERRUPT);\par
00390 \}\par
00391 \par
00392 {\cf18 void} MiBreakpoint (\par
00393     PTRAP_FRAME trap\par
00394 )\par
00395 \par
00396 {\cf20 /*++}\par
00397 {\cf20 }\par
00398 {\cf20     Routine description : Handles a breakpoint instruction (INT3)}\par
00399 {\cf20 }\par
00400 {\cf20     Arguments:}\par
00401 {\cf20 }\par
00402 {\cf20         Pointer to the current TRAP_FRAME.}\par
00403 {\cf20 }\par
00404 {\cf20     Return Values:}\par
00405 {\cf20 }\par
00406 {\cf20         None. This function will never return.}\par
00407 {\cf20 }\par
00408 {\cf20 --*/}\par
00409 \par
00410 \par
00411 \{\par
00412     gop_printf(COLOR_RED, {\cf22 "**INT3 Breakpoint hit at: %p - Halting.\\n"}, ({\cf18 void}*)(uintptr_t)trap->rip);\par
00413     __hlt();\par
00414 \}\par
00415 \par
00416 {\cf18 void} MiOverflow(PTRAP_FRAME trap) \{\par
00417     MeBugCheckEx(OVERFLOW, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00418 \}\par
00419 \par
00420 {\cf18 void} MiBoundsCheck(PTRAP_FRAME trap) \{\par
00421     {\cf20 // bugcheck too, this is kernel mode.}\par
00422     MeBugCheckEx(BOUNDS_CHECK, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00423 \}\par
00424 \par
00425 {\cf18 void} MiInvalidOpcode(PTRAP_FRAME trap) \{\par
00426     MeBugCheckEx(INVALID_OPCODE, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00427 \}\par
00428 \par
00429 {\cf18 void} MiNoCoprocessor(PTRAP_FRAME trap) \{\par
00430     {\cf20 // rarely triggered, if a floating point chip is not integrated, or is not attached, bugcheck.}\par
00431     MeBugCheckEx(NO_COPROCESSOR, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00432 \}\par
00433 \par
00434 {\cf18 void} MiCoprocessorSegmentOverrun(PTRAP_FRAME trap) \{\par
00435     {\cf20 // quite literally impossible in protected or long mode, since CPU's don't generate this exception on these modes, but if they did, bugcheck, severe code.}\par
00436     MeBugCheckEx(COPROCESSOR_SEGMENT_OVERRUN, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00437 \}\par
00438 \par
00439 {\cf18 void} MiInvalidTss(IN PTRAP_FRAME trap) \{\par
00440     {\cf20 // a tss is when the CPU hardware switches (usually does not happen, since OS'es implement switching in software, like process timer context switch, all in software)}\par
00441     {\cf20 // if it did happen though, we bugcheck.}\par
00442     MeBugCheckEx(INVALID_TSS, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00443 \}\par
00444 \par
00445 {\cf18 void} MiSegmentSelectorNotPresent(PTRAP_FRAME trap) \{\par
00446     {\cf20 // this happens when the CPU loads a segment that points to a valid descriptor, that is marked as "not present" (that the present bit is 0), which means it's swapped out to disk.}\par
00447     {\cf20 // we don't have disk paging right now, we don't even have a current user mode or stable memory for now, so we just bugcheck.}\par
00448     MeBugCheckEx(SEGMENT_SELECTOR_NOTPRESENT, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00449 \}\par
00450 \par
00451 {\cf18 void} MiStackSegmentOverrun(PTRAP_FRAME trap) \{\par
00452     {\cf20 // this happens when the stack pointer (esp, rsp, sp on 16 bit) moves OUTSIDE the bounds of the current stack segment, this is different from a stack overflow at the software level, this is a hardware level exception.}\par
00453     {\cf20 // segment limits on protected mode usually gets switched off, so if this happens just bugcheck.}\par
00454     MeBugCheckEx(STACK_SEGMENT_OVERRUN, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00455 \}\par
00456 \par
00457 {\cf18 void} MiGeneralProtectionFault(PTRAP_FRAME trap) \{\par
00458     {\cf20 // important exception, view error code and bugcheck with it}\par
00459     MeBugCheckEx(GENERAL_PROTECTION_FAULT, ({\cf18 void}*)trap->rip, ({\cf18 void}*)(uintptr_t)trap->error_code, NULL, NULL);\par
00460 \}\par
00461 \par
00462 {\cf18 void} MiFloatingPointError(PTRAP_FRAME trap) \{\par
00463     UNREFERENCED_PARAMETER(trap);\par
00464     {\cf20 // this occurs when a floating point operation has an error, (even division by zero floating point will get here), or underflow/overflow}\par
00465     gop_printf(0xFFFF0000, {\cf22 "Error: Floating Point error, have you done a correct calculation?\\n"});\par
00466 \}\par
00467 \par
00468 {\cf18 void} MiAlignmentCheck(PTRAP_FRAME trap) \{\par
00469     {\cf20 // 3 conditions must be met in-order for this to even reach.}\par
00470     {\cf20 // CR0.AM (Alignment Mask) must be set to 1.}\par
00471     {\cf20 // EFLAGS.AC (Alignment Check) must be set to 1.}\par
00472     {\cf20 // CPL (user mode or kernel mode) must be set to 3. (user mode only)}\par
00473     {\cf20 // If all are 1 and a stack alignment occurs (when doing char* ptr = kmalloc(64, 16); then writing like this *((uint32_t*)ptr) = 0xdeadbeef; // It's an unaligned write, writing more than there is.}\par
00474     {\cf20 // for now, bugcheck.}\par
00475     MeBugCheckEx(ALIGNMENT_CHECK, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00476 \}\par
00477 \par
00478 {\cf18 void} MiMachineCheck(PTRAP_FRAME trap) \{\par
00479     {\cf20 // creepy.}\par
00480     {\cf20 // This happens when the machine has a SEVERE problem, memory faults, CPU internal fault, all of that, the cpu registers this.}\par
00481     {\cf20 // obviously bugcheck.}\par
00482     MeBugCheckEx(SEVERE_MACHINE_CHECK, ({\cf18 void}*)trap->rip, NULL, NULL, NULL);\par
00483 \}\par
00484 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/idt.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/idt.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/idt.c}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mh.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_SPURIOUS_VECTOR}\~ 254\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_idt_gate} (int n, unsigned long int handler)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b install_idt} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_ENTRY64} {\b IDT} [{\b IDT_ENTRIES}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IDT_PTR} {\b PIDT}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LAPIC_SPURIOUS_VECTOR\:idt.c}
{\xe \v idt.c\:LAPIC_SPURIOUS_VECTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_SPURIOUS_VECTOR\~ 254}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v install_idt\:idt.c}
{\xe \v idt.c\:install_idt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void install_idt (void )}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b idt.c}.}\par
}
{\xe \v set_idt_gate\:idt.c}
{\xe \v idt.c\:set_idt_gate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_idt_gate (int n, unsigned long int handler)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b idt.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v IDT\:idt.c}
{\xe \v idt.c\:IDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_ENTRY64} IDT[{\b IDT_ENTRIES}]}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b idt.c}.}\par
}
{\xe \v PIDT\:idt.c}
{\xe \v idt.c\:PIDT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IDT_PTR} PIDT}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b idt.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
idt.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/idt.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/idt.c}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     IMPLEMENTATION To SETUP IDT Entries.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/mh.h"}\par
00008 \par
00009 IDT_ENTRY64 IDT[IDT_ENTRIES];\par
00010 IDT_PTR  PIDT;\par
00011 \par
00012 {\cf20 /* Set one gate. */}\par
00013 {\cf18 void} set_idt_gate({\cf18 int} n, {\cf18 unsigned} {\cf18 long} {\cf18 int} handler) \{\par
00014     IDT[n].offset_low = handler & 0xFFFF;\par
00015     IDT[n].selector = 0x08;   {\cf20 // code segment selector}\par
00016     IDT[n].ist = 0;         \par
00017     IDT[n].type_attr = 0x8E;  {\cf20 // interrupt gate, present, ring 0}\par
00018     IDT[n].offset_mid = (handler >> 16) & 0xFFFF;\par
00019     IDT[n].offset_high = (handler >> 32) & 0xFFFFFFFF;\par
00020     IDT[n].zero = 0;\par
00021 \}\par
00022 \par
00023 {\cf20 /* Populate IDT: exceptions, IRQ, and then finally load it. */}\par
00024 {\cf18 void} install_idt() \{\par
00025     {\cf20 /* REMAP the PIC so IRQs start at vector 0x20 */}\par
00026     __outbyte(0x20, 0x11); {\cf20 // initialize master PIC}\par
00027     __outbyte(0xA0, 0x11); {\cf20 // initialize slave PIC}\par
00028     __outbyte(0x21, 0x20); {\cf20 // master PIC vector offset 0x20.}\par
00029     __outbyte(0xA1, 0x28); {\cf20 // slave PIC vector offset 0x28}\par
00030     __outbyte(0x21, 0x04);\par
00031     __outbyte(0xA1, 0x02);\par
00032     __outbyte(0x21, 0x01);\par
00033     __outbyte(0xA1, 0x01);\par
00034     __outbyte(0x21, 0x0);\par
00035     __outbyte(0xA1, 0x0);\par
00036 \par
00037     {\cf20 /* Fill IDT Entries for CPU Exceptions (0-31) */} {\cf20 /* For clarifications, all of the ISR and IRQ externals live in isr_stub (where it defines the functions and gets linked together, via the global keyword) and isr_common_stub (where it does the routine), where they are linked together via the linker (externs) */}\par
00038     {\cf17 extern} {\cf18 void} isr0({\cf18 void}); {\cf17 extern} {\cf18 void} isr1({\cf18 void}); {\cf17 extern} {\cf18 void} isr2({\cf18 void}); {\cf17 extern} {\cf18 void} isr3({\cf18 void}); {\cf17 extern} {\cf18 void} isr4({\cf18 void}); {\cf17 extern} {\cf18 void} isr5({\cf18 void}); {\cf17 extern} {\cf18 void} isr6({\cf18 void}); {\cf17 extern} {\cf18 void} isr7({\cf18 void}); {\cf17 extern} {\cf18 void} isr8({\cf18 void}); {\cf17 extern} {\cf18 void} isr9({\cf18 void}); {\cf17 extern} {\cf18 void} isr10({\cf18 void}); {\cf17 extern} {\cf18 void} isr11({\cf18 void}); {\cf17 extern} {\cf18 void} isr12({\cf18 void}); {\cf17 extern} {\cf18 void} isr13({\cf18 void}); {\cf17 extern} {\cf18 void} isr14({\cf18 void}); {\cf17 extern} {\cf18 void} isr15({\cf18 void}); {\cf17 extern} {\cf18 void} isr16({\cf18 void}); {\cf17 extern} {\cf18 void} isr17({\cf18 void}); {\cf17 extern} {\cf18 void} isr18({\cf18 void}); {\cf17 extern} {\cf18 void} isr19({\cf18 void}); {\cf17 extern} {\cf18 void} isr20({\cf18 void}); {\cf17 extern} {\cf18 void} isr21({\cf18 void}); {\cf17 extern} {\cf18 void} isr22({\cf18 void}); {\cf17 extern} {\cf18 void} isr23({\cf18 void}); {\cf17 extern} {\cf18 void} isr24({\cf18 void}); {\cf17 extern} {\cf18 void} isr25({\cf18 void}); {\cf17 extern} {\cf18 void} isr26({\cf18 void}); {\cf17 extern} {\cf18 void} isr27({\cf18 void}); {\cf17 extern} {\cf18 void} isr28({\cf18 void}); {\cf17 extern} {\cf18 void} isr29({\cf18 void}); {\cf17 extern} {\cf18 void} isr30({\cf18 void}); {\cf17 extern} {\cf18 void} isr31({\cf18 void});\par
00039     {\cf20 /* I forgo t to set n in the set_idt_gate, they were all zeros and I didn't understand why I got IRQ of like 50 thousand and error code of 4 billion. (i copy pasted each line instead of typing manually) */}\par
00040     set_idt_gate(0, ({\cf18 unsigned} {\cf18 long})isr0);\par
00041     set_idt_gate(1, ({\cf18 unsigned} {\cf18 long})isr1);\par
00042     set_idt_gate(2, ({\cf18 unsigned} {\cf18 long})isr2);\par
00043     set_idt_gate(3, ({\cf18 unsigned} {\cf18 long})isr3);\par
00044     set_idt_gate(4, ({\cf18 unsigned} {\cf18 long})isr4);\par
00045     set_idt_gate(5, ({\cf18 unsigned} {\cf18 long})isr5);\par
00046     set_idt_gate(6, ({\cf18 unsigned} {\cf18 long})isr6);\par
00047     set_idt_gate(7, ({\cf18 unsigned} {\cf18 long})isr7);\par
00048     set_idt_gate(8, ({\cf18 unsigned} {\cf18 long})isr8);\par
00049     set_idt_gate(9, ({\cf18 unsigned} {\cf18 long})isr9);\par
00050     set_idt_gate(10, ({\cf18 unsigned} {\cf18 long})isr10);\par
00051     set_idt_gate(11, ({\cf18 unsigned} {\cf18 long})isr11);\par
00052     set_idt_gate(12, ({\cf18 unsigned} {\cf18 long})isr12);\par
00053     set_idt_gate(13, ({\cf18 unsigned} {\cf18 long})isr13);\par
00054     set_idt_gate(14, ({\cf18 unsigned} {\cf18 long})isr14);\par
00055     set_idt_gate(15, ({\cf18 unsigned} {\cf18 long})isr15);\par
00056     set_idt_gate(16, ({\cf18 unsigned} {\cf18 long})isr16);\par
00057     set_idt_gate(17, ({\cf18 unsigned} {\cf18 long})isr17);\par
00058     set_idt_gate(18, ({\cf18 unsigned} {\cf18 long})isr18);\par
00059     set_idt_gate(19, ({\cf18 unsigned} {\cf18 long})isr19);\par
00060     set_idt_gate(20, ({\cf18 unsigned} {\cf18 long})isr20);\par
00061     set_idt_gate(21, ({\cf18 unsigned} {\cf18 long})isr21);\par
00062     set_idt_gate(22, ({\cf18 unsigned} {\cf18 long})isr22);\par
00063     set_idt_gate(23, ({\cf18 unsigned} {\cf18 long})isr23);\par
00064     set_idt_gate(24, ({\cf18 unsigned} {\cf18 long})isr24);\par
00065     set_idt_gate(25, ({\cf18 unsigned} {\cf18 long})isr25);\par
00066     set_idt_gate(26, ({\cf18 unsigned} {\cf18 long})isr26);\par
00067     set_idt_gate(27, ({\cf18 unsigned} {\cf18 long})isr27);\par
00068     set_idt_gate(28, ({\cf18 unsigned} {\cf18 long})isr28);\par
00069     set_idt_gate(29, ({\cf18 unsigned} {\cf18 long})isr29);\par
00070     set_idt_gate(30, ({\cf18 unsigned} {\cf18 long})isr30);\par
00071     set_idt_gate(31, ({\cf18 unsigned} {\cf18 long})isr31);\par
00072 \par
00073     {\cf20 /* Fill IDT Gates for IRQs (32-47) */}\par
00074     {\cf17 extern} {\cf18 void} irq0({\cf18 void}); {\cf17 extern} {\cf18 void} irq1({\cf18 void}); {\cf17 extern} {\cf18 void} irq2({\cf18 void}); {\cf17 extern} {\cf18 void} irq3({\cf18 void}); {\cf17 extern} {\cf18 void} irq4({\cf18 void}); {\cf17 extern} {\cf18 void} irq5({\cf18 void}); {\cf17 extern} {\cf18 void} irq6({\cf18 void}); {\cf17 extern} {\cf18 void} irq7({\cf18 void}); {\cf17 extern} {\cf18 void} irq8({\cf18 void}); {\cf17 extern} {\cf18 void} irq9({\cf18 void}); {\cf17 extern} {\cf18 void} irq10({\cf18 void}); {\cf17 extern} {\cf18 void} irq11({\cf18 void}); {\cf17 extern} {\cf18 void} irq12({\cf18 void}); {\cf17 extern} {\cf18 void} irq13({\cf18 void}); {\cf17 extern} {\cf18 void} irq14({\cf18 void}); {\cf17 extern} {\cf18 void} irq15({\cf18 void});\par
00075     set_idt_gate(32, ({\cf18 unsigned} {\cf18 long})irq0);\par
00076     set_idt_gate(33, ({\cf18 unsigned} {\cf18 long})irq1);\par
00077     set_idt_gate(34, ({\cf18 unsigned} {\cf18 long})irq2);\par
00078     set_idt_gate(35, ({\cf18 unsigned} {\cf18 long})irq3);\par
00079     set_idt_gate(36, ({\cf18 unsigned} {\cf18 long})irq4);\par
00080     set_idt_gate(37, ({\cf18 unsigned} {\cf18 long})irq5);\par
00081     set_idt_gate(38, ({\cf18 unsigned} {\cf18 long})irq6);\par
00082     set_idt_gate(39, ({\cf18 unsigned} {\cf18 long})irq7);\par
00083     set_idt_gate(40, ({\cf18 unsigned} {\cf18 long})irq8);\par
00084     set_idt_gate(41, ({\cf18 unsigned} {\cf18 long})irq9);\par
00085     set_idt_gate(42, ({\cf18 unsigned} {\cf18 long})irq10);\par
00086     set_idt_gate(43, ({\cf18 unsigned} {\cf18 long})irq11);\par
00087     set_idt_gate(44, ({\cf18 unsigned} {\cf18 long})irq12);\par
00088     set_idt_gate(45, ({\cf18 unsigned} {\cf18 long})irq13);\par
00089     set_idt_gate(46, ({\cf18 unsigned} {\cf18 long})irq14);\par
00090     set_idt_gate(47, ({\cf18 unsigned} {\cf18 long})irq15);\par
00091     {\cf20 /* For LAPIC */}\par
00092     {\cf17 extern} {\cf18 void} isr239({\cf18 void}); {\cf20 // LAPIC ISR.}\par
00093     set_idt_gate(LAPIC_TIMER_VECTOR, ({\cf18 unsigned} {\cf18 long})isr239);\par
00094 {\cf21 #define LAPIC_SPURIOUS_VECTOR 254}\par
00095     {\cf20 /* For SIV LAPIC */}\par
00096     {\cf17 extern} {\cf18 void} isr254({\cf18 void}); {\cf20 // SIV ISR}\par
00097     set_idt_gate(LAPIC_SPURIOUS_VECTOR, ({\cf18 unsigned} {\cf18 long})isr254);\par
00098     {\cf20 /* For LAPIC CPU Action */}\par
00099     {\cf17 extern} {\cf18 void} isr_ipi({\cf18 void});\par
00100     set_idt_gate(VECTOR_IPI, ({\cf18 unsigned} {\cf18 long})isr_ipi);\par
00101 \par
00102     {\cf17 extern} {\cf18 void} isr_dpc({\cf18 void});   {\cf20 // DPC Handler.}\par
00103     set_idt_gate(VECTOR_DPC, ({\cf18 unsigned} {\cf18 long})isr_dpc);\par
00104 \par
00105     {\cf17 extern} {\cf18 void} isr_apc({\cf18 void});   {\cf20 // APC Handler.}\par
00106     set_idt_gate(VECTOR_APC, ({\cf18 unsigned} {\cf18 long})isr_apc);\par
00107 \par
00108     {\cf20 /* ISTs are reloaded in MeInitProcessor */}\par
00109 \par
00110     {\cf20 /* Finally, Load IDT. */}\par
00111     PIDT.limit = {\cf17 sizeof}(IDT_ENTRY64) * IDT_ENTRIES - 1; {\cf20 // Max limit is the amount of IDT_ENTRIES structs (0-255)}\par
00112     PIDT.base = ({\cf18 unsigned} long)&IDT;\par
00113     __lidt(&PIDT);\par
00114 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/isr.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/isr.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/isr.c}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/core.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b USED} void {\b MhHandleInterrupt} ({\b IN} int vec_num, {\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_interrupts} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const bool {\b has_error_code} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v init_interrupts\:isr.c}
{\xe \v isr.c\:init_interrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_interrupts (void )}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b isr.c}.}\par
}
{\xe \v lapic_eoi\:isr.c}
{\xe \v isr.c\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b apic.c}.}\par
}
{\xe \v MhHandleInterrupt\:isr.c}
{\xe \v isr.c\:MhHandleInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b USED} void MhHandleInterrupt ({\b IN} int vec_num, {\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b isr.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gop_local\:isr.c}
{\xe \v isr.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
{\xe \v has_error_code\:isr.c}
{\xe \v isr.c\:has_error_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const bool has_error_code[]}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, \par
    {\cf17 true},  {\cf17 false}, {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 false}, \par
    {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, \par
    {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}  \par
\}\par
}
{
Definition at line {\b 16} of file {\b isr.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
isr.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/isr.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/isr.c}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     IMPLEMENTATION To SETUP ISR Handler.}\par
00005 {\cf20  * EXPLANATION: An ISR is what handles the interrupts that gets sent from the CPU (after interrupt is sent to ISR itself), it will do stuff based if it's an exception, or a normal interrupt.}\par
00006 {\cf20  */}\par
00007 \par
00008 {\cf21 #include "../../includes/core.h"}\par
00009 {\cf21 #include "../../includes/mh.h"}\par
00010 {\cf21 #include "../../includes/mg.h"}\par
00011 {\cf21 #include "../../includes/me.h"}\par
00012 {\cf21 #include "../../assert.h"}\par
00013 \par
00014 {\cf17 extern} GOP_PARAMS gop_local;\par
00015 \par
00016 {\cf17 const} {\cf18 bool} has_error_code[] = \{\par
00017     {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf20 // 0-7}\par
00018     {\cf17 true},  {\cf17 false}, {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 true},  {\cf17 false}, {\cf20 // 8-15}\par
00019     {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf20 // 16-23}\par
00020     {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}, {\cf17 false}  {\cf20 // 24-31}\par
00021 \};\par
00022 \par
00023 {\cf17 extern} {\cf18 void} lapic_eoi({\cf18 void});    \par
00024 \par
00025 USED\par
00026 {\cf18 void}\par
00027 MhHandleInterrupt (\par
00028     IN  {\cf18 int} vec_num, \par
00029     IN  PTRAP_FRAME trap\par
00030 ) \par
00031 \par
00032 {\cf20 /*++}\par
00033 {\cf20 }\par
00034 {\cf20     Routine description : This function handles all traps, exceptions, and interrupts of the processor, and forwards them to the appropriate function.}\par
00035 {\cf20 }\par
00036 {\cf20     Arguments:}\par
00037 {\cf20 }\par
00038 {\cf20         [IN]    int vec_num: Vector number that represents the interrupt.}\par
00039 {\cf20         [IN]    PTRAP_FRAME trap: Pointer to trap frame, saved by the stub.}\par
00040 {\cf20 }\par
00041 {\cf20     Return Values:}\par
00042 {\cf20 }\par
00043 {\cf20         None.}\par
00044 {\cf20 }\par
00045 {\cf20 --*/}\par
00046 \par
00047 \{\par
00048 \par
00049     assert(MeAreInterruptsEnabled() == {\cf17 false});\par
00050 \par
00051     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00052     IRQL oldIrql;\par
00053     \par
00054     {\cf20 // Save if the scheduler was enabled or not before raising to >= DISPATCH_LEVEL (because in dispatch_level and above the scheduler gets disabled to disable pre-emption)}\par
00055     {\cf18 bool} schedulerEnabled = cpu->schedulerEnabled;\par
00056 \par
00057     {\cf20 // Save the PreviousMode to current thread.}\par
00058     PRIVILEGE_MODE PreviousMode;\par
00059 \par
00060     {\cf19 if} ((trap->cs & 0x3) == 0x3) \{\par
00061         PreviousMode = UserMode;\par
00062     \}\par
00063     {\cf19 else} \{\par
00064         PreviousMode = KernelMode;\par
00065     \}\par
00066     \par
00067     {\cf19 if} (cpu->currentThread) \{\par
00068         cpu->currentThread->PreviousMode = PreviousMode;\par
00069     \}\par
00070 \par
00071     {\cf19 switch} (vec_num) \{\par
00072     {\cf19 case} EXCEPTION_DIVIDE_BY_ZERO:\par
00073         MiDivideByZero(trap);\par
00074         {\cf19 break};\par
00075     {\cf19 case} EXCEPTION_SINGLE_STEP:\par
00076         MiDebugTrap(trap);\par
00077         {\cf19 break};\par
00078     {\cf19 case} EXCEPTION_NON_MASKABLE_INTERRUPT:\par
00079         _MeSetIrql(HIGH_LEVEL); {\cf20 // Non Maskable Interrupt - basically when the CPU encounters a hardware fault, cannot be masked, very alarming.}\par
00080         MiNonMaskableInterrupt(trap);\par
00081         {\cf19 break};\par
00082     {\cf19 case} EXCEPTION_BREAKPOINT:\par
00083         MiBreakpoint(trap);\par
00084         {\cf19 break};\par
00085     {\cf19 case} EXCEPTION_OVERFLOW:\par
00086         MiOverflow(trap);\par
00087         {\cf19 break};\par
00088     {\cf19 case} EXCEPTION_BOUNDS_CHECK:\par
00089         MiBoundsCheck(trap);\par
00090         {\cf19 break};\par
00091     {\cf19 case} EXCEPTION_INVALID_OPCODE:\par
00092         MiInvalidOpcode(trap);\par
00093         {\cf19 break};\par
00094     {\cf19 case} EXCEPTION_NO_COPROCESSOR:\par
00095         MiNoCoprocessor(trap);\par
00096         {\cf19 break};\par
00097     {\cf19 case} EXCEPTION_DOUBLE_FAULT:\par
00098         _MeSetIrql(HIGH_LEVEL);\par
00099         MiDoubleFault(trap);\par
00100         {\cf19 break};\par
00101     {\cf19 case} EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN:\par
00102         MiCoprocessorSegmentOverrun(trap);\par
00103         {\cf19 break};\par
00104     {\cf19 case} EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT:\par
00105         MiSegmentSelectorNotPresent(trap);\par
00106         {\cf19 break};\par
00107     {\cf19 case} EXCEPTION_INVALID_TSS:\par
00108         MiInvalidTss(trap);\par
00109         {\cf19 break};\par
00110     {\cf19 case} EXCEPTION_GENERAL_PROTECTION_FAULT:\par
00111         MiGeneralProtectionFault(trap);\par
00112         {\cf19 break};\par
00113     {\cf19 case} EXCEPTION_PAGE_FAULT:\par
00114         MiPageFault(trap);\par
00115         {\cf19 break};\par
00116     {\cf19 case} EXCEPTION_RESERVED:\par
00117         {\cf20 // reserved, do not use.}\par
00118         {\cf19 break};\par
00119     {\cf19 case} EXCEPTION_FLOATING_POINT_ERROR:\par
00120         MiFloatingPointError(trap);\par
00121         {\cf19 break};\par
00122     {\cf19 case} EXCEPTION_ALIGNMENT_CHECK:\par
00123         MiAlignmentCheck(trap);\par
00124         {\cf19 break};\par
00125     {\cf19 case} EXCEPTION_SEVERE_MACHINE_CHECK:\par
00126         _MeSetIrql(HIGH_LEVEL); {\cf20 // machine check, like NMI, high irql.}\par
00127         MiMachineCheck(trap);\par
00128         {\cf19 break};\par
00129     {\cf19 case} LAPIC_INTERRUPT:\par
00130         MeRaiseIrql(CLOCK_LEVEL, &oldIrql);\par
00131         MiLapicInterrupt(schedulerEnabled, trap);\par
00132         MeLowerIrql(oldIrql);\par
00133         {\cf19 break};\par
00134     {\cf19 case} VECTOR_IPI:\par
00135         MeRaiseIrql(IPI_LEVEL, &oldIrql);\par
00136         MiInterprocessorInterrupt();\par
00137         lapic_eoi();\par
00138         MeLowerIrql(oldIrql);\par
00139         {\cf19 break};\par
00140     {\cf19 case} VECTOR_DPC:\par
00141         {\cf20 // To see how is this triggered, check MeInsertQueueDpc or MeLowerIrql}\par
00142         assert(MeAreInterruptsEnabled() == {\cf17 false});\par
00143         {\cf20 // Raise IRQL to DISPATCH_LEVEL}\par
00144         MeRaiseIrql(DISPATCH_LEVEL, &oldIrql);\par
00145         {\cf20 // Drain DPCs while in DISPATCH}\par
00146         MeRetireDPCs();\par
00147         {\cf20 // Send EOI, this is called by the APIC Self BIT (so LAPIC)}\par
00148         lapic_eoi();\par
00149         {\cf20 // Lower IRQL back.}\par
00150         MeLowerIrql(oldIrql);\par
00151         {\cf19 break};\par
00152     {\cf19 case} VECTOR_APC:\par
00153         gop_printf(COLOR_RED, {\cf22 "APC Vector hit.\\n"});\par
00154         {\cf19 break};\par
00155     {\cf19 case} LAPIC_SIV_INTERRUPT:\par
00156         {\cf20 // just send EOI}\par
00157         lapic_eoi();\par
00158         {\cf19 break};\par
00159     {\cf19 default}:\par
00160         {\cf19 break};\par
00161     \}\par
00162 \par
00163     assert(MeAreInterruptsEnabled() == {\cf17 false});\par
00164     {\cf20 // Send An EOI}\par
00165     {\cf20 // TODO KINTERRUPT}\par
00166 \}\par
00167 \par
00168 {\cf18 void} init_interrupts() \{\par
00169     install_idt();\par
00170     _MeSetIrql(PASSIVE_LEVEL);\par
00171 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/pit.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/pit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/pit.c}
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include "../../intrinsics/intrin.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/me.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_FREQ_HZ}\~ 1193182U\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CMD_PORT}\~ 0x43\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CH0_PORT}\~ 0x40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CMD_MODE2_LBHB}\~ 0x34\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIT_CMD_LATCH_CH0}\~ 0x00\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pit_sleep_ms} (uint32_t ms)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v PIT_CH0_PORT\:pit.c}
{\xe \v pit.c\:PIT_CH0_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CH0_PORT\~ 0x40}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b pit.c}.}\par
}
{\xe \v PIT_CMD_LATCH_CH0\:pit.c}
{\xe \v pit.c\:PIT_CMD_LATCH_CH0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CMD_LATCH_CH0\~ 0x00}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b pit.c}.}\par
}
{\xe \v PIT_CMD_MODE2_LBHB\:pit.c}
{\xe \v pit.c\:PIT_CMD_MODE2_LBHB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CMD_MODE2_LBHB\~ 0x34}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b pit.c}.}\par
}
{\xe \v PIT_CMD_PORT\:pit.c}
{\xe \v pit.c\:PIT_CMD_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_CMD_PORT\~ 0x43}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b pit.c}.}\par
}
{\xe \v PIT_FREQ_HZ\:pit.c}
{\xe \v pit.c\:PIT_FREQ_HZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIT_FREQ_HZ\~ 1193182U}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b pit.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v pit_sleep_ms\:pit.c}
{\xe \v pit.c\:pit_sleep_ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pit_sleep_ms (uint32_t ms)}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b pit.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pit.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/pit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/pit.c}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <stdint.h>}\par
00002 {\cf21 #include "../../intrinsics/intrin.h"}\par
00003 {\cf21 #include "../../includes/mh.h"}\par
00004 {\cf21 #include "../../includes/me.h"}\par
00005 \par
00006 {\cf20 /* PIT constants */}\par
00007 {\cf21 #define PIT_FREQ_HZ 1193182U}\par
00008 {\cf21 #define PIT_CMD_PORT 0x43}\par
00009 {\cf21 #define PIT_CH0_PORT 0x40}\par
00010 \par
00011 {\cf20 /* Command bytes:}\par
00012 {\cf20    - 0x34 = channel 0, lobyte/hibyte, mode 2 (rate generator), binary}\par
00013 {\cf20    - 0x00 = latch command for channel 0 (bits 7..6 = 00, rest 0 = latch)}\par
00014 {\cf20 */}\par
00015 {\cf21 #define PIT_CMD_MODE2_LBHB 0x34}\par
00016 {\cf21 #define PIT_CMD_LATCH_CH0  0x00}\par
00017 \par
00018 {\cf20 /* Sleep ms implementation (blocking). Uses chunks <= 0xFFFF PIT ticks. */}\par
00019 {\cf18 void} pit_sleep_ms(uint32_t ms) \{\par
00020     {\cf19 if} (ms == 0) {\cf19 return};\par
00021 \par
00022     uint64_t total_ticks = ((uint64_t)PIT_FREQ_HZ * ms + 999) / 1000;\par
00023 \par
00024     {\cf19 while} (total_ticks > 0) \{\par
00025         uint32_t chunk = (total_ticks > 0xFFFF) ? 0xFFFF : (uint32_t)total_ticks;\par
00026         {\cf19 if} (chunk == 0) chunk = 0xFFFF;\par
00027 \par
00028         __outbyte(PIT_CMD_PORT, PIT_CMD_MODE2_LBHB);\par
00029         __outbyte(PIT_CH0_PORT, (uint8_t)(chunk & 0xFF));\par
00030         __outbyte(PIT_CH0_PORT, (uint8_t)((chunk >> 8) & 0xFF));\par
00031 \par
00032         {\cf18 bool} Enabled = MeDisableInterrupts();\par
00033 \par
00034         __outbyte(PIT_CMD_PORT, PIT_CMD_LATCH_CH0);\par
00035         {\cf20 // Ensure proper sequencing of port reads}\par
00036         uint8_t start_lo = __inbyte(PIT_CH0_PORT);\par
00037         {\cf17 asm} {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});  {\cf20 // compiler barrier}\par
00038         uint8_t start_hi = __inbyte(PIT_CH0_PORT);\par
00039         uint16_t start = start_lo | ((uint16_t)start_hi << 8);\par
00040 \par
00041         {\cf19 while} (1) \{\par
00042             __outbyte(PIT_CMD_PORT, PIT_CMD_LATCH_CH0);\par
00043             uint8_t curr_lo = __inbyte(PIT_CH0_PORT);\par
00044             {\cf17 asm} {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});  {\cf20 // compiler barrier}\par
00045             uint8_t curr_hi = __inbyte(PIT_CH0_PORT);\par
00046             uint16_t curr = curr_lo | ((uint16_t)curr_hi << 8);\par
00047 \par
00048             uint16_t elapsed = (uint16_t)(start - curr);\par
00049             {\cf19 if} ((uint32_t)elapsed >= chunk) {\cf19 break};\par
00050 \par
00051             {\cf17 asm} {\cf17 volatile}({\cf22 "pause"});\par
00052         \}\par
00053 \par
00054         MeEnableInterrupts(Enabled);\par
00055         total_ticks -= chunk;\par
00056     \}\par
00057 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/smp.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/smp.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/smp.c}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPU_STACK_SIZE}\~ (24*1024)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhInitializeSMP} (uint8_t *{\b apic_list}, uint32_t {\b cpu_count}, uint32_t {\b lapicAddress})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PPROCESSOR} {\b MeGetProcessorBlock} (uint8_t ProcessorNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhSendActionToCpusAndWait} ({\b CPU_ACTION} action, {\b IPI_PARAMS} parameter)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b _binary_build_ap_trampoline_bin_start} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b _binary_build_ap_trampoline_bin_end} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PROCESSOR} {\b cpus} [{\b MAX_CPUS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b smp_cpu_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SMP_BOOTINFO} {\b bootInfo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b smpInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PROCESSOR} {\b cpu0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b g_apic_list} [{\b MAX_CPUS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b g_cpuCount} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b g_lapicAddress}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CPU_STACK_SIZE\:smp.c}
{\xe \v smp.c\:CPU_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPU_STACK_SIZE\~ (24*1024)}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b smp.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MeGetProcessorBlock\:smp.c}
{\xe \v smp.c\:MeGetProcessorBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PPROCESSOR} MeGetProcessorBlock (uint8_t ProcessorNumber)}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b smp.c}.}\par
}
{\xe \v MhInitializeSMP\:smp.c}
{\xe \v smp.c\:MhInitializeSMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhInitializeSMP (uint8_t * apic_list, uint32_t cpu_count, uint32_t lapicAddress)}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b smp.c}.}\par
}
{\xe \v MhSendActionToCpusAndWait\:smp.c}
{\xe \v smp.c\:MhSendActionToCpusAndWait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhSendActionToCpusAndWait ({\b CPU_ACTION} action, {\b IPI_PARAMS} parameter)}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b smp.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v _binary_build_ap_trampoline_bin_end\:smp.c}
{\xe \v smp.c\:_binary_build_ap_trampoline_bin_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t _binary_build_ap_trampoline_bin_end[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v _binary_build_ap_trampoline_bin_start\:smp.c}
{\xe \v smp.c\:_binary_build_ap_trampoline_bin_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t _binary_build_ap_trampoline_bin_start[]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bootInfo\:smp.c}
{\xe \v smp.c\:bootInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SMP_BOOTINFO} bootInfo}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b smp.c}.}\par
}
{\xe \v cpu0\:smp.c}
{\xe \v smp.c\:cpu0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PROCESSOR} cpu0{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b kernel.c}.}\par
}
{\xe \v cpus\:smp.c}
{\xe \v smp.c\:cpus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PROCESSOR} cpus[{\b MAX_CPUS}]}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b smp.c}.}\par
}
{\xe \v g_apic_list\:smp.c}
{\xe \v smp.c\:g_apic_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t g_apic_list[{\b MAX_CPUS}]}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b smp.c}.}\par
}
{\xe \v g_cpuCount\:smp.c}
{\xe \v smp.c\:g_cpuCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t g_cpuCount = 1}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b smp.c}.}\par
}
{\xe \v g_lapicAddress\:smp.c}
{\xe \v smp.c\:g_lapicAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t g_lapicAddress}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b smp.c}.}\par
}
{\xe \v smp_cpu_count\:smp.c}
{\xe \v smp.c\:smp_cpu_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int smp_cpu_count = 0}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b smp.c}.}\par
}
{\xe \v smpInitialized\:smp.c}
{\xe \v smp.c\:smpInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool smpInitialized{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
smp.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/smp.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mh/smp.c}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Symmetric MultiProcessing Functions And Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../assert.h"}\par
00008 {\cf21 #include "../../includes/mh.h"}\par
00009 {\cf21 #include "../../includes/mm.h"}\par
00010 {\cf21 #include "../../includes/me.h"}\par
00011 {\cf21 #include <stdint.h>}\par
00012 \par
00013 {\cf17 extern} uint8_t _binary_build_ap_trampoline_bin_start[];\par
00014 {\cf17 extern} uint8_t _binary_build_ap_trampoline_bin_end[];\par
00015 \par
00016 PROCESSOR cpus[MAX_CPUS];\par
00017 {\cf18 int} smp_cpu_count = 0;\par
00018 SMP_BOOTINFO bootInfo;\par
00019 {\cf17 extern} {\cf18 bool} smpInitialized;\par
00020 \par
00021 {\cf17 static} {\cf17 inline} uint8_t my_lapic_id({\cf18 void}) \{\par
00022     uint32_t x = lapic_mmio_read(LAPIC_ID);\par
00023     {\cf19 return} (uint8_t)(x >> 24);\par
00024 \}\par
00025 \par
00026 {\cf20 // Copy trampoline binary to low phys and map identity for this page.}\par
00027 {\cf17 static} {\cf18 void} install_trampoline({\cf18 void}) \{\par
00028     uintptr_t virt = AP_TRAMP_PHYS + PhysicalMemoryOffset;\par
00029     PMMPTE pte = MiGetPtePointer(virt);\par
00030     PMMPTE apPhysPte = MiGetPtePointer(AP_TRAMP_PHYS);\par
00031     {\cf18 size_t} sz = (size_t)(_binary_build_ap_trampoline_bin_end - _binary_build_ap_trampoline_bin_start);\par
00032     assert((sz <= AP_TRAMP_SIZE), {\cf22 "Size of copy must not be larger than the binary itself"});\par
00033     {\cf20 /* 2) Map the physical page into our page tables (virt -> AP_TRAMP_PHYS) */}\par
00034     MI_WRITE_PTE(pte, virt, AP_TRAMP_PHYS, PAGE_PRESENT | PAGE_RW);\par
00035     MI_WRITE_PTE(apPhysPte, AP_TRAMP_PHYS, AP_TRAMP_PHYS, PAGE_PRESENT | PAGE_RW);\par
00036 \par
00037     {\cf20 /* 3) Copy the trampoline into that mapped page */}\par
00038     kmemcpy(({\cf18 void}*)virt, _binary_build_ap_trampoline_bin_start, sz);\par
00039 \par
00040     {\cf20 /* 4) Make sure caches/TLB don't have stale data:}\par
00041 {\cf20        clflush the page (per 64-byte cacheline) and invlpg the page. */}\par
00042     {\cf19 for} (uintptr_t off = 0; off < 4096; off += 64) \{\par
00043         __asm__ {\cf17 volatile}({\cf22 "clflush (%0)"} :: {\cf22 "r"}(({\cf18 char}*)virt + off) : {\cf22 "memory"});\par
00044     \}\par
00045     __asm__ {\cf17 volatile}({\cf22 "invlpg (%0)"} :: {\cf22 "r"}(virt) : {\cf22 "memory"});\par
00046 \}\par
00047 \par
00048 {\cf21 #define CPU_STACK_SIZE (24*1024) }{\cf20 // 24 KiB stack.}\par
00049 \par
00050 {\cf17 extern} PROCESSOR cpu0;\par
00051 \par
00052 {\cf20 // Allocate PER CPU stack and populare cpus[]}\par
00053 {\cf17 static} {\cf18 void} prepare_percpu(uint8_t* apic_list, uint32_t cpu_count) \{\par
00054     uint8_t my_id = my_lapic_id();\par
00055 \par
00056     {\cf19 for} (uint32_t i = 0; i < cpu_count && i < MAX_CPUS; i++) \{\par
00057         uint8_t aid = apic_list[i];\par
00058 \par
00059         {\cf19 if} (aid == my_id) \{\par
00060             {\cf20 // BSP slot, since we want synchronization for all APs, we migrate cpu0 to this global variable of CPUs, and change gs once again.}\par
00061             {\cf20 // Debugging helped me solve this, I saw that [i].IpiSeq (i = bsp slot), was 3, but [i].self->IpiSeq is 0, which was the real one.}\par
00062             {\cf20 // So we infinite looped.}\par
00063 \par
00064             {\cf20 // Explicitly disable interrupts for synchronization.}\par
00065             \par
00066             {\cf18 bool} Enabled = MeDisableInterrupts();\par
00067             \par
00068             {\cf20 // Copy all of the cpu data to here.}\par
00069             kmemcpy(&cpus[i], &cpu0, {\cf17 sizeof}(PROCESSOR));\par
00070 \par
00071             {\cf20 // Set the new self ptr and other variables.}\par
00072             cpus[i].self = &cpus[i];\par
00073             cpus[i].ID = i;\par
00074             cpus[i].lapic_ID = aid;\par
00075             cpus[i].flags = CPU_ONLINE;\par
00076 \par
00077             {\cf20 // Set the GS to point to new cpus[i]}\par
00078             __writemsr(IA32_GS_BASE, (uint64_t)&cpus[i]);\par
00079 \par
00080             {\cf20 // Re-Enable if enabled before.}\par
00081             MeEnableInterrupts(Enabled);\par
00082 \par
00083             {\cf19 continue};\par
00084         \}\par
00085         \par
00086         {\cf20 // Initialize basic values.}\par
00087         cpus[i].self = &cpus[i];\par
00088         cpus[i].currentIrql = PASSIVE_LEVEL;\par
00089         cpus[i].schedulerEnabled = {\cf17 false};\par
00090         cpus[i].currentThread = NULL;\par
00091         kmemset(&cpus[i].readyQueue, 0, {\cf17 sizeof}(cpus[i].readyQueue));\par
00092         cpus[i].ID = i;\par
00093         cpus[i].lapic_ID = aid;\par
00094 \par
00095         {\cf20 // Allocate stack -- aligned 16.}\par
00096         {\cf18 void}* stack = MiCreateKernelStack({\cf17 true});\par
00097         cpus[i].VirtStackTop = stack;\par
00098 \par
00099         {\cf20 // IST Stack setup & GDT & TSS have been moved to MeInitProcesor function.}\par
00100 \par
00101         {\cf20 // CPU Flags}\par
00102         cpus[i].flags |= CPU_UNAVAILABLE; {\cf20 // Start unavailable.}\par
00103         cpus[i].schedulePending = {\cf17 false};\par
00104 \par
00105         {\cf20 // DPCs & Queue}\par
00106         kmemset(&cpus[i].CurrentDeferredRoutine, 0, {\cf17 sizeof}(cpus[i].CurrentDeferredRoutine));\par
00107 \par
00108     \}\par
00109     smp_cpu_count = cpu_count;\par
00110 \}\par
00111 \par
00112 {\cf17 static} {\cf18 void} send_startup_ipis(uint8_t apic_id) \{\par
00113     {\cf20 // init}\par
00114     lapic_send_ipi(apic_id, 0, (0x5 << 8) | (1 << 14)); {\cf20 // init assert}\par
00115     pit_sleep_ms(10);\par
00116 \par
00117     uint8_t vector = (uint8_t)(AP_TRAMP_PHYS >> 12);\par
00118 \par
00119     {\cf20 // SIPI x2}\par
00120     lapic_send_ipi(apic_id, vector, (0x6 << 8));\par
00121     pit_sleep_ms(1);\par
00122     lapic_send_ipi(apic_id, vector, (0x6 << 8));\par
00123     pit_sleep_ms(1);\par
00124 \}\par
00125 \par
00126 {\cf20 // Globals for use of IPI & other functions.}\par
00127 uint8_t g_apic_list[MAX_CPUS];\par
00128 uint32_t g_cpuCount = 1; {\cf20 // Must be 1, to include the BSP.}\par
00129 uint32_t g_lapicAddress;\par
00130 \par
00131 {\cf20 // BSP Entry: start all APs.}\par
00132 {\cf18 void} MhInitializeSMP(uint8_t* apic_list, uint32_t cpu_count, uint32_t lapicAddress) \{\par
00133     {\cf20 // populate cpus and per cpu stacks.}\par
00134     prepare_percpu(apic_list, cpu_count);\par
00135     {\cf20 // copy trampoline}\par
00136     install_trampoline();\par
00137 \par
00138     {\cf20 // Fill in the globals.}\par
00139     g_cpuCount = cpu_count;\par
00140     g_lapicAddress = lapicAddress;\par
00141     {\cf19 for} (uint32_t i = 0; i < cpu_count; i++) \{\par
00142         g_apic_list[i] = apic_list[i];\par
00143     \}\par
00144     \par
00145     bootInfo.magic = SMP_MAGIC;\par
00146     bootInfo.kernel_pml4_phys = boot_info_local.Pml4Phys;\par
00147     bootInfo.ap_entry_virt = (uint64_t)&APMain;\par
00148     bootInfo.cpu_count = cpu_count;\par
00149     bootInfo.lapic_base = lapicAddress;\par
00150 \par
00151     {\cf20 // write address of ap main to the offset}\par
00152     uintptr_t virt = PhysicalMemoryOffset + AP_TRAMP_PHYS + AP_TRAMP_APMAIN_OFFSET;\par
00153     PMMPTE pte = MiGetPtePointer(virt);\par
00154     PMMPTE apPtePhys = MiGetPtePointer((AP_TRAMP_PHYS + AP_TRAMP_APMAIN_OFFSET));\par
00155     MI_WRITE_PTE(pte, virt, AP_TRAMP_PHYS + AP_TRAMP_APMAIN_OFFSET, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00156     MI_WRITE_PTE(apPtePhys, AP_TRAMP_PHYS + AP_TRAMP_APMAIN_OFFSET, AP_TRAMP_PHYS + AP_TRAMP_APMAIN_OFFSET, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00157     uint64_t ap_main_addr = (uint64_t)&APMain;\par
00158     kmemcpy(({\cf18 void}*)virt, &ap_main_addr, {\cf17 sizeof}(ap_main_addr));\par
00159 \par
00161     virt = PhysicalMemoryOffset + AP_TRAMP_PHYS + AP_TRAMP_PML4_OFFSET;\par
00162     pte = MiGetPtePointer(virt);\par
00163     apPtePhys = MiGetPtePointer((AP_TRAMP_PHYS + AP_TRAMP_PML4_OFFSET));\par
00164     MI_WRITE_PTE(pte, virt, AP_TRAMP_PHYS + AP_TRAMP_PML4_OFFSET, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00165     MI_WRITE_PTE(apPtePhys, AP_TRAMP_PHYS + AP_TRAMP_PML4_OFFSET, AP_TRAMP_PHYS + AP_TRAMP_PML4_OFFSET, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00166     uintptr_t cr3 = boot_info_local.Pml4Phys;\par
00167     kmemcpy(({\cf18 void}*)virt, &cr3, {\cf17 sizeof}(cr3));\par
00168 \par
00169     {\cf20 // write address of CPUs to the offset}\par
00170     virt = PhysicalMemoryOffset + AP_TRAMP_PHYS + AP_TRAMP_CPUS_OFFSET;\par
00171     pte = MiGetPtePointer(virt);\par
00172     apPtePhys = MiGetPtePointer((AP_TRAMP_PHYS + AP_TRAMP_CPUS_OFFSET));\par
00173     MI_WRITE_PTE(pte, virt, AP_TRAMP_PHYS + AP_TRAMP_CPUS_OFFSET, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00174     MI_WRITE_PTE(apPtePhys, AP_TRAMP_PHYS + AP_TRAMP_CPUS_OFFSET, AP_TRAMP_PHYS + AP_TRAMP_CPUS_OFFSET, PAGE_PRESENT | PAGE_RW | PAGE_PCD);\par
00175     uintptr_t cpuAddress = (uintptr_t)cpus;\par
00176     kmemcpy(({\cf18 void}*)virt, &cpuAddress, {\cf17 sizeof}(cpuAddress));\par
00177 \par
00178     {\cf20 // send INIT/SIPI/SIPI to APs (skip BSP)}\par
00179     uint8_t my_id = my_lapic_id();\par
00180     {\cf19 for} (uint32_t i = 0; i < cpu_count; i++) \{\par
00181         uint8_t aid = apic_list[i];\par
00182         {\cf19 if} (aid == my_id) {\cf19 continue};\par
00183         send_startup_ipis(aid);\par
00184     \}\par
00185     {\cf20 // over - Application Processors (the other CPUs) should execute trampoline and call ap_main();}\par
00186     {\cf20 // now, we wait until all are online.}\par
00187     {\cf19 for} (uint32_t i = 0; i < g_cpuCount; i++) \{\par
00188         {\cf19 while} (!(cpus[i].flags & CPU_ONLINE)) \{\par
00189             __pause();\par
00190         \}\par
00191     \}\par
00192     smpInitialized = {\cf17 true};\par
00193 \}\par
00194 \par
00195 PPROCESSOR \par
00196 MeGetProcessorBlock(\par
00197     uint8_t ProcessorNumber\par
00198 )\par
00199 \par
00200 \{\par
00201     {\cf19 if} (!smpInitialized) {\cf19 return} &cpu0;\par
00202 \par
00203     {\cf20 // SMP Is on, we iterate over the cpus list until we find the lapic for the processor.}\par
00204     {\cf19 for} (uint8_t i = 0; i < MeGetActiveProcessorCount(); i++) \{\par
00205         {\cf19 if} (cpus[i].lapic_ID == ProcessorNumber) {\cf19 return} &cpus[i];\par
00206     \}\par
00207 \par
00208     {\cf20 // The CPU isn't found, we return NULL (would bugcheck though).}\par
00209     {\cf19 return} NULL;\par
00210 \}\par
00211 \par
00212 {\cf18 void} MhSendActionToCpusAndWait(CPU_ACTION action, IPI_PARAMS parameter) \{\par
00213     {\cf19 if} (!g_cpuCount || !smpInitialized) {\cf19 return};\par
00214     uint8_t myid = my_lapic_id();\par
00215 \par
00216     {\cf17 static} uint64_t g_ipiSeq = 1; {\cf20 // Global sequence of IPIs made.}\par
00217     uint64_t seq = InterlockedIncrementU64(&g_ipiSeq);\par
00218 \par
00219     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00220 \par
00221     {\cf19 for} (uint32_t i = 0; i < g_cpuCount; i++) \{\par
00222         {\cf19 if} (cpus[i].lapic_ID == myid) {\cf19 continue};\par
00223         {\cf19 if} (!(cpus[i].flags & CPU_ONLINE)) {\cf19 continue};\par
00224 \par
00225         cpus[i].IpiAction = action;\par
00226         cpus[i].IpiParameter = parameter;\par
00227 \par
00228         cpus[i].IpiSeq = seq; {\cf20 // assign sequence number}\par
00229         uint32_t LAPIC_ACTION_VECTOR = VECTOR_IPI;\par
00230         lapic_send_ipi(cpus[i].lapic_ID, (uint8_t)LAPIC_ACTION_VECTOR, 0x0);\par
00231     \}\par
00232 \par
00233     {\cf20 // wait for all CPUs to handle this exact IPI}\par
00234     {\cf19 for} (uint32_t i = 0; i < g_cpuCount; i++) \{\par
00235         {\cf19 if} (cpus[i].lapic_ID == myid || !(cpus[i].flags & CPU_ONLINE))\par
00236             {\cf19 continue};\par
00237 \par
00238         {\cf19 while} (*({\cf17 volatile} uint64_t*)&cpus[i].IpiSeq == seq) \{\par
00239             __pause(); {\cf20 // spin until they clear the seq}\par
00240         \}\par
00241     \}\par
00242 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/fault.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/fault.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/fault.c}
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmAccessFault} ({\b IN} uint64_t FaultBits, {\b IN} uint64_t VirtualAddress, {\b IN} {\b PRIVILEGE_MODE} PreviousMode, {\b IN} {\b PTRAP_FRAME} TrapFrame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmInvalidAccessAllowed} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MmAccessFault\:fault.c}
{\xe \v fault.c\:MmAccessFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmAccessFault ({\b IN} uint64_t FaultBits, {\b IN} uint64_t VirtualAddress, {\b IN} {\b PRIVILEGE_MODE} PreviousMode, {\b IN} {\b PTRAP_FRAME} TrapFrame)}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b fault.c}.}\par
}
{\xe \v MmInvalidAccessAllowed\:fault.c}
{\xe \v fault.c\:MmInvalidAccessAllowed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmInvalidAccessAllowed (void )}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b fault.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fault.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/fault.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/fault.c}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     map.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of access faults in the system. (page faults)}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/mh.h"}\par
00021 {\cf21 #include "../../includes/me.h"}\par
00022 {\cf21 #include "../../includes/ps.h"}\par
00023 {\cf21 #include "../../includes/mg.h"}\par
00024 {\cf21 #include "../../assert.h"}\par
00025 \par
00026 MTSTATUS\par
00027 MmAccessFault(\par
00028     IN  uint64_t FaultBits,\par
00029     IN  uint64_t VirtualAddress,\par
00030     IN  PRIVILEGE_MODE PreviousMode,\par
00031     IN  PTRAP_FRAME TrapFrame\par
00032 )\par
00033 \par
00034 {\cf20 /*++}\par
00035 {\cf20 }\par
00036 {\cf20     Routine description:}\par
00037 {\cf20 }\par
00038 {\cf20         This function is called by the kernel on data or instruction access faults.}\par
00039 {\cf20         - The access fault was detected due to:}\par
00040 {\cf20             An Access Violation.}\par
00041 {\cf20             A PTE with the present bit clear.}\par
00042 {\cf20             A Valid PTE with the Dirty bit and a write operation.}\par
00043 {\cf20 }\par
00044 {\cf20         Note that the page fault could occur because of the Page Directory contents as well.}\par
00045 {\cf20 }\par
00046 {\cf20         This routine determines what type of fault it is and calls the appropriate routine to handle or write the page fault.}\par
00047 {\cf20 }\par
00048 {\cf20     Arguments:}\par
00049 {\cf20 }\par
00050 {\cf20         [IN]    FaultBits - The error code pushed by the CPU.}\par
00051 {\cf20         [IN]    VirtualAddress - The Memory Address Referenced (CR2)}\par
00052 {\cf20         [IN]    PreviousMode - Supplies the mode (kernel or user) where the fault occured.}\par
00053 {\cf20         [IN]    TrapFrame - Trap information at fault.}\par
00054 {\cf20 }\par
00055 {\cf20     Return Values:}\par
00056 {\cf20 }\par
00057 {\cf20         MTSTATUS Code resulting in the status of fault handling operation.}\par
00058 {\cf20 }\par
00059 {\cf20         Could be:}\par
00060 {\cf20             MT_SUCCESS -- Fault handled, return.}\par
00061 {\cf20             MT_ACCESS_VIOLATION -- User mode only (or kernel mode probing).}\par
00062 {\cf20             MT_GUARD_PAGE_VIOLATION -- Bugchecks.}\par
00063 {\cf20 }\par
00064 {\cf20         The function would bugcheck if an invalid kernel mode access occured (or in worst case, 0 memory is available to fill the VAD of the user mode process, but I want to change it to sleep instead..)}\par
00065 {\cf20 }\par
00066 {\cf20 --*/}\par
00067 \par
00068 \{\par
00069     {\cf20 // Declarations}\par
00070 {\cf21 #ifdef DEBUG}\par
00071     PMMPTE ReferencedPml4e = MiGetPml4ePointer(VirtualAddress);\par
00072     PMMPTE ReferencedPdpte = MiGetPdptePointer(VirtualAddress);\par
00073     PMMPTE ReferencedPde = MiGetPdePointer(VirtualAddress);\par
00074     UNREFERENCED_PARAMETER(ReferencedPml4e); UNREFERENCED_PARAMETER(ReferencedPdpte); UNREFERENCED_PARAMETER(ReferencedPde);\par
00075 {\cf21 #endif}\par
00076     PMMPTE ReferencedPte = MiGetPtePointer(VirtualAddress);\par
00077     FAULT_OPERATION OperationDone = MiRetrieveOperationFromErrorCode(FaultBits);\par
00078     IRQL PreviousIrql = MeGetCurrentIrql();\par
00079 \par
00080 {\cf21 #ifdef DEBUG}\par
00081     gop_printf(COLOR_RED, {\cf22 "Inside MmAccessFault | FaultBits: %llx | VirtualAddress: %p | PreviousMode: %d | TrapFrame->rip: %p | Operation: %d | Irql: %d\\n"}, ({\cf18 unsigned} {\cf18 long} {\cf18 long})FaultBits, ({\cf18 void}*)(uintptr_t)VirtualAddress, PreviousMode, ({\cf18 void}*)(uintptr_t)TrapFrame->rip, OperationDone, PreviousIrql);\par
00082 {\cf21 #endif}\par
00083 \par
00084     {\cf19 if} (!ReferencedPte) \{\par
00085         {\cf20 // If we cannot get the PTE for the VA, we raise access violation if its user mode, or bugcheck on kernel mode.}\par
00086         {\cf19 if} (PreviousMode == UserMode) \{\par
00087             {\cf19 return} MT_ACCESS_VIOLATION;\par
00088         \}\par
00089 \par
00090         {\cf19 goto} BugCheck;\par
00091     \}\par
00092 \par
00093     {\cf20 // If the VA given isn't canonical (sign extended after bit 47, required by CPU MMU Laws), we return or bugcheck depending on the previous mode.}\par
00094     {\cf19 if} (!MI_IS_CANONICAL_ADDR(VirtualAddress)) \{\par
00095 \par
00096         {\cf19 if} (PreviousMode == UserMode) \{\par
00097             {\cf20 // User mode fault on non canonical address, not destructive.}\par
00098             {\cf19 return} MT_ACCESS_VIOLATION;\par
00099         \}\par
00100 \par
00101         {\cf20 // Kernel mode page fault on a non canonical address.}\par
00102         {\cf19 goto} BugCheck;\par
00103 \par
00104     \}\par
00105 \par
00106     {\cf20 // Check for NX. (NX on anywhere is invalid, no matter the range)}\par
00107     {\cf19 if} (OperationDone == ExecuteOperation) \{\par
00108         {\cf20 // Fault on NX bit set page.}\par
00109         {\cf19 if} (PreviousMode == UserMode) {\cf19 return} MT_ACCESS_VIOLATION;\par
00110         {\cf20 // Bugcheck, its kernel mode.}\par
00111         {\cf19 goto} BugCheck;\par
00112     \}\par
00113 \par
00114     {\cf20 // Now we check for each address in the system, and handle the request based on that.}\par
00115     {\cf19 if} (VirtualAddress >= MmSystemRangeStart) \{\par
00116         {\cf19 if} (PreviousMode == UserMode) \{\par
00117             {\cf20 // User mode access in kernel memory, invalid.}\par
00118             {\cf19 return} MT_ACCESS_VIOLATION;\par
00119         \}\par
00120 \par
00121         MMPTE TempPte = *ReferencedPte;\par
00122 \par
00123         {\cf20 // If this is a guard page, we MUST NOT demand allocate it. (pre guard)}\par
00124         {\cf19 if} (TempPte.Soft.SoftwareFlags & MI_GUARD_PAGE_PROTECTION) \{\par
00125             {\cf19 goto} BugCheck;\par
00126         \}\par
00127 \par
00128         {\cf20 // PTE Is present, but we got a fault.}\par
00129         {\cf19 if} (TempPte.Hard.Present) \{\par
00130             {\cf20 // Write fault to read-only memory.}\par
00131             {\cf19 if} ((OperationDone == WriteOperation) && (TempPte.Hard.Write == 0)) \{\par
00132                 MeBugCheckEx(\par
00133                     ATTEMPTED_WRITE_TO_READONLY_MEMORY,\par
00134                     ({\cf18 void}*)VirtualAddress,\par
00135                     ({\cf18 void}*)ReferencedPte,\par
00136                     NULL,\par
00137                     NULL\par
00138                 );\par
00139             \}\par
00140 \par
00141             {\cf20 // If we get here, it was an access/dirty update \'97 set dirty bit if write}\par
00142             {\cf19 if} (OperationDone == WriteOperation) \{\par
00143                 {\cf20 // set dirty in PTE and, if needed, PFN->Dirty}\par
00144                 {\cf20 // Prefer an atomic update: build NewPte = TempPte; NewPte.Hard.Dirty = 1; WriteValidPteAtomic(...)}\par
00145                 MMPTE NewPte = TempPte;\par
00146                 NewPte.Hard.Dirty = 1;\par
00147                 MiAtomicExchangePte(ReferencedPte, NewPte.Value);\par
00148                 MiInvalidateTlbForVa(({\cf18 void}*)VirtualAddress);\par
00149             \}\par
00150             {\cf19 return} MT_SUCCESS;\par
00151         \}\par
00152         \par
00153         {\cf20 // Before any demand allocation, check IRQL.}\par
00154         {\cf19 if} (PreviousIrql >= DISPATCH_LEVEL) \{\par
00155             {\cf20 // IRQL Isn't less than DISPATCH_LEVEL, so we cannot lazily allocate, since it would **block**.}\par
00156             MeBugCheckEx(\par
00157                 IRQL_NOT_LESS_OR_EQUAL,\par
00158                 ({\cf18 void}*)VirtualAddress,\par
00159                 ({\cf18 void}*)PreviousIrql,\par
00160                 ({\cf18 void}*)OperationDone,\par
00161                 ({\cf18 void}*)TrapFrame->rip\par
00162             );\par
00163         \}\par
00164         \par
00165 \par
00166         {\cf20 // PTE Isn't present, check for demand allocations.}\par
00167         {\cf19 if} (MM_IS_DEMAND_ZERO_PTE(TempPte)) \{\par
00168             {\cf20 // Allocate a physical page for kernel demand-zero}\par
00169             PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00170             {\cf19 if} (pfn == PFN_ERROR) \{\par
00171                 {\cf20 // out of memory.}\par
00172                 {\cf19 goto} BugCheck;\par
00173             \}\par
00174 \par
00175             {\cf20 // Check protection mask.}\par
00176             uint64_t ProtectionFlags = PAGE_PRESENT;\par
00177             ProtectionFlags |= (TempPte.Soft.SoftwareFlags & PROT_KERNEL_WRITE) ? PAGE_RW : 0;\par
00178 \par
00179             {\cf20 // Write the PTE.}\par
00180             MI_WRITE_PTE(ReferencedPte, VirtualAddress, PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(pfn)), ProtectionFlags);\par
00181 \par
00182             {\cf19 return} MT_SUCCESS;\par
00183         \}\par
00184 \par
00185         {\cf20 // PTE Isn't present, and its a transition}\par
00186         {\cf19 if} (TempPte.Soft.Transition == 1) \{\par
00187             {\cf20 // Retrieve the PFN Number written in the transition page.}\par
00188             PAGE_INDEX pfn = TempPte.Soft.PageFrameNumber;\par
00189             {\cf19 if} (!MiIsValidPfn(pfn)) {\cf19 goto} BugCheck;\par
00190 \par
00191             {\cf20 // Check the PFN, it has to be in the StandBy list and be equal to our PTE, if not, bugcheck.}\par
00192             PPFN_ENTRY PPfn = INDEX_TO_PPFN(pfn);\par
00193             {\cf19 if} (PPfn->State != PfnStateStandby || PPfn->Descriptor.Mapping.PteAddress == NULL || PPfn->Descriptor.Mapping.PteAddress != ReferencedPte) {\cf19 goto} BugCheck;\par
00194 \par
00195             {\cf20 // PFN Is matching to this pte, now we can allocate, finally.}\par
00196             {\cf20 // Check protection mask.}\par
00197             uint64_t ProtectionFlags = PAGE_PRESENT;\par
00198             ProtectionFlags |= (TempPte.Soft.SoftwareFlags & PROT_KERNEL_WRITE) ? PAGE_RW : 0;\par
00199 \par
00200             MI_WRITE_PTE(ReferencedPte, VirtualAddress, PFN_TO_PHYS(pfn), ProtectionFlags);\par
00201 \par
00202             {\cf19 return} MT_SUCCESS;\par
00203         \}\par
00204 \par
00205         {\cf20 // TODO GRAB FROM PAGEFILE}\par
00206 \par
00207         {\cf20 // Unknown PTE format -> bugcheck (kernel space)}\par
00208         {\cf19 goto} BugCheck;\par
00209     \}\par
00210 \par
00211     {\cf20 // Address is below the kernel start, and above user address.}\par
00212     {\cf20 // This if statement should never pass, since these addresses are non canonical, and the first if statement checks for a non canonical adddres.}\par
00213     {\cf20 // basically kernel bloat this point.}\par
00214     {\cf20 // i removed it, bye bye.}\par
00215 \par
00216     {\cf20 // Address is in user range.}\par
00217     {\cf19 if} (VirtualAddress <= MmHighestUserAddress) \{\par
00218         {\cf19 if} (PreviousMode == KernelMode) \{\par
00219             {\cf20 // Kernel mode dereference on a user address}\par
00220             {\cf19 goto} BugCheck;\par
00221         \}\par
00222 \par
00223         {\cf20 // User mode fault on a user address, we check if there is a vad for it, if so, allocate the page.}\par
00224         PMMVAD vad = MiFindVad(PsGetCurrentProcess()->VadRoot, VirtualAddress);\par
00225         {\cf19 if} (!vad) {\cf19 return} MT_ACCESS_VIOLATION;\par
00226 \par
00227         {\cf20 // Looks like we have a valid vad, lets allocate.}\par
00228         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateFree);\par
00229         {\cf19 if} (pfn == PFN_ERROR) {\cf19 goto} BugCheck; {\cf20 // TODO OOM}\par
00230 \par
00231         {\cf20 // Acquire the PTE for the faulty VA.}\par
00232         PMMPTE pte = MiGetPtePointer(VirtualAddress);\par
00233 \par
00234         {\cf20 // Write the PTE.}\par
00235         MI_WRITE_PTE(pte, VirtualAddress, PFN_TO_PHYS(pfn), PAGE_PRESENT | PAGE_RW | PAGE_USER);\par
00236 \par
00237         {\cf20 // Return success.}\par
00238         {\cf19 return} MT_SUCCESS;\par
00239     \}\par
00240 \par
00241     {\cf20 // Address, is, what... impossible!}\par
00242     {\cf20 // This comment means execution is impossible to reach here, as we sanitized all (valid) addresses in the 48bit paging hierarchy.}\par
00243     {\cf20 // If it does reach here, look below.}\par
00244 \par
00245 BugCheck:\par
00246     {\cf20 // TODO Check for NX.}\par
00247 \par
00248     {\cf20 // Check if its a guard page violation}\par
00249     {\cf19 if} (ReferencedPte->Soft.SoftwareFlags & MI_GUARD_PAGE_PROTECTION) \{\par
00250         MeBugCheckEx(\par
00251             GUARD_PAGE_DEREFERENCE,\par
00252             ({\cf18 void}*)VirtualAddress,\par
00253             ({\cf18 void}*)MiRetrieveOperationFromErrorCode(TrapFrame->error_code),\par
00254             ({\cf18 void}*)TrapFrame->rip,\par
00255             ({\cf18 void}*)FaultBits\par
00256         );\par
00257     \}\par
00258 \par
00259     {\cf20 // Check if its a pool dereference (NonPagedPool first)}\par
00260     {\cf19 if} (VirtualAddress >= MmNonPagedPoolStart && VirtualAddress <= MmNonPagedPoolEnd) \{\par
00261         MeBugCheckEx(\par
00262             PAGE_FAULT_IN_FREED_NONPAGED_POOL,\par
00263             ({\cf18 void}*)VirtualAddress,\par
00264             ({\cf18 void}*)MiRetrieveOperationFromErrorCode(TrapFrame->error_code),\par
00265             ({\cf18 void}*)TrapFrame->rip,\par
00266             ({\cf18 void}*)FaultBits\par
00267         );\par
00268     \}\par
00269 \par
00270     {\cf20 // Check if Paged Pool Dereference. (the IRQL_NOT_LESS_OR_EQUAL bugcheck is up top)}\par
00271     {\cf19 if} (VirtualAddress >= MmPagedPoolStart && VirtualAddress <= MmPagedPoolEnd) \{\par
00272         MeBugCheckEx(\par
00273             PAGE_FAULT_IN_FREED_PAGED_POOL,\par
00274             ({\cf18 void}*)VirtualAddress,\par
00275             ({\cf18 void}*)MiRetrieveOperationFromErrorCode(TrapFrame->error_code),\par
00276             ({\cf18 void}*)TrapFrame->rip,\par
00277             ({\cf18 void}*)FaultBits\par
00278         );\par
00279     \}\par
00280 \par
00281     {\cf20 // Normal page fault.}\par
00282     MeBugCheckEx(\par
00283         PAGE_FAULT,\par
00284         ({\cf18 void}*)VirtualAddress,\par
00285         ({\cf18 void}*)MiRetrieveOperationFromErrorCode(TrapFrame->error_code),\par
00286         ({\cf18 void}*)TrapFrame->rip,\par
00287         ({\cf18 void}*)FaultBits\par
00288     );\par
00289 \}\par
00290 \par
00291 {\cf18 bool}\par
00292 MmInvalidAccessAllowed(\par
00293     {\cf18 void}\par
00294 )\par
00295 \par
00296 {\cf20 /*++}\par
00297 {\cf20 }\par
00298 {\cf20     Routine description:}\par
00299 {\cf20         (UNUSED, ALWAYS FALSE)}\par
00300 {\cf20         This function determines if invalid access (e.g, a null pointer dereference), is allowed within the current context.}\par
00301 {\cf20 }\par
00302 {\cf20     Arguments:}\par
00303 {\cf20 }\par
00304 {\cf20         None.}\par
00305 {\cf20 }\par
00306 {\cf20     Return Values:}\par
00307 {\cf20 }\par
00308 {\cf20         True if invalid access is allowed, false otherwise.}\par
00309 {\cf20 }\par
00310 {\cf20     Notes:}\par
00311 {\cf20 }\par
00312 {\cf20         This routine is unused, but will be kept for future modifications if any.}\par
00313 {\cf20 }\par
00314 {\cf20 --*/}\par
00315 \par
00316 \par
00317 \{\par
00318     {\cf19 return} {\cf17 false};\par
00319 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/hypermap.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/hypermap.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/hypermap.c}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HYPERMAP_VIRTUAL_ADDRESS}\~ {\b PhysicalMemoryOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOCK_HYPERSPACE}(PtrOldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNLOCK_HYPERSPACE}(OldIrql)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MiMapPageInHyperspace} ({\b IN} uint64_t PfnIndex, {\b OUT} {\b PIRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiUnmapHyperSpaceMap} ({\b IN} {\b IRQL} OldIrql)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b HyperLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PPFN_ENTRY} {\b g_pfnInUse}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v HYPERMAP_VIRTUAL_ADDRESS\:hypermap.c}
{\xe \v hypermap.c\:HYPERMAP_VIRTUAL_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HYPERMAP_VIRTUAL_ADDRESS\~ {\b PhysicalMemoryOffset}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b hypermap.c}.}\par
}
{\xe \v LOCK_HYPERSPACE\:hypermap.c}
{\xe \v hypermap.c\:LOCK_HYPERSPACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOCK_HYPERSPACE( PtrOldIrql)}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid MsAcquireSpinlock(&HyperLock, PtrOldIrql)\par
}
{
Definition at line {\b 29} of file {\b hypermap.c}.}\par
}
{\xe \v UNLOCK_HYPERSPACE\:hypermap.c}
{\xe \v hypermap.c\:UNLOCK_HYPERSPACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNLOCK_HYPERSPACE( OldIrql)}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid MsReleaseSpinlock(&HyperLock, OldIrql)\par
}
{
Definition at line {\b 30} of file {\b hypermap.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiMapPageInHyperspace\:hypermap.c}
{\xe \v hypermap.c\:MiMapPageInHyperspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MiMapPageInHyperspace ({\b IN} uint64_t PfnIndex, {\b OUT} {\b PIRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b hypermap.c}.}\par
}
{\xe \v MiUnmapHyperSpaceMap\:hypermap.c}
{\xe \v hypermap.c\:MiUnmapHyperSpaceMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiUnmapHyperSpaceMap ({\b IN} {\b IRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b hypermap.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v g_pfnInUse\:hypermap.c}
{\xe \v hypermap.c\:g_pfnInUse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PPFN_ENTRY} g_pfnInUse}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b hypermap.c}.}\par
}
{\xe \v HyperLock\:hypermap.c}
{\xe \v hypermap.c\:HyperLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} HyperLock}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b hypermap.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
hypermap.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/hypermap.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/hypermap.c}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     hypermap.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of the temporary mapping functions. (hyperspace)/s}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/mh.h"}\par
00021 {\cf21 #include "../../assert.h"}\par
00022 \par
00023 {\cf20 // The physical memory offset itself is the hypermap virtual address. This is ruled by not touching the 0x0 - 0x1000 physical addresses AT ALL (you may touch the physical addresses, but not map them with the PhysicalMemoryOffset virtual arithemtic.)}\par
00024 {\cf21 #define HYPERMAP_VIRTUAL_ADDRESS PhysicalMemoryOffset}\par
00025 \par
00026 SPINLOCK HyperLock;\par
00027 PPFN_ENTRY g_pfnInUse;\par
00028 \par
00029 {\cf21 #define LOCK_HYPERSPACE(PtrOldIrql) MsAcquireSpinlock(&HyperLock, PtrOldIrql)}\par
00030 {\cf21 #define UNLOCK_HYPERSPACE(OldIrql) MsReleaseSpinlock(&HyperLock, OldIrql)}\par
00031 \par
00032 {\cf18 void}*\par
00033 MiMapPageInHyperspace(\par
00034     IN  uint64_t PfnIndex,\par
00035     OUT  PIRQL OldIrql\par
00036 )\par
00037 \par
00038 {\cf20 /*++}\par
00039 {\cf20 }\par
00040 {\cf20     Routine description:}\par
00041 {\cf20 }\par
00042 {\cf20         Temporary maps the specified PFN Page into hyperspace and returns the virtual address mapped into.}\par
00043 {\cf20 }\par
00044 {\cf20             ************************************}\par
00045 {\cf20             *                                  *}\par
00046 {\cf20             * Returns with a spin lock held!!! * // thanks lou}\par
00047 {\cf20             *                                  *}\par
00048 {\cf20             ************************************}\par
00049 {\cf20 }\par
00050 {\cf20 }\par
00051 {\cf20     Arguments:}\par
00052 {\cf20 }\par
00053 {\cf20         [IN]    PfnIndex - Page frame index to map.}\par
00054 {\cf20         [OUT]    OldIrql - Pointer to store entry IRQL.}\par
00055 {\cf20 }\par
00056 {\cf20     Return Values:}\par
00057 {\cf20 }\par
00058 {\cf20         Valid Pointer to mapped region.}\par
00059 {\cf20 }\par
00060 {\cf20 --*/}\par
00061 \par
00062 \{\par
00063     {\cf20 // First, lock the hyperspace.}\par
00064     LOCK_HYPERSPACE (OldIrql);\par
00065 \par
00066     {\cf20 // Map the PFN into the page.}\par
00067     PPFN_ENTRY pfn = INDEX_TO_PPFN (PfnIndex);\par
00068     uint64_t physAddr = PPFN_TO_PHYSICAL_ADDRESS (pfn);\par
00069     PMMPTE pte = MiGetPtePointer(HYPERMAP_VIRTUAL_ADDRESS);\par
00070     MI_WRITE_PTE(pte, HYPERMAP_VIRTUAL_ADDRESS, physAddr, PAGE_PRESENT | PAGE_RW);\par
00071 \par
00072     {\cf20 // Set PFN metadata.}\par
00073     pfn->State = PfnStateActive;\par
00074     pfn->Descriptor.Mapping.PteAddress = pte;\par
00075     pfn->Descriptor.Mapping.Vad = NULL;\par
00076     g_pfnInUse = pfn;\par
00077 \par
00078     {\cf20 // Return the virtual address (now mapped)}\par
00079     {\cf19 return} ({\cf18 void}*)HYPERMAP_VIRTUAL_ADDRESS;\par
00080 \}\par
00081 \par
00082 {\cf18 void}\par
00083 MiUnmapHyperSpaceMap(\par
00084     IN  IRQL OldIrql\par
00085 )\par
00086 \par
00087 {\cf20 /*++}\par
00088 {\cf20 }\par
00089 {\cf20     Routine description:}\par
00090 {\cf20 }\par
00091 {\cf20         Unlocks the hyperspace, clears previous mapping.}\par
00092 {\cf20 }\par
00093 {\cf20     Arguments:}\par
00094 {\cf20 }\par
00095 {\cf20         [IN]    OldIrql - Entry IRQL given by MiMapPageInHyperspace}\par
00096 {\cf20 }\par
00097 {\cf20     Return Values:}\par
00098 {\cf20 }\par
00099 {\cf20         None.}\par
00100 {\cf20 }\par
00101 {\cf20     Notes:}\par
00102 {\cf20 }\par
00103 {\cf20         Does not release the PFN that was given, caller must do so.}\par
00104 {\cf20 }\par
00105 {\cf20 --*/}\par
00106 \par
00107 \{\par
00108     {\cf20 // Assertion that the hyperspace lock must be locked already (double unlock catch)}\par
00109     assert((HyperLock.locked) == 1, {\cf22 "Double hypermap unlock"});\par
00110     assert((g_pfnInUse) != 0, {\cf22 "No PFN when releasing hyperspace."});\par
00111     PPFN_ENTRY pfn = g_pfnInUse;\par
00112     {\cf20 // Clear the PTE present bit (to prevent use after free)}\par
00113     MiUnmapPte(MiGetPtePointer((uintptr_t)HYPERMAP_VIRTUAL_ADDRESS));\par
00114     \par
00115     {\cf20 // After MiUnmapPte changed the pfn metadata, we change it once again to invalidate it.}\par
00116     pfn->Descriptor.Mapping.PteAddress = NULL;\par
00117     pfn->Descriptor.Mapping.Vad = NULL;\par
00118     pfn->State = PfnStateTransition;\par
00119     g_pfnInUse = NULL;\par
00120 \par
00121     {\cf20 // We do not release the PFN, caller must do so, because it might have other uses with it.}\par
00122 \par
00123     {\cf20 // Unlock the hyperspace.}\par
00124     UNLOCK_HYPERSPACE (OldIrql);\par
00125 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/map.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/map.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/map.c}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/mh.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t * {\b pml4_from_recursive} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPtePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPml4ePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPdptePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPdePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInvalidateTlbForVa} ({\b IN} void *VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGE_INDEX} {\b MiTranslatePteToPfn} ({\b IN} {\b PMMPTE} pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b MiTranslatePteToVa} ({\b IN} {\b PMMPTE} pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiUnmapPte} ({\b IN} {\b PMMPTE} pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiReloadTLBs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MiTranslateVirtualToPhysical} ({\b IN} void *VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmIsAddressPresent} ({\b IN} uintptr_t VirtualAddress)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiGetPdePointer\:map.c}
{\xe \v map.c\:MiGetPdePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPdePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b map.c}.}\par
}
{\xe \v MiGetPdptePointer\:map.c}
{\xe \v map.c\:MiGetPdptePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPdptePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b map.c}.}\par
}
{\xe \v MiGetPml4ePointer\:map.c}
{\xe \v map.c\:MiGetPml4ePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPml4ePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b map.c}.}\par
}
{\xe \v MiGetPtePointer\:map.c}
{\xe \v map.c\:MiGetPtePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPtePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b map.c}.}\par
}
{\xe \v MiInvalidateTlbForVa\:map.c}
{\xe \v map.c\:MiInvalidateTlbForVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInvalidateTlbForVa ({\b IN} void * VirtualAddress)}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b map.c}.}\par
}
{\xe \v MiReloadTLBs\:map.c}
{\xe \v map.c\:MiReloadTLBs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiReloadTLBs (void )}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 443} of file {\b map.c}.}\par
}
{\xe \v MiTranslatePteToPfn\:map.c}
{\xe \v map.c\:MiTranslatePteToPfn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGE_INDEX} MiTranslatePteToPfn ({\b IN} {\b PMMPTE} pte)}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 310} of file {\b map.c}.}\par
}
{\xe \v MiTranslatePteToVa\:map.c}
{\xe \v map.c\:MiTranslatePteToVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t MiTranslatePteToVa ({\b IN} {\b PMMPTE} pte)}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 337} of file {\b map.c}.}\par
}
{\xe \v MiTranslateVirtualToPhysical\:map.c}
{\xe \v map.c\:MiTranslateVirtualToPhysical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MiTranslateVirtualToPhysical ({\b IN} void * VirtualAddress)}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 456} of file {\b map.c}.}\par
}
{\xe \v MiUnmapPte\:map.c}
{\xe \v map.c\:MiUnmapPte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiUnmapPte ({\b IN} {\b PMMPTE} pte)}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b map.c}.}\par
}
{\xe \v MmIsAddressPresent\:map.c}
{\xe \v map.c\:MmIsAddressPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmIsAddressPresent ({\b IN} uintptr_t VirtualAddress)}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b map.c}.}\par
}
{\xe \v pml4_from_recursive\:map.c}
{\xe \v map.c\:pml4_from_recursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t * pml4_from_recursive (void )}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b map.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
map.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/map.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/map.c}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     map.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of the internal mapping functions for kernel use.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/mh.h"}\par
00021 {\cf21 #include "../../assert.h"}\par
00022 \par
00023 {\cf17 static} {\cf17 inline} uint64_t canonical_high(uint64_t addr) \{\par
00024     {\cf20 // If bit 47 is set, set all higher bits}\par
00025     {\cf19 if} (addr & (1ULL << 47)) \{\par
00026         {\cf19 return} addr | 0xFFFF000000000000ULL;\par
00027     \}\par
00028     {\cf19 return} addr;\par
00029 \}\par
00030 \par
00031 uint64_t* pml4_from_recursive({\cf18 void}) \{\par
00032     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00033         ((uint64_t)RECURSIVE_INDEX << 30) |\par
00034         ((uint64_t)RECURSIVE_INDEX << 21) |\par
00035         ((uint64_t)RECURSIVE_INDEX << 12);\par
00036     va = canonical_high(va);\par
00037     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00038 \}\par
00039 \par
00040 {\cf17 static} {\cf17 inline} uint64_t* pdpt_from_recursive({\cf18 size_t} pml4_i) \{\par
00041     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00042         ((uint64_t)RECURSIVE_INDEX << 30) |\par
00043         ((uint64_t)RECURSIVE_INDEX << 21) |\par
00044         ((uint64_t)pml4_i << 12); {\cf20 // <-- CORRECTED}\par
00045     va = canonical_high(va);\par
00046     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00047 \}\par
00048 \par
00049 {\cf20 // To get PD page for pml4_i, pdpt_i}\par
00050 {\cf17 static} {\cf17 inline} uint64_t* pd_from_recursive({\cf18 size_t} pml4_i, {\cf18 size_t} pdpt_i) \{\par
00051     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00052         ((uint64_t)RECURSIVE_INDEX << 30) |\par
00053         ((uint64_t)pml4_i << 21) |        {\cf20 // <-- CORRECTED}\par
00054         ((uint64_t)pdpt_i << 12);       {\cf20 // <-- CORRECTED}\par
00055     va = canonical_high(va);\par
00056     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00057 \}\par
00058 \par
00059 {\cf20 // To get PT page for pml4_i, pdpt_i, pd_i}\par
00060 {\cf17 static} {\cf17 inline} uint64_t* pt_from_recursive({\cf18 size_t} pml4_i, {\cf18 size_t} pdpt_i, {\cf18 size_t} pd_i) \{\par
00061     uint64_t va = ((uint64_t)RECURSIVE_INDEX << 39) |\par
00062         ((uint64_t)pml4_i << 30) |\par
00063         ((uint64_t)pdpt_i << 21) |\par
00064         ((uint64_t)pd_i << 12);\par
00065     va = canonical_high(va);\par
00066     {\cf19 return} (uint64_t*)(uintptr_t)va;\par
00067 \}\par
00068 \par
00069 {\cf20 // Extract indices from virtual address}\par
00070 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pml4_index(uint64_t va) \{ {\cf19 return} (va >> 39) & 0x1FF; \} \par
00071 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pdpt_index(uint64_t va) \{ {\cf19 return} (va >> 30) & 0x1FF; \}\par
00072 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pd_index(uint64_t va) \{ {\cf19 return} (va >> 21) & 0x1FF; \}\par
00073 {\cf17 static} {\cf17 inline} {\cf18 size_t} get_pt_index(uint64_t va) \{ {\cf19 return} (va >> 12) & 0x1FF; \}\par
00074 \par
00075 PMMPTE\par
00076 MiGetPtePointer(\par
00077     IN  uintptr_t va\par
00078 )\par
00079 \par
00080 {\cf20 /*++}\par
00081 {\cf20 }\par
00082 {\cf20     Routine description : Retrieves the pointer to the PTE from the virtual address given}\par
00083 {\cf20 }\par
00084 {\cf20     Arguments:}\par
00085 {\cf20 }\par
00086 {\cf20         [IN]    Virtual Address.}\par
00087 {\cf20 }\par
00088 {\cf20     Return Values:}\par
00089 {\cf20 }\par
00090 {\cf20         Pointer to PTE associated with the Virtual Address. (NULL if out of memory)}\par
00091 {\cf20 }\par
00092 {\cf20 --*/}\par
00093 \par
00094 \{\par
00095     {\cf20 // 1. Calculate Indices}\par
00096     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00097     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00098     {\cf18 size_t} pd_i = get_pd_index(va);\par
00099     {\cf18 size_t} pt_i = get_pt_index(va);\par
00100 \par
00101     uint64_t intermediateFlags = PAGE_PRESENT | PAGE_RW;\par
00102 \par
00103     {\cf20 // If we are touching user address space, we add user accessibility.}\par
00104     {\cf19 if} (va <= MmHighestUserAddress) \{\par
00105         intermediateFlags |= PAGE_USER;\par
00106     \}\par
00107 \par
00108     uint64_t* pml4_va = pml4_from_recursive();\par
00109     {\cf19 if} (!(pml4_va[pml4_i] & PAGE_PRESENT)) \{\par
00110         {\cf20 // Allocate a new PDPT}\par
00111         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00112         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00113 \par
00114         {\cf20 // We are modifying the recursive mapping of the PML4 entry.}\par
00115         PMMPTE pml4e = (PMMPTE)&pml4_va[pml4_i];\par
00116         MI_WRITE_PTE(pml4e, pdpt_from_recursive(pml4_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00117     \}\par
00118 \par
00119     uint64_t* pdpt_va = pdpt_from_recursive(pml4_i);\par
00120     {\cf19 if} (!(pdpt_va[pdpt_i] & PAGE_PRESENT)) \{\par
00121         {\cf20 // Allocate a new Page Directory}\par
00122         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00123         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00124 \par
00125         {\cf20 // Link new PD into PDPT}\par
00126         PMMPTE pdpte = (PMMPTE)&pdpt_va[pdpt_i];\par
00127         MI_WRITE_PTE(pdpte, pd_from_recursive(pml4_i, pdpt_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00128     \}\par
00129 \par
00130     uint64_t* pd_va = pd_from_recursive(pml4_i, pdpt_i);\par
00131     {\cf19 if} (!(pd_va[pd_i] & PAGE_PRESENT)) \{\par
00132         {\cf20 // Allocate a new Page Table}\par
00133         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00134         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00135 \par
00136         {\cf20 // Link new PT into PD}\par
00137         PMMPTE pde = (PMMPTE)&pd_va[pd_i];\par
00138         MI_WRITE_PTE(pde, pt_from_recursive(pml4_i, pdpt_i, pd_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00139     \}\par
00140 \par
00141     {\cf20 // Return addr of PTE.}\par
00142     uint64_t* pt_va = pt_from_recursive(pml4_i, pdpt_i, pd_i);\par
00143     {\cf19 return} (PMMPTE)&pt_va[pt_i];\par
00144 \}\par
00145 \par
00146 PMMPTE\par
00147 MiGetPml4ePointer(\par
00148     IN  uintptr_t va\par
00149 )\par
00150 \par
00151 \{\par
00152     {\cf20 // 1. Calculate Indices}\par
00153     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00154 \par
00155     uint64_t intermediateFlags = PAGE_PRESENT | PAGE_RW;\par
00156 \par
00157     {\cf20 // If we are touching user address space, we add user accessibility.}\par
00158     {\cf19 if} (va <= MmHighestUserAddress) \{\par
00159         intermediateFlags |= PAGE_USER;\par
00160     \}\par
00161 \par
00162     uint64_t* pml4_va = pml4_from_recursive();\par
00163     {\cf19 if} (!(pml4_va[pml4_i] & PAGE_PRESENT)) \{\par
00164         {\cf20 // Allocate a new PDPT}\par
00165         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00166         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00167 \par
00168         {\cf20 // We are modifying the recursive mapping of the PML4 entry.}\par
00169         PMMPTE pml4e = (PMMPTE)&pml4_va[pml4_i];\par
00170         MI_WRITE_PTE(pml4e, pdpt_from_recursive(pml4_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00171     \}\par
00172     \par
00173     {\cf19 return} (PMMPTE) & pml4_va[pml4_i];\par
00174 \}\par
00175 \par
00176 PMMPTE\par
00177 MiGetPdptePointer(\par
00178     IN  uintptr_t va\par
00179 )\par
00180 \par
00181 \{\par
00182     {\cf20 // 1. Calculate Indices}\par
00183     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00184     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00185 \par
00186     uint64_t intermediateFlags = PAGE_PRESENT | PAGE_RW;\par
00187 \par
00188     {\cf20 // If we are touching user address space, we add user accessibility.}\par
00189     {\cf19 if} (va <= MmHighestUserAddress) \{\par
00190         intermediateFlags |= PAGE_USER;\par
00191     \}\par
00192 \par
00193     uint64_t* pml4_va = pml4_from_recursive();\par
00194     {\cf19 if} (!(pml4_va[pml4_i] & PAGE_PRESENT)) \{\par
00195         {\cf20 // Allocate a new PDPT}\par
00196         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00197         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00198 \par
00199         {\cf20 // We are modifying the recursive mapping of the PML4 entry.}\par
00200         PMMPTE pml4e = (PMMPTE)&pml4_va[pml4_i];\par
00201         MI_WRITE_PTE(pml4e, pdpt_from_recursive(pml4_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00202     \}\par
00203 \par
00204     uint64_t* pdpt_va = pdpt_from_recursive(pml4_i);\par
00205     {\cf19 if} (!(pdpt_va[pdpt_i] & PAGE_PRESENT)) \{\par
00206         {\cf20 // Allocate a new Page Directory}\par
00207         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00208         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00209 \par
00210         {\cf20 // Link new PD into PDPT}\par
00211         PMMPTE pdpte = (PMMPTE)&pdpt_va[pdpt_i];\par
00212         MI_WRITE_PTE(pdpte, pd_from_recursive(pml4_i, pdpt_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00213     \}\par
00214 \par
00215     {\cf19 return} (PMMPTE)&pdpt_va[pdpt_i];\par
00216 \}\par
00217 \par
00218 PMMPTE\par
00219 MiGetPdePointer(\par
00220     IN  uintptr_t va\par
00221 )\par
00222 \par
00223 \{\par
00224     {\cf20 // 1. Calculate Indices}\par
00225     {\cf18 size_t} pml4_i = get_pml4_index(va);\par
00226     {\cf18 size_t} pdpt_i = get_pdpt_index(va);\par
00227     {\cf18 size_t} pd_i = get_pd_index(va);\par
00228 \par
00229     uint64_t intermediateFlags = PAGE_PRESENT | PAGE_RW;\par
00230 \par
00231     {\cf20 // If we are touching user address space, we add user accessibility.}\par
00232     {\cf19 if} (va <= MmHighestUserAddress) \{\par
00233         intermediateFlags |= PAGE_USER;\par
00234     \}\par
00235 \par
00236     uint64_t* pml4_va = pml4_from_recursive();\par
00237     {\cf19 if} (!(pml4_va[pml4_i] & PAGE_PRESENT)) \{\par
00238         {\cf20 // Allocate a new PDPT}\par
00239         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00240         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00241 \par
00242         {\cf20 // We are modifying the recursive mapping of the PML4 entry.}\par
00243         PMMPTE pml4e = (PMMPTE)&pml4_va[pml4_i];\par
00244         MI_WRITE_PTE(pml4e, pdpt_from_recursive(pml4_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00245     \}\par
00246 \par
00247     uint64_t* pdpt_va = pdpt_from_recursive(pml4_i);\par
00248     {\cf19 if} (!(pdpt_va[pdpt_i] & PAGE_PRESENT)) \{\par
00249         {\cf20 // Allocate a new Page Directory}\par
00250         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00251         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00252 \par
00253         {\cf20 // Link new PD into PDPT}\par
00254         PMMPTE pdpte = (PMMPTE)&pdpt_va[pdpt_i];\par
00255         MI_WRITE_PTE(pdpte, pd_from_recursive(pml4_i, pdpt_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00256     \}\par
00257 \par
00258     uint64_t* pd_va = pd_from_recursive(pml4_i, pdpt_i);\par
00259     {\cf19 if} (!(pd_va[pd_i] & PAGE_PRESENT)) \{\par
00260         {\cf20 // Allocate a new Page Table}\par
00261         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00262         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} NULL;\par
00263 \par
00264         {\cf20 // Link new PT into PD}\par
00265         PMMPTE pde = (PMMPTE)&pd_va[pd_i];\par
00266         MI_WRITE_PTE(pde, pt_from_recursive(pml4_i, pdpt_i, pd_i), PFN_TO_PHYS(pfn), intermediateFlags);\par
00267     \}\par
00268 \par
00269     {\cf19 return} (PMMPTE)&pd_va[pd_i];\par
00270 \}\par
00271 \par
00272 {\cf18 void}\par
00273 MiInvalidateTlbForVa(\par
00274     IN {\cf18 void}* VirtualAddress\par
00275 )\par
00276 \par
00277 {\cf20 /*++}\par
00278 {\cf20 }\par
00279 {\cf20     Routine description:}\par
00280 {\cf20 }\par
00281 {\cf20         Invalidates CPUs TLB for the specified virtual address.}\par
00282 {\cf20 }\par
00283 {\cf20     Arguments:}\par
00284 {\cf20 }\par
00285 {\cf20         [IN]    void* VirtualAddress - Virtual address to flush for.}\par
00286 {\cf20 }\par
00287 {\cf20     Return Values:}\par
00288 {\cf20 }\par
00289 {\cf20         None.}\par
00290 {\cf20 }\par
00291 {\cf20     Notes:}\par
00292 {\cf20         }\par
00293 {\cf20         On the SMP Build, if APs are active, an IPI is sent to flush their TLB for the VA as well.}\par
00294 {\cf20 }\par
00295 {\cf20 --*/}\par
00296 \par
00297 \{\par
00298     invlpg(VirtualAddress);\par
00299     {\cf20 // If SMP is initialized, send IPI.}\par
00300 {\cf21 #ifndef MT_UP}\par
00301     {\cf19 if} (smpInitialized) \{\par
00302         IPI_PARAMS Param;\par
00303         Param.pageParams.addressToInvalidate = (uint64_t)VirtualAddress;\par
00304         MhSendActionToCpusAndWait(CPU_ACTION_PERFORM_TLB_SHOOTDOWN, Param);\par
00305     \}\par
00306 {\cf21 #endif}\par
00307 \}\par
00308 \par
00309 PAGE_INDEX\par
00310 MiTranslatePteToPfn (\par
00311     IN  PMMPTE pte\par
00312 )\par
00313 \par
00314 {\cf20 /*++}\par
00315 {\cf20 }\par
00316 {\cf20     Routine description:}\par
00317 {\cf20         }\par
00318 {\cf20         Translates the PTE given into the appropriate PFN behind its physical address.}\par
00319 {\cf20 }\par
00320 {\cf20     Arguments:}\par
00321 {\cf20 }\par
00322 {\cf20         [IN]    pte - Pointer to MMPTE PTE in memory.}\par
00323 {\cf20 }\par
00324 {\cf20     Return Values:}\par
00325 {\cf20 }\par
00326 {\cf20         Page Frame Index.}\par
00327 {\cf20 }\par
00328 {\cf20 --*/}\par
00329 \par
00330 \{\par
00331     {\cf19 if} (!pte) {\cf19 return} PFN_ERROR;\par
00332     uintptr_t phys = PTE_TO_PHYSICAL(pte);\par
00333     {\cf19 return} PPFN_TO_INDEX(PHYSICAL_TO_PPFN(phys));\par
00334 \}\par
00335 \par
00336 uint64_t\par
00337 MiTranslatePteToVa(\par
00338     IN PMMPTE pte\par
00339 )\par
00340 \par
00341 {\cf20 /*++}\par
00342 {\cf20 }\par
00343 {\cf20     Routine description:}\par
00344 {\cf20 }\par
00345 {\cf20         Translates the PTE given to its appropriate virtual address.}\par
00346 {\cf20 }\par
00347 {\cf20     Arguments:}\par
00348 {\cf20 }\par
00349 {\cf20         [IN]    pte - Pointer to MMPTE PTE in memory.}\par
00350 {\cf20 }\par
00351 {\cf20     Return Values:}\par
00352 {\cf20 }\par
00353 {\cf20         Virtual Address associated with the PTE.}\par
00354 {\cf20 }\par
00355 {\cf20     Notes:}\par
00356 {\cf20 }\par
00357 {\cf20         The only reason this works is because the method used to find the indices for the VA (pml4, pdpt, pd, pt, pte) }\par
00358 {\cf20         Is reversible, since it is bit shifting.}\par
00359 {\cf20 }\par
00360 {\cf20 --*/}\par
00361 \par
00362 \{\par
00363     uintptr_t p = (uintptr_t)pte;\par
00364 \par
00365     {\cf18 size_t} pml4_check = (p >> 39) & 0x1FF;\par
00366     {\cf19 if} (pml4_check != RECURSIVE_INDEX) \{\par
00367         {\cf20 /* not a recursive PTE pointer */}\par
00368         {\cf19 return} (uintptr_t)0;\par
00369     \}\par
00370 \par
00371     {\cf18 size_t} pml4_i = (p >> 30) & 0x1FF;\par
00372     {\cf18 size_t} pdpt_i = (p >> 21) & 0x1FF;\par
00373     {\cf18 size_t} pd_i = (p >> 12) & 0x1FF;\par
00374     {\cf18 size_t} pt_i = (p >> 3) & 0x1FF; {\cf20 /* pt entry index */}\par
00375 \par
00376     uint64_t va = ((uint64_t)pml4_i << 39) |\par
00377         ((uint64_t)pdpt_i << 30) |\par
00378         ((uint64_t)pd_i << 21) |\par
00379         ((uint64_t)pt_i << 12);\par
00380 \par
00381     {\cf19 return} canonical_high(va); {\cf20 /* page-aligned VA for invlpg */}\par
00382 \}\par
00383 \par
00384 {\cf18 void}\par
00385 MiUnmapPte (\par
00386     IN  PMMPTE pte\par
00387 )\par
00388 \par
00389 {\cf20 /*++}\par
00390 {\cf20 }\par
00391 {\cf20     Routine description:}\par
00392 {\cf20 }\par
00393 {\cf20         Unmaps the pte from the current address pace.}\par
00394 {\cf20 }\par
00395 {\cf20     Arguments:}\par
00396 {\cf20 }\par
00397 {\cf20         [IN]    pte - Pointer to MMPTE PTE in memory.}\par
00398 {\cf20 }\par
00399 {\cf20     Return Values:}\par
00400 {\cf20 }\par
00401 {\cf20         None.}\par
00402 {\cf20 }\par
00403 {\cf20     Notes:}\par
00404 {\cf20 }\par
00405 {\cf20         This function DOES NOT release the PFN associated with the PTE back to the database, you must do so yourself.}\par
00406 {\cf20 }\par
00407 {\cf20 --*/}\par
00408 \par
00409 \{\par
00410     {\cf19 if} (!pte) {\cf19 return};\par
00411     {\cf20 // First gets its PFN to write to the PMMPTE PresentNotSet union.}\par
00412     PAGE_INDEX pfn = MiTranslatePteToPfn(pte);\par
00413     {\cf19 if} (!pfn) {\cf19 return};\par
00414     {\cf20 // Get the PTE's original VA.}\par
00415     uint64_t origVa = MiTranslatePteToVa(pte);\par
00416 \par
00417     {\cf20 // Atomically exchange old info with new info to avoid races.}\par
00418     MMPTE newPte;\par
00419     \par
00420     {\cf20 // Zero out newPte}\par
00421     kmemset(&newPte, 0, {\cf17 sizeof}(MMPTE));\par
00422 \par
00423     {\cf20 // Write new values.}\par
00424     newPte.Soft.PageFrameNumber = pfn;\par
00425     \par
00426     {\cf20 // I removed the transition set here, even though it has a PFN assigned to it (to track last good PFN), we don't mark it as transition.}\par
00427     {\cf20 // Instead, when we put it in the standby list, there should be a unique function for it. TODO}\par
00428 \par
00429     {\cf20 // Exchange now.}\par
00430     InterlockedExchangeU64(({\cf17 volatile} uint64_t*)pte, newPte.Value);\par
00431 \par
00432     {\cf20 // Invalidate TLBs}\par
00433     {\cf19 if} (origVa) MiInvalidateTlbForVa(({\cf18 void}*)origVa);\par
00434     {\cf19 else} MiReloadTLBs();\par
00435 \par
00436     {\cf20 // Return.}\par
00437     {\cf19 return};\par
00438 \}\par
00439 \par
00440 \par
00441 {\cf20 // Reloads CR3 to flush all TLBs (slow flush)}\par
00442 {\cf18 void}\par
00443 MiReloadTLBs(\par
00444     {\cf18 void}\par
00445 )\par
00446 \par
00447 \{\par
00448     __write_cr3(__read_cr3());\par
00449 {\cf21 #ifndef MT_UP}\par
00450     IPI_PARAMS param;\par
00451     MhSendActionToCpusAndWait(CPU_ACTION_FLUSH_CR3, param);\par
00452 {\cf21 #endif}\par
00453 \}\par
00454 \par
00455 uintptr_t\par
00456 MiTranslateVirtualToPhysical(\par
00457     IN {\cf18 void}* VirtualAddress\par
00458 )\par
00459 \par
00460 {\cf20 /*++}\par
00461 {\cf20 }\par
00462 {\cf20     Routine description:}\par
00463 {\cf20 }\par
00464 {\cf20         Translates the given virtual address to its equivalent (**IF MAPPED TO**) physical address.}\par
00465 {\cf20 }\par
00466 {\cf20     Arguments:}\par
00467 {\cf20 }\par
00468 {\cf20         [IN]    void* VirtualAddress - The mapped virtual address.}\par
00469 {\cf20 }\par
00470 {\cf20     Return Values:}\par
00471 {\cf20 }\par
00472 {\cf20         The physical address mapped to the virtual address, or 0 if invalid.}\par
00473 {\cf20 }\par
00474 {\cf20         The physical address is returned with its equivalent offset (so not page aligned, maybe, modulus the VA given to check.). (e.g VA = 0xff8880 Phys = 0x4880)}\par
00475 {\cf20 }\par
00476 {\cf20 --*/}\par
00477 \par
00478 \{\par
00479     PMMPTE pte = MiGetPtePointer((uintptr_t)VirtualAddress);\par
00480     {\cf19 if} (!pte) {\cf19 return} 0;\par
00481 \par
00482     {\cf19 if} (!pte->Hard.Present) {\cf19 return} 0;\par
00483 \par
00484     {\cf19 return} (uintptr_t)PTE_TO_PHYSICAL(pte) + VA_OFFSET(VirtualAddress);\par
00485 \}\par
00486 \par
00487 {\cf18 bool}\par
00488 MmIsAddressPresent(\par
00489     IN  uintptr_t VirtualAddress\par
00490 )\par
00491 \par
00492 {\cf20 /*++}\par
00493 {\cf20 }\par
00494 {\cf20     Routine description:}\par
00495 {\cf20 }\par
00496 {\cf20         Checks if the given address is currently present in memory (won't cause a page fault on access)}\par
00497 {\cf20 }\par
00498 {\cf20     Arguments:}\par
00499 {\cf20 }\par
00500 {\cf20         [IN]    uintptr_t VirtualAddress - The virtual address.}\par
00501 {\cf20 }\par
00502 {\cf20     Return Values:}\par
00503 {\cf20 }\par
00504 {\cf20         True if the address is valid and in memory, false otherwise.}\par
00505 {\cf20 }\par
00506 {\cf20 --*/}\par
00507 \par
00508 \{\par
00509     PMMPTE pte = MiGetPtePointer(VirtualAddress);\par
00510     {\cf19 return} pte->Hard.Present;\par
00511 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mminit.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mminit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mminit.c}
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IA32_PAT}\~ 0x277\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmInitSystem} ({\b IN} uint8_t Phase, {\b IN} {\b PBOOT_INFO} BootInformation)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiMoveUefiDataToHigherHalf} ({\b IN} {\b PBOOT_INFO} BootInfo)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IA32_PAT\:mminit.c}
{\xe \v mminit.c\:IA32_PAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IA32_PAT\~ 0x277}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b mminit.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiMoveUefiDataToHigherHalf\:mminit.c}
{\xe \v mminit.c\:MiMoveUefiDataToHigherHalf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiMoveUefiDataToHigherHalf ({\b IN} {\b PBOOT_INFO} BootInfo)}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b mminit.c}.}\par
}
{\xe \v MmInitSystem\:mminit.c}
{\xe \v mminit.c\:MmInitSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmInitSystem ({\b IN} uint8_t Phase, {\b IN} {\b PBOOT_INFO} BootInformation)}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b mminit.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v boot_info_local\:mminit.c}
{\xe \v mminit.c\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b kernel.c}.}\par
}
{\xe \v gop_local\:mminit.c}
{\xe \v mminit.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mminit.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mminit.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mminit.c}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     mminit.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of memory manager initialization routines.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/me.h"}\par
00021 {\cf21 #include "../../includes/mg.h"}\par
00022 {\cf21 #include "../../assert.h"}\par
00023 \par
00024 {\cf21 #define IA32_PAT 0x277}\par
00025 \par
00026 {\cf17 static}\par
00027 {\cf18 bool}\par
00028 MiIsPATAvailable({\cf18 void})\par
00029 \par
00030 \{\par
00031     uint32_t eax, ebx, ecx, edx;\par
00032     __cpuid(1, eax, ebx, ecx, edx);\par
00033     {\cf19 return} (edx & (1 << 16)) != 0;\par
00034 \}\par
00035 \par
00036 {\cf17 static}\par
00037 {\cf18 void} \par
00038 MiInitializePAT({\cf18 void}) \par
00039 \par
00040 \{\par
00041     uint64_t pat =\par
00042         0x00 |                   {\cf20 // 0 = WB}\par
00043         (0x01ULL << 8) |         {\cf20 // 1 = WT}\par
00044         (0x02ULL << 16) |        {\cf20 // 2 = UC-}\par
00045         (0x03ULL << 24) |        {\cf20 // 3 = UC}\par
00046         (0x00ULL << 32) |        {\cf20 // 4 = WB}\par
00047         (0x01ULL << 40) |        {\cf20 // 5 = WC}\par
00048         (0x02ULL << 48) |        {\cf20 // 6 = UC-}\par
00049         (0x03ULL << 56);         {\cf20 // 7 = UC}\par
00050 \par
00051     __writemsr(IA32_PAT, pat);\par
00052 \}\par
00053 \par
00054 {\cf18 bool}\par
00055 MmInitSystem(\par
00056     IN uint8_t Phase,\par
00057     IN PBOOT_INFO BootInformation\par
00058 )\par
00059 \par
00060 {\cf20 /*++}\par
00061 {\cf20 }\par
00062 {\cf20     Routine description:}\par
00063 {\cf20 }\par
00064 {\cf20         Initializes the memory manager of the system.}\par
00065 {\cf20 }\par
00066 {\cf20     Arguments:}\par
00067 {\cf20 }\par
00068 {\cf20         [IN]    uint8_t Phase - Specifies the phase of the system for correct init routines. (enum SYSTEM_PHASE_ROUTINE)}\par
00069 {\cf20         [IN]    PBOOT_INFO BootInformation - The boot information supplied by the UEFI Bootloader (can be NULL in later phases, look below)}\par
00070 {\cf20 }\par
00071 {\cf20     Phase Demands:}\par
00072 {\cf20 }\par
00073 {\cf20         1 - BootInformation}\par
00074 {\cf20         2 - None.}\par
00075 {\cf20 }\par
00076 {\cf20     Phase Does:}\par
00077 {\cf20            }\par
00078 {\cf20         1 (SYSTEM_PHASE_INITIALIZE_ALL) - Initializes PAT and the core memory managment routines. (PFN Database, Virtual Address bitmap, PAT, PTE Database, etc.)}\par
00079 {\cf20 }\par
00080 {\cf20         2 (SYSTEM_PHASE_INITIALIZE_PAT_ONLY) - Initializes PAT only (used in AP startup)}\par
00081 {\cf20 }\par
00082 {\cf20     Return Values:}\par
00083 {\cf20 }\par
00084 {\cf20         True or false if the phase given has succeeded initilization.}\par
00085 {\cf20 }\par
00086 {\cf20 --*/}\par
00087 \par
00088 \{\par
00089     {\cf20 // Currently we only support the first and only phase.}\par
00090     {\cf19 if} (Phase == SYSTEM_PHASE_INITIALIZE_ALL) \{\par
00091 \par
00092         {\cf20 // Initialize PAT (Page Attribute Table)}\par
00093         {\cf18 bool} PatAvailable = MiIsPATAvailable();\par
00094         assert(PatAvailable == {\cf17 true});\par
00095         {\cf19 if} (PatAvailable) \{\par
00096             MiInitializePAT();\par
00097         \}\par
00098 \par
00099         {\cf20 // Initialize all memory managment routines (PFN Database, VA Space, Pools, MMIO, PTE Database)}\par
00100         {\cf20 // If we fail init of one of them, we bugcheck, since they are mandatory for operation.}\par
00101         MTSTATUS st = MiInitializePfnDatabase(BootInformation);\par
00102         {\cf19 if} (MT_FAILURE(st)) \{\par
00103             MeBugCheckEx(\par
00104                 PFN_DATABASE_INIT_FAILURE,\par
00105                 ({\cf18 void}*)(uintptr_t)st,\par
00106                 NULL,\par
00107                 NULL,\par
00108                 NULL\par
00109             );\par
00110         \}\par
00111 \par
00112         {\cf19 if} (!MiInitializePoolVaSpace()) \{\par
00113             MeBugCheck(VA_SPACE_INIT_FAILURE);\par
00114         \}\par
00115 \par
00116         st = MiInitializePoolSystem();\par
00117         {\cf19 if} (MT_FAILURE(st)) \{\par
00118             MeBugCheckEx(\par
00119                 POOL_INIT_FAILURE,\par
00120                 ({\cf18 void}*)(uintptr_t)st,\par
00121                 NULL,\par
00122                 NULL,\par
00123                 NULL\par
00124             );\par
00125         \}\par
00126 \par
00127         {\cf20 // Phase 1 Done.}\par
00128         {\cf19 return} {\cf17 true};\par
00129     \}\par
00130 \par
00131     {\cf19 else} {\cf19 if} (Phase == SYSTEM_PHASE_INITIALIZE_PAT_ONLY) \{\par
00132         {\cf20 // Phase only initializes PAT for the current core.}\par
00133         {\cf20 // Initialize PAT (Page Attribute Table)}\par
00134         {\cf18 bool} PatAvailable = MiIsPATAvailable();\par
00135         assert(PatAvailable == {\cf17 true});\par
00136         {\cf19 if} (PatAvailable) \{\par
00137             MiInitializePAT();\par
00138         \}\par
00139 \par
00140         {\cf20 // Return if PAT is available on the current core or not (if available, it's initialized)}\par
00141         {\cf19 return} PatAvailable;\par
00142     \}\par
00143 \par
00144     {\cf19 else} \{\par
00145         {\cf20 // Only phase 1 & 2 are supported currently.}\par
00146         MeBugCheck(INVALID_INITIALIZATION_PHASE);\par
00147     \}\par
00148 \}\par
00149 \par
00150 {\cf17 extern} GOP_PARAMS gop_local;\par
00151 {\cf17 extern} BOOT_INFO boot_info_local;\par
00152 \par
00153 {\cf18 void}\par
00154 MiMoveUefiDataToHigherHalf(\par
00155     IN PBOOT_INFO BootInfo\par
00156 )\par
00157 \par
00158 \par
00159 {\cf20 /*++}\par
00160 {\cf20 }\par
00161 {\cf20     Routine description:}\par
00162 {\cf20 }\par
00163 {\cf20         Moves UEFI Memory that is mapped below the kernel half to the kernel half.}\par
00164 {\cf20 }\par
00165 {\cf20     Arguments:}\par
00166 {\cf20 }\par
00167 {\cf20         [IN]    PBOOT_INFO BootInformation - The boot information supplied by the UEFI Bootloader.}\par
00168 {\cf20 }\par
00169 {\cf20 }\par
00170 {\cf20     Return Values:}\par
00171 {\cf20 }\par
00172 {\cf20         None.}\par
00173 {\cf20 }\par
00174 {\cf20     Notes:}\par
00175 {\cf20 }\par
00176 {\cf20         Currently the only UEFI memory that is below the higher half is the GOP. (and RSDP, but that is processed during kernel startup, so its fine)}\par
00177 {\cf20 }\par
00178 {\cf20 --*/}\par
00179 \par
00180 \{\par
00181     {\cf20 // Move GOP to higher half, luckily i developed this extremely advanced memory api (its just advancing pointers)}\par
00182     uintptr_t Virt = MiTranslateVirtualToPhysical(({\cf18 void}*)gop_local.FrameBufferBase);\par
00183 \par
00184 {\cf21 #ifdef DEBUG}\par
00185     uint64_t oldBase = gop_local.FrameBufferBase;\par
00186 {\cf21 #endif}\par
00187 \par
00188     gop_local.FrameBufferBase = (uint64_t)MmMapIoSpace(Virt, gop_local.FrameBufferSize, MmCached);\par
00189     assert(gop_local.FrameBufferBase != Virt);\par
00190     assert(({\cf18 void}*)gop_local.FrameBufferBase != NULL);\par
00191 \par
00192     {\cf20 // Unmap the previous PTE.}\par
00193     MiUnmapPte(MiGetPtePointer(Virt));\par
00194 \par
00195 {\cf21 #ifdef DEBUG}\par
00196     assert(MmIsAddressValid((uintptr_t)oldBase) == {\cf17 false});\par
00197 {\cf21 #endif}\par
00198     uintptr_t BootInfoPhys = MiTranslateVirtualToPhysical(({\cf18 void}*)BootInfo);\par
00199 \par
00200     {\cf20 // Destroy the boot_info struct PTE.}\par
00201     {\cf20 // First, memory set it to 0 (just for good measure)}\par
00202     kmemset(BootInfo, 0, {\cf17 sizeof}(BOOT_INFO));\par
00203 \par
00204     {\cf20 // Great, unmap it now.}\par
00205     assert({\cf17 sizeof}(BOOT_INFO) <= VirtualPageSize); {\cf20 // If the size is larger, we would need to do a for loop.}\par
00206     MiUnmapPte(MiGetPtePointer((uintptr_t)BootInfo));\par
00207     assert(MmIsAddressValid((uintptr_t)BootInfo) == {\cf17 false});\par
00208 \par
00209     {\cf20 // Free its physical frame.}\par
00210     MiReleasePhysicalPage(PPFN_TO_INDEX(PHYSICAL_TO_PPFN(BootInfoPhys)));\par
00211 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmio.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmio.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmio.c}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MiCheckForContigiousMemory} ({\b IN} void *StartAddress, {\b IN} size_t NumberOfBytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MmAllocateContigiousMemory} ({\b IN} size_t NumberOfBytes, {\b IN} uint64_t HighestAcceptableAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MmFreeContigiousMemory} ({\b IN} void *BaseAddress, {\b IN} size_t NumberOfBytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MmMapIoSpace} ({\b IN} uintptr_t PhysicalAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b MEMORY_CACHING_TYPE} CacheType)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiCheckForContigiousMemory\:mmio.c}
{\xe \v mmio.c\:MiCheckForContigiousMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MiCheckForContigiousMemory ({\b IN} void * StartAddress, {\b IN} size_t NumberOfBytes)}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mmio.c}.}\par
}
{\xe \v MmAllocateContigiousMemory\:mmio.c}
{\xe \v mmio.c\:MmAllocateContigiousMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MmAllocateContigiousMemory ({\b IN} size_t NumberOfBytes, {\b IN} uint64_t HighestAcceptableAddress)}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b mmio.c}.}\par
}
{\xe \v MmFreeContigiousMemory\:mmio.c}
{\xe \v mmio.c\:MmFreeContigiousMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MmFreeContigiousMemory ({\b IN} void * BaseAddress, {\b IN} size_t NumberOfBytes)}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b mmio.c}.}\par
}
{\xe \v MmMapIoSpace\:mmio.c}
{\xe \v mmio.c\:MmMapIoSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MmMapIoSpace ({\b IN} uintptr_t PhysicalAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b MEMORY_CACHING_TYPE} CacheType)}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b mmio.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mmio.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmio.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmio.c}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     mmio.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of MMIO functions responsible for easy interaction with physical hardware.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/me.h"}\par
00021 {\cf21 #include "../../assert.h"}\par
00022 \par
00023 \par
00024 {\cf18 bool}\par
00025 MiCheckForContigiousMemory(\par
00026     IN {\cf18 void}* StartAddress,\par
00027     IN {\cf18 size_t} NumberOfBytes\par
00028 )\par
00029 \par
00030 {\cf20 /*++}\par
00031 {\cf20 }\par
00032 {\cf20     Routine description:}\par
00033 {\cf20 }\par
00034 {\cf20         Checks if the given address + amount of bytes is contigious in physical memory.}\par
00035 {\cf20 }\par
00036 {\cf20     Arguments:}\par
00037 {\cf20 }\par
00038 {\cf20         [IN]    void* StartAddress - The base address to check for.}\par
00039 {\cf20         [IN]    size_t NumberOfBytes - The amount of contigious bytes to check.}\par
00040 {\cf20 }\par
00041 {\cf20     Return Values:}\par
00042 {\cf20 }\par
00043 {\cf20         True if contigious, false otherwise.}\par
00044 {\cf20 }\par
00045 {\cf20 --*/}\par
00046 \par
00047 \{\par
00048     {\cf20 // Assertions & Declarations}\par
00049     assert(NumberOfBytes > 0);\par
00050     assert(StartAddress != 0);\par
00051     {\cf19 if} (!NumberOfBytes || !StartAddress) {\cf19 return} {\cf17 false};\par
00052 \par
00053     {\cf18 size_t} AmtPages = BYTES_TO_PAGES(NumberOfBytes);\par
00054     uintptr_t CurrentAddress = (uintptr_t)StartAddress;\par
00055 \par
00056     {\cf20 // Get the First PFN.}\par
00057     PMMPTE CurrentPte = MiGetPtePointer(CurrentAddress);\par
00058 \par
00059     {\cf20 // Check if PTE exists and is valid before translating}\par
00060     {\cf19 if} (!CurrentPte || !CurrentPte->Hard.Present) {\cf19 return} {\cf17 false};\par
00061 \par
00062     PAGE_INDEX StartPfn = MiTranslatePteToPfn(CurrentPte);\par
00063     {\cf19 if} (StartPfn == PFN_ERROR) {\cf19 return} {\cf17 false};\par
00064 \par
00065     {\cf20 // 3. Loop from i = 1 (we already checked the first page)}\par
00066     {\cf19 for} ({\cf18 size_t} i = 1; i < AmtPages; i++) \{\par
00067 \par
00068         {\cf20 // Advance VA.}\par
00069         CurrentAddress += VirtualPageSize;\par
00070         CurrentPte = MiGetPtePointer(CurrentAddress);\par
00071 \par
00072         {\cf20 // Check if page is even present.}\par
00073         {\cf19 if} (!CurrentPte || !CurrentPte->Hard.Present) {\cf19 return} {\cf17 false};\par
00074 \par
00075         PAGE_INDEX CurrentPfn = MiTranslatePteToPfn(CurrentPte);\par
00076 \par
00077         {\cf20 // If the current Pfn isn't adjacent to the previous one, its not contigious.}\par
00078         {\cf19 if} (CurrentPfn != (StartPfn + i)) \{\par
00079             {\cf19 return} {\cf17 false};\par
00080         \}\par
00081     \}\par
00082 \par
00083     {\cf19 return} {\cf17 true};\par
00084 \}\par
00085 \par
00086 {\cf18 void}*\par
00087 MmAllocateContigiousMemory(\par
00088     IN  {\cf18 size_t} NumberOfBytes,\par
00089     IN  uint64_t HighestAcceptableAddress\par
00090 )\par
00091 \par
00092 {\cf20 /*++}\par
00093 {\cf20 }\par
00094 {\cf20     Routine description:}\par
00095 {\cf20 }\par
00096 {\cf20         Allocate contingious physical memory pages and maps them. (used for DMA)}\par
00097 {\cf20 }\par
00098 {\cf20     Arguments:}\par
00099 {\cf20 }\par
00100 {\cf20         [IN]    size_t NumberOfBytes - The amount of contigious bytes to allocate.}\par
00101 {\cf20         [IN]    uint64_t HighestAcceptableAddress - The highest physical address to find contigious bytes for. (used for drivers that cannot see the full 64bit system memory amount)}\par
00102 {\cf20 }\par
00103 {\cf20     Return Values:}\par
00104 {\cf20 }\par
00105 {\cf20         Base virtual address to allocated memory, or NULL on failure.}\par
00106 {\cf20 }\par
00107 {\cf20     Notes:}\par
00108 {\cf20 }\par
00109 {\cf20         This will probably cause fragmentation, and is very expensive as it iterates O(n) over the PFN Database, use sparingly.}\par
00110 {\cf20 }\par
00111 {\cf20 --*/}\par
00112 \par
00113 \{\par
00114     {\cf20 // According to MSDN this must be satisfied (this isnt NT compatible, but it follows its rules)}\par
00115     {\cf19 if} (MeGetCurrentIrql() > DISPATCH_LEVEL) {\cf19 return} NULL;\par
00116 \par
00117     {\cf20 // Declarations}\par
00118     {\cf18 size_t} pageCount = BYTES_TO_PAGES(NumberOfBytes);\par
00119     PAGE_INDEX MaxPfn = PPFN_TO_INDEX(PHYSICAL_TO_PPFN(HighestAcceptableAddress));\par
00120     {\cf18 size_t} ConsecutiveFound = 0;\par
00121     IRQL DbIrql;\par
00122     PAGE_INDEX StartIndex = 0;\par
00123     {\cf18 void}* BaseAddress = NULL; {\cf20 // Null initially, unless enough pages.}\par
00124 \par
00125     {\cf20 /* FIXME NonPagedPoolCacheAligned type. (That returns an addres that is page aligned actually), since ahci wanted & 0x3FF, for alignment.}\par
00126 {\cf20     // First, try to allocate from the NonPagedPool, if it returned a contigious physical memory address, we are lucky! (if we reach MiRefillPool we are less lucky, its actually worse...)}\par
00127 {\cf20     if (HighestAcceptableAddress == UINT64_T_MAX) \{}\par
00128 {\cf20         BaseAddress = MmAllocatePoolWithTag(NonPagedPool, NumberOfBytes, 'mCmM');}\par
00129 {\cf20 }\par
00130 {\cf20         if (BaseAddress) \{}\par
00131 {\cf20             if (MiCheckForContigiousMemory(BaseAddress, NumberOfBytes)) \{}\par
00132 {\cf20                 // Its physically contigious!}\par
00133 {\cf20                 return BaseAddress;}\par
00134 {\cf20             \}}\par
00135 {\cf20             else \{}\par
00136 {\cf20                 // It's not.. Free allocated memory.}\par
00137 {\cf20                 MmFreePool(BaseAddress);}\par
00138 {\cf20                 BaseAddress = NULL;}\par
00139 {\cf20             \}}\par
00140 {\cf20         \}}\par
00141 {\cf20     \}}\par
00142 {\cf20     */}\par
00143 \par
00144     {\cf20 // Acquire the global DB lock so we dont get the contigious pages stolen from us.}\par
00145     MsAcquireSpinlock(&PfnDatabase.PfnDatabaseLock, &DbIrql);\par
00146 \par
00147     {\cf19 for} (PAGE_INDEX i = 0; i < PfnDatabase.TotalPageCount; i++) \{\par
00148         {\cf20 // Check bounds.}\par
00149         {\cf19 if} (i >= MaxPfn) {\cf19 break};\par
00150 \par
00151         PPFN_ENTRY pfn = &PfnDatabase.PfnEntries[i];\par
00152 \par
00153         {\cf20 // Is this page a candidate}\par
00154         {\cf18 bool} isCandidate = (pfn->State == PfnStateFree || pfn->State == PfnStateZeroed || pfn->State == PfnStateStandby);\par
00155 \par
00156         {\cf19 if} (isCandidate) \{\par
00157             {\cf19 if} (ConsecutiveFound == 0) \{\par
00158                 StartIndex = i;\par
00159             \}\par
00160             ConsecutiveFound++;\par
00161         \}\par
00162         {\cf19 else} \{\par
00163             ConsecutiveFound = 0;\par
00164         \}\par
00165 \par
00166         {\cf20 // Found a good enough block?}\par
00167         {\cf19 if} (ConsecutiveFound == pageCount) \{\par
00168             {\cf20 // We found a range! Now we must claim them.}\par
00169             {\cf18 bool} first = {\cf17 true};\par
00170             {\cf19 for} (PAGE_INDEX j = 0; j < pageCount; j++) \{\par
00171                 PPFN_ENTRY pageToClaim = &PfnDatabase.PfnEntries[StartIndex + j];\par
00172 \par
00173                 {\cf20 // Remove from whatever list it is currently in}\par
00174                 MiUnlinkPageFromList(pageToClaim);\par
00175 \par
00176                 {\cf20 // Mark as active}\par
00177                 pageToClaim->State = PfnStateActive;\par
00178                 pageToClaim->RefCount = 1;\par
00179                 pageToClaim->Flags = PFN_FLAG_LOCKED_FOR_IO;\par
00180 \par
00181                 {\cf20 // Clear mapping info}\par
00182                 pageToClaim->Descriptor.Mapping.PteAddress = NULL;\par
00183                 pageToClaim->Descriptor.Mapping.Vad = NULL;\par
00184 \par
00185                 {\cf20 // Map the physical to the offset.}\par
00186                 uintptr_t phys = PPFN_TO_PHYSICAL_ADDRESS(pageToClaim);\par
00187                 uintptr_t virt = (phys + PhysicalMemoryOffset);\par
00188 \par
00189                 PMMPTE pte = MiGetPtePointer(virt);\par
00190                 assert((pte) != NULL);\par
00191 \par
00192                 {\cf20 // Set the return value to the first address.}\par
00193                 {\cf19 if} (first) \{\par
00194                     first = {\cf17 false};\par
00195                     BaseAddress = ({\cf18 void}*)virt;\par
00196                 \}\par
00197 \par
00198                 {\cf20 // Write through is set, we want immediate flush to main memory.}\par
00199                 MI_WRITE_PTE(pte, virt, phys, PAGE_PRESENT | PAGE_RW | PAGE_PWT);\par
00200             \}\par
00201             InterlockedAddU64(&PfnDatabase.TotalReserved, pageCount);\par
00202             {\cf20 // Break out of the 'i' loop}\par
00203             {\cf19 break};\par
00204         \}\par
00205     \}\par
00206 \par
00207     MsReleaseSpinlock(&PfnDatabase.PfnDatabaseLock, DbIrql);\par
00208     {\cf20 // This could be NULL if we didnt find a contigious amount, or the valid pointer to start of block (mapped with PhysicalMemoryOffset)}\par
00209     {\cf19 return} BaseAddress;\par
00210 \}\par
00211 \par
00212 {\cf18 void}\par
00213 MmFreeContigiousMemory(\par
00214     IN  {\cf18 void}* BaseAddress,\par
00215     IN  {\cf18 size_t} NumberOfBytes\par
00216 )\par
00217 \par
00218 {\cf20 /*++}\par
00219 {\cf20 }\par
00220 {\cf20     Routine description:}\par
00221 {\cf20 }\par
00222 {\cf20         Releases contigious physical memory allocated by the MmAllocateContigiousMemory routine.}\par
00223 {\cf20 }\par
00224 {\cf20     Arguments:}\par
00225 {\cf20 }\par
00226 {\cf20         [IN]    void* BaseAddress - Base virtual address to allocated memory, returned by the allocation routine.}\par
00227 {\cf20         [IN]    size_t NumberOfBytes - Number of bytes allocated.}\par
00228 {\cf20 }\par
00229 {\cf20     Return Values:}\par
00230 {\cf20 }\par
00231 {\cf20         None.}\par
00232 {\cf20 }\par
00233 {\cf20 --*/}\par
00234 \par
00235 \{\par
00236     {\cf20 // Declarations}\par
00237     IRQL DbIrql;\par
00238     {\cf18 size_t} pageCount = BYTES_TO_PAGES(NumberOfBytes);\par
00239     uintptr_t CurrentAddress = (uintptr_t)BaseAddress;\par
00240 \par
00241     {\cf20 // Check if the base address is from the NPG Pool allocation.}\par
00242     {\cf19 if} (BaseAddress >= ({\cf18 void}*)MI_NONPAGED_POOL_BASE && BaseAddress <= ({\cf18 void}*)MI_NONPAGED_POOL_END) \{\par
00243         MmFreePool(BaseAddress);\par
00244         {\cf19 return};\par
00245     \}\par
00246 \par
00247     {\cf20 // Just unmap each page, and return the PFN to DB.}\par
00248     MsAcquireSpinlock(&PfnDatabase.PfnDatabaseLock, &DbIrql);\par
00249 \par
00250     {\cf19 for} ({\cf18 size_t} i = 0; i < pageCount; i++) \{\par
00251         {\cf20 // Retrieve the PTE for the current VA.}\par
00252         PMMPTE pte = MiGetPtePointer(CurrentAddress);\par
00253         {\cf19 if} (!pte) {\cf19 break};\par
00254         {\cf20 // Retrieve the PFN for the current PTE.}\par
00255         PAGE_INDEX pfn = MiTranslatePteToPfn(pte);\par
00256         {\cf20 // Unmap the PTE.}\par
00257         MiUnmapPte(pte);\par
00258         {\cf20 // Release the PFN back.}\par
00259         MiReleasePhysicalPage(pfn);\par
00260 \par
00261         {\cf20 // Advance VA by VirtualPageSize}\par
00262         CurrentAddress += VirtualPageSize;\par
00263     \}\par
00264 \par
00265     MsReleaseSpinlock(&PfnDatabase.PfnDatabaseLock, DbIrql);\par
00266 \}\par
00267 \par
00268 {\cf18 void}*\par
00269 MmMapIoSpace(\par
00270     IN uintptr_t PhysicalAddress,\par
00271     IN {\cf18 size_t} NumberOfBytes,\par
00272     IN MEMORY_CACHING_TYPE CacheType\par
00273 )\par
00274 \par
00275 {\cf20 /*++}\par
00276 {\cf20 }\par
00277 {\cf20     Routine description:}\par
00278 {\cf20 }\par
00279 {\cf20         Maps the given physical address + NumberOfBytes to nonpaged system space.}\par
00280 {\cf20 }\par
00281 {\cf20     Arguments:}\par
00282 {\cf20 }\par
00283 {\cf20         [IN]    uintptr_t PhysicalAddress - Specifies the starting physical address of the I/O range to be mapped.}\par
00284 {\cf20         [IN]    size_t NumberOfBytes - Specifies a value greater than zero, indicating the number of bytes to be mapped.}\par
00285 {\cf20         [IN]    MEMORY_CACHING_TYPE CacheType - Specifies the cache attribute to use to map the physical address range.}\par
00286 {\cf20 }\par
00287 {\cf20     Return Values:}\par
00288 {\cf20 }\par
00289 {\cf20         Base Virtual Address that is mapped to the base physical address, or NULL on failure.}\par
00290 {\cf20 }\par
00291 {\cf20 --*/}\par
00292 \par
00293 \{\par
00294     {\cf20 // Declarations}\par
00295     {\cf18 void}* BaseAddress = NULL;\par
00296     {\cf18 size_t} NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);\par
00297     uint64_t CacheFlags = MiCacheToFlags(CacheType);\par
00298 \par
00299     {\cf20 // Runtime Assertions}\par
00300     assert(NumberOfBytes > 0);\par
00301     assert(MeGetCurrentIrql() <= DISPATCH_LEVEL);\par
00302 \par
00303     {\cf20 // Get space reservation for amount of bytes. (we could also use PhysicalMemoryOffset, but the caller must adhere that the PhysicalAddress given is NOT mapped, and I dont have time for their shenangians)}\par
00304     uintptr_t VA = MiAllocatePoolVa(NonPagedPool, NumberOfBytes);\par
00305     {\cf19 if} (!VA) {\cf19 return} NULL;\par
00306 \par
00307     {\cf20 // Good, now all we do is map, easy as that.}\par
00308     uintptr_t CurrentVA = VA;\par
00309     uintptr_t CurrentPhys = PhysicalAddress;\par
00310     {\cf19 for} ({\cf18 size_t} i = 0; i < NumberOfPages; i++) \{\par
00311         PMMPTE pte = MiGetPtePointer(CurrentVA);\par
00312         assert(pte != NULL);\par
00313         {\cf19 if} (!pte) {\cf19 goto} failure;\par
00314 \par
00315         {\cf20 // Write the PTE with the appropriate cache flags (requires PAT, enabled in MmInitSystem)}\par
00316         MI_WRITE_PTE(pte, CurrentVA, CurrentPhys, PAGE_PRESENT | PAGE_RW | CacheFlags);\par
00317 \par
00318         {\cf20 // Advance the current addresses.}\par
00319         CurrentPhys += PhysicalFrameSize;\par
00320         CurrentVA += VirtualPageSize;\par
00321     \}\par
00322 \par
00323     BaseAddress = ({\cf18 void}*)VA;\par
00324     {\cf19 return} BaseAddress;\par
00325 \par
00326 failure:\par
00327     {\cf19 if} (VA) \{\par
00328         MiFreePoolVaContiguous(VA, NumberOfBytes, NonPagedPool);\par
00329     \}\par
00330 \par
00331     {\cf19 return} NULL;\par
00332 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmproc.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmproc.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmproc.c}
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/mg.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MiCreateKernelStack} ({\b IN} bool LargeStack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiFreeKernelStack} ({\b IN} void *AllocatedStackTop, {\b IN} bool LargeStack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmCreateProcessAddressSpace} ({\b OUT} void **DirectoryTable)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiCreateKernelStack\:mmproc.c}
{\xe \v mmproc.c\:MiCreateKernelStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MiCreateKernelStack ({\b IN} bool LargeStack)}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mmproc.c}.}\par
}
{\xe \v MiFreeKernelStack\:mmproc.c}
{\xe \v mmproc.c\:MiFreeKernelStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiFreeKernelStack ({\b IN} void * AllocatedStackTop, {\b IN} bool LargeStack)}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b mmproc.c}.}\par
}
{\xe \v MmCreateProcessAddressSpace\:mmproc.c}
{\xe \v mmproc.c\:MmCreateProcessAddressSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmCreateProcessAddressSpace ({\b OUT} void ** DirectoryTable)}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b mmproc.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mmproc.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmproc.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/mmproc.c}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     mmproc.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of process supporting memory management routines.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/me.h"}\par
00021 {\cf21 #include "../../assert.h"}\par
00022 {\cf21 #include "../../includes/mg.h"}\par
00023 \par
00024 {\cf18 void}*\par
00025 MiCreateKernelStack(\par
00026     IN  {\cf18 bool} LargeStack\par
00027 )\par
00028 \par
00029 {\cf20 /*++}\par
00030 {\cf20 }\par
00031 {\cf20     Routine description:}\par
00032 {\cf20 }\par
00033 {\cf20         Creates a kernel stack for general use.}\par
00034 {\cf20         The stack cannot be accessible in user mode (assert(cpl == 0);)}\par
00035 {\cf20 }\par
00036 {\cf20     Arguments:}\par
00037 {\cf20 }\par
00038 {\cf20         [IN]    bool LargeStack - Determines if the stack allocated should be MI_LARGE_STACK_SIZE bytes long. (default is MI_STACK_SIZE)}\par
00039 {\cf20 }\par
00040 {\cf20     Return Values:}\par
00041 {\cf20 }\par
00042 {\cf20         Pointer to top of the stack, or NULL on failure.}\par
00043 {\cf20 }\par
00044 {\cf20     Notes:}\par
00045 {\cf20 }\par
00046 {\cf20         The previous comment stated that it would return at the end of the guard page, which was incorrect when I went through my code.}\par
00047 {\cf20         This means you CAN emit the PUSH instruction, as it will also subtract space from the stack automatically (based on the pushed immediate).}\par
00048 {\cf20         But do not subtract too much (hit the guard page), or add to this pointer (hit the next page, could very well be unmapped, or a guard page of another thread)}\par
00049 {\cf20         - As you risk a page fault.}\par
00050 {\cf20 }\par
00051 {\cf20 --*/}\par
00052 \par
00053 \{\par
00054     {\cf20 // Declarations}\par
00055     {\cf18 size_t} StackSize = LargeStack ? MI_LARGE_STACK_SIZE : MI_STACK_SIZE;\par
00056     {\cf18 size_t} GuardSize = VirtualPageSize;\par
00057     {\cf18 size_t} TotalSize = StackSize + GuardSize;\par
00058     {\cf18 size_t} PagesToMap = BYTES_TO_PAGES(StackSize);\par
00059 \par
00060     {\cf20 // Allocate VA range, the stack + guard page.}\par
00061     uintptr_t BaseVa = MiAllocatePoolVa(NonPagedPool, TotalSize);\par
00062     {\cf19 if} (!BaseVa) {\cf19 return} NULL;\par
00063 \par
00064     {\cf20 // Define where we actually start mapping, we skip the Guard page as we obviously dont want to map it.}\par
00065     uintptr_t MapStartVa = BaseVa + GuardSize;\par
00066 \par
00067     {\cf18 size_t} Iterations = 0;\par
00068     {\cf18 bool} failure = {\cf17 false};\par
00069 \par
00070     {\cf19 for} ({\cf18 size_t} i = 0; i < PagesToMap; i++) \{\par
00071         {\cf20 // Calculate current VA to map}\par
00072         uintptr_t currVa = MapStartVa + (i * VirtualPageSize);\par
00073 \par
00074         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00075 \par
00076         {\cf19 if} (pfn == PFN_ERROR) \{\par
00077             failure = {\cf17 true};\par
00078             {\cf19 break};\par
00079         \}\par
00080 \par
00081         PMMPTE pte = MiGetPtePointer(currVa);\par
00082         {\cf19 if} (!pte) \{\par
00083             MiReleasePhysicalPage(pfn);\par
00084             failure = {\cf17 true};\par
00085             {\cf19 break};\par
00086         \}\par
00087 \par
00088         {\cf20 // Map the Stack Page}\par
00089         MI_WRITE_PTE(pte, currVa, PFN_TO_PHYS(pfn), PAGE_PRESENT | PAGE_RW);\par
00090         Iterations++;\par
00091     \}\par
00092 \par
00093     PMMPTE GuardPte = MiGetPtePointer(BaseVa);\par
00094 \par
00095     {\cf19 if} (!GuardPte) \{\par
00096         {\cf20 // Now, I could continue and just not mark the GuardPte as a guard page, as it is only used in bugcheck}\par
00097         {\cf20 // debugging, but I want to make my debugging life easier.}\par
00098         {\cf20 // I don't even have a stable kernel debugger, so excuse me for the horrifying line im about to put below.}\par
00099         MeBugCheckEx(MANUALLY_INITIATED_CRASH,\par
00100             ({\cf18 void}*)RETADDR(0),\par
00101             ({\cf18 void}*)BaseVa,\par
00102             ({\cf18 void}*)TotalSize,\par
00103             ({\cf18 void}*)123432 {\cf20 /* special identifier for manually initiated crash to know its here */}\par
00104         );\par
00105         {\cf20 // If the bugcheck is ever removed, it would be a failure.}\par
00106         failure = {\cf17 true};\par
00107 \par
00108     \}\par
00109 \par
00110     {\cf19 if} (failure) {\cf19 goto} failure_cleanup;\par
00111 \par
00112     {\cf20 // Clean the PTE.}\par
00113     GuardPte->Value = 0;\par
00114 \par
00115     {\cf20 // Set the Guard page bit in the GuardPte.}\par
00116     GuardPte->Hard.Present = 0;\par
00117     GuardPte->Soft.SoftwareFlags |= MI_GUARD_PAGE_PROTECTION;\par
00118 \par
00119     {\cf20 // Invalidate the guard page VA.}\par
00120     MiInvalidateTlbForVa(({\cf18 void}*)BaseVa);\par
00121 \par
00122     {\cf20 // Return the TOP of the stack.}\par
00123     {\cf19 return} ({\cf18 void}*)(BaseVa + TotalSize);\par
00124 \par
00125 failure_cleanup:\par
00126     {\cf20 // Unmap the pages we successfully mapped}\par
00127     {\cf19 for} ({\cf18 size_t} j = 0; j < Iterations; j++) \{\par
00128         uintptr_t vaToFree = MapStartVa + (j * VirtualPageSize);\par
00129         PMMPTE pte = MiGetPtePointer(vaToFree);\par
00130 \par
00131         {\cf19 if} (pte && pte->Hard.Present) \{\par
00132             PAGE_INDEX pfn = MiTranslatePteToPfn(pte);\par
00133             MiUnmapPte(pte);\par
00134             MiReleasePhysicalPage(pfn);\par
00135         \}\par
00136     \}\par
00137 \par
00138     {\cf20 // Free the VA reservation}\par
00139     {\cf19 if} (BaseVa) \{\par
00140         MiFreePoolVaContiguous(BaseVa, TotalSize, NonPagedPool);\par
00141     \}\par
00142 \par
00143     assert({\cf17 false}, {\cf22 "This function is currently a Must-Succeed."});\par
00144     {\cf19 return} NULL;\par
00145 \}\par
00146 \par
00147 {\cf18 void}\par
00148 MiFreeKernelStack(\par
00149     IN {\cf18 void}* AllocatedStackTop,\par
00150     IN {\cf18 bool} LargeStack\par
00151 )\par
00152 \par
00153 {\cf20 /*++}\par
00154 {\cf20 }\par
00155 {\cf20     Routine description:}\par
00156 {\cf20 }\par
00157 {\cf20         Frees the stack given to a kernel thread.}\par
00158 {\cf20 }\par
00159 {\cf20     Arguments:}\par
00160 {\cf20 }\par
00161 {\cf20         [IN]    void* AllocatedStackBase - The pointer given by MiCreateKernelStack}\par
00162 {\cf20         [IN]    bool LargeStack - Signifies if the stack being deleted is a MI_LARGE_STACK_SIZE bytes long (true), or MI_STACK_SIZE bytes long (false)}\par
00163 {\cf20 }\par
00164 {\cf20     Return Values:}\par
00165 {\cf20 }\par
00166 {\cf20         None.}\par
00167 {\cf20 }\par
00168 {\cf20 --*/}\par
00169 \par
00170 \{\par
00171     gop_printf(COLOR_PINK, {\cf22 "**Reached MiFreeKernelStack | LargeStack: %s | AllocatedStackTop: %p**\\n"}, (LargeStack ? {\cf22 "True"} : {\cf22 "False"}), AllocatedStackTop);\par
00172     {\cf20 // Declarations}\par
00173     {\cf18 size_t} StackSize = LargeStack ? MI_LARGE_STACK_SIZE : MI_STACK_SIZE;\par
00174     {\cf18 size_t} GuardSize = VirtualPageSize;\par
00175     {\cf18 size_t} TotalSize = StackSize + GuardSize;\par
00176     {\cf18 size_t} PagesToUnMap = BYTES_TO_PAGES(StackSize);\par
00177 \par
00178     {\cf20 // 1. Calculate the START of the stack memory (The highest valid byte addressable page)}\par
00179     {\cf20 // AllocatedStackTop is the byte *after* the stack end. }\par
00180     {\cf20 // We start at Top - PageSize.}\par
00181     uintptr_t CurrentVA = (uintptr_t)AllocatedStackTop - VirtualPageSize;\par
00182 \par
00183     {\cf19 for} ({\cf18 size_t} i = 0; i < PagesToUnMap; i++) \{\par
00184         PMMPTE pte = MiGetPtePointer(CurrentVA);\par
00185 \par
00186         {\cf19 if} (pte && pte->Hard.Present) \{\par
00187 \par
00188             {\cf20 // Get its PFN that was allocated to it.}\par
00189             PAGE_INDEX pfn = MiTranslatePteToPfn(pte);\par
00190 \par
00191             {\cf20 // Unmap the PTE.}\par
00192             MiUnmapPte(pte);\par
00193 \par
00194             {\cf20 // Release the physical page back to the PFN DB.}\par
00195             MiReleasePhysicalPage(pfn);\par
00196         \}\par
00197 \par
00198         {\cf20 // Move down to the next page}\par
00199         CurrentVA -= VirtualPageSize;\par
00200     \}\par
00201 \par
00202     {\cf20 // The Guard Page is at the very bottom of the allocation.}\par
00203     uintptr_t BaseVa = (uintptr_t)AllocatedStackTop - TotalSize;\par
00204 \par
00205     PMMPTE GuardPte = MiGetPtePointer(BaseVa);\par
00206     {\cf19 if} (GuardPte) \{\par
00207         assert((GuardPte->Soft.SoftwareFlags & MI_GUARD_PAGE_PROTECTION) != 0, {\cf22 "The guard page must have the GUARD_PAGE_PROTECTION bit set."});\par
00208         {\cf20 // Clean the page.}\par
00209         GuardPte->Value = 0;\par
00210     \}\par
00211 \par
00212     {\cf20 // Invalidate the VA for the Guard Page.}\par
00213     MiInvalidateTlbForVa(({\cf18 void}*)BaseVa);\par
00214 \par
00215     {\cf20 // Free the Virtual Address allocation}\par
00216     MiFreePoolVaContiguous(BaseVa, TotalSize, NonPagedPool);\par
00217 \}\par
00218 \par
00219 MTSTATUS\par
00220 MmCreateProcessAddressSpace(\par
00221     OUT {\cf18 void}** DirectoryTable\par
00222 )\par
00223 \par
00224 {\cf20 /*++}\par
00225 {\cf20 }\par
00226 {\cf20     Routine description:}\par
00227 {\cf20 }\par
00228 {\cf20         Creates a new paging address space for the process.}\par
00229 {\cf20 }\par
00230 {\cf20     Arguments:}\par
00231 {\cf20 }\par
00232 {\cf20         [OUT] void** DirectoryTable - Pointer to set the newly physical address of the process's CR3.}\par
00233 {\cf20 }\par
00234 {\cf20     Return Values:}\par
00235 {\cf20 }\par
00236 {\cf20         None.}\par
00237 {\cf20 }\par
00238 {\cf20 --*/}\par
00239 \par
00240 \{\par
00241     {\cf20 // Declarations}\par
00242     PAGE_INDEX pfnIndex;\par
00243     uint64_t* pml4Base;\par
00244     IRQL oldIrql;\par
00245     uint64_t physicalAddress;\par
00246 \par
00247     {\cf20 // Allocate a physical page for the PML4.}\par
00248     pfnIndex = MiRequestPhysicalPage(PfnStateZeroed);\par
00249 \par
00250     {\cf19 if} (pfnIndex == PFN_ERROR) \{\par
00251         {\cf19 return} MT_NO_RESOURCES;\par
00252     \}\par
00253 \par
00254     {\cf20 // Convert the Index to a Physical Address (needed for CR3 and Recursive entry)}\par
00255     physicalAddress = PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(pfnIndex));\par
00256 \par
00257     {\cf20 // Map the physical page into hypermap so we can edit it temporarily.}\par
00258     pml4Base = (uint64_t*)MiMapPageInHyperspace(pfnIndex, &oldIrql);\par
00259 \par
00260     {\cf19 if} (!pml4Base) \{\par
00261         {\cf20 // If hyperspace mapping fails, release the page and fail.}\par
00262         MiReleasePhysicalPage(pfnIndex);\par
00263         {\cf19 return} MT_GENERAL_FAILURE;\par
00264     \}\par
00265 \par
00266     {\cf20 // Copy Kernel Address Space.}\par
00267     {\cf20 // The higher half of memory (Kernel Space) is shared across all processes.}\par
00268     uint64_t* currentPml4 = pml4_from_recursive();\par
00269 \par
00270     {\cf20 // This copies the PML4 from PhysicalMemoryOffset all the way ot the end of the 48bit addressing.}\par
00271     {\cf20 // Excluding user regions.}\par
00272     {\cf19 for} ({\cf18 int} i = MiConvertVaToPml4Offset(PhysicalMemoryOffset); i < 512; i++) \{\par
00273         pml4Base[i] = currentPml4[i];\par
00274     \}\par
00275 \par
00276     MMPTE recursivePte;\par
00277     kmemset(&recursivePte, 0, {\cf17 sizeof}(MMPTE)); {\cf20 // Ensure clean start}\par
00278 \par
00279     {\cf20 // Note: We pass NULL for the VA as it's a self-ref, we only care about the PFN and Flags.}\par
00280     {\cf20 // Ensure PFN_TO_PHYS is used if MI_WRITE_PTE expects a physical address.}\par
00281     MI_WRITE_PTE(&recursivePte,\par
00282         ({\cf18 void}*)0,\par
00283         PFN_TO_PHYS(pfnIndex),\par
00284         PAGE_PRESENT | PAGE_RW);\par
00285 \par
00286     {\cf20 // Write to index 0x1FF (511)}\par
00287     pml4Base[RECURSIVE_INDEX] = recursivePte.Value;\par
00288 \par
00289     {\cf20 // Ensure it is stored.}\par
00290     MmFullBarrier();\par
00291 \par
00292     {\cf20 // Unmap from Hyperspace.}\par
00293     MiUnmapHyperSpaceMap(oldIrql);\par
00294 \par
00295     {\cf20 // Return the Physical Address.}\par
00296     {\cf20 // The scheduler will load this into CR3 when switching to this process.}\par
00297     *DirectoryTable = ({\cf18 void}*)physicalAddress;\par
00298 \par
00299     {\cf19 return} MT_SUCCESS;\par
00300 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pfn.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pfn.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pfn.c}
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/me.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MiInitializePfnDatabase} ({\b IN} {\b PBOOT_INFO} BootInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGE_INDEX} {\b MiRequestPhysicalPage} ({\b IN} {\b PFN_STATE} ListType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiReleasePhysicalPage} ({\b IN} {\b PAGE_INDEX} PfnIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiUnlinkPageFromList} ({\b PPFN_ENTRY} pfn)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_DATABASE} {\b PfnDatabase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmPfnDatabaseInitialized} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGE_INDEX} {\b MmHighestPfn} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiInitializePfnDatabase\:pfn.c}
{\xe \v pfn.c\:MiInitializePfnDatabase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MiInitializePfnDatabase ({\b IN} {\b PBOOT_INFO} BootInfo)}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b pfn.c}.}\par
}
{\xe \v MiReleasePhysicalPage\:pfn.c}
{\xe \v pfn.c\:MiReleasePhysicalPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiReleasePhysicalPage ({\b IN} {\b PAGE_INDEX} PfnIndex)}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 421} of file {\b pfn.c}.}\par
}
{\xe \v MiRequestPhysicalPage\:pfn.c}
{\xe \v pfn.c\:MiRequestPhysicalPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGE_INDEX} MiRequestPhysicalPage ({\b IN} {\b PFN_STATE} ListType)}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 325} of file {\b pfn.c}.}\par
}
{\xe \v MiUnlinkPageFromList\:pfn.c}
{\xe \v pfn.c\:MiUnlinkPageFromList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiUnlinkPageFromList ({\b PPFN_ENTRY} pfn)}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 486} of file {\b pfn.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v MmHighestPfn\:pfn.c}
{\xe \v pfn.c\:MmHighestPfn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGE_INDEX} MmHighestPfn = 0}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b pfn.c}.}\par
}
{\xe \v MmPfnDatabaseInitialized\:pfn.c}
{\xe \v pfn.c\:MmPfnDatabaseInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmPfnDatabaseInitialized = false}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b pfn.c}.}\par
}
{\xe \v PfnDatabase\:pfn.c}
{\xe \v pfn.c\:PfnDatabase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_DATABASE} PfnDatabase}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b pfn.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pfn.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pfn.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pfn.c}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     pfn.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of the PFN Database (covers physical memory map init)}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20     DD/MM/YY}\par
00017 {\cf20 }\par
00018 {\cf20 }\par
00019 {\cf20     17/10/2025 - Revised Physical Memory from a simple bitmap to a PFN database.}\par
00020 {\cf20     }\par
00021 {\cf20 }\par
00022 {\cf20 --*/}\par
00023 \par
00024 {\cf21 #include "../../includes/mm.h"}\par
00025 {\cf21 #include "../../includes/mg.h"}\par
00026 {\cf21 #include "../../assert.h"}\par
00027 {\cf21 #include "../../includes/me.h"}\par
00028 \par
00029 MM_PFN_DATABASE PfnDatabase;\par
00030 {\cf18 bool} MmPfnDatabaseInitialized = {\cf17 false};\par
00031 PAGE_INDEX MmHighestPfn = 0;\par
00032 \par
00033 {\cf17 static}\par
00034 uint64_t \par
00035 MiGetTotalMemory (\par
00036     {\cf17 const} BOOT_INFO* boot_info\par
00037 )\par
00038 \par
00039 {\cf20 /*++}\par
00040 {\cf20 }\par
00041 {\cf20     Routine description:}\par
00042 {\cf20     }\par
00043 {\cf20         Calculates the highest address of USABLE physical memory in the system.}\par
00044 {\cf20 }\par
00045 {\cf20     Arguments:}\par
00046 {\cf20 }\par
00047 {\cf20         [IN]    Pointer to BOOT_INFO struct, obtained from UEFI.}\par
00048 {\cf20 }\par
00049 {\cf20     Return Values:}\par
00050 {\cf20 }\par
00051 {\cf20         Highest Usable Address in physical memory (total amount of usable RAM)}\par
00052 {\cf20 }\par
00053 {\cf20         DO NOTE: The function will return the max address that is usable in the system, which might leave MMIO holes above, these will NOT be added into the PFN DB.}\par
00054 {\cf20 }\par
00055 {\cf20 --*/}\par
00056 \par
00057 \{\par
00058     uint64_t highest_addr = 0;\par
00059     {\cf18 size_t} entry_count = boot_info->MapSize / boot_info->DescriptorSize;\par
00060     PEFI_MEMORY_DESCRIPTOR desc = boot_info->MemoryMap;\par
00061 \par
00062     {\cf19 for} ({\cf18 size_t} i = 0; i < entry_count; i++) \{\par
00063         {\cf20 // FILTER: Only look at usable RAM or memory we might reclaim.}\par
00064         {\cf20 // Ignore Reserved, Unusable, and MemoryMappedIO.}\par
00065         {\cf20 // TODO Other types...}\par
00066         {\cf19 if} (desc->Type == EfiConventionalMemory)\par
00067         \{\par
00068             uint64_t region_end = desc->PhysicalStart + (desc->NumberOfPages * PhysicalFrameSize);\par
00069             {\cf19 if} (region_end > highest_addr) highest_addr = region_end;\par
00070         \}\par
00071 \par
00072         desc = (PEFI_MEMORY_DESCRIPTOR)((uint8_t*)desc + boot_info->DescriptorSize);\par
00073     \}\par
00074 \par
00075     {\cf19 return} highest_addr;\par
00076 \}\par
00077 \par
00078 {\cf17 static}\par
00079 {\cf18 void}\par
00080 MiReservePhysRange(\par
00081     uint64_t phys_start,\par
00082     uint64_t length\par
00083 )\par
00084 \par
00085 \{\par
00086     uint64_t first = phys_start / PhysicalFrameSize;\par
00087     uint64_t pages = (length + PhysicalFrameSize - 1) / PhysicalFrameSize;\par
00088     {\cf19 for} (uint64_t i = 0; i < pages; ++i) \{\par
00089         uint64_t idx = first + i;\par
00090         {\cf19 if} (idx >= PfnDatabase.TotalPageCount) {\cf19 continue};\par
00091         PPFN_ENTRY e = &PfnDatabase.PfnEntries[idx];\par
00092         e->RefCount = 1;\par
00093         e->State = PfnStateActive;\par
00094         e->Flags = PFN_FLAG_NONE;\par
00095         InterlockedIncrementU64(&PfnDatabase.TotalReserved);\par
00096     \}\par
00097 \}\par
00098 \par
00099 MTSTATUS\par
00100 MiInitializePfnDatabase(\par
00101     IN  PBOOT_INFO BootInfo\par
00102 )\par
00103 \par
00104 {\cf20 /*++}\par
00105 {\cf20 }\par
00106 {\cf20     Routine description: }\par
00107 {\cf20         }\par
00108 {\cf20         Initializes the global PFN database.}\par
00109 {\cf20 }\par
00110 {\cf20     Arguments:}\par
00111 {\cf20 }\par
00112 {\cf20         [IN]    Pointer to BOOT_INFO struct, obtained from UEFI.}\par
00113 {\cf20 }\par
00114 {\cf20     Return Values:}\par
00115 {\cf20 }\par
00116 {\cf20         MTSTATUS Status Code.}\par
00117 {\cf20 }\par
00118 {\cf20 --*/}\par
00119 \par
00120 \{\par
00121     {\cf20 // First of all, before creating the PFN Database}\par
00122     {\cf20 // we would need the amount of total RAM, divide that by each physical frame size}\par
00123     {\cf20 // to allocate the amount of PFN_ENTRY(ies) needed.}\par
00124     uint64_t totalRam = MiGetTotalMemory(BootInfo);\par
00125     {\cf19 if} (!totalRam) {\cf19 return} MT_NO_MEMORY;\par
00126 \par
00127     uint64_t totalPfnEntries = totalRam / PhysicalFrameSize;\par
00128 \par
00129     {\cf20 // The amount of PFN Entries needed times the sizeof the struct, gives us the amount in bytes.}\par
00130     uint64_t neededRam = totalPfnEntries * {\cf17 sizeof}(PFN_ENTRY);\par
00131     assert((neededRam) < INT32_MAX, {\cf22 "Needed Ram DB is insanely huge"});\par
00132 \par
00133     {\cf20 // Now, we need to find a suitable memory region to hold the PFN Entries in.}\par
00134     PEFI_MEMORY_DESCRIPTOR desc = BootInfo->MemoryMap;\par
00135     {\cf18 size_t} entryCount = BootInfo->MapSize / BootInfo->DescriptorSize;\par
00136     uint64_t pfnEntriesPhys = 0;\par
00137 \par
00138     {\cf20 // Loop over all memory.}\par
00139     {\cf19 for} ({\cf18 size_t} i = 0; i < entryCount; i++) \{\par
00140         {\cf19 if} (desc->Type == EfiConventionalMemory) \{\par
00141             {\cf20 // This physical region size is the number of pages in it times frame size.}\par
00142             uint64_t regionSize = desc->NumberOfPages * PhysicalFrameSize;\par
00143 \par
00144             {\cf19 if} (regionSize >= neededRam) \{\par
00145                 {\cf20 // This region can hold the PFN database entries.}\par
00146                 pfnEntriesPhys = desc->PhysicalStart;\par
00147                 {\cf19 break};\par
00148             \}\par
00149         \}\par
00150         {\cf20 // Advance to the next UEFI memory descriptor in the map.}\par
00151         desc = (PEFI_MEMORY_DESCRIPTOR)((uint8_t*)desc + BootInfo->DescriptorSize);\par
00152     \}\par
00153 \par
00154     {\cf20 // Verify we found a suitable region.}\par
00155     {\cf19 if} (!pfnEntriesPhys) {\cf19 return} MT_NOT_FOUND;\par
00156 \par
00157     {\cf20 // Convert the address to our virtual offsetable.}\par
00158     uint64_t pfnEntriesVirt = pfnEntriesPhys + PhysicalMemoryOffset;\par
00159 \par
00160     {\cf20 // Initialize the doubly linked lists.}\par
00161     InitializeListHead(&PfnDatabase.FreePageList.ListEntry);\par
00162     InitializeListHead(&PfnDatabase.BadPageList.ListEntry);\par
00163     InitializeListHead(&PfnDatabase.StandbyPageList.ListEntry);\par
00164     InitializeListHead(&PfnDatabase.ZeroedPageList.ListEntry);\par
00165     InitializeListHead(&PfnDatabase.ModifiedPageList.ListEntry);\par
00166 \par
00167     {\cf20 // Map the whole region, acquire its PTE for each 4KiB.}\par
00168     uint64_t neededPages = (neededRam + VirtualPageSize - 1) / VirtualPageSize; \par
00169 \par
00170     {\cf19 for} (uint64_t i = 0; i < neededPages; i++) \{\par
00171         PMMPTE pte = MiGetPtePointer(pfnEntriesVirt);\par
00172         {\cf19 if} (!pte) {\cf19 return} MT_GENERAL_FAILURE;\par
00173         MI_WRITE_PTE(pte, pfnEntriesVirt, pfnEntriesPhys, PAGE_PRESENT | PAGE_RW);\par
00174         pfnEntriesVirt += VirtualPageSize;\par
00175         pfnEntriesPhys += VirtualPageSize;\par
00176     \}\par
00177 \par
00178     {\cf20 // Set the pointer.}\par
00179     uint64_t pfn_region_phys = pfnEntriesPhys - (neededPages * VirtualPageSize);\par
00180     PfnDatabase.PfnEntries = (PPFN_ENTRY)(uintptr_t)(pfn_region_phys + PhysicalMemoryOffset);\par
00181 \par
00182     {\cf20 // Zero the region.}\par
00183     kmemset(PfnDatabase.PfnEntries, 0, neededPages * VirtualPageSize);\par
00184 \par
00185     {\cf20 // Initialize counts.}\par
00186     PfnDatabase.TotalPageCount = totalPfnEntries;            \par
00187     PfnDatabase.AvailablePages = 0;\par
00188     PfnDatabase.TotalReserved = 0;\par
00189 \par
00190     PfnDatabase.FreePageList.Count = 0;\par
00191     PfnDatabase.BadPageList.Count = 0;\par
00192     PfnDatabase.StandbyPageList.Count = 0;\par
00193     PfnDatabase.ZeroedPageList.Count = 0;\par
00194     PfnDatabase.ModifiedPageList.Count = 0;\par
00195 \par
00196     {\cf20 // Initialize locks}\par
00197     PfnDatabase.PfnDatabaseLock.locked = 0;\par
00198     PfnDatabase.BadPageList.PfnListLock.locked = 0;\par
00199     PfnDatabase.StandbyPageList.PfnListLock.locked = 0;\par
00200     PfnDatabase.ZeroedPageList.PfnListLock.locked = 0;\par
00201     PfnDatabase.FreePageList.PfnListLock.locked = 0;\par
00202     PfnDatabase.ModifiedPageList.PfnListLock.locked = 0;\par
00203 \par
00204     {\cf20 // Reserve the PFN Array in the PFN List.}\par
00205     MiReservePhysRange(pfn_region_phys, neededPages * VirtualPageSize);\par
00206 \par
00207     {\cf20 // We can interact with the entries, begin filling the PFN DB.}\par
00208     PAGE_INDEX lastPfnIdx = 0;\par
00209     desc = BootInfo->MemoryMap; {\cf20 // reset desc to original pointer}\par
00210     {\cf19 for} ({\cf18 size_t} i = 0; i < entryCount; i++) \{\par
00211         uint64_t regionStart = desc->PhysicalStart;\par
00212         uint64_t regionPages = desc->NumberOfPages;\par
00213 \par
00214         {\cf20 // For each 4KiB page in the physical region of pages}\par
00215         {\cf19 for} (uint64_t p = 0; p < regionPages; p++) \{\par
00216             {\cf20 // The physical address is calculated by taking the (regionStart (physical address of region base) plus the current increment) times the frame size.}\par
00217             uint64_t physAddr = regionStart + p * PhysicalFrameSize;\par
00218 \par
00219             uint64_t currentPfnIndex = (physAddr / PhysicalFrameSize);\par
00220 \par
00221             {\cf20 // UEFI Memory maps arent sorted in order, we could get address 0x100000 at one iteration, and address 0x2000 at the next iteration.}\par
00222             {\cf20 // We guard it with a simple if statement.}\par
00223             {\cf19 if} (currentPfnIndex > lastPfnIdx) \{\par
00224                 lastPfnIdx = currentPfnIndex;\par
00225             \}\par
00226 \par
00227             {\cf19 if} (currentPfnIndex >= PfnDatabase.TotalPageCount) \{\par
00228                 {\cf20 // out of range physical address, we skip.}\par
00229                 {\cf19 continue};\par
00230             \}\par
00231 \par
00232             PPFN_ENTRY entry = &PfnDatabase.PfnEntries[currentPfnIndex];\par
00233 \par
00234             {\cf20 // If this page is inside the PFN-array region we just reserved, skip adding it to db.}\par
00235             {\cf19 if} (desc->Type == EfiConventionalMemory) \{\par
00236                 {\cf19 if} (physAddr >= pfn_region_phys && physAddr < pfn_region_phys + neededPages * VirtualPageSize) \{\par
00237                     {\cf19 continue}; {\cf20 // Do not touch this entry, it was set by MiReservePhysRange}\par
00238                 \}\par
00239             \}\par
00240 \par
00241             {\cf20 // Initialize the PFN Entry.}\par
00242             entry->RefCount = 0;\par
00243 \par
00244             {\cf19 switch} (desc->Type) \{\par
00245             {\cf19 case} EfiConventionalMemory:\par
00246                 entry->State = PfnStateFree;\par
00247                 entry->Flags = PFN_FLAG_NONE;\par
00248 \par
00249                 {\cf20 // Add to free list.}\par
00250                 InsertTailList(&PfnDatabase.FreePageList.ListEntry, &entry->Descriptor.ListEntry);\par
00251                 {\cf20 // Increment the free page list count.}\par
00252                 InterlockedIncrementU64(&PfnDatabase.FreePageList.Count);\par
00253                 InterlockedIncrementU64(&PfnDatabase.AvailablePages);\par
00254                 {\cf19 break};\par
00255             {\cf19 case} EfiBootServicesCode:\par
00256             {\cf19 case} EfiBootServicesData:\par
00257             {\cf19 case} EfiLoaderCode:\par
00258             {\cf19 case} EfiLoaderData:\par
00259             {\cf19 case} EfiRuntimeServicesCode:\par
00260             {\cf19 case} EfiRuntimeServicesData:\par
00261             {\cf19 case} EfiReservedMemoryType:\par
00262             {\cf19 case} EfiACPIMemoryNVS:\par
00263                 {\cf20 // Mark pages used by firmware, loader, or kernel as active.}\par
00264                 {\cf20 // these will not be returned by the page allocator.}\par
00265                 entry->State = PfnStateActive;\par
00266                 entry->Flags = PFN_FLAG_NONE;\par
00267                 entry->Descriptor.Mapping.PteAddress = NULL;\par
00268                 entry->Descriptor.Mapping.Vad = NULL; {\cf20 // No VAD for these.}\par
00269                 entry->RefCount = 1; {\cf20 // Set reference count to 1, so allocator will not get confused.}\par
00270                 InterlockedIncrementU64(&PfnDatabase.TotalReserved);\par
00271                 {\cf19 break};\par
00272             {\cf20 //case EfiACPIReclaimMemory TODO RECLAIMABLE.}\par
00273             {\cf19 default}:\par
00274                 {\cf20 // If its not conventional memory, or one of the runtime/loader/boot/reserved, it is bad memory.}\par
00275                 entry->State = PfnStateBad;\par
00276                 entry->Flags = PFN_FLAG_NONE;\par
00277 \par
00278                 {\cf20 // Add to free list and increment count.}\par
00279                 InsertTailList(&PfnDatabase.BadPageList.ListEntry, &entry->Descriptor.ListEntry);\par
00280                 InterlockedIncrementU64(&PfnDatabase.BadPageList.Count);\par
00281                 {\cf19 break};\par
00282             \}\par
00283         \}\par
00284         desc = (PEFI_MEMORY_DESCRIPTOR)((uint8_t*)desc + BootInfo->DescriptorSize);\par
00285     \}\par
00286 \par
00287     {\cf20 // Set the global state as initialized.}\par
00288     MmPfnDatabaseInitialized = {\cf17 true};\par
00289     MmHighestPfn = lastPfnIdx;\par
00290     {\cf19 return} MT_SUCCESS;\par
00291 \}\par
00292 \par
00293 {\cf17 static}\par
00294 PPFN_ENTRY\par
00295 MiReleaseAnyPage(\par
00296     IN PDOUBLY_LINKED_LIST ListEntry\par
00297 )\par
00298 \par
00299 {\cf20 /*++}\par
00300 {\cf20 }\par
00301 {\cf20     Routine description:}\par
00302 {\cf20 }\par
00303 {\cf20         Attempts to retrieve a PFN Entry from the ListEntry given.}\par
00304 {\cf20 }\par
00305 {\cf20     Arguments:}\par
00306 {\cf20 }\par
00307 {\cf20         [IN]    Pointer to ListEntry of PFN_LIST.}\par
00308 {\cf20 }\par
00309 {\cf20     Return Values:}\par
00310 {\cf20 }\par
00311 {\cf20         Pointer of PFN_ENTRY, NULL on failure.}\par
00312 {\cf20 }\par
00313 {\cf20 --*/}\par
00314 \par
00315 \{\par
00316     PDOUBLY_LINKED_LIST pListEntry = RemoveHeadList(ListEntry);\par
00317     {\cf19 if} (!pListEntry) {\cf19 return} NULL;\par
00318 \par
00319     {\cf20 // Return the PFN_ENTRY of this ListEntry.}\par
00320     PPFN_ENTRY pPfnEntry = CONTAINING_RECORD(pListEntry, PFN_ENTRY, Descriptor.ListEntry);\par
00321     {\cf19 return} pPfnEntry;\par
00322 \}\par
00323 \par
00324 PAGE_INDEX\par
00325 MiRequestPhysicalPage(\par
00326     IN  PFN_STATE ListType\par
00327 )\par
00328 \par
00329 {\cf20 /*++}\par
00330 {\cf20 }\par
00331 {\cf20     Routine description:}\par
00332 {\cf20 }\par
00333 {\cf20         Retrieves a physical page from the PFN Database.}\par
00334 {\cf20 }\par
00335 {\cf20     Arguments:}\par
00336 {\cf20 }\par
00337 {\cf20         [IN]    enum _PFN_STATE Type. (e.g PfnStateZeroed is guranteed to return a zeroed physical page)}\par
00338 {\cf20 }\par
00339 {\cf20     Return Values:}\par
00340 {\cf20 }\par
00341 {\cf20         PFN Index of the page, otherwise PFN_ERROR on failure.}\par
00342 {\cf20 }\par
00343 {\cf20     Notes:}\par
00344 {\cf20 }\par
00345 {\cf20         The PFN index given, does not return an actively mapped PFN (that is mapped to a VA), other functions must set its mapping.}\par
00346 {\cf20 }\par
00347 {\cf20 --*/}\par
00348 \par
00349 \{  \par
00350     {\cf20 // Declarations}\par
00351     IRQL oldIrql;\par
00352     IRQL DbIrql;\par
00353     PPFN_ENTRY pfn = NULL;\par
00354     PFN_STATE oldState; {\cf20 // To know if we need to zero}\par
00355     \par
00356     {\cf20 // Acquire global PFN DB lock.}\par
00357     MsAcquireSpinlock(&PfnDatabase.PfnDatabaseLock, &DbIrql);\par
00358     \par
00359     {\cf20 // 1. Try ZeroedPageList}\par
00360     MsAcquireSpinlock(&PfnDatabase.ZeroedPageList.PfnListLock, &oldIrql);\par
00361     pfn = MiReleaseAnyPage(&PfnDatabase.ZeroedPageList.ListEntry);\par
00362     MsReleaseSpinlock(&PfnDatabase.ZeroedPageList.PfnListLock, oldIrql);\par
00363     {\cf19 if} (pfn) \{\par
00364         InterlockedDecrementU64(&PfnDatabase.ZeroedPageList.Count);\par
00365         oldState = PfnStateZeroed;\par
00366         {\cf19 goto} found;\par
00367     \}\par
00368 \par
00369     {\cf20 // 2. Try FreePageList}\par
00370     MsAcquireSpinlock(&PfnDatabase.FreePageList.PfnListLock, &oldIrql);\par
00371     pfn = MiReleaseAnyPage(&PfnDatabase.FreePageList.ListEntry);\par
00372     MsReleaseSpinlock(&PfnDatabase.FreePageList.PfnListLock, oldIrql);\par
00373     {\cf19 if} (pfn) \{\par
00374         InterlockedDecrementU64(&PfnDatabase.FreePageList.Count);\par
00375         oldState = PfnStateFree;\par
00376         {\cf19 goto} found;\par
00377     \}\par
00378 \par
00379     {\cf20 // 3. Try StandbyPageList}\par
00380     MsAcquireSpinlock(&PfnDatabase.StandbyPageList.PfnListLock, &oldIrql);\par
00381     pfn = MiReleaseAnyPage(&PfnDatabase.StandbyPageList.ListEntry);\par
00382     MsReleaseSpinlock(&PfnDatabase.StandbyPageList.PfnListLock, oldIrql);\par
00383     {\cf19 if} (pfn) \{\par
00384         InterlockedDecrementU64(&PfnDatabase.StandbyPageList.Count);\par
00385         oldState = PfnStateStandby;\par
00386         {\cf19 goto} found;\par
00387     \}\par
00388 \par
00389     {\cf20 // 4. All lists are empty}\par
00390     {\cf20 // TODO: Paging (flush modified list to disk, give a page from there.)}\par
00391     {\cf20 // Release Global Lock}\par
00392     MsReleaseSpinlock(&PfnDatabase.PfnDatabaseLock, DbIrql);\par
00393     {\cf19 return} (uint64_t)-1;\par
00394 \par
00395 found:\par
00396     {\cf20 // Claim while locked.}\par
00397     assert((pfn->RefCount) == 0);\par
00398     pfn->State = PfnStateTransition;\par
00399     {\cf20 // Set final metadata: now "owned" by the caller.}\par
00400     pfn->RefCount = 1;\par
00401 \par
00402     {\cf20 // Release Global Lock}\par
00403     MsReleaseSpinlock(&PfnDatabase.PfnDatabaseLock, DbIrql);\par
00404     {\cf20 // Decrement total available pages}\par
00405     InterlockedDecrementU64(&PfnDatabase.AvailablePages);\par
00406 \par
00407     uint64_t pfnIndex = PPFN_TO_INDEX(pfn);\par
00408 \par
00409     {\cf20 // If caller wants a zeroed page, but we didn't get one, zero it now.}\par
00410     {\cf19 if} (ListType == PfnStateZeroed && oldState != PfnStateZeroed) \{\par
00411         IRQL hyperIrql;\par
00412         uint8_t* va = MiMapPageInHyperspace(pfnIndex, &hyperIrql);\par
00413         kmemset(va, 0, VirtualPageSize);\par
00414         MiUnmapHyperSpaceMap(hyperIrql);\par
00415     \}\par
00416 \par
00417     {\cf19 return} pfnIndex;\par
00418 \}\par
00419 \par
00420 {\cf18 void}\par
00421 MiReleasePhysicalPage(\par
00422     IN  PAGE_INDEX PfnIndex\par
00423 )\par
00424 \par
00425 {\cf20 /*++}\par
00426 {\cf20 }\par
00427 {\cf20     Routine description:}\par
00428 {\cf20 }\par
00429 {\cf20         Releases a physical page back to the memory manager}\par
00430 {\cf20 }\par
00431 {\cf20     Arguments:}\par
00432 {\cf20 }\par
00433 {\cf20         [IN]    PAGE_INDEX Index of the PFN given by MiRequestPhysicalPage}\par
00434 {\cf20 }\par
00435 {\cf20     Return Values:}\par
00436 {\cf20 }\par
00437 {\cf20         None.}\par
00438 {\cf20 }\par
00439 {\cf20 --*/}\par
00440 \par
00441 \{\par
00442     {\cf20 // First, access the PFN in the database to determine its staistics.}\par
00443     PPFN_ENTRY pfn = INDEX_TO_PPFN(PfnIndex);\par
00444 \par
00445     assert((pfn->RefCount) > 0, {\cf22 "Refcount is 0 while releasing. Double Free"});\par
00446 \par
00447     {\cf19 if} (InterlockedDecrementU32(&pfn->RefCount) == 0) \{\par
00448         {\cf20 // This is the last reference to the page, store it back in the list.}\par
00449         {\cf19 if} (pfn->State == PfnStateActive) \{\par
00450             {\cf20 // Clear mapping info.}\par
00451             pfn->Descriptor.Mapping.Vad = NULL;\par
00452             {\cf19 if} (pfn->Descriptor.Mapping.PteAddress != NULL &&\par
00453                 pfn->Descriptor.Mapping.PteAddress->Hard.Dirty) \{\par
00454                 {\cf20 // Dirty bit is set, we throw it back to the modified page list.}\par
00455                 IRQL oldIrql;\par
00456                 pfn->State = PfnStateModified;\par
00457                 MsAcquireSpinlock(&PfnDatabase.ModifiedPageList.PfnListLock, &oldIrql);\par
00458                 {\cf20 // TODO SET FILE OFFSET PAGING}\par
00459                 InsertTailList(&PfnDatabase.ModifiedPageList.ListEntry, &pfn->Descriptor.ListEntry);\par
00460                 \par
00461                 {\cf20 // Increment the counters}\par
00462                 InterlockedIncrementU64(&PfnDatabase.ModifiedPageList.Count);\par
00463                 InterlockedIncrementU64(&PfnDatabase.AvailablePages);\par
00464                 \par
00465                 MsReleaseSpinlock(&PfnDatabase.ModifiedPageList.PfnListLock, oldIrql);\par
00466             \}\par
00467             {\cf19 else} \{\par
00468                 {\cf20 // Dirty bit is not set, we throw it to the standby list.}\par
00469                 IRQL oldIrql;\par
00470                 pfn->State = PfnStateStandby;\par
00471                 MsAcquireSpinlock(&PfnDatabase.StandbyPageList.PfnListLock, &oldIrql);\par
00472                 {\cf20 // TODO SET FILE OFFSET PAGING}\par
00473                 InsertTailList(&PfnDatabase.StandbyPageList.ListEntry, &pfn->Descriptor.ListEntry);\par
00474 \par
00475                 {\cf20 // Increment the counters}\par
00476                 InterlockedIncrementU64(&PfnDatabase.StandbyPageList.Count);\par
00477                 InterlockedIncrementU64(&PfnDatabase.AvailablePages);\par
00478 \par
00479                 MsReleaseSpinlock(&PfnDatabase.StandbyPageList.PfnListLock, oldIrql);\par
00480             \}\par
00481         \}\par
00482     \}\par
00483 \}\par
00484 \par
00485 {\cf18 void}\par
00486 MiUnlinkPageFromList(\par
00487     PPFN_ENTRY pfn\par
00488 )\par
00489 \par
00490 {\cf20 // Link a specified PPFN_ENTRY from its PfnDb list.}\par
00491 \par
00492 \{\par
00493     IRQL oldIrql;\par
00494     SPINLOCK* lock = NULL;\par
00495     {\cf17 volatile} uint64_t* count = NULL;\par
00496 \par
00497     {\cf20 /* Determine which list this PFN is on and pick the corresponding lock/count */}\par
00498     {\cf19 switch} (pfn->State) \{\par
00499     {\cf19 case} PfnStateFree:\par
00500         lock = &PfnDatabase.FreePageList.PfnListLock;\par
00501         count = &PfnDatabase.FreePageList.Count;\par
00502         {\cf19 break};\par
00503     {\cf19 case} PfnStateZeroed:\par
00504         lock = &PfnDatabase.ZeroedPageList.PfnListLock;\par
00505         count = &PfnDatabase.ZeroedPageList.Count;\par
00506         {\cf19 break};\par
00507     {\cf19 case} PfnStateStandby:\par
00508         lock = &PfnDatabase.StandbyPageList.PfnListLock;\par
00509         count = &PfnDatabase.StandbyPageList.Count;\par
00510         {\cf19 break};\par
00511     {\cf19 default}:\par
00512         {\cf20 /* Active/Modified/Bad pages are handled elsewhere */}\par
00513         {\cf19 return};\par
00514     \}\par
00515 \par
00516     MsAcquireSpinlock(lock, &oldIrql);\par
00517 \par
00518     {\cf20 /*}\par
00519 {\cf20      * Guard: if the entry isn't linked (both pointers NULL) then nothing to do.}\par
00520 {\cf20      * This avoids calling RemoveEntryList on an unlinked node.}\par
00521 {\cf20      */}\par
00522     {\cf19 if} (pfn->Descriptor.ListEntry.Flink == NULL &&\par
00523         pfn->Descriptor.ListEntry.Blink == NULL) \{\par
00524         MsReleaseSpinlock(lock, oldIrql);\par
00525         {\cf19 return};\par
00526     \}\par
00527 \par
00528     {\cf20 /* Remove this node from whatever list it currently sits on. */}\par
00529     RemoveEntryList(&pfn->Descriptor.ListEntry);\par
00530 \par
00531     {\cf20 /* Clear the entry's links to mark it as unlinked (like RemoveHeadList does). */}\par
00532     pfn->Descriptor.ListEntry.Flink = pfn->Descriptor.ListEntry.Blink = NULL;\par
00533 \par
00534     {\cf20 /* Update list and global counts while holding the lock. */}\par
00535     InterlockedDecrementU64(count);\par
00536     InterlockedDecrementU64(&PfnDatabase.AvailablePages);\par
00537 \par
00538     MsReleaseSpinlock(lock, oldIrql);\par
00539 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pool.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pool.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pool.c}
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b POOL_TYPE_GLOBAL}\~ 9999\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b POOL_TYPE_PAGED}\~ 1234\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MiInitializePoolSystem} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MmAllocatePoolWithTag} ({\b IN} enum {\b _POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes, {\b IN} uint32_t Tag)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MmFreePool} ({\b IN} void *buf)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POOL_DESCRIPTOR} {\b GlobalPool}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmNonPagedPoolStart} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmNonPagedPoolEnd} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmPagedPoolStart} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmPagedPoolEnd} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v POOL_TYPE_GLOBAL\:pool.c}
{\xe \v pool.c\:POOL_TYPE_GLOBAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define POOL_TYPE_GLOBAL\~ 9999}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b pool.c}.}\par
}
{\xe \v POOL_TYPE_PAGED\:pool.c}
{\xe \v pool.c\:POOL_TYPE_PAGED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define POOL_TYPE_PAGED\~ 1234}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b pool.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiInitializePoolSystem\:pool.c}
{\xe \v pool.c\:MiInitializePoolSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MiInitializePoolSystem (void )}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b pool.c}.}\par
}
{\xe \v MmAllocatePoolWithTag\:pool.c}
{\xe \v pool.c\:MmAllocatePoolWithTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MmAllocatePoolWithTag ({\b IN} enum {\b _POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes, {\b IN} uint32_t Tag)}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 427} of file {\b pool.c}.}\par
}
{\xe \v MmFreePool\:pool.c}
{\xe \v pool.c\:MmFreePool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MmFreePool ({\b IN} void * buf)}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 586} of file {\b pool.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v GlobalPool\:pool.c}
{\xe \v pool.c\:GlobalPool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POOL_DESCRIPTOR} GlobalPool}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b pool.c}.}\par
}
{\xe \v MmNonPagedPoolEnd\:pool.c}
{\xe \v pool.c\:MmNonPagedPoolEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmNonPagedPoolEnd = 0}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b pool.c}.}\par
}
{\xe \v MmNonPagedPoolStart\:pool.c}
{\xe \v pool.c\:MmNonPagedPoolStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmNonPagedPoolStart = 0}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b pool.c}.}\par
}
{\xe \v MmPagedPoolEnd\:pool.c}
{\xe \v pool.c\:MmPagedPoolEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmPagedPoolEnd = 0}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b pool.c}.}\par
}
{\xe \v MmPagedPoolStart\:pool.c}
{\xe \v pool.c\:MmPagedPoolStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmPagedPoolStart = 0}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b pool.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pool.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pool.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/pool.c}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     pool.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of pool allocations in the kernel.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/me.h"}\par
00021 {\cf21 #include "../../includes/mg.h"}\par
00022 {\cf21 #include "../../assert.h"}\par
00023 \par
00024 {\cf20 // Can hold any size.}\par
00025 POOL_DESCRIPTOR GlobalPool;\par
00026 \par
00027 {\cf21 #define POOL_TYPE_GLOBAL 9999}\par
00028 {\cf21 #define POOL_TYPE_PAGED  1234}\par
00029 \par
00030 uintptr_t MmNonPagedPoolStart = 0;\par
00031 uintptr_t MmNonPagedPoolEnd = 0;\par
00032 uintptr_t MmPagedPoolStart = 0;\par
00033 uintptr_t MmPagedPoolEnd = 0;\par
00034 \par
00035 MTSTATUS\par
00036 MiInitializePoolSystem(\par
00037     {\cf18 void}\par
00038 )\par
00039 \par
00040 {\cf20 /*++}\par
00041 {\cf20 }\par
00042 {\cf20     Routine description:}\par
00043 {\cf20 }\par
00044 {\cf20         Initializes the Pool Allocation System of the kernel.}\par
00045 {\cf20 }\par
00046 {\cf20     Arguments:}\par
00047 {\cf20 }\par
00048 {\cf20         None.}\par
00049 {\cf20 }\par
00050 {\cf20     Return Values:}\par
00051 {\cf20 }\par
00052 {\cf20         MTSTATUS Status Code.}\par
00053 {\cf20 }\par
00054 {\cf20 --*/}\par
00055 \par
00056 \{\par
00057     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00058     {\cf19 if} (!cpu) {\cf19 return} MT_NOT_FOUND;\par
00059 \par
00060     {\cf18 size_t} base = 32; {\cf20 // Start size}\par
00061     {\cf19 for} ({\cf18 int} i = 0; i < MAX_POOL_DESCRIPTORS; i++) \{\par
00062         PPOOL_DESCRIPTOR desc = &cpu->LookasidePools[i];\par
00063 \par
00064         {\cf20 // Would grow in binary (32,64,128,256... + sizeof(POOL_HEADER)) (max would be 2048)}\par
00065         {\cf18 size_t} blockSize = (base << i) + {\cf17 sizeof}(POOL_HEADER);\par
00066         desc->BlockSize = blockSize;\par
00067         desc->FreeCount = 0;\par
00068         desc->FreeListHead.Next = NULL;\par
00069         desc->TotalBlocks = 0;\par
00070         desc->PoolLock.locked = 0;\par
00071     \}\par
00072 \par
00073     MmNonPagedPoolStart = MI_NONPAGED_POOL_BASE;\par
00074     MmNonPagedPoolEnd = MI_NONPAGED_POOL_END;\par
00075     MmPagedPoolStart = MI_PAGED_POOL_BASE;\par
00076     MmPagedPoolEnd = MI_PAGED_POOL_END;\par
00077     {\cf19 return} MT_SUCCESS;\par
00078 \}\par
00079 \par
00080 {\cf17 static}\par
00081 {\cf18 bool}\par
00082 MiRefillPool(\par
00083     PPOOL_DESCRIPTOR Desc,\par
00084     {\cf18 size_t} PoolIndex\par
00085 )\par
00086 \par
00087 {\cf20 /*++}\par
00088 {\cf20 }\par
00089 {\cf20     Routine description:}\par
00090 {\cf20 }\par
00091 {\cf20         Refills the specified pool with a block of its size.}\par
00092 {\cf20 }\par
00093 {\cf20     Arguments:}\par
00094 {\cf20 }\par
00095 {\cf20         [IN]    PPOOL_DESCRIPTOR Desc - Pointer to descriptor.}\par
00096 {\cf20         [IN]    size_T PoolIndex - Index of the slab in the CPU Lookaside buffer.}\par
00097 {\cf20 }\par
00098 {\cf20     Return Values:}\par
00099 {\cf20 }\par
00100 {\cf20         True or False based if allocation and/or refill succeeded.}\par
00101 {\cf20 }\par
00102 {\cf20 --*/}\par
00103 \par
00104 \{\par
00105     {\cf20 // Before allocating a va or another PFN, lets check the global pool first, see if we have a free 4KiB block.}\par
00106     IRQL oldIrql;\par
00107     uintptr_t PageVa = 0;\par
00108     {\cf18 size_t} HeaderBlockSize = 0;\par
00109     {\cf18 size_t} Iterations = 0;\par
00110 \par
00111     {\cf20 // Acquire the spinlock for atomicity.}\par
00112     MsAcquireSpinlock(&GlobalPool.PoolLock, &oldIrql);\par
00113 \par
00114     {\cf20 // Initialize the local list so that we push back to not memory leak blocks from the global pol.}\par
00115     SINGLE_LINKED_LIST localList;\par
00116     localList.Next = NULL;\par
00117 \par
00118     {\cf19 while} (GlobalPool.FreeCount) \{\par
00119         {\cf20 // As long as we have a free block in the global pool, we check it.}\par
00120         PSINGLE_LINKED_LIST list = GlobalPool.FreeListHead.Next;\par
00121         {\cf19 if} (list == NULL) {\cf19 break}; {\cf20 // FreeCount was wrong, but that's ok}\par
00122         GlobalPool.FreeListHead.Next = list->Next;\par
00123         PPOOL_HEADER header = CONTAINING_RECORD(list, POOL_HEADER, Metadata.FreeListEntry);\par
00124         GlobalPool.FreeCount--;\par
00125         \par
00126         {\cf19 if} (header->PoolCanary != {\cf22 'BEKA'}) \{\par
00127             MeBugCheckEx(\par
00128                 MEMORY_CORRUPT_HEADER,\par
00129                 ({\cf18 void}*)header,\par
00130                 ({\cf18 void}*)__read_rip(),\par
00131                 NULL,\par
00132                 NULL\par
00133             );\par
00134         \}\par
00135 \par
00136         {\cf19 if} (Desc->BlockSize > header->Metadata.BlockSize) \{\par
00137             {\cf20 // If the block gotten from the global pool is smaller than the required refill size, we continue and add this block to the list (to push back later)}\par
00138             header->Metadata.FreeListEntry.Next = localList.Next;\par
00139             localList.Next = &header->Metadata.FreeListEntry;\par
00140             Iterations++;\par
00141             {\cf19 continue};\par
00142         \}\par
00143 \par
00144         {\cf20 // The block is good! The loop that refills the desc wil overwrite this header data. (this is why we dont add sizeof)}\par
00145         PageVa = (uintptr_t)header;\par
00146         HeaderBlockSize = header->Metadata.BlockSize;\par
00147         {\cf19 break};\par
00148     \}\par
00149 \par
00150     {\cf20 // Refill back the pool.}\par
00151     {\cf19 while} (Iterations--) \{\par
00152         PSINGLE_LINKED_LIST entryToPushBack = localList.Next;\par
00153         {\cf19 if} (entryToPushBack == NULL) \{\par
00154             {\cf20 // Shouldn't happen if iterations is correct, but I always admire checking.}\par
00155             {\cf19 break};\par
00156         \}\par
00157 \par
00158         localList.Next = entryToPushBack->Next;\par
00159         entryToPushBack->Next = GlobalPool.FreeListHead.Next;\par
00160         GlobalPool.FreeListHead.Next = entryToPushBack;\par
00161 \par
00162         GlobalPool.FreeCount++;\par
00163     \}\par
00164 \par
00165     {\cf20 // Release global pool lock.}\par
00166     MsReleaseSpinlock(&GlobalPool.PoolLock, oldIrql);\par
00167 \par
00168     {\cf19 if} (!PageVa) \{\par
00169         {\cf20 // The global pool is empty... lets allocate.}\par
00170         {\cf20 // Allocate a 4KiB virtual address.}\par
00171         PageVa = MiAllocatePoolVa(NonPagedPool, VirtualPageSize);\par
00172         {\cf19 if} (!PageVa) {\cf19 return} {\cf17 false}; {\cf20 // Out of VA Space.}\par
00173 \par
00174         {\cf20 // Allocate a 4KiB Physical page.}\par
00175         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00176         {\cf19 if} (pfn == PFN_ERROR) \{\par
00177             MiFreePoolVaContiguous(PageVa, VirtualPageSize, NonPagedPool);\par
00178             {\cf19 return} {\cf17 false};\par
00179         \}\par
00180 \par
00181         {\cf20 // Map the page permanently.}\par
00182         PMMPTE pte = MiGetPtePointer((uintptr_t)PageVa);\par
00183         uint64_t phys = PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(pfn));\par
00184         MI_WRITE_PTE(pte, PageVa, phys, PAGE_PRESENT | PAGE_RW);\par
00185 \par
00186         {\cf20 // Update PFN metadata.}\par
00187         PPFN_ENTRY ppfn = INDEX_TO_PPFN(pfn);\par
00188         ppfn->State = PfnStateActive;\par
00189         ppfn->Flags = PFN_FLAG_NONPAGED;\par
00190         ppfn->Descriptor.Mapping.PteAddress = pte;\par
00191         ppfn->Descriptor.Mapping.Vad = NULL;\par
00192         HeaderBlockSize = VirtualPageSize;\par
00193     \}\par
00194 \par
00195     {\cf20 // Reaching here means we got a valid page (either from the global pool, or allocation), now we must carve it up to the appropriate slab's size.}\par
00196     {\cf20 // Acquire the spinlock for the descriptor given before modifying its data.}\par
00197     IRQL descIrql;\par
00198     MsAcquireSpinlock(&Desc->PoolLock, &descIrql);\par
00199 \par
00200     {\cf20 // Loop from the start to the end of the page, stepping by the small block size.}\par
00201     {\cf19 for} ({\cf18 size_t} offset = 0; (offset + Desc->BlockSize) <= HeaderBlockSize; offset += Desc->BlockSize) \{\par
00202         {\cf20 // newBlock points to the start of this Desc->BlockSize chunk.}\par
00203         PPOOL_HEADER newBlock = (PPOOL_HEADER)((uint8_t*)PageVa + offset);\par
00204 \par
00205         {\cf20 // Set its header metadata.}\par
00206         newBlock->Metadata.BlockSize = Desc->BlockSize;\par
00207         newBlock->Metadata.PoolIndex = PoolIndex;\par
00208         newBlock->PoolCanary = {\cf22 'BEKA'}; {\cf20 // Pool Canary}\par
00209         newBlock->PoolTag = {\cf22 'ADIR'}; {\cf20 // Default Tag}\par
00210         \par
00211         {\cf20 // Add this block to the list of the descriptor.}\par
00212         newBlock->Metadata.FreeListEntry.Next = Desc->FreeListHead.Next;\par
00213         Desc->FreeListHead.Next = &newBlock->Metadata.FreeListEntry;\par
00214         Desc->TotalBlocks++;\par
00215         Desc->FreeCount++;\par
00216     \}\par
00217 \par
00218     MsReleaseSpinlock(&Desc->PoolLock, descIrql);\par
00219     {\cf19 return} {\cf17 true};\par
00220 \}\par
00221 \par
00222 {\cf17 static}\par
00223 {\cf18 void}*\par
00224 MiAllocateLargePool(\par
00225     {\cf18 size_t} NumberOfBytes,\par
00226     uint32_t Tag\par
00227 )\par
00228 \par
00229 {\cf20 /*++}\par
00230 {\cf20 }\par
00231 {\cf20     Routine description:}\par
00232 {\cf20 }\par
00233 {\cf20         Allocates a NonPagedPool pool, and returns a pointer to start of region.}\par
00234 {\cf20 }\par
00235 {\cf20     Arguments:}\par
00236 {\cf20 }\par
00237 {\cf20         [IN]    size_t NumberOfBytes - Number of bytes needed to allocate.}\par
00238 {\cf20         [IN]    uint32_t Tag - A 4 byte integer that signifies the current allocation, in little endian (e.g 'TSET' -> 'TEST')}\par
00239 {\cf20 }\par
00240 {\cf20     Return Values:}\par
00241 {\cf20 }\par
00242 {\cf20         Pointer to start of allocated region}\par
00243 {\cf20 }\par
00244 {\cf20 --*/}\par
00245 \par
00246 \{\par
00247     {\cf20 // Large pool allocations are always popped / pushed into the global free list (since its the only one that holds more than 2048 bytes)}\par
00248     IRQL oldIrql;\par
00249     MsAcquireSpinlock(&GlobalPool.PoolLock, &oldIrql);\par
00250 \par
00251     {\cf20 // Compute the actual allocation size in bytes.}\par
00252     {\cf18 size_t} RequiredSize = NumberOfBytes + {\cf17 sizeof}(POOL_HEADER);\par
00253 \par
00254     PSINGLE_LINKED_LIST* PtrToPrevNext = &GlobalPool.FreeListHead.Next;\par
00255     PSINGLE_LINKED_LIST list = GlobalPool.FreeListHead.Next;\par
00256     PPOOL_HEADER foundHeader = NULL;\par
00257 \par
00258     {\cf19 while} (list) \{\par
00259         PPOOL_HEADER header = CONTAINING_RECORD(list, POOL_HEADER, Metadata.FreeListEntry);\par
00260 \par
00261         {\cf19 if} (header->PoolCanary != {\cf22 'BEKA'}) \{\par
00262             MeBugCheckEx(\par
00263                 MEMORY_CORRUPT_HEADER,\par
00264                 ({\cf18 void}*)header,\par
00265                 ({\cf18 void}*)__read_rip(),\par
00266                 NULL,\par
00267                 NULL\par
00268             );\par
00269         \}\par
00270 \par
00271         {\cf19 if} (header->Metadata.BlockSize >= RequiredSize) \{\par
00272             {\cf20 // Found a block that holds the amount of bytes we need!}\par
00273             foundHeader = header;\par
00274             \par
00275             {\cf20 // Unlink it from the list.}\par
00276             *PtrToPrevNext = list->Next;\par
00277             GlobalPool.FreeCount--;\par
00278             {\cf19 break};\par
00279         \}\par
00280 \par
00281         {\cf20 // Didn't find an appropriate block, move to next.}\par
00282         PtrToPrevNext = &list->Next;\par
00283         list = list->Next;\par
00284     \}\par
00285 \par
00286     {\cf20 // Release the lock.}\par
00287     MsReleaseSpinlock(&GlobalPool.PoolLock, oldIrql);\par
00288 \par
00289     {\cf20 // Now lets check if we found a block or we didn't.}\par
00290     {\cf19 if} (foundHeader) \{\par
00291         {\cf20 // Good, lets set metadata, and return it to the caller.}\par
00292         foundHeader->PoolTag = Tag;\par
00293         {\cf19 return} ({\cf18 void}*)((uint8_t*)foundHeader + {\cf17 sizeof}(POOL_HEADER));\par
00294     \}\par
00295 \par
00296     {\cf20 // Looks like we didn't find a block that has the amount of bytes we need, allocate one.}\par
00297     {\cf18 size_t} neededPages = BYTES_TO_PAGES(RequiredSize);\par
00298 \par
00299     {\cf20 // Allocate contiguous VAs.}\par
00300     uintptr_t pageVa = MiAllocatePoolVa(NonPagedPool, RequiredSize);\par
00301     \par
00302     {\cf19 if} (!pageVa) \{\par
00303         {\cf20 // We don't have enough VA space to allocate required pool.}\par
00304         {\cf19 return} NULL;\par
00305     \}\par
00306 \par
00307     {\cf20 // Now lets loop to request PFNs, we also create a safeguard to unroll the loop if failure happens.}\par
00308     {\cf18 bool} failure = {\cf17 false};\par
00309     {\cf18 size_t} Iterations = 0;\par
00310 \par
00311     {\cf19 for} ({\cf18 size_t} i = 0; i < neededPages; i++) \{\par
00312         {\cf20 // Increment by 4KiB each time.}\par
00313         uint8_t* currVa = (uint8_t*)pageVa + (i * VirtualPageSize);\par
00314 \par
00315         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateFree);\par
00316 \par
00317         {\cf19 if} (pfn == PFN_ERROR) \{\par
00318             {\cf20 // Allocation for a physical page failed, free the VA allocated, and unroll the loop (see code below loop)}\par
00319             MiFreePoolVaContiguous(pageVa, RequiredSize, NonPagedPool);\par
00320             failure = {\cf17 true};\par
00321             {\cf19 break};\par
00322         \}\par
00323 \par
00324         {\cf20 // Map the page.}\par
00325         PMMPTE pte = MiGetPtePointer((uintptr_t)currVa);\par
00326         uint64_t phys = PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(pfn));\par
00327         MI_WRITE_PTE(pte, currVa, phys, PAGE_PRESENT | PAGE_RW);\par
00328         \par
00329         {\cf20 // Update PFN metadata.}\par
00330         PPFN_ENTRY ppfn = INDEX_TO_PPFN(pfn);\par
00331         ppfn->State = PfnStateActive;\par
00332         ppfn->Flags = PFN_FLAG_NONPAGED;\par
00333         ppfn->Descriptor.Mapping.PteAddress = pte;\par
00334 \par
00335         {\cf20 // Update iterations for loop unroll (if failure)}\par
00336         Iterations++;\par
00337     \}\par
00338 \par
00339     {\cf20 // If failure, unroll PFNs using Iterations.}\par
00340     {\cf19 if} (failure) \{\par
00341         {\cf19 for} ({\cf18 size_t} j = 0; j < Iterations; j++) \{\par
00342             uint8_t* vaToFree = (uint8_t*)pageVa + (j * VirtualPageSize);\par
00343             PMMPTE pte = MiGetPtePointer((uintptr_t)vaToFree);\par
00344             PAGE_INDEX pfn = MiTranslatePteToPfn(pte);\par
00345             MiUnmapPte(pte);\par
00346             MiReleasePhysicalPage(pfn);\par
00347         \}\par
00348         {\cf19 return} NULL;\par
00349     \}\par
00350 \par
00351     {\cf20 // Success! Initialize the block and return the pointer to caller.}\par
00352     PPOOL_HEADER newHeader = (PPOOL_HEADER)pageVa;\par
00353     newHeader->PoolCanary = {\cf22 'BEKA'};\par
00354     newHeader->PoolTag = Tag;\par
00355     newHeader->Metadata.BlockSize = neededPages * VirtualPageSize; {\cf20 // Store allocated size.}\par
00356     newHeader->Metadata.PoolIndex = POOL_TYPE_GLOBAL;\par
00357 \par
00358     {\cf18 void}* UserAddress = ({\cf18 void}*)((uint8_t*)newHeader + {\cf17 sizeof}(POOL_HEADER));\par
00359     {\cf20 // Set to zero (to avoid kernel issues)}\par
00360     kmemset(UserAddress, 0, NumberOfBytes);\par
00361     {\cf20 // Return the pointer (exclude metadata start).}\par
00362     {\cf19 return} UserAddress;\par
00363 \}\par
00364 \par
00365 {\cf17 static}\par
00366 {\cf18 void}*\par
00367 MiAllocatePagedPool(\par
00368     IN  {\cf18 size_t} NumberOfBytes,\par
00369     IN  uint32_t Tag\par
00370 )\par
00371 \par
00372 {\cf20 /*++}\par
00373 {\cf20 }\par
00374 {\cf20     Routine description:}\par
00375 {\cf20 }\par
00376 {\cf20         Allocates a paged pool.}\par
00377 {\cf20 }\par
00378 {\cf20     Arguments:}\par
00379 {\cf20 }\par
00380 {\cf20         [IN]    size_t NumberOfBytes - Number of bytes needed to allocate.}\par
00381 {\cf20         [IN]    uint32_t Tag - A 4 byte integer that signifies the current allocation, in big endian (e.g 'TSET' - "TEST")}\par
00382 {\cf20 }\par
00383 {\cf20     Return Values:}\par
00384 {\cf20 }\par
00385 {\cf20         Pointer to allocated region, or NULL on failure.}\par
00386 {\cf20 }\par
00387 {\cf20     Notes:}\par
00388 {\cf20 }\par
00389 {\cf20         This function AND access to it's pool contents MUST be with IRQL < DISPATCH_LEVEL.}\par
00390 {\cf20 }\par
00391 {\cf20 --*/}\par
00392 \par
00393 \{\par
00394     {\cf18 size_t} ActualSize = NumberOfBytes + {\cf17 sizeof}(POOL_HEADER);\par
00395     uintptr_t PagedVa = MiAllocatePoolVa(PagedPool, ActualSize);\par
00396     {\cf19 if} (!PagedVa) {\cf19 return} NULL;\par
00397 \par
00398     PPOOL_HEADER header = (PPOOL_HEADER)PagedVa;\par
00399     {\cf20 // The first page will not be resident in memory anymore, it should be paged in as well, that means that pool free routines will need to be executed at < DISPATCH_LEVEL too.}\par
00400     {\cf20 // Set each page to be a demand lazy allocation.}\par
00401     {\cf18 size_t} NumberOfPages = BYTES_TO_PAGES(ActualSize);\par
00402     {\cf18 size_t} currVa = PagedVa;\par
00403     {\cf19 for} ({\cf18 size_t} i = 0; i < NumberOfPages; i++) \{\par
00404         PMMPTE tmpPte = MiGetPtePointer(currVa);\par
00405         {\cf19 if} (!tmpPte) {\cf19 continue}; {\cf20 // TODO Unroll.}\par
00406         MMPTE TempPte = *tmpPte;\par
00407         {\cf20 // Set the PTE as demand zero.}\par
00408         MM_SET_DEMAND_ZERO_PTE(TempPte, PROT_KERNEL_READ | PROT_KERNEL_WRITE, {\cf17 false});\par
00409         {\cf20 // Atomically exchange new value.}\par
00410         MiAtomicExchangePte(tmpPte, TempPte.Value);\par
00411         {\cf20 // Invalidate the VA.}\par
00412         MiInvalidateTlbForVa(({\cf18 void}*)currVa);\par
00413         currVa += VirtualPageSize;\par
00414     \}\par
00415 \par
00416     {\cf20 // Set metadata. (header should get paged in now).}\par
00417     header->PoolCanary = {\cf22 'BEKA'};\par
00418     header->PoolTag = Tag;\par
00419     header->Metadata.BlockSize = ActualSize;\par
00420     header->Metadata.PoolIndex = POOL_TYPE_PAGED;\par
00421 \par
00422     {\cf20 // Return VA.}\par
00423     {\cf19 return} ({\cf18 void}*)((uint8_t*)PagedVa + {\cf17 sizeof}(POOL_HEADER));\par
00424 \}\par
00425 \par
00426 {\cf18 void}*\par
00427 MmAllocatePoolWithTag(\par
00428     IN {\cf17 enum} _POOL_TYPE PoolType,\par
00429     IN  {\cf18 size_t} NumberOfBytes,\par
00430     IN  uint32_t Tag\par
00431 )\par
00432 \par
00433 {\cf20 /*++}\par
00434 {\cf20 }\par
00435 {\cf20     Routine description:}\par
00436 {\cf20 }\par
00437 {\cf20         Allocates a pool block of the specified type and returns a pointer to allocated block.}\par
00438 {\cf20         On any allocation, the returned block(s) is/are zeroed, no exceptions.}\par
00439 {\cf20 }\par
00440 {\cf20     Arguments:}\par
00441 {\cf20 }\par
00442 {\cf20         [IN]    enum _POOL_TYPE - POOL_TYPE Enumerator, specifying the type of pool that will be allocated.}\par
00443 {\cf20         [IN]    size_t NumberOfBytes - Number of bytes needed to allocate.}\par
00444 {\cf20         [IN]    uint32_t Tag - A 4 byte integer that signifies the current allocation, in big endian (e.g 'TSET' - "TEST")}\par
00445 {\cf20 }\par
00446 {\cf20     Return Values:}\par
00447 {\cf20 }\par
00448 {\cf20         Pointer to allocated region, or NULL on failure.}\par
00449 {\cf20 }\par
00450 {\cf20     Notes:}\par
00451 {\cf20 }\par
00452 {\cf20         PagedPool allocations CANNOT happen at IRQL => DISPATCH_LEVEL.}\par
00453 {\cf20         NonPagedPool allocations CANNOT happen at IRQL > DISPATCH_LEVEL.}\par
00454 {\cf20 }\par
00455 {\cf20 --*/}\par
00456 \par
00457 \{\par
00458     {\cf20 // Declarations}\par
00459     IRQL oldIrql;\par
00460     {\cf18 size_t} ActualSize;\par
00461     PPROCESSOR cpu;\par
00462     PPOOL_DESCRIPTOR Desc;\par
00463     PPOOL_HEADER header;\par
00464     PSINGLE_LINKED_LIST list;\par
00465     {\cf18 size_t} Index;\par
00466 \par
00467     {\cf20 // Runtime assertions}\par
00468     {\cf20 //assert((NumberOfBytes) != 0); Better to use the if statement, supplies retaddr.}\par
00469     assert((Tag) != 0);\par
00470 \par
00471     {\cf19 if} (NumberOfBytes == 0) \{\par
00472         {\cf20 // Bad pool caller.}\par
00473         MeBugCheckEx(\par
00474             BAD_POOL_CALLER,\par
00475             RETADDR(0),\par
00476             NULL,\par
00477             NULL,\par
00478             NULL\par
00479         );\par
00480     \}\par
00481 \par
00482     IRQL currIrql = MeGetCurrentIrql();\par
00483 \par
00484     {\cf20 // IRQL Must be less or equal to DISPATCH_LEVEL if allocating with NonPagedPool.}\par
00485     {\cf20 // IRQL Must be LESS than DISPATCH_LEVEL if allocating with PagedPool.}\par
00486     {\cf19 if} (currIrql <= DISPATCH_LEVEL) \{\par
00487         {\cf19 if} (PoolType == PagedPool && currIrql == DISPATCH_LEVEL) \{\par
00488             MeBugCheckEx(\par
00489                 BAD_POOL_CALLER,\par
00490                 ({\cf18 void}*)&MmAllocatePoolWithTag,\par
00491                 ({\cf18 void}*)MeGetCurrentIrql(),\par
00492                 ({\cf18 void}*)8,\par
00493                 ({\cf18 void}*)__builtin_return_address(0)\par
00494             );\par
00495         \}\par
00496     \}\par
00497     {\cf20 // IRQL Must NOT be greater than DISPATCH_LEVEL at any allocation.}\par
00498     {\cf19 else} \{\par
00499         MeBugCheckEx(\par
00500             BAD_POOL_CALLER,\par
00501             ({\cf18 void}*)&MmAllocatePoolWithTag,\par
00502             ({\cf18 void}*)MeGetCurrentIrql(),\par
00503             ({\cf18 void}*)8,\par
00504             ({\cf18 void}*)__builtin_return_address(0)\par
00505         );\par
00506     \}\par
00507 \par
00508     {\cf19 if} (PoolType == PagedPool) \{\par
00509         {\cf20 // Use the internal paged pool allocator.}\par
00510         {\cf19 return} MiAllocatePagedPool(NumberOfBytes, Tag);\par
00511     \}\par
00512 \par
00513     ActualSize = NumberOfBytes + {\cf17 sizeof}(POOL_HEADER);\par
00514     cpu = MeGetCurrentProcessor();\par
00515 \par
00516 \par
00517     {\cf20 // It's NonPagedPool. Find the correct slab.}\par
00518     Desc = NULL;\par
00519     {\cf19 for} ({\cf18 int} i = 0; i < MAX_POOL_DESCRIPTORS; i++) \{\par
00520         PPOOL_DESCRIPTOR currentSlab = &cpu->LookasidePools[i];\par
00521         {\cf19 if} (ActualSize <= currentSlab->BlockSize) \{\par
00522             Desc = currentSlab;\par
00523             Index = i;\par
00524             {\cf19 break}; {\cf20 // Found the best-fit slab}\par
00525         \}\par
00526     \}\par
00527 \par
00528     {\cf19 if} (Desc == NULL) \{\par
00529         {\cf20 // Allocation is larger than 2048 bytes, use the large pool allocator.}\par
00530         {\cf19 return} MiAllocateLargePool(NumberOfBytes, Tag);\par
00531     \}\par
00532     \par
00533     MsAcquireSpinlock(&Desc->PoolLock, &oldIrql);\par
00534     assert((Desc->FreeCount) != UINT64_T_MAX);\par
00535 \par
00536     {\cf19 if} (Desc->FreeCount == 0) \{\par
00537         {\cf20 // Looks like the pool is empty, refill all empty pools.}\par
00538         {\cf20 // First, release the spinlock.}\par
00539         MsReleaseSpinlock(&Desc->PoolLock, oldIrql);\par
00540         {\cf19 if} (!MiRefillPool(Desc, Index)) \{\par
00541             {\cf20 // If we failed allocation, act on failure.}\par
00542             {\cf19 return} NULL;\par
00543         \}\par
00544         {\cf20 // Retry allocation.}\par
00545         {\cf19 return} MmAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);\par
00546     \}\par
00547 \par
00548     {\cf20 // Looks like we have a block to return! Return its PTR.}\par
00549     {\cf20 // First, acquire it. (we are under spinlock, no need for interlocked pop)}\par
00550     list = Desc->FreeListHead.Next;\par
00551     assert((list) != NULL, {\cf22 "Pool is nullptr even though freecount isn't zero."});\par
00552     Desc->FreeListHead.Next = list->Next; {\cf20 // Finish the pop}\par
00553     header = CONTAINING_RECORD(list, POOL_HEADER, Metadata.FreeListEntry);\par
00554 \par
00555     {\cf20 // We must restore the metadata because the linked list pointer }\par
00556     {\cf20 // overwrote it while the block was sitting in the free list.}\par
00557     header->Metadata.PoolIndex = (uint16_t)Index;\par
00558     header->Metadata.BlockSize = (uint16_t)Desc->BlockSize;\par
00559 \par
00560     {\cf20 // First check if the canary is wrong.}\par
00561     {\cf19 if} (header->PoolCanary != {\cf22 'BEKA'}) \{\par
00562         MeBugCheckEx(\par
00563             MEMORY_CORRUPT_HEADER,\par
00564             ({\cf18 void}*)header,\par
00565             ({\cf18 void}*)__read_rip(),\par
00566             NULL,\par
00567             NULL\par
00568         );\par
00569     \}\par
00570 \par
00571     {\cf20 // Rewrite its tag.}\par
00572     header->PoolTag = Tag;\par
00573     {\cf20 // Decrement descriptor free count.}\par
00574     Desc->FreeCount--;\par
00575     assert((Desc->FreeCount) != SIZE_T_MAX); {\cf20 // Check for underflow.}\par
00576     {\cf20 // Release spinlock.}\par
00577     MsReleaseSpinlock(&Desc->PoolLock, oldIrql);\par
00578     {\cf18 void}* UserAddress = ({\cf18 void}*)((uint8_t*)header + {\cf17 sizeof}(POOL_HEADER));\par
00579     {\cf20 // Set to zero (to avoid kernel issues)}\par
00580     kmemset(UserAddress, 0, NumberOfBytes);\par
00581     {\cf20 // Return the pointer (exclude metadata start).}\par
00582     {\cf19 return} UserAddress;\par
00583 \}\par
00584 \par
00585 {\cf18 void}\par
00586 MmFreePool(\par
00587     IN  {\cf18 void}* buf\par
00588 )\par
00589 \par
00590 {\cf20 /*++}\par
00591 {\cf20 }\par
00592 {\cf20     Routine description:}\par
00593 {\cf20 }\par
00594 {\cf20         Deallocates the buffer allocated by the MmAllocatePoolWithTag routine (or other pool allocation routines if present).}\par
00595 {\cf20 }\par
00596 {\cf20     Arguments:}\par
00597 {\cf20 }\par
00598 {\cf20         [IN]    void* buf - The pointer given by the routine. (start of allocated region)}\par
00599 {\cf20 }\par
00600 {\cf20     Return Values:}\par
00601 {\cf20 }\par
00602 {\cf20         None.}\par
00603 {\cf20 }\par
00604 {\cf20     Notes:}\par
00605 {\cf20 }\par
00606 {\cf20         Memory is freed here, do not use the pointer after freeing the pool.}\par
00607 {\cf20         The Pool tag will not be modified when freeing, useful for debugging.}\par
00608 {\cf20 }\par
00609 {\cf20         Memory allocated with PagedPoolXxX type must be deallocated at IRQL < DISPATCH_LEVEL.}\par
00610 {\cf20 }\par
00611 {\cf20 --*/}\par
00612 \par
00613 \{\par
00614     {\cf19 if} (!buf) {\cf19 return};\par
00615     assert(MeGetCurrentIrql() <= DISPATCH_LEVEL);\par
00616 \par
00617     {\cf20 // Convert the buffer to the header.}\par
00618     PPOOL_HEADER header = (PPOOL_HEADER)((uint8_t*)buf - {\cf17 sizeof}(POOL_HEADER));\par
00619 \par
00620     gop_printf(COLOR_YELLOW, {\cf22 "MmFreePool called with IRQL: %d | Header: %p\\n"}, MeGetCurrentIrql(), header);\par
00621 \par
00622     {\cf19 if} (header->PoolCanary != {\cf22 'BEKA'}) \{\par
00623         MeBugCheckEx(\par
00624             MEMORY_CORRUPT_HEADER,\par
00625             ({\cf18 void}*)header,\par
00626             ({\cf18 void}*)RETADDR(0),\par
00627             NULL,\par
00628             NULL\par
00629         );\par
00630     \}\par
00631 \par
00632     {\cf20 // Obtain the pool index to free the region back into.}\par
00633     uint16_t PoolIndex = header->Metadata.PoolIndex;\par
00634 \par
00635     {\cf19 if} (PoolIndex == POOL_TYPE_GLOBAL) \{\par
00636         {\cf20 // Big pool allocation, return it to the global pool.}\par
00637         IRQL oldIrql;\par
00638         MsAcquireSpinlock(&GlobalPool.PoolLock, &oldIrql);\par
00639 \par
00640         {\cf20 // Push the block back onto the global free list}\par
00641         header->Metadata.FreeListEntry.Next = GlobalPool.FreeListHead.Next;\par
00642         GlobalPool.FreeListHead.Next = &header->Metadata.FreeListEntry;\par
00643         GlobalPool.FreeCount++;\par
00644 \par
00645         MsReleaseSpinlock(&GlobalPool.PoolLock, oldIrql);\par
00646         {\cf19 return};\par
00647     \}\par
00648 \par
00649     {\cf19 if} (PoolIndex == POOL_TYPE_PAGED) \{\par
00650         assert(MeGetCurrentIrql() < DISPATCH_LEVEL); {\cf20 // I mean, this assertion is KINDA useless, as we cant get here in the first place, since we would IRQL_NOT_LESS_OR_EQUAL while acquiring the index.}\par
00651         {\cf20 // For a paged pool allocation, we just free every PTE, then returned the VA space consumed.}\par
00652         {\cf20 // The BlockSize field in a PagedPool allocation is how many bytes were requested + sizeof(POOL_HEADER)}\par
00653         {\cf18 size_t} NumberOfPages = BYTES_TO_PAGES(header->Metadata.BlockSize);\par
00654 \par
00655         {\cf20 // Loop over the amount, if the PTE is present, unmap it and clear the demand page.}\par
00656         uintptr_t CurrentVA = (uintptr_t)header;\par
00657 \par
00658         {\cf19 for} ({\cf18 size_t} i = 0; i < NumberOfPages; i++) \{\par
00659             PMMPTE pte = MiGetPtePointer(CurrentVA);\par
00660             {\cf19 if} (!pte) {\cf19 goto} advance;\par
00661             assert(MM_IS_DEMAND_ZERO_PTE(*pte) == {\cf17 true});\par
00662 \par
00663             {\cf20 // Check if the PTE is present, if it is, the demand zero page has been consumed, we deallocate, and unset the demand zero.}\par
00664             {\cf19 if} (pte->Hard.Present) \{\par
00665                 {\cf20 // It has a PFN.}\par
00666                 PAGE_INDEX Pfn = MiTranslatePteToPfn(pte);\par
00667 \par
00668                 {\cf20 // Unmap PTE, free PFN.}\par
00669                 MiUnmapPte(pte);\par
00670                 MiReleasePhysicalPage(Pfn);\par
00671             \}\par
00672 \par
00673             {\cf20 // Flip the demand zero bit.}\par
00674             MMPTE TempPte = *pte;\par
00675             MM_UNSET_DEMAND_ZERO_PTE(TempPte);\par
00676             MiAtomicExchangePte(pte, TempPte.Value);\par
00677             {\cf20 // Invalidate the VA.}\par
00678             MiInvalidateTlbForVa(({\cf18 void}*)CurrentVA);\par
00679 \par
00680             advance:\par
00681             CurrentVA += VirtualPageSize;\par
00682         \}\par
00683         {\cf19 return};\par
00684     \}\par
00685 \par
00686     {\cf20 //}\par
00687     {\cf20 // Nonpaged pool allocation}\par
00688     {\cf20 //}\par
00689 \par
00690     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00691     PPOOL_DESCRIPTOR Desc = &cpu->LookasidePools[PoolIndex];\par
00692 \par
00693     {\cf20 // Acquire the same lock used by the allocator}\par
00694     IRQL oldIrql;\par
00695     MsAcquireSpinlock(&Desc->PoolLock, &oldIrql);\par
00696 \par
00697     {\cf20 // Push the entry back onto the list (it's protected by the lock)}\par
00698     header->Metadata.FreeListEntry.Next = Desc->FreeListHead.Next;\par
00699     Desc->FreeListHead.Next = &header->Metadata.FreeListEntry;\par
00700 \par
00701     {\cf20 // Increment the free count.}\par
00702     Desc->FreeCount++;\par
00703 \par
00704     {\cf20 // Release the lock}\par
00705     MsReleaseSpinlock(&Desc->PoolLock, oldIrql);\par
00706 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/va.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/va.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/va.c}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/ps.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MiInitializePoolVaSpace} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b MiBitmapTestBit} (uint64_t *bitmap, size_t bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b MiBitmapTestAndSetBitLocked} (uint64_t *bitmap, size_t bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MiBitmapClearBitLocked} (uint64_t *bitmap, size_t bit)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uintptr_t {\b MiIndexToVa} (uintptr_t poolBase, size_t index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} size_t {\b MiVaToIndex} (uintptr_t poolBase, uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MiAllocatePoolVa} ({\b IN} {\b POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiFreePoolVaContiguous} ({\b IN} uintptr_t va, {\b IN} size_t NumberOfBytes, {\b IN} {\b POOL_TYPE} PoolType)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiAllocatePoolVa\:va.c}
{\xe \v va.c\:MiAllocatePoolVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MiAllocatePoolVa ({\b IN} {\b POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes)}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b va.c}.}\par
}
{\xe \v MiBitmapClearBitLocked\:va.c}
{\xe \v va.c\:MiBitmapClearBitLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MiBitmapClearBitLocked (uint64_t * bitmap, size_t bit)}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b va.c}.}\par
}
{\xe \v MiBitmapTestAndSetBitLocked\:va.c}
{\xe \v va.c\:MiBitmapTestAndSetBitLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool MiBitmapTestAndSetBitLocked (uint64_t * bitmap, size_t bit)}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b va.c}.}\par
}
{\xe \v MiBitmapTestBit\:va.c}
{\xe \v va.c\:MiBitmapTestBit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool MiBitmapTestBit (uint64_t * bitmap, size_t bit)}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b va.c}.}\par
}
{\xe \v MiFreePoolVaContiguous\:va.c}
{\xe \v va.c\:MiFreePoolVaContiguous}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiFreePoolVaContiguous ({\b IN} uintptr_t va, {\b IN} size_t NumberOfBytes, {\b IN} {\b POOL_TYPE} PoolType)}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 367} of file {\b va.c}.}\par
}
{\xe \v MiIndexToVa\:va.c}
{\xe \v va.c\:MiIndexToVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uintptr_t MiIndexToVa (uintptr_t poolBase, size_t index)}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b va.c}.}\par
}
{\xe \v MiInitializePoolVaSpace\:va.c}
{\xe \v va.c\:MiInitializePoolVaSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MiInitializePoolVaSpace (void )}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b va.c}.}\par
}
{\xe \v MiVaToIndex\:va.c}
{\xe \v va.c\:MiVaToIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} size_t MiVaToIndex (uintptr_t poolBase, uintptr_t va)}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b va.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
va.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/va.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/va.c}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     va.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of virtual address pool of the kernel.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/mm.h"}\par
00020 {\cf21 #include "../../includes/ps.h"}\par
00021 \par
00022 {\cf20 // NONPAGED ----}\par
00023 {\cf17 static} uint64_t* g_NonpagedPoolVaBitmap;\par
00024 \par
00025 {\cf20 // Hint for next search}\par
00026 {\cf17 static} {\cf17 volatile} uint64_t g_NonpagedPoolHintIndex = 0;\par
00027 \par
00028 {\cf20 // PAGED ----}\par
00029 {\cf17 static} uint64_t* g_PagedPoolVaBitmap;\par
00030 \par
00031 {\cf20 // Hint for next search}\par
00032 {\cf17 static} {\cf17 volatile} uint64_t g_PagedPoolHintIndex = 0;\par
00033 \par
00034 {\cf18 bool}\par
00035 MiInitializePoolVaSpace(\par
00036     {\cf18 void}\par
00037 )\par
00038 \par
00039 {\cf20 /*++}\par
00040 {\cf20 }\par
00041 {\cf20     Routine description:}\par
00042 {\cf20 }\par
00043 {\cf20         Initializes the nonpaged & paged pool virtual address bitmap.}\par
00044 {\cf20 }\par
00045 {\cf20     Arguments:}\par
00046 {\cf20 }\par
00047 {\cf20         None.}\par
00048 {\cf20 }\par
00049 {\cf20     Return Values:}\par
00050 {\cf20 }\par
00051 {\cf20         True or False based on succession.}\par
00052 {\cf20 }\par
00053 {\cf20 --*/}\par
00054 \par
00055 \{\par
00056     {\cf20 // Initialize the nonpaged bitmap first.}\par
00057     uintptr_t currNpgBitmapVa = MI_NONPAGED_BITMAP_BASE;\par
00058     uintptr_t currPgBitmapVa = MI_PAGED_BITMAP_BASE;\par
00059 \par
00060     {\cf19 for} ({\cf18 size_t} i = 0; i < MI_NONPAGED_BITMAP_PAGES_NEEDED; i++) \{\par
00061         {\cf20 // Request a physical page.}\par
00062         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00063         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} {\cf17 false}; {\cf20 // Would bugcheck, no need for physical page release back. (loop unroll)}\par
00064 \par
00065         {\cf20 // Get the PTE ptr for the curr va.}\par
00066         PMMPTE pte = MiGetPtePointer(currNpgBitmapVa);\par
00067         {\cf19 if} (!pte) {\cf19 return} {\cf17 false};\par
00068         {\cf20 // Get the physical address of the PFN.}\par
00069         uint64_t phys = PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(pfn));\par
00070         {\cf20 // Map it.}\par
00071         MI_WRITE_PTE(pte, currNpgBitmapVa, phys, PAGE_PRESENT | PAGE_RW);\par
00072 \par
00073         {\cf20 // Set the PFNs states.}\par
00074         PPFN_ENTRY pfnEntry = INDEX_TO_PPFN(pfn);\par
00075         pfnEntry->State = PfnStateActive;\par
00076         pfnEntry->Flags = PFN_FLAG_NONPAGED;\par
00077         pfnEntry->Descriptor.Mapping.PteAddress = pte;\par
00078         pfnEntry->Descriptor.Mapping.Vad = NULL; {\cf20 // Not VAD-backed}\par
00079 \par
00080         {\cf20 // Advance VA by 4KiB.}\par
00081         currNpgBitmapVa += VirtualPageSize;\par
00082     \}\par
00083 \par
00084     {\cf19 for} ({\cf18 size_t} i = 0; i < MI_PAGED_BITMAP_PAGES_NEEDED; i++) \{\par
00085         {\cf20 // Request a physical page.}\par
00086         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00087         {\cf19 if} (pfn == PFN_ERROR) {\cf19 return} {\cf17 false}; {\cf20 // Would bugcheck, no need for physical page release back. (loop unroll)}\par
00088 \par
00089         {\cf20 // Get the PTE ptr for the curr va.}\par
00090         PMMPTE pte = MiGetPtePointer(currPgBitmapVa);\par
00091         {\cf19 if} (!pte) {\cf19 return} {\cf17 false};\par
00092         {\cf20 // Get the physical address of the PFN.}\par
00093         uint64_t phys = PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(pfn));\par
00094         {\cf20 // Map it.}\par
00095         MI_WRITE_PTE(pte, currNpgBitmapVa, phys, PAGE_PRESENT | PAGE_RW);\par
00096 \par
00097         {\cf20 // Set the PFNs states.}\par
00098         PPFN_ENTRY pfnEntry = INDEX_TO_PPFN(pfn);\par
00099         pfnEntry->State = PfnStateActive;\par
00100         pfnEntry->Flags = PFN_FLAG_NONPAGED;\par
00101         pfnEntry->Descriptor.Mapping.PteAddress = pte;\par
00102         pfnEntry->Descriptor.Mapping.Vad = NULL; {\cf20 // Not VAD-backed}\par
00103 \par
00104         {\cf20 // Advance VA by 4KiB.}\par
00105         currPgBitmapVa += VirtualPageSize;\par
00106     \}\par
00107 \par
00108     g_NonpagedPoolVaBitmap = (uint64_t*)MI_NONPAGED_BITMAP_BASE;\par
00109     g_PagedPoolVaBitmap = (uint64_t*)MI_PAGED_BITMAP_BASE;\par
00110 \par
00111     {\cf20 // Both bitmaps are mapped, begin building them.}\par
00112     {\cf20 // Initialize both bitmaps to FREE.}\par
00113     {\cf18 size_t} nonpaged_bitmap_bytes = (size_t)NONPAGED_POOL_VA_BITMAP_QWORDS * {\cf17 sizeof}(uint64_t);\par
00114     {\cf18 size_t} paged_bitmap_bytes = (size_t)PAGED_POOL_VA_BITMAP_QWORDS * {\cf17 sizeof}(uint64_t);\par
00115 \par
00116     kmemset(g_NonpagedPoolVaBitmap, 0, nonpaged_bitmap_bytes);\par
00117     kmemset(g_PagedPoolVaBitmap, 0, paged_bitmap_bytes);\par
00118     \par
00119     {\cf20 // Initialize hints.}\par
00120     g_NonpagedPoolHintIndex = 0;\par
00121     g_PagedPoolHintIndex = 0;\par
00122 \par
00123     {\cf20 // Both bitmaps fully setupped}\par
00124     {\cf19 return} {\cf17 true};\par
00125 \}\par
00126 \par
00127 {\cf20 // Testing and applying functions.}\par
00128 \par
00129 FORCEINLINE\par
00130 {\cf18 bool}\par
00131 MiBitmapTestBit(\par
00132     uint64_t* bitmap,\par
00133     {\cf18 size_t} bit\par
00134 )\par
00135 \par
00136 {\cf20 // Description: Tests a bit in the bitmap provided.}\par
00137 {\cf20 // Return Values: True if bit is set, false otherwise}\par
00138 \par
00139 \{\par
00140     {\cf18 size_t} q = bit >> 6; {\cf20 // QWORD Index}\par
00141     {\cf18 size_t} b = bit & 63; {\cf20 // Bit index within that qword.}\par
00142 \par
00143     {\cf20 // Atomically read the 64bit word.}\par
00144     uint64_t value = InterlockedFetchU64(({\cf17 volatile} uint64_t*)&bitmap[q]);\par
00145     {\cf19 return} (value >> b) & 1ULL;\par
00146 \}\par
00147 \par
00148 FORCEINLINE\par
00149 {\cf18 bool}\par
00150 MiBitmapTestAndSetBitLocked(\par
00151     uint64_t* bitmap,\par
00152     {\cf18 size_t} bit\par
00153 )\par
00154 \par
00155 {\cf20 // Description: This routine tests if the bit isn't set, and if so, sets it, and returns true (all atomically). Otherwise, returns false.}\par
00156 \par
00157 \{\par
00158     {\cf18 size_t} q = bit >> 6;\par
00159     {\cf18 size_t} b = bit & 63;\par
00160     uint64_t mask = (1ULL << b);\par
00161 \par
00162     {\cf20 // Atomically OR the mask in and return the original qword value}\par
00163     uint64_t old_qword = __sync_fetch_and_or(&bitmap[q], mask);\par
00164 \par
00165     {\cf20 // Return 'true' if our bit was NOT set in the old value}\par
00166     {\cf19 return} (old_qword & mask) == 0;\par
00167 \}\par
00168 \par
00169 FORCEINLINE\par
00170 {\cf18 void}\par
00171 MiBitmapClearBitLocked(\par
00172     uint64_t* bitmap,\par
00173     {\cf18 size_t} bit\par
00174 )\par
00175 \par
00176 {\cf20 // Description: Clears a bit from locked in the bitmap.}\par
00177 {\cf20 // Return Values: None.}\par
00178 \par
00179 \{\par
00180     {\cf18 size_t} q = bit >> 6;\par
00181     {\cf18 size_t} b = bit & 63;\par
00182     {\cf20 // ~ signifies the opposite of the set.}\par
00183     InterlockedAndU64(({\cf17 volatile} uint64_t*)&bitmap[q], ~(1ULL << b));\par
00184 \}\par
00185 \par
00186 FORCEINLINE\par
00187 uintptr_t\par
00188 MiIndexToVa(\par
00189     uintptr_t poolBase,\par
00190     {\cf18 size_t} index\par
00191 )\par
00192 \par
00193 {\cf20 // Converts a pool base index to its corresponding virtual address.}\par
00194 \par
00195 \{\par
00196     {\cf19 return} poolBase + (index * VirtualPageSize);\par
00197 \}\par
00198 \par
00199 FORCEINLINE\par
00200 {\cf18 size_t}\par
00201 MiVaToIndex(\par
00202     uintptr_t poolBase,\par
00203     uintptr_t va\par
00204 )\par
00205 \par
00206 {\cf20 // Converts a VA into its corresponding Pool index.}\par
00207 \par
00208 \{\par
00209     {\cf19 return} (va - poolBase) / VirtualPageSize; {\cf20 // The caller must ensure the VA is in range.}\par
00210 \}\par
00211 \par
00212 uintptr_t\par
00213 MiAllocatePoolVa(\par
00214     IN  POOL_TYPE PoolType,\par
00215     IN  {\cf18 size_t} NumberOfBytes\par
00216 )\par
00217 \par
00218 {\cf20 /*++}\par
00219 {\cf20 }\par
00220 {\cf20     Routine description:}\par
00221 {\cf20 }\par
00222 {\cf20         Searches for a free VA (NumberOfBytes size) in the pool, and returns it.}\par
00223 {\cf20 }\par
00224 {\cf20     Arguments:}\par
00225 {\cf20 }\par
00226 {\cf20         [IN] POOL_TYPE PoolType - The type of pool to return the VA for.}\par
00227 {\cf20         [IN] size_t NumberOfBytes - The amount of contingious VA bytes to find for. (rounds up to next page)}\par
00228 {\cf20 }\par
00229 {\cf20     Return Values:}\par
00230 {\cf20 }\par
00231 {\cf20         The VA on success, otherwise 0 on failure.}\par
00232 {\cf20 }\par
00233 {\cf20     Notes:}\par
00234 {\cf20 }\par
00235 {\cf20         The returned VA is not mapped to any physical memory.}\par
00236 {\cf20 }\par
00237 {\cf20 --*/}\par
00238 \par
00239 \{\par
00240     {\cf20 // Declarations for mixed pools}\par
00241     {\cf18 size_t} total_pages, total_qwords;\par
00242     {\cf18 size_t} hint;\par
00243     uint64_t* bitmap;\par
00244     uintptr_t poolBase;\par
00245     {\cf17 volatile} uint64_t* hintIndexPtr;\par
00246 \par
00247     {\cf20 // Calculate pages needed, rounding up.}\par
00248     {\cf18 size_t} NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);\par
00249     {\cf19 if} (NumberOfPages == 0) {\cf19 return} 0;\par
00250 \par
00251     {\cf20 // Set-up pool specific parameters.}\par
00252     {\cf19 if} (PoolType == NonPagedPool) \{\par
00253         total_pages = NONPAGED_POOL_VA_TOTAL_PAGES;\par
00254         hint = (size_t)InterlockedFetchU64(&g_NonpagedPoolHintIndex);\par
00255         bitmap = g_NonpagedPoolVaBitmap;\par
00256         poolBase = MI_NONPAGED_POOL_BASE;\par
00257         hintIndexPtr = &g_NonpagedPoolHintIndex;\par
00258     \}\par
00259     {\cf19 else} {\cf19 if} (PoolType == PagedPool) \{\par
00260         total_pages = PAGED_POOL_VA_TOTAL_PAGES;\par
00261         hint = (size_t)InterlockedFetchU64(&g_PagedPoolHintIndex);\par
00262         bitmap = g_PagedPoolVaBitmap;\par
00263         poolBase = MI_PAGED_POOL_BASE;\par
00264         hintIndexPtr = &g_PagedPoolHintIndex;\par
00265     \}\par
00266     {\cf19 else} \{\par
00267         {\cf20 // Invalid parameter.}\par
00268         {\cf19 return} 0;\par
00269     \}\par
00270 \par
00271     total_qwords = total_pages / 64;\par
00272 \par
00273     {\cf20 // SINGLE PAGE ALLOCATION}\par
00274     {\cf19 if} (NumberOfPages == 1) \{\par
00275         {\cf18 size_t} start_q = (hint / 64) % total_qwords;\par
00276 \par
00277         {\cf20 // Scan qword-by-qword}\par
00278         {\cf19 for} ({\cf18 size_t} i = 0; i < total_qwords; i++) \{\par
00279             {\cf18 size_t} q_idx = (start_q + i) % total_qwords;\par
00280 \par
00281             {\cf20 // rescan loop}\par
00282             {\cf19 while} ({\cf17 true})\par
00283             \{\par
00284                 uint64_t qword = bitmap[q_idx];\par
00285                 {\cf19 if} (qword == 0xFFFFFFFFFFFFFFFFULL) \{\par
00286                     {\cf19 break}; {\cf20 // This qword is full, move to the next q_idx}\par
00287                 \}\par
00288 \par
00289                 uint64_t inverted_qword = ~qword;\par
00290                 {\cf18 unsigned} {\cf18 long} bit_index_in_qword = __builtin_ctzll(inverted_qword);\par
00291                 {\cf18 size_t} global_bit_idx = (q_idx * 64) + bit_index_in_qword;\par
00292 \par
00293                 {\cf19 if} (MiBitmapTestAndSetBitLocked(bitmap, global_bit_idx)) \{\par
00294                     {\cf20 // We successfully claimed it!}\par
00295                     InterlockedExchangeU64(hintIndexPtr, (uint64_t)(global_bit_idx + 1));\par
00296                     {\cf19 return} MiIndexToVa(poolBase, global_bit_idx);\par
00297                 \}\par
00298                 {\cf20 // If we failed, another CPU beat us. The while(true) loop}\par
00299                 {\cf20 // will just retry on the same qword.}\par
00300             \}\par
00301         \}\par
00302         {\cf19 return} 0; {\cf20 // No free VA pages found}\par
00303     \}\par
00304 \par
00305     {\cf20 // CONTINGUOUS PAGE ALLOCATION}\par
00306     {\cf18 size_t} start_idx = hint % total_pages;\par
00307     {\cf18 size_t} contiguous_found = 0;\par
00308     {\cf18 size_t} start_of_run_idx = 0;\par
00309 \par
00310     {\cf20 // This loop must check every bit.}\par
00311     {\cf19 for} ({\cf18 size_t} i = 0; i < total_pages; i++) \{\par
00312         {\cf18 size_t} current_idx = (start_idx + i) % total_pages;\par
00313 \par
00314         {\cf20 // We can't use TestAndSet yet. Just read the bit.}\par
00315         {\cf19 if} (MiBitmapTestBit(bitmap, current_idx)) \{\par
00316             {\cf20 // This bit is set. Reset our contiguous run.}\par
00317             contiguous_found = 0;\par
00318             {\cf19 continue};\par
00319         \}\par
00320 \par
00321         {\cf20 // Free bit.}\par
00322         {\cf19 if} (contiguous_found == 0) \{\par
00323             {\cf20 // This is the start of a potential run}\par
00324             start_of_run_idx = current_idx;\par
00325         \}\par
00326         contiguous_found++;\par
00327 \par
00328         {\cf19 if} (current_idx < start_of_run_idx) \{\par
00329             contiguous_found = 0; {\cf20 // Wrapped around, reset}\par
00330             {\cf19 continue};\par
00331         \}\par
00332 \par
00333         {\cf20 // Do we have enough pages?}\par
00334         {\cf19 if} (contiguous_found == NumberOfPages) \{\par
00335             {\cf20 // We found a potential run from 'start_of_run_idx' for NumberOfPages, attempt to claim all of them.}\par
00336 \par
00337             {\cf18 size_t} j = 0;\par
00338             {\cf19 for} (; j < NumberOfPages; j++) \{\par
00339                 {\cf18 size_t} idx_to_claim = start_of_run_idx + j;\par
00340 \par
00341                 {\cf19 if} (!MiBitmapTestAndSetBitLocked(bitmap, idx_to_claim)) \{\par
00342                     {\cf20 // WE FAILED! Another CPU grabbed a bit in our run.}\par
00343                     {\cf20 // We must roll back all the bits we *did* claim.}\par
00344                     {\cf19 for} ({\cf18 size_t} k = 0; k < j; k++) \{\par
00345                         MiBitmapClearBitLocked(bitmap, start_of_run_idx + k);\par
00346                     \}\par
00347 \par
00348                     {\cf20 // Reset contiguous_found and continue the outer search}\par
00349                     contiguous_found = 0;\par
00350                     {\cf19 break}; {\cf20 // Break from this 'j' loop}\par
00351                 \}\par
00352             \}\par
00353 \par
00354             {\cf20 // If 'j' == NumberOfPages, it means we successfully claimed ALL bits}\par
00355             {\cf19 if} (j == NumberOfPages) \{\par
00356                 InterlockedExchangeU64(hintIndexPtr, (start_of_run_idx + NumberOfPages));\par
00357                 {\cf19 return} MiIndexToVa(poolBase, start_of_run_idx);\par
00358             \}\par
00359             {\cf20 // If we're here, we failed the claim and rolled back, outer loop will continue.}\par
00360         \}\par
00361     \}\par
00362 \par
00363     {\cf19 return} 0; {\cf20 // No contiguous range found}\par
00364 \}\par
00365 \par
00366 {\cf18 void}\par
00367 MiFreePoolVaContiguous(\par
00368     IN  uintptr_t va,\par
00369     IN  {\cf18 size_t} NumberOfBytes,\par
00370     IN  POOL_TYPE PoolType\par
00371 )\par
00372 \par
00373 {\cf20 /*++}\par
00374 {\cf20 }\par
00375 {\cf20     Routine description:}\par
00376 {\cf20 }\par
00377 {\cf20         Frees a VA in the bitmap.}\par
00378 {\cf20 }\par
00379 {\cf20     Arguments:}\par
00380 {\cf20 }\par
00381 {\cf20         [IN] uintptr_t va - The virtual address to free in the bitmap.}\par
00382 {\cf20         [IN] size_t NumberOfBytes - Number of bytes used to allocate from the VA allocation.}\par
00383 {\cf20         [IN] POOL_TYPE PoolType - The type of pool to free the VA for.}\par
00384 {\cf20 }\par
00385 {\cf20     Return Values:}\par
00386 {\cf20 }\par
00387 {\cf20         None.}\par
00388 {\cf20 }\par
00389 {\cf20 --*/}\par
00390 \par
00391 \{\par
00392     {\cf18 size_t} NumberOfPages = BYTES_TO_PAGES(NumberOfBytes);\par
00393     uint64_t* bitmap;\par
00394     uintptr_t poolBase;\par
00395     uintptr_t poolEnd;\par
00396 \par
00397     {\cf19 if} (PoolType == NonPagedPool) \{\par
00398         poolBase = MI_NONPAGED_POOL_BASE;\par
00399         poolEnd = MI_NONPAGED_POOL_END;\par
00400         bitmap = g_NonpagedPoolVaBitmap;\par
00401     \}\par
00402     {\cf19 else} \{\par
00403         poolBase = MI_PAGED_POOL_BASE;\par
00404         poolEnd = MI_PAGED_POOL_END;\par
00405         bitmap = g_PagedPoolVaBitmap;\par
00406         {\cf19 return};\par
00407     \}\par
00408 \par
00409     {\cf19 if} (va < poolBase || va >= poolEnd) {\cf19 return};\par
00410 \par
00411     {\cf18 size_t} start_idx = MiVaToIndex(poolBase, va);\par
00412 \par
00413     {\cf20 // Loop and free all bits in the range}\par
00414     {\cf19 for} ({\cf18 size_t} i = 0; i < NumberOfPages; i++) \{\par
00415         MiBitmapClearBitLocked(bitmap, start_idx + i);\par
00416     \}\par
00417 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/vad.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/vad.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/vad.c}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/mm.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_VAD_DEPTH}\~ 64\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int {\b MiGetNodeHeight} ({\b IN} {\b PMMVAD} Node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MiUpdateNodeHeight} ({\b IN} {\b PMMVAD} Node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int {\b MiGetBalanceFactor} ({\b IN} {\b PMMVAD} Node)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMVAD} {\b MiFindVad} ({\b IN} {\b PMMVAD} Root, {\b IN} uintptr_t VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmFindFreeAddressSpace} ({\b IN} {\b PEPROCESS} Process, {\b IN} size_t NumberOfBytes, {\b IN} uintptr_t SearchStart, {\b IN} uintptr_t SearchEnd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmAllocateVirtualMemory} ({\b IN} {\b PEPROCESS} Process, {\b _In_Opt} {\b _Out_Opt} void **BaseAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b VAD_FLAGS} VadFlags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmFreeVirtualMemory} ({\b IN} {\b PEPROCESS} Process, {\b IN} void *BaseAddress)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMVAD} {\b vadStack} [{\b MAX_VAD_DEPTH}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b stackTop} = -1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_VAD_DEPTH\:vad.c}
{\xe \v vad.c\:MAX_VAD_DEPTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_VAD_DEPTH\~ 64}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 589} of file {\b vad.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MiFindVad\:vad.c}
{\xe \v vad.c\:MiFindVad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMVAD} MiFindVad ({\b IN} {\b PMMVAD} Root, {\b IN} uintptr_t VirtualAddress)}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b vad.c}.}\par
}
{\xe \v MiGetBalanceFactor\:vad.c}
{\xe \v vad.c\:MiGetBalanceFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int MiGetBalanceFactor ({\b IN} {\b PMMVAD} Node)}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b vad.c}.}\par
}
{\xe \v MiGetNodeHeight\:vad.c}
{\xe \v vad.c\:MiGetNodeHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int MiGetNodeHeight ({\b IN} {\b PMMVAD} Node)}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b vad.c}.}\par
}
{\xe \v MiUpdateNodeHeight\:vad.c}
{\xe \v vad.c\:MiUpdateNodeHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MiUpdateNodeHeight ({\b IN} {\b PMMVAD} Node)}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b vad.c}.}\par
}
{\xe \v MmAllocateVirtualMemory\:vad.c}
{\xe \v vad.c\:MmAllocateVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmAllocateVirtualMemory ({\b IN} {\b PEPROCESS} Process, {\b _In_Opt} {\b _Out_Opt} void ** BaseAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b VAD_FLAGS} VadFlags)}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 723} of file {\b vad.c}.}\par
}
{\xe \v MmFindFreeAddressSpace\:vad.c}
{\xe \v vad.c\:MmFindFreeAddressSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmFindFreeAddressSpace ({\b IN} {\b PEPROCESS} Process, {\b IN} size_t NumberOfBytes, {\b IN} uintptr_t SearchStart, {\b IN} uintptr_t SearchEnd)}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 708} of file {\b vad.c}.}\par
}
{\xe \v MmFreeVirtualMemory\:vad.c}
{\xe \v vad.c\:MmFreeVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmFreeVirtualMemory ({\b IN} {\b PEPROCESS} Process, {\b IN} void * BaseAddress)}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 817} of file {\b vad.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v stackTop\:vad.c}
{\xe \v vad.c\:stackTop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int stackTop = -1}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 591} of file {\b vad.c}.}\par
}
{\xe \v vadStack\:vad.c}
{\xe \v vad.c\:vadStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMVAD} vadStack[{\b MAX_VAD_DEPTH}]}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 590} of file {\b vad.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vad.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/vad.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/mm/vad.c}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     vad.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of Virtual Address Descriptors (VADs) of the memory manager.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf20 // Dev notes: BST's left child are smaller than the node, and the right child is larger than the node (heavier)}\par
00020 {\cf20 // So: LeftChild < Node < RightChild}\par
00021 \par
00022 {\cf21 #include "../../includes/mm.h"}\par
00023 {\cf21 #include "../../includes/ps.h"}\par
00024 {\cf21 #include "../../assert.h"}\par
00025 \par
00026 FORCEINLINE\par
00027 {\cf18 int}\par
00028 MiGetNodeHeight(\par
00029     IN  PMMVAD Node\par
00030 )\par
00031 \par
00032 {\cf20 /*++}\par
00033 {\cf20 }\par
00034 {\cf20     Routine description:}\par
00035 {\cf20 }\par
00036 {\cf20         This routine returns the current height of the VAD node (or -1)}\par
00037 {\cf20 }\par
00038 {\cf20     Arguments:}\par
00039 {\cf20 }\par
00040 {\cf20         Pointer to MMVAD Node.}\par
00041 {\cf20 }\par
00042 {\cf20     Return Values:}\par
00043 {\cf20 }\par
00044 {\cf20         Height of node, or -1 if invalid pointer. (0)}\par
00045 {\cf20 }\par
00046 {\cf20 --*/}\par
00047 \par
00048 \{\par
00049     {\cf19 if} (!Node) {\cf19 return} -1;\par
00050     {\cf19 return} Node->Height;\par
00051 \}\par
00052 \par
00053 FORCEINLINE\par
00054 {\cf18 void}\par
00055 MiUpdateNodeHeight(\par
00056     IN  PMMVAD Node\par
00057 )\par
00058 \par
00059 {\cf20 /*++}\par
00060 {\cf20 }\par
00061 {\cf20     Routine description:}\par
00062 {\cf20 }\par
00063 {\cf20         Updates the node's height based on its children.}\par
00064 {\cf20 }\par
00065 {\cf20     Arguments:}\par
00066 {\cf20 }\par
00067 {\cf20         Pointer to MMVAD Node.}\par
00068 {\cf20 }\par
00069 {\cf20     Return Values:}\par
00070 {\cf20 }\par
00071 {\cf20         None.}\par
00072 {\cf20 }\par
00073 {\cf20 --*/}\par
00074 \par
00075 \{\par
00076     {\cf19 if} (!Node) {\cf19 return};\par
00077     Node->Height = 1 + MAX(MiGetNodeHeight(Node->LeftChild), MiGetNodeHeight(Node->RightChild));\par
00078 \}\par
00079 \par
00080 FORCEINLINE\par
00081 {\cf18 int}\par
00082 MiGetBalanceFactor(\par
00083     IN  PMMVAD Node\par
00084 )\par
00085 \par
00086 {\cf20 /*++}\par
00087 {\cf20 }\par
00088 {\cf20     Routine description:}\par
00089 {\cf20 }\par
00090 {\cf20         Calculates balance factor of node in the tree.}\par
00091 {\cf20 }\par
00092 {\cf20     Arguments:}\par
00093 {\cf20 }\par
00094 {\cf20         Pointer to MMVAD Node.}\par
00095 {\cf20 }\par
00096 {\cf20     Return Values:}\par
00097 {\cf20 }\par
00098 {\cf20         Return's the nodes balance factor.}\par
00099 {\cf20 }\par
00100 {\cf20 --*/}\par
00101 \par
00102 \{\par
00103     {\cf19 if} (!Node) {\cf19 return} 0;\par
00104     {\cf20 // balance factor is the (height of the right - height of the left)}\par
00105     {\cf19 return} MiGetNodeHeight(Node->RightChild) - MiGetNodeHeight(Node->LeftChild);\par
00106 \}\par
00107 \par
00108 {\cf17 static}\par
00109 PMMVAD \par
00110 MiAllocateVad(\par
00111     {\cf18 void}\par
00112 )\par
00113 \par
00114 {\cf20 /*++}\par
00115 {\cf20 }\par
00116 {\cf20     Routine description:}\par
00117 {\cf20 }\par
00118 {\cf20         This routine allocates a VAD from the nonpaged pool and sets it up.}\par
00119 {\cf20 }\par
00120 {\cf20     Arguments:}\par
00121 {\cf20 }\par
00122 {\cf20         None.}\par
00123 {\cf20 }\par
00124 {\cf20     Return Values:}\par
00125 {\cf20 }\par
00126 {\cf20         Pointer to allocated VAD. NULL On failure.}\par
00127 {\cf20 }\par
00128 {\cf20 --*/}\par
00129 \par
00130 \{\par
00131     {\cf20 // Allocate the VAD.}\par
00132     PMMVAD vad = (PMMVAD)MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(MMVAD), {\cf22 ' daV'}); {\cf20 // Little endian tag.}\par
00133     {\cf19 if} (!vad) {\cf19 return} NULL;\par
00134     \par
00135     {\cf20 // Initialize to zero. (including height)}\par
00136     kmemset(vad, 0, {\cf17 sizeof}(MMVAD));\par
00137 \par
00138     {\cf19 return} vad;\par
00139 \}\par
00140 \par
00141 \par
00142 {\cf17 static}\par
00143 {\cf18 void}\par
00144 MiFreeVad(\par
00145     IN PMMVAD Vad\par
00146 )\par
00147 \par
00148 {\cf20 /*++}\par
00149 {\cf20 }\par
00150 {\cf20     Routine description:}\par
00151 {\cf20 }\par
00152 {\cf20     Frees a VAD structure back to the non-paged pool.}\par
00153 {\cf20 }\par
00154 {\cf20     Arguments:}\par
00155 {\cf20 }\par
00156 {\cf20         Pointer to MMVAD Node.}\par
00157 {\cf20 }\par
00158 {\cf20     Return Values:}\par
00159 {\cf20 }\par
00160 {\cf20         None.}\par
00161 {\cf20 }\par
00162 {\cf20 --*/}\par
00163 \par
00164 \{\par
00165     {\cf19 return} MmFreePool(({\cf18 void}*)Vad);\par
00166 \}\par
00167 \par
00168 {\cf17 static}\par
00169 PMMVAD\par
00170 MiRotateRight(\par
00171     IN PMMVAD y\par
00172 )\par
00173 \par
00174 {\cf20 /*++}\par
00175 {\cf20     Routine description:}\par
00176 {\cf20         Performs a single right rotation on node y.}\par
00177 {\cf20 }\par
00178 {\cf20     Before:}\par
00179 {\cf20              y}\par
00180 {\cf20             / \\}\par
00181 {\cf20            x   T3}\par
00182 {\cf20           / \\}\par
00183 {\cf20          T1  T2}\par
00184 {\cf20 }\par
00185 {\cf20     After:}\par
00186 {\cf20              x}\par
00187 {\cf20             / \\}\par
00188 {\cf20            T1  y}\par
00189 {\cf20               / \\}\par
00190 {\cf20              T2  T3}\par
00191 {\cf20 }\par
00192 {\cf20     Return Values:}\par
00193 {\cf20         }\par
00194 {\cf20         New root of subtree.}\par
00195 {\cf20 --*/}\par
00196 \par
00197 \{\par
00198     PMMVAD x = y->LeftChild;\par
00199     PMMVAD T2 = x->RightChild;\par
00200     \par
00201     {\cf20 // Perform rotation}\par
00202     x->RightChild = y;\par
00203     y->LeftChild = T2;\par
00204 \par
00205     {\cf20 // Update parent pointers}\par
00206     x->Parent = y->Parent;\par
00207     y->Parent = x;\par
00208     {\cf19 if} (T2) T2->Parent = y;\par
00209 \par
00210     {\cf20 // Update heights (update Y before X, since the function uses X)}\par
00211     MiUpdateNodeHeight(y);\par
00212     MiUpdateNodeHeight(x);\par
00213 \par
00214     {\cf20 // Return new root of subtree.}\par
00215     {\cf19 return} x;\par
00216 \}\par
00217 \par
00218 {\cf17 static}\par
00219 PMMVAD\par
00220 MiRotateLeft(\par
00221     IN PMMVAD x\par
00222 )\par
00223 \par
00224 {\cf20 /*++}\par
00225 {\cf20     Routine description:}\par
00226 {\cf20         Performs a single left rotation on node x.}\par
00227 {\cf20 }\par
00228 {\cf20     Before:}\par
00229 {\cf20              x}\par
00230 {\cf20             / \\}\par
00231 {\cf20            T1  y}\par
00232 {\cf20               / \\}\par
00233 {\cf20              T2  T3}\par
00234 {\cf20 }\par
00235 {\cf20     After:}\par
00236 {\cf20              y}\par
00237 {\cf20             / \\}\par
00238 {\cf20            x   T3}\par
00239 {\cf20           / \\}\par
00240 {\cf20          T1  T2}\par
00241 {\cf20 }\par
00242 {\cf20     Return Values:}\par
00243 {\cf20 }\par
00244 {\cf20         New root of subtree.}\par
00245 {\cf20 --*/}\par
00246 \par
00247 \{\par
00248     PMMVAD y = x->RightChild;\par
00249     PMMVAD T2 = y->LeftChild;\par
00250 \par
00251     {\cf20 // Perform rotation}\par
00252     y->LeftChild = x;\par
00253     x->RightChild = T2;\par
00254 \par
00255     {\cf20 // Update parent pointers}\par
00256     y->Parent = x->Parent;\par
00257     x->Parent = y;\par
00258     {\cf19 if} (T2) T2->Parent = x;\par
00259 \par
00260     {\cf20 // Update heights (update X before Y, since the function uses Y)}\par
00261     MiUpdateNodeHeight(x);\par
00262     MiUpdateNodeHeight(y);\par
00263 \par
00264     {\cf20 // Return new root of subtree.}\par
00265     {\cf19 return} y;\par
00266 \}\par
00267 \par
00268 {\cf17 static}\par
00269 PMMVAD\par
00270 MiFindMinimumVad(\par
00271     IN PMMVAD Node\par
00272 )\par
00273 \par
00274 {\cf20 /*++}\par
00275 {\cf20 }\par
00276 {\cf20     Routine description:}\par
00277 {\cf20 }\par
00278 {\cf20         Finds the node with the minimum value (StartVa) in a given sub-tree.}\par
00279 {\cf20 }\par
00280 {\cf20     Arguments:}\par
00281 {\cf20 }\par
00282 {\cf20         Pointer to MMVAD Node.}\par
00283 {\cf20 }\par
00284 {\cf20     Return Values:}\par
00285 {\cf20 }\par
00286 {\cf20         None.}\par
00287 {\cf20 }\par
00288 {\cf20 --*/}\par
00289 \par
00290 \{\par
00291     PMMVAD current = Node;\par
00292     {\cf19 while} (current && current->LeftChild != NULL) \{\par
00293         current = current->LeftChild;\par
00294     \}\par
00295     {\cf19 return} current;\par
00296 \}\par
00297 \par
00298 {\cf17 static}\par
00299 {\cf18 bool}\par
00300 MiCheckVadOverlap(\par
00301     IN PMMVAD Root,\par
00302     IN uintptr_t StartVa,\par
00303     IN uintptr_t EndVa\par
00304 )\par
00305 \par
00306 {\cf20 /*++}\par
00307 {\cf20 }\par
00308 {\cf20     Routine description:}\par
00309 {\cf20 }\par
00310 {\cf20         Checks if a proposed new VAD (defined by StartVA and EndVA) overlaps with any existing VADs in the tree.}\par
00311 {\cf20 }\par
00312 {\cf20     Arguments:}\par
00313 {\cf20 }\par
00314 {\cf20         Pointer to MMVAD Node.}\par
00315 {\cf20         Start Virtual Address.}\par
00316 {\cf20         Ending Virtual Address.}\par
00317 {\cf20 }\par
00318 {\cf20     Return Values:}\par
00319 {\cf20 }\par
00320 {\cf20         True if there is an overlap, false otherwise.}\par
00321 {\cf20 }\par
00322 {\cf20 --*/}\par
00323 \par
00324 \{\par
00325     PMMVAD Node = Root;\par
00326     {\cf19 while} (Node) \{\par
00327         {\cf20 // Check for overlap}\par
00328         {\cf20 // A overlaps B if A.start < B.End AND > B.start}\par
00329         {\cf19 if} (StartVa <= Node->EndVa && EndVa >= Node->StartVa) \{\par
00330             {\cf19 return} {\cf17 true};\par
00331         \}\par
00332 \par
00333         {\cf20 // If the new VAD is entirely before the current one}\par
00334         {\cf19 if} (EndVa < Node->StartVa) \{\par
00335             Node = Node->LeftChild; {\cf20 // Only need to check left}\par
00336         \}\par
00337 \par
00338         {\cf20 // If the new VAD is entirely after the current one}\par
00339         {\cf19 else} {\cf19 if} (StartVa > Node->EndVa) \{\par
00340             Node = Node->RightChild; {\cf20 // Only need to check right}\par
00341         \}\par
00342 \par
00343         {\cf20 // Overlaps.}\par
00344         {\cf19 else} \{\par
00345             {\cf19 return} {\cf17 true};\par
00346         \}\par
00347     \}\par
00348 \par
00349     {\cf20 // No overlap found.}\par
00350     {\cf19 return} {\cf17 false};\par
00351 \}\par
00352 \par
00353 PMMVAD\par
00354 MiFindVad(\par
00355     IN  PMMVAD Root,\par
00356     IN  uintptr_t VirtualAddress\par
00357 )\par
00358 \par
00359 {\cf20 /*++}\par
00360 {\cf20 }\par
00361 {\cf20     Routine description:}\par
00362 {\cf20 }\par
00363 {\cf20         Finds a VAD that contains the given virtual address in it.}\par
00364 {\cf20 }\par
00365 {\cf20     Arguments:}\par
00366 {\cf20 }\par
00367 {\cf20         [IN]    PMMVAD Root - Root of the VAD Tree of the process.}\par
00368 {\cf20         [IN]    uintptr_t VirtualAddress - Virtual address to check for.}\par
00369 {\cf20 }\par
00370 {\cf20     Return Values:}\par
00371 {\cf20 }\par
00372 {\cf20         Returns the VAD if found, NULL otherwise.}\par
00373 {\cf20 }\par
00374 {\cf20 --*/}\par
00375 \par
00376 \{\par
00377     PMMVAD current = Root;\par
00378 \par
00379     {\cf19 while} (current) \{\par
00380         {\cf20 // Is the virtual address BEFORE this VAD}\par
00381         {\cf19 if} (VirtualAddress < current->StartVa) \{\par
00382             current = current->LeftChild;\par
00383         \}\par
00384 \par
00385         {\cf20 // Is the virtual address AFTER this VAD}\par
00386         {\cf19 else} {\cf19 if} (VirtualAddress > current->EndVa) \{\par
00387             current = current->RightChild;\par
00388         \}\par
00389 \par
00390         {\cf20 // Then, it must be inside of this VAD.}\par
00391         {\cf19 else} {\cf19 return} current;\par
00392     \}\par
00393 \par
00394     {\cf20 // Not found.}\par
00395     {\cf19 return} NULL;\par
00396 \}\par
00397 \par
00398 {\cf17 static}\par
00399 PMMVAD\par
00400 MiInsertVadNode(\par
00401     IN PMMVAD Node,\par
00402     IN PMMVAD NewVad\par
00403 )\par
00404 \par
00405 {\cf20 /*++}\par
00406 {\cf20 }\par
00407 {\cf20     Routine description:}\par
00408 {\cf20 }\par
00409 {\cf20         Inserts the NewVad into Node using AVL insert.}\par
00410 {\cf20 }\par
00411 {\cf20     Arguments:}\par
00412 {\cf20 }\par
00413 {\cf20         Node to insert to.}\par
00414 {\cf20         Vad to insert.}\par
00415 {\cf20 }\par
00416 {\cf20     Return Values:}\par
00417 {\cf20 }\par
00418 {\cf20         New root of subtree.}\par
00419 {\cf20 }\par
00420 {\cf20 --*/}\par
00421 \par
00422 \{\par
00423     {\cf20 // Found the best spot to insert}\par
00424     {\cf19 if} (!Node) {\cf19 return} NewVad;\par
00425 \par
00426     {\cf20 // Recursive step}\par
00427     {\cf19 if} (NewVad->StartVa < Node->StartVa) \{\par
00428         PMMVAD newLeft = MiInsertVadNode(Node->LeftChild, NewVad);\par
00429         Node->LeftChild = newLeft;\par
00430         {\cf19 if} (newLeft) newLeft->Parent = Node;\par
00431     \}\par
00432     {\cf19 else} \{\par
00433         {\cf20 // No duplicates or overlaps, the caller should handle that before calling.}\par
00434         PMMVAD newRight = MiInsertVadNode(Node->RightChild, NewVad);\par
00435         Node->RightChild = newRight;\par
00436         {\cf19 if} (newRight) newRight->Parent = Node;\par
00437     \}\par
00438 \par
00439     {\cf20 // Update height}\par
00440     MiUpdateNodeHeight(Node);\par
00441 \par
00442     {\cf20 // Get balance, and rebalance the tree if needed.}\par
00443     {\cf18 int} balance = MiGetBalanceFactor(Node);\par
00444 \par
00445     {\cf20 // Left heavy tree}\par
00446     {\cf19 if} (balance < -1) \{\par
00447         {\cf20 // Left left}\par
00448         {\cf19 if} (NewVad->StartVa < Node->LeftChild->StartVa) \{\par
00449             {\cf19 return} MiRotateRight(Node);\par
00450         \}\par
00451         {\cf20 // Left right}\par
00452         {\cf19 else} \{\par
00453             Node->LeftChild = MiRotateLeft(Node->LeftChild);\par
00454             {\cf19 return} MiRotateRight(Node);\par
00455         \}\par
00456     \}\par
00457 \par
00458     {\cf20 // Right heavy tree}\par
00459     {\cf19 if} (balance > 1) \{\par
00460         {\cf20 // Right right}\par
00461         {\cf19 if} (NewVad->StartVa > Node->RightChild->StartVa) \{\par
00462             {\cf19 return} MiRotateLeft(Node);\par
00463         \}\par
00464         {\cf20 // Right left}\par
00465         {\cf19 else} \{\par
00466             Node->RightChild = MiRotateRight(Node->RightChild);\par
00467             {\cf19 return} MiRotateLeft(Node);\par
00468         \}\par
00469     \}\par
00470 \par
00471     {\cf20 // Return the (probably new) root of the this subtree.}\par
00472     {\cf19 return} Node;\par
00473 \}\par
00474 \par
00475 {\cf17 static}\par
00476 PMMVAD\par
00477 MiDeleteVadNode(\par
00478     IN  PMMVAD Root,\par
00479     IN  PMMVAD VadToDelete\par
00480 )\par
00481 \par
00482 {\cf20 /*++}\par
00483 {\cf20 }\par
00484 {\cf20     Routine description:}\par
00485 {\cf20 }\par
00486 {\cf20         Delets VadToDelete from Root.}\par
00487 {\cf20 }\par
00488 {\cf20     Arguments:}\par
00489 {\cf20 }\par
00490 {\cf20         Root to delete from}\par
00491 {\cf20         Vad to delete.}\par
00492 {\cf20 }\par
00493 {\cf20     Return Values:}\par
00494 {\cf20 }\par
00495 {\cf20         New root of subtree.}\par
00496 {\cf20 }\par
00497 {\cf20 --*/}\par
00498 \par
00499 \{\par
00500     {\cf19 if} (Root == NULL) \{\par
00501         {\cf20 // Shouldn't happen if logic is correct.}\par
00502         {\cf19 return} NULL;\par
00503     \}\par
00504 \par
00505     {\cf20 // Find the node}\par
00506     {\cf19 if} (VadToDelete->StartVa < Root->StartVa) \{\par
00507         Root->LeftChild = MiDeleteVadNode(Root->LeftChild, VadToDelete);\par
00508     \}\par
00509     {\cf19 else} {\cf19 if} (VadToDelete->StartVa > Root->StartVa) \{\par
00510         Root->RightChild = MiDeleteVadNode(Root->RightChild, VadToDelete);\par
00511     \}\par
00512     {\cf19 else} \{\par
00513         {\cf20 // Node with 0 or 1 child.}\par
00514         {\cf19 if} (Root->LeftChild == NULL || Root->RightChild == NULL) \{\par
00515             PMMVAD temp = Root->LeftChild ? Root->LeftChild : Root->RightChild;\par
00516 \par
00517             {\cf20 // No childs.}\par
00518             {\cf19 if} (!temp) \{\par
00519                 {\cf20 // This node (root) is what we want to delete.}\par
00520                 {\cf20 // We return NULL to our parent, who will set its child ptr to null. (and free it from memory)}\par
00521                 {\cf19 return} NULL;\par
00522             \}\par
00523             {\cf20 // One child}\par
00524             {\cf19 else} \{\par
00525                 {\cf20 // The child takes our place.}\par
00526                 temp->Parent = Root->Parent;\par
00527                 {\cf19 return} temp; {\cf20 // Return the child to our parent.}\par
00528             \}\par
00529         \}\par
00530         {\cf20 // Node with 2 children}\par
00531         {\cf19 else} \{\par
00532             PMMVAD successor = MiFindMinimumVad(Root->RightChild);\par
00533 \par
00534             {\cf20 // Save Root's tree links}\par
00535             PMMVAD oldLeft = Root->LeftChild;\par
00536             PMMVAD oldParent = Root->Parent;\par
00537 \par
00538             {\cf20 // Copy all of successor's data (data + tree links)}\par
00539             kmemcpy(Root, successor, {\cf17 sizeof}(MMVAD));\par
00540 \par
00541             {\cf20 // Restore Root's original tree links}\par
00542             Root->LeftChild = oldLeft;\par
00543             Root->Parent = oldParent;\par
00544 \par
00545             {\cf20 // Update parent pointers for Root's children}\par
00546             {\cf19 if} (Root->LeftChild) Root->LeftChild->Parent = Root;\par
00547             {\cf19 if} (Root->RightChild) Root->RightChild->Parent = Root; {\cf20 // successor's right}\par
00548 \par
00549             {\cf20 // Now delete the original successor}\par
00550             Root->RightChild = MiDeleteVadNode(Root->RightChild, successor);\par
00551         \}\par
00552     \}\par
00553 \par
00554     {\cf20 // Update height.}\par
00555     MiUpdateNodeHeight(Root);\par
00556 \par
00557     {\cf20 // Get balance and rebalance if needed.}\par
00558     {\cf18 int} balance = MiGetBalanceFactor(Root);\par
00559 \par
00560     {\cf20 // Left Heavy}\par
00561     {\cf19 if} (balance < -1) \{\par
00562         {\cf20 // Left-Left}\par
00563         {\cf19 if} (MiGetBalanceFactor(Root->LeftChild) <= 0) \{\par
00564             {\cf19 return} MiRotateRight(Root);\par
00565         \}\par
00566         {\cf20 // Left-Right}\par
00567         {\cf19 else} \{\par
00568             Root->LeftChild = MiRotateLeft(Root->LeftChild);\par
00569             {\cf19 return} MiRotateRight(Root);\par
00570         \}\par
00571     \}\par
00572 \par
00573     {\cf20 // Right Heavy}\par
00574     {\cf19 if} (balance > 1) \{\par
00575         {\cf20 // Right-Right}\par
00576         {\cf19 if} (MiGetBalanceFactor(Root->RightChild) >= 0) \{\par
00577             {\cf19 return} MiRotateLeft(Root);\par
00578         \}\par
00579         {\cf20 // Right-Left}\par
00580         {\cf19 else} \{\par
00581             Root->RightChild = MiRotateRight(Root->RightChild);\par
00582             {\cf19 return} MiRotateLeft(Root);\par
00583         \}\par
00584     \}\par
00585 \par
00586     {\cf19 return} Root;\par
00587 \}\par
00588 \par
00589 {\cf21 #define MAX_VAD_DEPTH 64 }{\cf20 // Usually enough for a 64-bit tree}\par
00590 PMMVAD vadStack[MAX_VAD_DEPTH];\par
00591 {\cf18 int} stackTop = -1;\par
00592 \par
00593 {\cf17 static}\par
00594 uintptr_t\par
00595 MiFindGap(\par
00596     IN  PMMVAD Root,\par
00597     IN  {\cf18 size_t} NumberOfBytes,\par
00598     IN  uintptr_t SearchStart,\par
00599     IN  uintptr_t SearchEnd    {\cf20 // exclusive}\par
00600 )\par
00601 \par
00602 {\cf20 /*++}\par
00603 {\cf20 }\par
00604 {\cf20     Routine description:}\par
00605 {\cf20 }\par
00606 {\cf20         Finds a VA gap in the VAD Tree using an iterative in-order traversal. (does NOT claim the gap)}\par
00607 {\cf20 }\par
00608 {\cf20     Arguments:}\par
00609 {\cf20 }\par
00610 {\cf20         [IN] PMMVAD Root - The ROOT of the VAD Tree.}\par
00611 {\cf20         [IN] size_t NumberOfBytes - The size of the gap needed.}\par
00612 {\cf20         [IN] uintptr_t SearchStart - Inclusive start of the search range.}\par
00613 {\cf20         [IN] uintptr_t SearchEnd   - Exclusive end of the search range.}\par
00614 {\cf20 }\par
00615 {\cf20     Return Values:}\par
00616 {\cf20 }\par
00617 {\cf20         Start of VA that has enough bytes for 'size'. 0 If gap isn't found.}\par
00618 {\cf20 }\par
00619 {\cf20 --*/}\par
00620 \{\par
00621     {\cf19 if} (SearchStart >= SearchEnd) {\cf19 return} 0;                {\cf20 // invalid range}\par
00622     {\cf19 if} (NumberOfBytes == 0) {\cf19 return} 0;                     {\cf20 // no zero-sized allocations}\par
00623     {\cf19 if} (SearchStart == 0) {\cf19 return} 0;                       {\cf20 // defensive: we don't expect VA 0}\par
00624 \par
00625     PMMVAD current = Root;\par
00626     {\cf18 size_t} size_needed = ALIGN_UP(NumberOfBytes, VirtualPageSize);\par
00627 \par
00628     {\cf20 // Start from one byte before SearchStart so ALIGN_UP(lastEndVa + 1, page) == aligned SearchStart}\par
00629     uintptr_t lastEndVa = SearchStart - 1;\par
00630 \par
00631     stackTop = -1; {\cf20 // Reset stack (you already use this global stack)}\par
00632 \par
00633     {\cf19 while} (current != NULL || stackTop != -1) \{\par
00634         {\cf20 // Go all the way left, pushing nodes onto the stack}\par
00635         {\cf19 while} (current != NULL) \{\par
00636             {\cf19 if} (stackTop + 1 >= MAX_VAD_DEPTH) \{\par
00637                 {\cf20 // Tree is too deep (shouldn't happen if we balanced it though)}\par
00638                 {\cf19 return} 0;\par
00639             \}\par
00640             vadStack[++stackTop] = current;\par
00641             current = current->LeftChild;\par
00642         \}\par
00643 \par
00644         {\cf20 // Pop the next in-order node}\par
00645         current = vadStack[stackTop--];\par
00646 \par
00647         {\cf20 // If this VAD is entirely before our search range, skip it.}\par
00648         {\cf19 if} (current->EndVa < SearchStart) \{\par
00649             {\cf20 // Still update lastEndVa so gaps before SearchStart are ignored}\par
00650             {\cf19 if} (current->EndVa > lastEndVa) lastEndVa = current->EndVa;\par
00651             current = current->RightChild;\par
00652             {\cf19 continue};\par
00653         \}\par
00654 \par
00655         {\cf20 // If this VAD starts at/after the search end, we can check the final gap and exit.}\par
00656         {\cf19 if} (current->StartVa >= SearchEnd) \{\par
00657             uintptr_t gapStart = ALIGN_UP(lastEndVa + 1, VirtualPageSize);\par
00658 \par
00659             {\cf20 // Overflow check: gapStart + size_needed must not wrap}\par
00660             {\cf19 if} (gapStart <= (uintptr_t)-1 - (size_needed - 1)) \{\par
00661                 {\cf19 if} (gapStart + size_needed <= SearchEnd) {\cf19 return} gapStart;\par
00662             \}\par
00663             {\cf19 return} 0;\par
00664         \}\par
00665 \par
00666         {\cf20 // Normal case: VAD intersects our search range in some way.}\par
00667         {\cf20 // We compute gapStart relative to lastEndVa, but it must also be >= SearchStart.}\par
00668         uintptr_t gapStart = ALIGN_UP(lastEndVa + 1, VirtualPageSize);\par
00669         {\cf19 if} (gapStart < SearchStart) gapStart = ALIGN_UP(SearchStart, VirtualPageSize);\par
00670 \par
00671         {\cf20 // If gapStart is strictly before this VAD's StartVa, we have candidate gap.}\par
00672         {\cf19 if} (gapStart < current->StartVa) \{\par
00673             {\cf20 // check overflow and fit into both current VAD and SearchEnd}\par
00674             {\cf19 if} (gapStart <= (uintptr_t)-1 - (size_needed - 1)) \{\par
00675                 uintptr_t gapEndExclusive = gapStart + size_needed;\par
00676                 {\cf20 // must fit before current VAD and before SearchEnd (SearchEnd is exclusive)}\par
00677                 {\cf19 if} (gapEndExclusive <= current->StartVa && gapEndExclusive <= SearchEnd) \{\par
00678                     {\cf19 return} gapStart;\par
00679                 \}\par
00680             \}\par
00681         \}\par
00682 \par
00683         {\cf20 // Update lastEndVa to cover this VAD. ensure monotonicity.}\par
00684         {\cf19 if} (current->EndVa > lastEndVa) lastEndVa = current->EndVa;\par
00685 \par
00686         {\cf20 // Move to right subtree}\par
00687         current = current->RightChild;\par
00688     \}\par
00689 \par
00690     {\cf20 // After traversing entire tree, check the gap between lastEndVa and SearchEnd (exclusive)}\par
00691     uintptr_t finalGapStart = ALIGN_UP(lastEndVa + 1, VirtualPageSize);\par
00692     {\cf19 if} (finalGapStart < SearchStart) finalGapStart = ALIGN_UP(SearchStart, VirtualPageSize);\par
00693 \par
00694     {\cf19 if} (finalGapStart <= (uintptr_t)-1 - (size_needed - 1)) \{\par
00695         {\cf19 if} (finalGapStart + size_needed <= SearchEnd) \{\par
00696             {\cf19 return} finalGapStart;\par
00697         \}\par
00698     \}\par
00699 \par
00700     {\cf20 // No gap found anywhere}\par
00701     {\cf19 return} 0;\par
00702 \}\par
00703 \par
00704 {\cf20 // PUBLIC API}\par
00705 \par
00706 {\cf20 // Wrapper}\par
00707 uintptr_t\par
00708 MmFindFreeAddressSpace(\par
00709     IN  PEPROCESS Process,\par
00710     IN  {\cf18 size_t} NumberOfBytes,\par
00711     IN  uintptr_t SearchStart,\par
00712     IN  uintptr_t SearchEnd    {\cf20 // exclusive}\par
00713 )\par
00714 \par
00715 \{\par
00716     {\cf19 if} (Process && NumberOfBytes) \{\par
00717         {\cf19 return} MiFindGap(Process->VadRoot, NumberOfBytes, SearchStart, SearchEnd);\par
00718     \}\par
00719     {\cf19 return} 0;\par
00720 \}\par
00721 \par
00722 MTSTATUS\par
00723 MmAllocateVirtualMemory(\par
00724     IN PEPROCESS Process,\par
00725     _In_Opt _Out_Opt {\cf18 void}** BaseAddress,\par
00726     IN {\cf18 size_t} NumberOfBytes,\par
00727     IN VAD_FLAGS VadFlags\par
00728 )\par
00729 \par
00730 {\cf20 /*++}\par
00731 {\cf20 }\par
00732 {\cf20     Routine description:}\par
00733 {\cf20 }\par
00734 {\cf20         Allocates virtual memory (paged) for the process.}\par
00735 {\cf20 }\par
00736 {\cf20     Arguments:}\par
00737 {\cf20 }\par
00738 {\cf20         [IN]    PEPROCESS Process - Process to allocate memory for}\par
00739 {\cf20         [IN OPTIONAL | OUT OPTIONAL] [PTR_TO_PTR]   void** BaseAddress - The base address to allocate memory starting from if supplied. If NULL, a free gap is chosen and used by NumberOfBytes, and *baseAddress is set to the found start of gap.}\par
00740 {\cf20         [IN]    size_t NumberOfBytes - The amount in virtual memory to allocate.}\par
00741 {\cf20         [IN]    uint32_t VadFlags - The VAD Flags to supply for the allocation (file backed?)}\par
00742 {\cf20 }\par
00743 {\cf20     Return Values:}\par
00744 {\cf20 }\par
00745 {\cf20         Various MTSTATUS Status codes.}\par
00746 {\cf20 }\par
00747 {\cf20 --*/}\par
00748 \par
00749 \{\par
00750     {\cf20 // Calculate pages needed}\par
00751     uintptr_t StartVa = (uintptr_t)*BaseAddress;\par
00752     {\cf18 size_t} Pages = BYTES_TO_PAGES(NumberOfBytes);\par
00753     uintptr_t EndVa = StartVa + PAGES_TO_BYTES(Pages) - 1;\par
00754     MTSTATUS status = MT_GENERAL_FAILURE; {\cf20 // Default to failure}\par
00755     {\cf18 bool} checkForOverlap = {\cf17 true};\par
00756 \par
00757     {\cf19 if} (!StartVa) \{\par
00758         {\cf20 // We need to determine if the allocation is for a system process or a user process.}\par
00759         {\cf18 bool} KernelProcess = (Process->PID == 4) ? {\cf17 true} : {\cf17 false};\par
00760         {\cf19 if} (unlikely(KernelProcess)) \{\par
00761             assert({\cf17 false});\par
00762             MeBugCheckEx(MANUALLY_INITIATED_CRASH, RETADDR(0), NULL, NULL, NULL);\par
00763         \}\par
00764         {\cf19 else} \{\par
00765             {\cf20 // User mode}\par
00766             StartVa = MiFindGap(Process->VadRoot, NumberOfBytes, USER_VA_START, (uintptr_t)USER_VA_END + 1);\par
00767         \}\par
00768         {\cf19 if} (!StartVa) {\cf19 return} MT_NOT_FOUND;\par
00769         {\cf20 // No need to check for an overlap as if we found a sufficient gap, there is guranteed to be no overlap.}\par
00770         checkForOverlap = {\cf17 false};\par
00771 \par
00772         {\cf20 // Calculate the end VA.}\par
00773         EndVa = StartVa + PAGES_TO_BYTES(Pages) - 1;\par
00774     \} \par
00775 \par
00776     {\cf20 // Acquire rundown protection for process}\par
00777     {\cf19 if} (!MsAcquireRundownProtection(&Process->ProcessRundown)) \{\par
00778         {\cf19 return} MT_INVALID_STATE;\par
00779     \}\par
00780 \par
00781     {\cf20 // Acquire lock for this process VAD tree.}\par
00782     IRQL oldIrql;\par
00783     MsAcquireSpinlock(&Process->VadLock, &oldIrql); \par
00784 \par
00785     {\cf20 // Check for overlap}\par
00786     {\cf19 if} (checkForOverlap && MiCheckVadOverlap(Process->VadRoot, StartVa, EndVa)) \{\par
00787         status = MT_CONFLICTING_ADDRESSES;\par
00788         {\cf19 goto} cleanup;\par
00789     \}\par
00790 \par
00791     {\cf20 // Allocate and initialize new VAD.}\par
00792     PMMVAD newVad = MiAllocateVad();\par
00793     {\cf19 if} (!newVad) \{\par
00794         status = MT_NO_RESOURCES;\par
00795         {\cf19 goto} cleanup;\par
00796     \}\par
00797 \par
00798     newVad->StartVa = StartVa;\par
00799     newVad->EndVa = EndVa;\par
00800     newVad->Flags = VadFlags;\par
00801     newVad->OwningProcess = Process;\par
00802 \par
00803     {\cf20 // TODO init file info if VAD_FLAG_MAPPED_FILE is set. (TODO FILE PAGING)}\par
00804 \par
00805     {\cf20 // Insert the VAD into the the process's tree.}\par
00806     Process->VadRoot = MiInsertVadNode(Process->VadRoot, newVad);\par
00807     status = MT_SUCCESS;\par
00808     {\cf19 goto} cleanup;\par
00809 \par
00810 cleanup:\par
00811     MsReleaseRundownProtection(&Process->ProcessRundown);\par
00812     MsReleaseSpinlock(&Process->VadLock, oldIrql);\par
00813     {\cf19 return} status;\par
00814 \}\par
00815 \par
00816 MTSTATUS\par
00817 MmFreeVirtualMemory(\par
00818     IN PEPROCESS Process,\par
00819     IN {\cf18 void}* BaseAddress\par
00820 )\par
00821 \par
00822 {\cf20 /*++}\par
00823 {\cf20 }\par
00824 {\cf20     Routine description:}\par
00825 {\cf20 }\par
00826 {\cf20         Releases virtual memory allocated by MmAllocateVirtualMemory.}\par
00827 {\cf20 }\par
00828 {\cf20     Arguments:}\par
00829 {\cf20 }\par
00830 {\cf20         [IN]    PEPROCESS Process - Process to allocate memory for}\par
00831 {\cf20         [IN]    void* BaseAddress - The base address to release memory, supplied from/to MmAllocateVirtualMemory.}\par
00832 {\cf20 }\par
00833 {\cf20     Return Values:}\par
00834 {\cf20 }\par
00835 {\cf20         Various MTSTATUS Status code.}\par
00836 {\cf20 }\par
00837 {\cf20 --*/}\par
00838 \par
00839 \{\par
00840     MTSTATUS status = MT_GENERAL_FAILURE;\par
00841     uintptr_t va = (uintptr_t)BaseAddress;\par
00842 \par
00843     {\cf20 // Acquire rundown protection}\par
00844     {\cf19 if} (!MsAcquireRundownProtection(&Process->ProcessRundown)) \{\par
00845         {\cf19 return} MT_INVALID_STATE;\par
00846     \}\par
00847 \par
00848     {\cf20 // Acquire VAD lock}\par
00849     IRQL oldIrql;\par
00850     MsAcquireSpinlock(&Process->VadLock, &oldIrql);\par
00851 \par
00852     PMMVAD VadToFree = MiFindVad(Process->VadRoot, va);\par
00853 \par
00854     {\cf20 // Check if its the valid VAD and if the base address is the start of the VAD region.}\par
00855     {\cf19 if} (VadToFree == NULL || VadToFree->StartVa != va) \{\par
00856         status = MT_INVALID_PARAM;\par
00857         {\cf19 goto} cleanup;\par
00858     \}\par
00859 \par
00860     {\cf20 // Unmap all PTEs and physical pages from VAD.}\par
00861     {\cf19 for} (uintptr_t virtualaddr = VadToFree->StartVa; virtualaddr <= VadToFree->EndVa; virtualaddr += VirtualPageSize) \{\par
00862         {\cf20 // Get the PTE pointer for the current VA.}\par
00863         PMMPTE pte = MiGetPtePointer(virtualaddr);\par
00864         {\cf20 // Atomically unmap the PTE.}\par
00865         MiUnmapPte(pte);\par
00866         {\cf20 // Grab the PFN Number from the (now replaced) PTE. (in PresentSet, PageFrameNumber is the physical address, not the PFN index, our MiUnmapPte function replaced that)}\par
00867         PAGE_INDEX pfn = pte->Soft.PageFrameNumber;\par
00868         {\cf20 // Release the PFN back to MM.}\par
00869         MiReleasePhysicalPage(pfn);\par
00870     \}\par
00871 \par
00872     {\cf20 // Delete the VAD from the tree.}\par
00873     Process->VadRoot = MiDeleteVadNode(Process->VadRoot, VadToFree);\par
00874     {\cf20 // Free the VAD struct itself (from kernel's nonpagedpool memory, its not a double free)}\par
00875     MiFreeVad(VadToFree);\par
00876 \par
00877     {\cf20 // Set status.}\par
00878     status = MT_SUCCESS;\par
00879     {\cf19 goto} cleanup;\par
00880 \par
00881 cleanup:\par
00882     MsReleaseRundownProtection(&Process->ProcessRundown);\par
00883     MsReleaseSpinlock(&Process->VadLock, oldIrql);\par
00884     {\cf19 return} status;\par
00885 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/events.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/events.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/events.c}
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsSetEvent} ({\b IN} {\b PEVENT} event)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsWaitForEvent} ({\b IN} {\b PEVENT} event)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MsSetEvent\:events.c}
{\xe \v events.c\:MsSetEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsSetEvent ({\b IN} {\b PEVENT} event)}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b events.c}.}\par
}
{\xe \v MsWaitForEvent\:events.c}
{\xe \v events.c\:MsWaitForEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsWaitForEvent ({\b IN} {\b PEVENT} event)}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b events.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
events.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/events.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/events.c}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Events Implementation (see KeSetEvent and KMUTANT in MSDN)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/me.h"}\par
00008 {\cf21 #include "../../includes/ps.h"}\par
00009 {\cf21 #include "../../includes/mg.h"}\par
00010 {\cf21 #include "../../assert.h"}\par
00011 \par
00012 MTSTATUS \par
00013 MsSetEvent (\par
00014     IN  PEVENT event\par
00015 ) \par
00016 \par
00017 {\cf20 /*++}\par
00018 {\cf20 }\par
00019 {\cf20     Routine description : Sets an event to wake threads waiting on it.}\par
00020 {\cf20 }\par
00021 {\cf20     Arguments:}\par
00022 {\cf20     }\par
00023 {\cf20         Pointer to EVENT object.}\par
00024 {\cf20 }\par
00025 {\cf20     Return Values:}\par
00026 {\cf20 }\par
00027 {\cf20         Varuious MTSTATUS Codes.}\par
00028 {\cf20 }\par
00029 {\cf20 --*/}\par
00030 \par
00031 \{\par
00032     {\cf19 if} (!event) {\cf19 return} MT_INVALID_ADDRESS;\par
00033 \par
00034     IRQL flags;\par
00035     MsAcquireSpinlock(&event->lock, &flags);\par
00036 \par
00037     {\cf19 if} (event->type == SynchronizationEvent) \{\par
00038         {\cf20 // Wake exactly one waiter (auto-reset)}\par
00039         PETHREAD waiter = MeDequeueThread(&event->waitingQueue); {\cf20 // safe under event->lock}\par
00040         {\cf19 if} (waiter) \{\par
00041             {\cf17 event}->signaled = {\cf17 false}; {\cf20 // consumed by waking one waiter}\par
00042             MsReleaseSpinlock(&event->lock, flags);\par
00043 \par
00044             waiter->InternalThread.ThreadState = THREAD_READY;\par
00045             MeEnqueueThreadWithLock(&MeGetCurrentProcessor()->readyQueue, waiter);\par
00046             {\cf19 return} MT_SUCCESS;\par
00047         \}\par
00048         {\cf19 else} \{\par
00049             {\cf20 // No waiter -> mark event signaled so next waiter won't block}\par
00050             {\cf17 event}->signaled = {\cf17 true};\par
00051             MsReleaseSpinlock(&event->lock, flags);\par
00052             {\cf19 return} MT_SUCCESS;\par
00053         \}\par
00054     \}\par
00055 \par
00056     {\cf20 // NotificationEvent: drain waiters into local list while holding event lock}\par
00057     PETHREAD head = NULL;\par
00058     PETHREAD tail = NULL;\par
00059     PETHREAD t;\par
00060 \par
00061     {\cf19 while} ((t = MeDequeueThread(&event->waitingQueue)) != NULL) \{\par
00062         {\cf20 // 1. Detach the thread from any previous list by nulling its links}\par
00063         t->ThreadListEntry.Flink = NULL;\par
00064         t->ThreadListEntry.Blink = NULL;\par
00065 \par
00066         {\cf20 // 2. Build the local singly-linked list (head/tail) using Flink}\par
00067         {\cf19 if} (tail) \{\par
00068             {\cf20 // Link the current tail to the new thread via Flink}\par
00069             tail->ThreadListEntry.Flink = &t->ThreadListEntry;\par
00070             {\cf20 // Optionally: Set the new thread's Blink to the old tail (for local list integrity)}\par
00071             t->ThreadListEntry.Blink = &tail->ThreadListEntry;\par
00072         \}\par
00073         {\cf19 else} \{\par
00074             {\cf20 // First thread}\par
00075             head = t;\par
00076             {\cf20 // First thread's Blink should be NULL}\par
00077             t->ThreadListEntry.Blink = NULL;\par
00078         \}\par
00079 \par
00080         {\cf20 // The new tail is 't'}\par
00081         tail = t;\par
00082     \}\par
00083 \par
00084     {\cf20 // Notification persists until reset}\par
00085     {\cf17 event}->signaled = {\cf17 true};\par
00086     MsReleaseSpinlock(&event->lock, flags);\par
00087 \par
00088     {\cf20 // Enqueue drained threads to scheduler (after releasing event lock)}\par
00089     t = head;\par
00090     {\cf19 while} (t) \{\par
00091         {\cf20 // Get the next thread pointer by reading the Flink, then CONTAINING_RECORD}\par
00092         {\cf17 struct }_DOUBLY_LINKED_LIST* nxtEntry = t->ThreadListEntry.Flink;\par
00093 \par
00094         {\cf20 // Set thread state}\par
00095         t->InternalThread.ThreadState = THREAD_READY;\par
00096 \par
00097         {\cf20 // Enqueue}\par
00098         MeEnqueueThreadWithLock(&MeGetCurrentProcessor()->readyQueue, t);\par
00099 \par
00100         {\cf20 // Move to the next thread}\par
00101         {\cf19 if} (nxtEntry) \{\par
00102             t = CONTAINING_RECORD(nxtEntry, ETHREAD, ThreadListEntry);\par
00103         \}\par
00104         {\cf19 else} \{\par
00105             t = NULL;\par
00106         \}\par
00107     \}\par
00108 \par
00109     {\cf19 return} MT_SUCCESS;\par
00110 \}\par
00111 \par
00112 MTSTATUS \par
00113 MsWaitForEvent (\par
00114     IN  PEVENT event\par
00115 ) \par
00116 \par
00117 {\cf20 /*++}\par
00118 {\cf20 }\par
00119 {\cf20     Routine description : Sleeps the current thread to wait on the specified event.}\par
00120 {\cf20 }\par
00121 {\cf20     Arguments:}\par
00122 {\cf20 }\par
00123 {\cf20         Pointer to EVENT Object.}\par
00124 {\cf20 }\par
00125 {\cf20     Return Values:}\par
00126 {\cf20 }\par
00127 {\cf20         MT_SUCCESS on wake, other MTSTATUS codes for failure.}\par
00128 {\cf20 }\par
00129 {\cf20     Notes:}\par
00130 {\cf20         }\par
00131 {\cf20         This function MUST NOT be called on IRQL higher or equal to DISPATCH_LEVEL, as this function is blocking or uses pageable memory.}\par
00132 {\cf20 }\par
00133 {\cf20 --*/}\par
00134 \par
00135 \{\par
00136     {\cf19 if} (!event) {\cf19 return} MT_INVALID_ADDRESS;\par
00137     assert((MeGetCurrentIrql() < DISPATCH_LEVEL), {\cf22 "Blocking function called with DISPATCH_LEVEL IRQL or Higher."});\par
00138     IRQL flags;\par
00139     PETHREAD curr = PsGetCurrentThread();\par
00140 \par
00141     {\cf20 // Acquire event lock to check signaled state atomically with enqueue.}\par
00142     MsAcquireSpinlock(&event->lock, &flags);\par
00143 \par
00144     {\cf20 // If already signaled, consume or accept depending on type:}\par
00145     {\cf19 if} (event->signaled) \{\par
00146         {\cf19 if} (event->type == SynchronizationEvent) \{\par
00147             {\cf20 // consume the single-signaled state}\par
00148             {\cf17 event}->signaled = {\cf17 false};\par
00149             {\cf19 goto} Continue;\par
00150         \}\par
00151         {\cf20 // For NotificationEvent, leave event->signaled = true (notification persists)}\par
00152         MsReleaseSpinlock(&event->lock, flags);\par
00153         {\cf19 return} MT_SUCCESS;\par
00154     \}\par
00155 \par
00156     Continue:\par
00157     {\cf20 // Block the thread. When MtSetEvent wakes it, it will be placed on ready queue.}\par
00158     curr->InternalThread.ThreadState = THREAD_BLOCKED;\par
00159     curr->CurrentEvent = event;\par
00160     {\cf20 // Not signaled -> enqueue this thread into the event waiting queue (under event lock)}\par
00161     MeEnqueueThread(&event->waitingQueue, curr);\par
00162     {\cf20 // Keep event lock held only for enqueue; after this we release and block.}\par
00163     MsReleaseSpinlock(&event->lock, flags);\par
00164 {\cf21 #ifdef DEBUG}\par
00165     gop_printf(COLOR_PURPLE, {\cf22 "Sleeping current thread: %p\\n"}, PsGetCurrentThread());\par
00166 {\cf21 #endif}\par
00167     assert((MeGetCurrentIrql()) < DISPATCH_LEVEL);\par
00168     MsYieldExecution(&curr->InternalThread.TrapRegisters);\par
00169 \par
00170     {\cf20 // When we resume here, the waker has already moved us to the ready queue, and we are now an active thread on the CPU.}\par
00171     {\cf19 return} MT_SUCCESS;\par
00172 \}\par
00173 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/mutex.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/mutex.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/mutex.c}
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsInitializeMutexObject} ({\b IN} {\b PMUTEX} mut)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsAcquireMutexObject} ({\b IN} {\b PMUTEX} mut)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsReleaseMutexObject} ({\b IN} {\b PMUTEX} mut)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MsAcquireMutexObject\:mutex.c}
{\xe \v mutex.c\:MsAcquireMutexObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsAcquireMutexObject ({\b IN} {\b PMUTEX} mut)}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b mutex.c}.}\par
}
{\xe \v MsInitializeMutexObject\:mutex.c}
{\xe \v mutex.c\:MsInitializeMutexObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsInitializeMutexObject ({\b IN} {\b PMUTEX} mut)}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#else #undef MsAcquireSpinlock #undef MsReleaseSpinlock\par
#define {\b MsAcquireSpinlock()} // NO-OP #define {\b MsReleaseSpinlock()} // NO-OP #endif \par
}{
Definition at line {\b 13} of file {\b mutex.c}.}\par
}
{\xe \v MsReleaseMutexObject\:mutex.c}
{\xe \v mutex.c\:MsReleaseMutexObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsReleaseMutexObject ({\b IN} {\b PMUTEX} mut)}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b mutex.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mutex.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/mutex.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/mutex.c}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     Mutex Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../includes/me.h"}\par
00008 {\cf21 #include "../../includes/ps.h"}\par
00009 {\cf21 #include "../../includes/mg.h"}\par
00010 {\cf21 #include "../../assert.h"}\par
00011 \par
00012 MTSTATUS \par
00013 MsInitializeMutexObject (\par
00014     IN  PMUTEX mut\par
00015 ) \par
00016 \par
00017 {\cf20 /*++}\par
00018 {\cf20 }\par
00019 {\cf20     Routine description : }\par
00020 {\cf20 }\par
00021 {\cf20         Initializes a MUTEX object, the MUTEX must be in resident memory.}\par
00022 {\cf20 }\par
00023 {\cf20     Arguments:}\par
00024 {\cf20 }\par
00025 {\cf20         Pointer to MUTEX object.}\par
00026 {\cf20 }\par
00027 {\cf20     Return Values:}\par
00028 {\cf20 }\par
00029 {\cf20         Various MTSTATUS Codes. }\par
00030 {\cf20 }\par
00031 {\cf20 --*/}\par
00032 \par
00033 \{\par
00034 \par
00035     {\cf20 // Start of function}\par
00036     {\cf19 if} (!mut) {\cf19 return} MT_INVALID_ADDRESS;\par
00037 \par
00038     {\cf18 bool} isValid = MmIsAddressPresent((uintptr_t)mut);\par
00039     assert((isValid) == 1, {\cf22 "MUTEX Pointer given to function isn't paged in."});\par
00040     {\cf19 if} (!isValid) \{\par
00041         {\cf19 return} MT_INVALID_ADDRESS;\par
00042     \}\par
00043 \par
00044     IRQL oldirql;\par
00045     MsAcquireSpinlock(&mut->lock, &oldirql);\par
00046 \par
00047     assert((mut->ownerTid) == 0, {\cf22 "Mutex must not be owned already in initialization."});\par
00048     {\cf19 if} (mut->ownerTid) \{\par
00049         MsReleaseSpinlock(&mut->lock, oldirql);\par
00050         {\cf19 return} MT_MUTEX_ALREADY_OWNED;\par
00051     \}\par
00052 \par
00053     mut->ownerTid = 0;\par
00054     mut->locked = {\cf17 false};\par
00055     mut->ownerThread = NULL;\par
00056 \par
00057     {\cf20 // Initialize the event state (event->lock is separate and must be preallocated)}\par
00058     {\cf20 // Initialize waiting queue under event lock for safety}\par
00059     \{\par
00060         IRQL eflags;\par
00061         MsAcquireSpinlock(&mut->SynchEvent.lock, &eflags);\par
00062         mut->SynchEvent.type = SynchronizationEvent;\par
00063         mut->SynchEvent.signaled = {\cf17 false};\par
00064         mut->SynchEvent.waitingQueue.head = mut->SynchEvent.waitingQueue.tail = NULL;\par
00065         MsReleaseSpinlock(&mut->SynchEvent.lock, eflags);\par
00066     \}\par
00067 \par
00068     MsReleaseSpinlock(&mut->lock, oldirql);\par
00069     {\cf19 return} MT_SUCCESS;\par
00070 \}\par
00071 \par
00072 MTSTATUS \par
00073 MsAcquireMutexObject (\par
00074     IN  PMUTEX mut\par
00075 ) \par
00076 \par
00077 {\cf20 /*++}\par
00078 {\cf20 }\par
00079 {\cf20     Routine description : Acquires a MUTEX for the current thread.}\par
00080 {\cf20 }\par
00081 {\cf20     Arguments:}\par
00082 {\cf20 }\par
00083 {\cf20         Pointer to MUTEX object.}\par
00084 {\cf20 }\par
00085 {\cf20     Return Values:}\par
00086 {\cf20 }\par
00087 {\cf20         MTSTATUS Code.}\par
00088 {\cf20 }\par
00089 {\cf20     Note:}\par
00090 {\cf20         }\par
00091 {\cf20         This function MUST NOT be called when IRQL is equal or higher than DISPATCH_LEVEL.}\par
00092 {\cf20 }\par
00093 {\cf20 --*/}\par
00094 \par
00095 \{\par
00096     {\cf20 // Check parameter.}\par
00097     {\cf19 if} (!mut) {\cf19 return} MT_INVALID_ADDRESS;\par
00098     {\cf20 // Check if address is currently non pageable in memory.}\par
00099     {\cf19 if} (!MmIsAddressPresent((uintptr_t)mut)) \{\par
00100         {\cf19 return} MT_INVALID_ADDRESS;\par
00101     \}\par
00102 \par
00103     IRQL mflags;\par
00104     assert((MeGetCurrentIrql() < DISPATCH_LEVEL), {\cf22 "Blocking code called at DISPATCH_LEVEL or higher IRQL."});\par
00105 \par
00106     {\cf19 for} (;;) \{\par
00107         MsAcquireSpinlock(&mut->lock, &mflags);\par
00108         PETHREAD currThread = PsGetCurrentThread();\par
00109 \par
00110         {\cf19 if} (!mut->locked) \{\par
00111             mut->locked = {\cf17 true};\par
00112             mut->ownerTid = currThread->TID;\par
00113             mut->ownerThread = currThread;\par
00114             MsReleaseSpinlock(&mut->lock, mflags);\par
00115 {\cf21 #ifdef DEBUG}\par
00116             gop_printf(COLOR_RED, {\cf22 "[MUTEX-DEBUG] Mutex successfully acquired by: %p. MUT: %p\\n"}, currThread, mut);\par
00117 {\cf21 #endif}\par
00118             {\cf19 return} MT_SUCCESS;\par
00119         \}\par
00120 \par
00121         {\cf20 /* mutex is locked -> enqueue/wait */}\par
00122 {\cf21 #ifdef DEBUG}\par
00123         gop_printf(COLOR_RED, {\cf22 "[MUTEX-DEBUG] Mutex busy, enqueuing: MUT: %p\\n"}, mut);\par
00124 {\cf21 #endif}\par
00125         {\cf20 /* Enqueue under the event lock inside MsWaitForEvent; release mut->lock first */}\par
00126         MsReleaseSpinlock(&mut->lock, mflags);\par
00127 \par
00128         MsWaitForEvent(&mut->SynchEvent);\par
00129 \par
00130         {\cf20 /* When MsWaitForEvent returns we loop and try again atomically */}\par
00131     \}\par
00132 \}\par
00133 \par
00134 MTSTATUS \par
00135 MsReleaseMutexObject (\par
00136     IN  PMUTEX mut\par
00137 ) \par
00138 \par
00139 {\cf20 /*++}\par
00140 {\cf20 }\par
00141 {\cf20     Routine description : Releases a MUTEX object, wakes all threads waiting on it (nonblocking).}\par
00142 {\cf20 }\par
00143 {\cf20     Arguments:}\par
00144 {\cf20 }\par
00145 {\cf20         Pointer to MUTEX object.}\par
00146 {\cf20 }\par
00147 {\cf20     Return Values:}\par
00148 {\cf20 }\par
00149 {\cf20         MTSTATUS Code.}\par
00150 {\cf20 }\par
00151 {\cf20 --*/}\par
00152 \par
00153 \{\par
00154 \par
00155     {\cf20 // Start of function}\par
00156     {\cf19 if} (!mut) {\cf19 return} MT_INVALID_ADDRESS;\par
00157 \par
00158     {\cf20 // FOLLOW LOCK ORDER: acquire mut->lock then event->lock}\par
00159     IRQL mflags;\par
00160     MsAcquireSpinlock(&mut->lock, &mflags);\par
00161 \par
00162     assert((mut->ownerTid) != 0, {\cf22 "Attempted release of mutex when it has no owner."});\par
00163     {\cf19 if} (!mut->ownerTid) \{\par
00164         MsReleaseSpinlock(&mut->lock, mflags);\par
00165         {\cf19 return} MT_MUTEX_NOT_OWNED;\par
00166     \}\par
00167 \par
00168     {\cf20 // Clear ownership while still holding the spinlock}\par
00169     mut->ownerTid = 0;\par
00170     mut->locked = {\cf17 false};\par
00171     mut->ownerThread = NULL;\par
00172 \par
00173     MsReleaseSpinlock(&mut->lock, mflags);\par
00174 \par
00175     {\cf20 // Wake the selected thread by setting an event.}\par
00176     MsSetEvent(&mut->SynchEvent);\par
00177 \par
00178     {\cf19 return} MT_SUCCESS;\par
00179 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/rundown.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/rundown.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/rundown.c}
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/me.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEARDOWN_ACTIVE}\~ (1ULL << 63)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b REFERENCE_COUNT}\~ (0x7FFFFFFFFFFFFFFF)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MsAcquireRundownProtection} ({\b IN} {\b PRUNDOWN_REF} rundown)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsReleaseRundownProtection} ({\b IN} {\b PRUNDOWN_REF} rundown)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsWaitForRundownProtectionRelease} ({\b IN} {\b PRUNDOWN_REF} rundown)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v REFERENCE_COUNT\:rundown.c}
{\xe \v rundown.c\:REFERENCE_COUNT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define REFERENCE_COUNT\~ (0x7FFFFFFFFFFFFFFF)}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b rundown.c}.}\par
}
{\xe \v TEARDOWN_ACTIVE\:rundown.c}
{\xe \v rundown.c\:TEARDOWN_ACTIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEARDOWN_ACTIVE\~ (1ULL << 63)}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b rundown.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MsAcquireRundownProtection\:rundown.c}
{\xe \v rundown.c\:MsAcquireRundownProtection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MsAcquireRundownProtection ({\b IN} {\b PRUNDOWN_REF} rundown)}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b rundown.c}.}\par
}
{\xe \v MsReleaseRundownProtection\:rundown.c}
{\xe \v rundown.c\:MsReleaseRundownProtection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsReleaseRundownProtection ({\b IN} {\b PRUNDOWN_REF} rundown)}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b rundown.c}.}\par
}
{\xe \v MsWaitForRundownProtectionRelease\:rundown.c}
{\xe \v rundown.c\:MsWaitForRundownProtectionRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsWaitForRundownProtectionRelease ({\b IN} {\b PRUNDOWN_REF} rundown)}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b rundown.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rundown.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/rundown.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/rundown.c}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "../../includes/me.h"}\par
00002 \par
00003 {\cf21 #define TEARDOWN_ACTIVE (1ULL << 63)}\par
00004 {\cf21 #define REFERENCE_COUNT (0x7FFFFFFFFFFFFFFF)}\par
00005 \par
00006 {\cf18 bool} \par
00007 MsAcquireRundownProtection (\par
00008     IN    PRUNDOWN_REF rundown\par
00009 ) \par
00010 \par
00011 {\cf20 /*++}\par
00012 {\cf20 }\par
00013 {\cf20     Routine description : Safely acquires rundown protection on a shared resource to prevent it from being deleted or "rundown" while in use.}\par
00014 {\cf20 }\par
00015 {\cf20     Arguments:}\par
00016 {\cf20 }\par
00017 {\cf20         Pointer to RUNDOWN_REF Object.}\par
00018 {\cf20 }\par
00019 {\cf20     Return Values:}\par
00020 {\cf20 }\par
00021 {\cf20         True - The rundown protection acquisition has succeeded, the object is safe from memory deletion.}\par
00022 {\cf20         False - Teardown has started on the object, handle gracefully.}\par
00023 {\cf20 }\par
00024 {\cf20 --*/}\par
00025 \par
00026 \{\par
00027     uint64_t old_count, new_count;\par
00028     {\cf19 do} \{\par
00029         old_count = rundown->Count;\par
00030         {\cf19 if} (old_count & TEARDOWN_ACTIVE) \{\par
00031             {\cf20 // Teardown has started, refuse to acquire.}\par
00032             {\cf19 return} {\cf17 false};\par
00033         \}\par
00034         new_count = old_count + 1;\par
00035     \} {\cf19 while} (!InterlockedCompareExchangeU64(&rundown->Count, new_count, old_count));\par
00036     {\cf19 return} {\cf17 true};\par
00037 \}\par
00038 \par
00039 {\cf18 void} \par
00040 MsReleaseRundownProtection (\par
00041     IN    PRUNDOWN_REF rundown\par
00042 ) \par
00043 \par
00044 {\cf20 /*++}\par
00045 {\cf20 }\par
00046 {\cf20     Routine description : Releases rundown protection from the object.}\par
00047 {\cf20 }\par
00048 {\cf20     Arguments:}\par
00049 {\cf20 }\par
00050 {\cf20         Pointer to RUNDOWN_REF Object.}\par
00051 {\cf20 }\par
00052 {\cf20     Return Values:}\par
00053 {\cf20 }\par
00054 {\cf20         None.}\par
00055 {\cf20 }\par
00056 {\cf20 --*/}\par
00057 \par
00058 \{\par
00059     InterlockedDecrementU64(&rundown->Count);\par
00060 \}\par
00061 \par
00062 {\cf20 // Wait for rundown (teardown)}\par
00063 {\cf18 void} MsWaitForRundownProtectionRelease (\par
00064     IN    PRUNDOWN_REF rundown\par
00065 ) \par
00066 \par
00067 {\cf20 /*++}\par
00068 {\cf20 }\par
00069 {\cf20     Routine description : Waits until all rundown protections have been released from the object, then starts Teardown.}\par
00070 {\cf20     Use this when you want to gurantee an object will not be used after free.}\par
00071 {\cf20 }\par
00072 {\cf20     Arguments:}\par
00073 {\cf20 }\par
00074 {\cf20         Pointer to RUNDOWN_REF Object.}\par
00075 {\cf20 }\par
00076 {\cf20     Return Values:}\par
00077 {\cf20 }\par
00078 {\cf20         None.}\par
00079 {\cf20 }\par
00080 {\cf20 --*/}\par
00081 \par
00082 \{\par
00083     uint64_t old_count;\par
00084     {\cf19 do} \{\par
00085         old_count = rundown->Count;\par
00086     \} {\cf19 while} (!InterlockedCompareExchangeU64(&rundown->Count, old_count | TEARDOWN_ACTIVE, old_count));\par
00087 \par
00088     {\cf20 // Spin until count reaches zero (TODO RUNDOWN REF WAKE SLEEP (use the 0-62 bits for a pointer )}\par
00089     {\cf19 while} ((rundown->Count & REFERENCE_COUNT) != 0) \{\par
00090         __pause();\par
00091     \}\par
00092 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/spinlock.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/spinlock.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/spinlock.c}
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ms.h"}\par
{\f2 #include "../../includes/me.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b X86_SPINLOCK_H}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsAcquireSpinlock} ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b PIRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsReleaseSpinlock} ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b IRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsAcquireSpinlockAtDpcLevel} ({\b IN} {\b PSPINLOCK} Lock)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsReleaseSpinlockFromDpcLevel} ({\b IN} {\b PSPINLOCK} Lock)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v X86_SPINLOCK_H\:spinlock.c}
{\xe \v spinlock.c\:X86_SPINLOCK_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define X86_SPINLOCK_H}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b spinlock.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MsAcquireSpinlock\:spinlock.c}
{\xe \v spinlock.c\:MsAcquireSpinlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsAcquireSpinlock ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b PIRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b spinlock.c}.}\par
}
{\xe \v MsAcquireSpinlockAtDpcLevel\:spinlock.c}
{\xe \v spinlock.c\:MsAcquireSpinlockAtDpcLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsAcquireSpinlockAtDpcLevel ({\b IN} {\b PSPINLOCK} Lock)}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b spinlock.c}.}\par
}
{\xe \v MsReleaseSpinlock\:spinlock.c}
{\xe \v spinlock.c\:MsReleaseSpinlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsReleaseSpinlock ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b IRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b spinlock.c}.}\par
}
{\xe \v MsReleaseSpinlockFromDpcLevel\:spinlock.c}
{\xe \v spinlock.c\:MsReleaseSpinlockFromDpcLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsReleaseSpinlockFromDpcLevel ({\b IN} {\b PSPINLOCK} Lock)}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b spinlock.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
spinlock.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/spinlock.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ms/spinlock.c}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Spinlock Types and Function Declarations. (MS)}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_SPINLOCK_H}\par
00007 {\cf21 #define X86_SPINLOCK_H}\par
00008 \par
00009 {\cf21 #include "../../includes/ms.h"}\par
00010 {\cf21 #include "../../includes/me.h"}\par
00011 \par
00012 {\cf18 void} \par
00013 MsAcquireSpinlock (\par
00014     IN    PSPINLOCK lock,\par
00015     IN    PIRQL OldIrql\par
00016 ) \par
00017 \par
00018 {\cf20 /*++}\par
00019 {\cf20 }\par
00020 {\cf20     Routine description : Acquires a spinlock, raises IRQL to DISPATCH_LEVEL.}\par
00021 {\cf20 }\par
00022 {\cf20     Arguments:}\par
00023 {\cf20 }\par
00024 {\cf20         [IN]    Pointer to SPINLOCK object.}\par
00025 {\cf20         [IN]    Pointer to Old IRQL variable.}\par
00026 {\cf20 }\par
00027 {\cf20     Return Values:}\par
00028 {\cf20 }\par
00029 {\cf20         None.}\par
00030 {\cf20 }\par
00031 {\cf20 --*/}\par
00032 \par
00033 \{\par
00034     {\cf19 if} (!lock) {\cf19 return};\par
00035     {\cf20 // spin until we grab the lock.}\par
00036     MeRaiseIrql(DISPATCH_LEVEL, OldIrql);\par
00037     {\cf19 while} (__sync_lock_test_and_set(&lock->locked, 1)) \{\par
00038         __asm__ {\cf17 volatile}({\cf22 "pause"} ::: {\cf22 "memory"}); {\cf20 /* x86 pause \'97 CPU relax hint */}\par
00039     \}\par
00040     {\cf20 // Memory barrier to prevent instruction reordering}\par
00041     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00042 \}\par
00043 \par
00044 {\cf18 void} \par
00045 MsReleaseSpinlock (\par
00046     IN    PSPINLOCK lock, \par
00047     IN    IRQL OldIrql\par
00048 ) \par
00049 \par
00050 {\cf20 /*++}\par
00051 {\cf20 }\par
00052 {\cf20     Routine description : Releases a spinlock, restores previous IRQL.}\par
00053 {\cf20 }\par
00054 {\cf20     Arguments:}\par
00055 {\cf20 }\par
00056 {\cf20         [IN]    Pointer to SPINLOCK object.}\par
00057 {\cf20         [IN]    Old IRQL given by MsAcquireSpinlock}\par
00058 {\cf20 }\par
00059 {\cf20     Return Values:}\par
00060 {\cf20 }\par
00061 {\cf20         None.}\par
00062 {\cf20 }\par
00063 {\cf20 --*/}\par
00064 \par
00065 \{\par
00066     {\cf19 if} (!lock) {\cf19 return};\par
00067     {\cf20 // Memory barrier before release}\par
00068     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00069     __sync_lock_release(&lock->locked);\par
00070     MeLowerIrql(OldIrql);\par
00071 \}\par
00072 \par
00073 {\cf18 void}\par
00074 MsAcquireSpinlockAtDpcLevel(\par
00075     IN PSPINLOCK Lock\par
00076 )\par
00077 \par
00078 \{\par
00079     {\cf20 // Make sure we are at DPC level or above}\par
00080     {\cf19 if} (MeGetCurrentIrql() < DISPATCH_LEVEL) \{\par
00081         {\cf20 // Bugcheck.}\par
00082         MeBugCheckEx(\par
00083             IRQL_NOT_GREATER_OR_EQUAL,\par
00084             ({\cf18 void}*)Lock,\par
00085             ({\cf18 void}*)MeGetCurrentIrql(),\par
00086             NULL,\par
00087             NULL\par
00088         );\par
00089     \}\par
00090     \par
00091     {\cf20 // Acquire the spinlock.}\par
00092     {\cf19 while} (__sync_lock_test_and_set(&Lock->locked, 1)) \{\par
00093         __asm__ {\cf17 volatile}({\cf22 "pause"} ::: {\cf22 "memory"}); {\cf20 /* x86 pause \'97 CPU relax hint */}\par
00094     \}\par
00095     {\cf20 // Memory barrier to prevent instruction reordering}\par
00096     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00097 \}\par
00098 \par
00099 {\cf18 void}\par
00100 MsReleaseSpinlockFromDpcLevel(\par
00101     IN PSPINLOCK Lock\par
00102 )\par
00103 \par
00104 \{\par
00105     {\cf20 // Make sure we are at DPC level or above}\par
00106     {\cf19 if} (MeGetCurrentIrql() < DISPATCH_LEVEL) \{\par
00107         {\cf20 // Bugcheck.}\par
00108         MeBugCheckEx(\par
00109             IRQL_NOT_GREATER_OR_EQUAL,\par
00110             ({\cf18 void}*)Lock,\par
00111             ({\cf18 void}*)MeGetCurrentIrql(),\par
00112             NULL,\par
00113             NULL\par
00114         );\par
00115     \}\par
00116 \par
00117     {\cf20 // Release the spinlock.}\par
00118     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00119     __sync_lock_release(&Lock->locked);\par
00120 \}\par
00121 \par
00122 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ob/ob.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ob/ob.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ob/ob.c}
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ob.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/md.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/ps.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ObInitialize} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateObjectType} ({\b IN} char *TypeName, {\b IN} {\b POBJECT_TYPE_INITIALIZER} ObjectTypeInitializer, {\b OUT} {\b POBJECT_TYPE} *ReturnedObjectType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateObject} ({\b IN} {\b POBJECT_TYPE} ObjectType, {\b IN} uint32_t ObjectSize, {\b OUT} void **ObjectCreated)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ObReferenceObject} ({\b IN} void *Object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObReferenceObjectByPointer} ({\b IN} void *Object, {\b IN} {\b POBJECT_TYPE} DesiredType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObReferenceObjectByHandle} ({\b IN} {\b HANDLE} Handle, {\b IN} uint32_t DesiredAccess, {\b IN} {\b POBJECT_TYPE} DesiredType, {\b OUT} void **Object, {\b _Out_Opt} {\b PHANDLE_TABLE_ENTRY} HandleInformation)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateHandleForObject} ({\b IN} void *Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateHandleForObjectEx} ({\b IN} void *Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle, {\b IN} {\b PHANDLE_TABLE} ObjectTable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ObDereferenceObject} ({\b IN} void *Object)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DOUBLY_LINKED_LIST} {\b ObTypeDirectoryList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b ObGlobalLock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile void * {\b ObpReaperList} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DPC} {\b ObpReaperDpc}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ObCreateHandleForObject\:ob.c}
{\xe \v ob.c\:ObCreateHandleForObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateHandleForObject ({\b IN} void * Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle)}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 318} of file {\b ob.c}.}\par
}
{\xe \v ObCreateHandleForObjectEx\:ob.c}
{\xe \v ob.c\:ObCreateHandleForObjectEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateHandleForObjectEx ({\b IN} void * Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle, {\b IN} {\b PHANDLE_TABLE} ObjectTable)}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 363} of file {\b ob.c}.}\par
}
{\xe \v ObCreateObject\:ob.c}
{\xe \v ob.c\:ObCreateObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateObject ({\b IN} {\b POBJECT_TYPE} ObjectType, {\b IN} uint32_t ObjectSize, {\b OUT} void ** ObjectCreated)}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b ob.c}.}\par
}
{\xe \v ObCreateObjectType\:ob.c}
{\xe \v ob.c\:ObCreateObjectType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateObjectType ({\b IN} char * TypeName, {\b IN} {\b POBJECT_TYPE_INITIALIZER} ObjectTypeInitializer, {\b OUT} {\b POBJECT_TYPE} * ReturnedObjectType)}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b ob.c}.}\par
}
{\xe \v ObDereferenceObject\:ob.c}
{\xe \v ob.c\:ObDereferenceObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObDereferenceObject ({\b IN} void * Object)}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 446} of file {\b ob.c}.}\par
}
{\xe \v ObInitialize\:ob.c}
{\xe \v ob.c\:ObInitialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObInitialize (void )}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ob.c}.}\par
}
{\xe \v ObReferenceObject\:ob.c}
{\xe \v ob.c\:ObReferenceObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ObReferenceObject ({\b IN} void * Object)}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b ob.c}.}\par
}
{\xe \v ObReferenceObjectByHandle\:ob.c}
{\xe \v ob.c\:ObReferenceObjectByHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObReferenceObjectByHandle ({\b IN} {\b HANDLE} Handle, {\b IN} uint32_t DesiredAccess, {\b IN} {\b POBJECT_TYPE} DesiredType, {\b OUT} void ** Object, {\b _Out_Opt} {\b PHANDLE_TABLE_ENTRY} HandleInformation)}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b ob.c}.}\par
}
{\xe \v ObReferenceObjectByPointer\:ob.c}
{\xe \v ob.c\:ObReferenceObjectByPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObReferenceObjectByPointer ({\b IN} void * Object, {\b IN} {\b POBJECT_TYPE} DesiredType)}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b ob.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ObGlobalLock\:ob.c}
{\xe \v ob.c\:ObGlobalLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} ObGlobalLock}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b ob.c}.}\par
}
{\xe \v ObpReaperDpc\:ob.c}
{\xe \v ob.c\:ObpReaperDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DPC} ObpReaperDpc}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b ob.c}.}\par
}
{\xe \v ObpReaperList\:ob.c}
{\xe \v ob.c\:ObpReaperList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* ObpReaperList = NULL}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b ob.c}.}\par
}
{\xe \v ObTypeDirectoryList\:ob.c}
{\xe \v ob.c\:ObTypeDirectoryList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DOUBLY_LINKED_LIST} ObTypeDirectoryList}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b ob.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ob.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ob/ob.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ob/ob.c}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     ob.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of the object manager.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/ob.h"}\par
00020 {\cf21 #include "../../includes/mg.h"}\par
00021 {\cf21 #include "../../includes/md.h"}\par
00022 {\cf21 #include "../../assert.h"}\par
00023 {\cf21 #include "../../includes/ps.h"}\par
00024 \par
00025 {\cf20 // Global list of types (for debugging/enumeration)}\par
00026 DOUBLY_LINKED_LIST ObTypeDirectoryList;\par
00027 SPINLOCK ObGlobalLock;\par
00028 {\cf17 volatile} {\cf18 void}* ObpReaperList = NULL;\par
00029 \par
00030 \par
00031 DPC ObpReaperDpc;\par
00032 \par
00033 {\cf18 void} ObInitialize (\par
00034     {\cf18 void}\par
00035 ) \par
00036 \par
00037 {\cf20 /*++}\par
00038 {\cf20 }\par
00039 {\cf20     Routine description:}\par
00040 {\cf20 }\par
00041 {\cf20         Initializes the Object Manager of the kernel.}\par
00042 {\cf20 }\par
00043 {\cf20     Arguments:}\par
00044 {\cf20 }\par
00045 {\cf20         None.}\par
00046 {\cf20 }\par
00047 {\cf20     Return Values:}\par
00048 {\cf20 }\par
00049 {\cf20         None.}\par
00050 {\cf20 }\par
00051 {\cf20 --*/}\par
00052 \par
00053 \{\par
00054     ObGlobalLock.locked = {\cf17 false};\par
00055     InitializeListHead(&ObTypeDirectoryList);\par
00056     {\cf20 // Initialize the DPC here, not at the ObpDefer function, as it would overwrite.}\par
00057     MeInitializeDpc(&ObpReaperDpc, ReapOb, NULL, MEDIUM_PRIORITY);\par
00058 \}\par
00059 \par
00060 MTSTATUS ObCreateObjectType(\par
00061     IN {\cf18 char}* TypeName,\par
00062     IN POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,\par
00063     OUT POBJECT_TYPE* ReturnedObjectType\par
00064 ) \par
00065 \par
00066 {\cf20 /*++}\par
00067 {\cf20 }\par
00068 {\cf20     Routine description:}\par
00069 {\cf20 }\par
00070 {\cf20         Creates an object type for the specified object in the kernel subsystem.}\par
00071 {\cf20 }\par
00072 {\cf20     Arguments:}\par
00073 {\cf20 }\par
00074 {\cf20         [IN]    char* TypeName - The name of the object subsystem that will be created for.}\par
00075 {\cf20         [IN]    POBJECT_TYPE_INITIALIZER ObjectTypeInitializer - The initializer for each object created by ObCreateObject that defines how it should be created & its attributes.}\par
00076 {\cf20         [OUT]   POBJECT_TYPE* ReturnedObjectType - The returned object type, used to identify this type of object initialization.}\par
00077 {\cf20 }\par
00078 {\cf20     Return Values:}\par
00079 {\cf20 }\par
00080 {\cf20         MTSTATUS Status codes:}\par
00081 {\cf20 }\par
00082 {\cf20             MT_INVALID_PARAM: Invalid parameter, one of them is NULL.}\par
00083 {\cf20             MT_NO_MEMORY: No memory is available to create the object type.}\par
00084 {\cf20             MT_SUCCESS: Successfully created the object type.}\par
00085 {\cf20 }\par
00086 {\cf20 --*/}\par
00087 \par
00088 \{\par
00089     {\cf19 if} (!TypeName || !ObjectTypeInitializer || !ReturnedObjectType) \{\par
00090         {\cf19 return} MT_INVALID_PARAM;\par
00091     \}\par
00092 \par
00093     {\cf20 // Allocate the Type Object itself.}\par
00094     POBJECT_TYPE NewType = (POBJECT_TYPE)MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(OBJECT_TYPE), {\cf22 'epyT'}); {\cf20 // Type}\par
00095     {\cf19 if} (!NewType) {\cf19 return} MT_NO_MEMORY;\par
00096 \par
00097     {\cf20 // Initialize the Type Object}\par
00098     kmemset(NewType, 0, {\cf17 sizeof}(OBJECT_TYPE));\par
00099     kstrncpy(NewType->Name, TypeName, 32);\par
00100 \par
00101     {\cf20 // Copy the initializer into the object}\par
00102     kmemcpy(&NewType->TypeInfo, ObjectTypeInitializer, {\cf17 sizeof}(OBJECT_TYPE_INITIALIZER));\par
00103 \par
00104     {\cf20 // Link it into the global list}\par
00105     IRQL oldIrql;\par
00106     MsAcquireSpinlock(&ObGlobalLock, &oldIrql);\par
00107     InsertTailList(&ObTypeDirectoryList, &NewType->TypeList);\par
00108     MsReleaseSpinlock(&ObGlobalLock, oldIrql);\par
00109 \par
00110     {\cf20 // 5. Return the pointer}\par
00111     *ReturnedObjectType = NewType;\par
00112     {\cf19 return} MT_SUCCESS;\par
00113 \}\par
00114 \par
00115 MTSTATUS\par
00116 ObCreateObject(\par
00117     IN POBJECT_TYPE ObjectType,\par
00118     IN uint32_t ObjectSize,\par
00119     OUT {\cf18 void}** ObjectCreated\par
00120     {\cf20 //_In_Opt char* Name - When files arrive, i'll uncomment this.}\par
00121 ) \par
00122 \par
00123 {\cf20 /*++}\par
00124 {\cf20 }\par
00125 {\cf20     Routine description:}\par
00126 {\cf20 }\par
00127 {\cf20        Creates an object for the specified object type subsystem.}\par
00128 {\cf20 }\par
00129 {\cf20     Arguments:}\par
00130 {\cf20 }\par
00131 {\cf20         [IN]    POBJECT_TYPE ObjectType - The object type to create the object for.}\par
00132 {\cf20         [IN]    uint32_t ObjectBodySize - The size of the object in bytes to create.}\par
00133 {\cf20 }\par
00134 {\cf20     Return Values:}\par
00135 {\cf20 }\par
00136 {\cf20         Pointer to object, or NULL on failure.}\par
00137 {\cf20 }\par
00138 {\cf20 --*/}\par
00139 \par
00140 \{\par
00141     {\cf20 // 1. Calculate size}\par
00142     {\cf18 size_t} ActualSize = {\cf17 sizeof}(OBJECT_HEADER) + ObjectSize;\par
00143 \par
00144     {\cf20 // Allocate memory for the header.}\par
00145     POBJECT_HEADER Header = (POBJECT_HEADER)MmAllocatePoolWithTag(ObjectType->TypeInfo.PoolType, ActualSize, {\cf22 'bObO'}); {\cf20 // Ob Object, not bobo, lol.}\par
00146     {\cf19 if} (!Header) {\cf19 return} MT_NO_MEMORY;\par
00147 \par
00148     Header->Type = ObjectType;\par
00149     Header->PointerCount = 1; {\cf20 // Start with 1 reference}\par
00150 \par
00151     {\cf20 // Update stats in the Type object}\par
00152     InterlockedIncrementU32(({\cf17 volatile} uint32_t*)&ObjectType->TotalNumberOfObjects);\par
00153 \par
00154     {\cf20 // Return Body}\par
00155     *ObjectCreated = OBJECT_HEADER_TO_OBJECT(Header);\par
00156     {\cf19 return} MT_SUCCESS;\par
00157 \}\par
00158 \par
00159 {\cf18 bool} \par
00160 ObReferenceObject(\par
00161     IN  {\cf18 void}* Object\par
00162 ) \par
00163 \par
00164 {\cf20 /*++}\par
00165 {\cf20 }\par
00166 {\cf20     Routine description:}\par
00167 {\cf20 }\par
00168 {\cf20        References the Object given.}\par
00169 {\cf20 }\par
00170 {\cf20     Arguments:}\par
00171 {\cf20 }\par
00172 {\cf20         [IN]    void* Object - The Object to increment reference count for.}\par
00173 {\cf20 }\par
00174 {\cf20     Return Values:}\par
00175 {\cf20 }\par
00176 {\cf20         True if reference succeded, false otherwise (object dying/dead).}\par
00177 {\cf20 }\par
00178 {\cf20 --*/}\par
00179 \par
00180 \{\par
00181     {\cf19 if} (!Object) {\cf19 return} {\cf17 false};\par
00182     POBJECT_HEADER Header = OBJECT_TO_OBJECT_HEADER(Object);\par
00183 \par
00184     uint64_t OldCount = Header->PointerCount;\par
00185     {\cf19 while} (1) \{\par
00186         {\cf19 if} (OldCount == 0) {\cf19 return} {\cf17 false}; {\cf20 // Object is dying or dead}\par
00187 \par
00188         uint64_t NewCount = InterlockedCompareExchangeU64(\par
00189             ({\cf17 volatile} uint64_t*)&Header->PointerCount,\par
00190             OldCount + 1,\par
00191             OldCount\par
00192         );\par
00193 \par
00194         {\cf19 if} (NewCount == OldCount) {\cf19 return} {\cf17 true};\par
00195         OldCount = NewCount;\par
00196     \}\par
00197 \}\par
00198 \par
00199 MTSTATUS\par
00200 ObReferenceObjectByPointer(\par
00201     IN  {\cf18 void}* Object,\par
00202     IN  POBJECT_TYPE DesiredType\par
00203 )\par
00204 \par
00205 {\cf20 /*++}\par
00206 {\cf20 }\par
00207 {\cf20     Routine description:}\par
00208 {\cf20 }\par
00209 {\cf20        References the Object given by its pointer.}\par
00210 {\cf20 }\par
00211 {\cf20     Arguments:}\par
00212 {\cf20 }\par
00213 {\cf20         [IN]    void* Object - The Object to increment reference count for.}\par
00214 {\cf20         [IN]    POBJECT_TYPE DesiredType - The type we EXPECT the Object to be (PsProcessType, PsThreadType, etc..)}\par
00215 {\cf20 }\par
00216 {\cf20     Return Values:}\par
00217 {\cf20 }\par
00218 {\cf20         MT_SUCCESS if reference succeeded.}\par
00219 {\cf20         MT_TYPE_MISMATCH if DesiredType isn't the Object's actual OBJECT_TYPE.}\par
00220 {\cf20         MT_INVALID_PARAM if Object is NULL.}\par
00221 {\cf20         MT_OBJECT_DELETED if Object is deleted / ongoing deletion.}\par
00222 {\cf20 }\par
00223 {\cf20         MT_BETTER_THAN_WINDOWS if (true)}\par
00224 {\cf20 }\par
00225 {\cf20 --*/}\par
00226 \par
00227 \{\par
00228     {\cf19 if} (!Object) {\cf19 return} MT_INVALID_PARAM;\par
00229 \par
00230     POBJECT_HEADER Header = OBJECT_TO_OBJECT_HEADER(Object);\par
00231 \par
00232     {\cf20 // If the caller expects a process but gets a thread or a file, we say no no bye bye.}\par
00233     {\cf19 if} (DesiredType != NULL && Header->Type != DesiredType) \{\par
00234         {\cf19 return} MT_TYPE_MISMATCH;\par
00235     \}\par
00236 \par
00237     {\cf20 // We reference it.}\par
00238     {\cf19 if} (ObReferenceObject(Object)) \{\par
00239         {\cf19 return} MT_SUCCESS;\par
00240     \}\par
00241 \par
00242     {\cf20 // Object is RIP, we return.}\par
00243     {\cf19 return} MT_OBJECT_DELETED;\par
00244 \}\par
00245 \par
00246 MTSTATUS\par
00247 ObReferenceObjectByHandle(\par
00248     IN HANDLE Handle,\par
00249     IN uint32_t DesiredAccess,\par
00250     IN POBJECT_TYPE DesiredType,\par
00251     OUT {\cf18 void}** Object,\par
00252     _Out_Opt PHANDLE_TABLE_ENTRY HandleInformation\par
00253 )\par
00254 \par
00255 {\cf20 /*++}\par
00256 {\cf20 }\par
00257 {\cf20     Routine description:}\par
00258 {\cf20 }\par
00259 {\cf20        References the Object given by its given handle.}\par
00260 {\cf20 }\par
00261 {\cf20     Arguments:}\par
00262 {\cf20 }\par
00263 {\cf20         [IN]    HANDLE Handle - The handle to reference the object for.}\par
00264 {\cf20         [IN]    uint32_t DesiredAccess - The access rights requested for the object.}\par
00265 {\cf20         [IN]    POBJECT_TYPE DesiredType - The type we EXPECT the Object to be (PsProcessType, PsThreadType, etc..)}\par
00266 {\cf20         [OUT]   void** Object - The pointer to the object expected.}\par
00267 {\cf20         [OUT OPTIONAL]  PHANDLE_TABLE_ENTRY HandleInformation - Information about the handle given if MT_SUCCESS is returned.}\par
00268 {\cf20 }\par
00269 {\cf20     Return Values:}\par
00270 {\cf20 }\par
00271 {\cf20         MT_SUCCESS if reference succeeded.}\par
00272 {\cf20         MT_INVALID_HANDLE if the HANDLE is simply invalid (doesn't exist, or table doesnt exist)}\par
00273 {\cf20         MT_TYPE_MISMATCH if DesiredType isn't the Object's actual OBJECT_TYPE.}\par
00274 {\cf20         MT_INVALID_PARAM if Object is NULL.}\par
00275 {\cf20         MT_OBJECT_DELETED if Object is deleted / ongoing deletion.}\par
00276 {\cf20         MT_ACCESS_DENIED if the desired access does not meet the access rights of the Object.}\par
00277 {\cf20 }\par
00278 {\cf20         MT_BETTER_THAN_WINDOWS if (true)}\par
00279 {\cf20 }\par
00280 {\cf20 --*/}\par
00281 \par
00282 \{\par
00283     {\cf20 // Set initially to NULL. (to overwrite stack default if uninitialized)}\par
00284     *Object = NULL;\par
00285 \par
00286     {\cf20 // Get the handle table from current process (requesting process)}\par
00287     PEPROCESS Process = PsGetCurrentProcess();\par
00288     {\cf19 if} (!Process || !Process->ObjectTable) {\cf19 return} MT_INVALID_HANDLE;\par
00289 \par
00290     {\cf20 // Lookup in the handle table.}\par
00291     PHANDLE_TABLE_ENTRY OutHandleEntry = NULL;\par
00292     {\cf18 void}* RetrievedObject = HtGetObject(Process->ObjectTable, Handle, &OutHandleEntry);\par
00293     {\cf19 if} (!RetrievedObject) {\cf19 return} MT_INVALID_HANDLE;\par
00294 \par
00295     {\cf20 // Get the header.}\par
00296     POBJECT_HEADER Header = OBJECT_TO_OBJECT_HEADER(RetrievedObject);\par
00297 \par
00298     {\cf20 // Lets check if the type matches}\par
00299     {\cf19 if} (DesiredType && Header->Type != DesiredType) \{\par
00300         {\cf20 // Invalid type.}\par
00301         {\cf19 return} MT_TYPE_MISMATCH;\par
00302     \}\par
00303 \par
00304     {\cf20 // Check access.}\par
00305     {\cf19 if} ((OutHandleEntry->GrantedAccess & DesiredAccess) != DesiredAccess) \{\par
00306         {\cf20 // Access is invalid.}\par
00307         {\cf19 return} MT_ACCESS_DENIED;\par
00308     \}\par
00309 \par
00310     {\cf20 // Wow!! It is all good!!, reference it.}\par
00311     ObReferenceObject(RetrievedObject);\par
00312     *Object = RetrievedObject;\par
00313     {\cf19 if} (HandleInformation) *HandleInformation = *OutHandleEntry;\par
00314     {\cf19 return} MT_SUCCESS;\par
00315 \}\par
00316 \par
00317 MTSTATUS\par
00318 ObCreateHandleForObject(\par
00319     IN {\cf18 void}* Object,\par
00320     IN ACCESS_MASK DesiredAccess,\par
00321     OUT PHANDLE ReturnedHandle\par
00322 )\par
00323 \par
00324 {\cf20 /*++}\par
00325 {\cf20 }\par
00326 {\cf20     Routine description:}\par
00327 {\cf20 }\par
00328 {\cf20        Creates a handle in the current process's handle table for the specified Object.}\par
00329 {\cf20 }\par
00330 {\cf20     Arguments:}\par
00331 {\cf20 }\par
00332 {\cf20         [IN]    void* Object - The object to create the handle for.}\par
00333 {\cf20         [IN]    ACCESS_MASK DesiredAccess - The maximum access the handle should have.}\par
00334 {\cf20         [OUT]   PHANDLE ReturnedHandle - The returned handle for the object if success.}\par
00335 {\cf20 }\par
00336 {\cf20     Return Values:}\par
00337 {\cf20 }\par
00338 {\cf20         MTSTATUS Status Codes:}\par
00339 {\cf20 }\par
00340 {\cf20             MT_SUCCESS - Successful.}\par
00341 {\cf20             MT_INVALID_STATE - No handle table for current process.}\par
00342 {\cf20             MT_INVALID_CHECK - HtCreateHandle returned MT_INVALID_HANDLE.}\par
00343 {\cf20 --*/}\par
00344 \par
00345 \{\par
00346     {\cf20 // Acquire the object table.}\par
00347     PHANDLE_TABLE ObjectTable = PsGetCurrentProcess()->ObjectTable;\par
00348     {\cf19 if} (!ObjectTable) {\cf19 return} MT_INVALID_ADDRESS;\par
00349 \par
00350     {\cf20 // Create the handle.}\par
00351     HANDLE Handle = HtCreateHandle(ObjectTable, Object, DesiredAccess);\par
00352     {\cf19 if} (Handle == MT_INVALID_HANDLE) {\cf19 return} MT_INVALID_CHECK;\par
00353 \par
00354     {\cf20 // Reference the object.}\par
00355     ObReferenceObject(Object);\par
00356     \par
00357     {\cf20 // Return success.}\par
00358     *ReturnedHandle = Handle;\par
00359     {\cf19 return} MT_SUCCESS;\par
00360 \}\par
00361 \par
00362 MTSTATUS\par
00363 ObCreateHandleForObjectEx(\par
00364     IN {\cf18 void}* Object,\par
00365     IN ACCESS_MASK DesiredAccess,\par
00366     OUT PHANDLE ReturnedHandle,\par
00367     IN PHANDLE_TABLE ObjectTable\par
00368 )\par
00369 \par
00370 {\cf20 /*++}\par
00371 {\cf20 }\par
00372 {\cf20     Routine description:}\par
00373 {\cf20 }\par
00374 {\cf20        Creates a handle in the specified handle table for the specified Object.}\par
00375 {\cf20 }\par
00376 {\cf20     Arguments:}\par
00377 {\cf20 }\par
00378 {\cf20         [IN]    void* Object - The object to create the handle for.}\par
00379 {\cf20         [IN]    ACCESS_MASK DesiredAccess - The maximum access the handle should have.}\par
00380 {\cf20         [OUT]   PHANDLE ReturnedHandle - The returned handle for the object if success.}\par
00381 {\cf20         [IN]    PHANDLE_TABLE ObjectTable - The handle table to insert the newly created handle in.}\par
00382 {\cf20 }\par
00383 {\cf20     Return Values:}\par
00384 {\cf20 }\par
00385 {\cf20         MTSTATUS Status Codes:}\par
00386 {\cf20 }\par
00387 {\cf20             MT_SUCCESS - Successful.}\par
00388 {\cf20             MT_INVALID_STATE - No handle table for current process.}\par
00389 {\cf20             MT_INVALID_CHECK - HtCreateHandle returned MT_INVALID_HANDLE.}\par
00390 {\cf20 --*/}\par
00391 \par
00392 \{\par
00393     {\cf19 if} (!ObjectTable || !Object) {\cf19 return} MT_INVALID_ADDRESS;\par
00394 \par
00395     {\cf20 // Create the handle.}\par
00396     HANDLE Handle = HtCreateHandle(ObjectTable, Object, DesiredAccess);\par
00397     {\cf19 if} (Handle == MT_INVALID_HANDLE) {\cf19 return} MT_INVALID_CHECK;\par
00398 \par
00399     {\cf20 // Reference the object.}\par
00400     ObReferenceObject(Object);\par
00401 \par
00402     {\cf20 // Return success.}\par
00403     *ReturnedHandle = Handle;\par
00404     {\cf19 return} MT_SUCCESS;\par
00405 \}\par
00406 \par
00407 {\cf17 static}\par
00408 {\cf18 void}\par
00409 ObpDeferObjectDeletion(\par
00410     IN POBJECT_HEADER Header\par
00411 )\par
00412 \par
00413 {\cf20 /*++}\par
00414 {\cf20 }\par
00415 {\cf20     Routine description:}\par
00416 {\cf20 }\par
00417 {\cf20        Defers object deletion to a DPC, to ensure no use after free.}\par
00418 {\cf20 }\par
00419 {\cf20     Arguments:}\par
00420 {\cf20 }\par
00421 {\cf20         [IN]    POBJECT_HEADER Header - The object header to defer deletion for.}\par
00422 {\cf20 }\par
00423 {\cf20     Return Values:}\par
00424 {\cf20 }\par
00425 {\cf20         None.}\par
00426 {\cf20 }\par
00427 {\cf20 --*/}\par
00428 \par
00429 \{\par
00430     {\cf17 volatile} {\cf18 void}* Entry;\par
00431     {\cf19 do} \{\par
00432         {\cf20 // Get the current entry.}\par
00433         Entry = ObpReaperList;\par
00434 \par
00435         {\cf20 // Link our object to the linked list.}\par
00436         Header->NextToFree = Entry;\par
00437         {\cf20 // Update the list}\par
00438     \} {\cf19 while} (InterlockedCompareExchangePointer(&ObpReaperList, Header, ({\cf18 void}*)Entry) != Entry);\par
00439 \par
00440     {\cf19 if} (!Entry) \{\par
00441         {\cf20 // Looks like a DPC hasn't been queued yet, lets do so!}\par
00442         MeInsertQueueDpc(&ObpReaperDpc, NULL, NULL);\par
00443     \}\par
00444 \}\par
00445 \par
00446 {\cf18 void} ObDereferenceObject(\par
00447     IN  {\cf18 void}* Object\par
00448 ) \par
00449 \par
00450 {\cf20 /*++}\par
00451 {\cf20 }\par
00452 {\cf20     Routine description:}\par
00453 {\cf20 }\par
00454 {\cf20        Dereferences the Object given.}\par
00455 {\cf20 }\par
00456 {\cf20     Arguments:}\par
00457 {\cf20 }\par
00458 {\cf20         [IN]    void* Object - The Object to decrement reference count for.}\par
00459 {\cf20 }\par
00460 {\cf20     Return Values:}\par
00461 {\cf20 }\par
00462 {\cf20         None.}\par
00463 {\cf20 }\par
00464 {\cf20     Notes:}\par
00465 {\cf20 }\par
00466 {\cf20         On reference count 0, object is deleted using type initializer routine.}\par
00467 {\cf20 }\par
00468 {\cf20 --*/}\par
00469 \par
00470 \{\par
00471     {\cf19 if} (!Object) {\cf19 return};\par
00472     POBJECT_HEADER Header = OBJECT_TO_OBJECT_HEADER(Object);\par
00473 \par
00474     uint64_t NewCount = InterlockedDecrementU64(({\cf17 volatile} uint64_t*)&Header->PointerCount);\par
00475 \par
00476     {\cf19 if} (NewCount == 0) \{\par
00477         {\cf20 // Get the type initializer for the object.}\par
00478         POBJECT_TYPE Type = Header->Type;\par
00479 \par
00480 {\cf21 #ifdef DEBUG}\par
00481         {\cf20 // First call debug callback if exists}\par
00482         {\cf19 if} (Type->TypeInfo.DumpProcedure) Type->TypeInfo.DumpProcedure(Object);\par
00483 {\cf21 #endif}\par
00484 \par
00485         {\cf20 // Call Delete Callback if it exists}\par
00486         {\cf19 if} (Type->TypeInfo.DeleteProcedure) Type->TypeInfo.DeleteProcedure(Object);\par
00487 \par
00488         {\cf20 // Update Stats}\par
00489         InterlockedDecrementU32(({\cf17 volatile} uint32_t*)&Type->TotalNumberOfObjects);\par
00490         {\cf20 // Free Memory}\par
00491         gop_printf(COLOR_RED, {\cf22 "Freeing the header\\n"});\par
00492         {\cf20 //ObpDeferObjectDeletion(Header);}\par
00493         MmFreePool(Header);\par
00494     \}\par
00495 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/cid.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/cid.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/cid.c}
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/ob.h"}\par
{\f2 #include "../../includes/ht.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsInitializeCidTable} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b PsAllocateProcessId} ({\b IN} {\b PEPROCESS} Process)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b PsAllocateThreadId} ({\b IN} {\b PETHREAD} Thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PEPROCESS} {\b PsLookupProcessByProcessId} ({\b IN} {\b HANDLE} ProcessId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b PsLookupThreadByThreadId} ({\b IN} {\b HANDLE} ThreadId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsFreeCid} ({\b IN} {\b HANDLE} Cid)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PHANDLE_TABLE} {\b PspCidTable} = NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v PsAllocateProcessId\:cid.c}
{\xe \v cid.c\:PsAllocateProcessId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} PsAllocateProcessId ({\b IN} {\b PEPROCESS} Process)}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b cid.c}.}\par
}
{\xe \v PsAllocateThreadId\:cid.c}
{\xe \v cid.c\:PsAllocateThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} PsAllocateThreadId ({\b IN} {\b PETHREAD} Thread)}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b cid.c}.}\par
}
{\xe \v PsFreeCid\:cid.c}
{\xe \v cid.c\:PsFreeCid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsFreeCid ({\b IN} {\b HANDLE} Cid)}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b cid.c}.}\par
}
{\xe \v PsInitializeCidTable\:cid.c}
{\xe \v cid.c\:PsInitializeCidTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsInitializeCidTable (void )}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b cid.c}.}\par
}
{\xe \v PsLookupProcessByProcessId\:cid.c}
{\xe \v cid.c\:PsLookupProcessByProcessId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PEPROCESS} PsLookupProcessByProcessId ({\b IN} {\b HANDLE} ProcessId)}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b cid.c}.}\par
}
{\xe \v PsLookupThreadByThreadId\:cid.c}
{\xe \v cid.c\:PsLookupThreadByThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} PsLookupThreadByThreadId ({\b IN} {\b HANDLE} ThreadId)}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b cid.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PspCidTable\:cid.c}
{\xe \v cid.c\:PspCidTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PHANDLE_TABLE} PspCidTable = NULL}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b cid.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cid.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/cid.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/cid.c}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     cid.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of client IDS of processes and threads. (PID/TID)}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/ps.h"}\par
00020 {\cf21 #include "../../includes/ob.h"}\par
00021 {\cf21 #include "../../includes/ht.h"}\par
00022 {\cf21 #include "../../assert.h"}\par
00023 \par
00024 PHANDLE_TABLE PspCidTable = NULL; {\cf20 // The main table.}\par
00025 \par
00026 {\cf18 void}\par
00027 PsInitializeCidTable(\par
00028     {\cf18 void}\par
00029 )\par
00030 \par
00031 {\cf20 /*++}\par
00032 {\cf20 }\par
00033 {\cf20     Routine description:}\par
00034 {\cf20 }\par
00035 {\cf20         Initializes the CID Table.}\par
00036 {\cf20 }\par
00037 {\cf20     Arguments:}\par
00038 {\cf20 }\par
00039 {\cf20         None.}\par
00040 {\cf20 }\par
00041 {\cf20     Return Values:}\par
00042 {\cf20 }\par
00043 {\cf20         None, on failure it bugchecks.}\par
00044 {\cf20 }\par
00045 {\cf20 --*/}\par
00046 \par
00047 \{\par
00048     PspCidTable = HtCreateHandleTable(NULL);\par
00049     assert(PspCidTable != NULL);\par
00050     {\cf19 if} (!PspCidTable) MeBugCheck(CID_TABLE_NULL);\par
00051 \par
00052     {\cf20 // Claim the first handle, HANDLE 4 (pid) is the PID of the SystemProcess, it must not be used.}\par
00053     HtCreateHandle(PspCidTable, &PsInitialSystemProcess, MT_PROCESS_ALL_ACCESS);\par
00054 \par
00055     {\cf20 // Set the system process's handle table to the CID Table.}\par
00056 \}\par
00057 \par
00058 HANDLE\par
00059 PsAllocateProcessId(\par
00060     IN  PEPROCESS Process\par
00061 )\par
00062 \par
00063 {\cf20 /*++}\par
00064 {\cf20 }\par
00065 {\cf20     Routine description:}\par
00066 {\cf20 }\par
00067 {\cf20         Creates a PID for the specified Process.}\par
00068 {\cf20 }\par
00069 {\cf20     Arguments:}\par
00070 {\cf20 }\par
00071 {\cf20         [IN]    PEPROCESS Process - The process to create the PID for.}\par
00072 {\cf20 }\par
00073 {\cf20     Return Values:}\par
00074 {\cf20 }\par
00075 {\cf20         The HANDLE (pid) for the process.}\par
00076 {\cf20 }\par
00077 {\cf20 --*/}\par
00078 \par
00079 \{\par
00080     {\cf20 // Basically, return the handle from the PspCidTable.}\par
00081     {\cf20 // The PID/TID is a NULL access, it is only used to identify a process}\par
00082     {\cf20 // But to NOT authenticate it, routines like MtOpenProcess (future) would check the HANDLE of a process itself}\par
00083     {\cf20 // (e.g PspCreateProcess returns it), but not the PID, dumbo bumbo.}\par
00084     {\cf19 return} HtCreateHandle(PspCidTable, ({\cf18 void}*)Process, 0);\par
00085 \}\par
00086 \par
00087 HANDLE\par
00088 PsAllocateThreadId(\par
00089     IN  PETHREAD Thread\par
00090 )\par
00091 \par
00092 {\cf20 /*++}\par
00093 {\cf20 }\par
00094 {\cf20     Routine description:}\par
00095 {\cf20 }\par
00096 {\cf20         Creates a TID for the specified thread.}\par
00097 {\cf20 }\par
00098 {\cf20     Arguments:}\par
00099 {\cf20 }\par
00100 {\cf20         [IN]    PETHREAD Thread - The thread to create the TID for.}\par
00101 {\cf20 }\par
00102 {\cf20     Return Values:}\par
00103 {\cf20 }\par
00104 {\cf20         The HANDLE (tid) for the thread.}\par
00105 {\cf20 }\par
00106 {\cf20 --*/}\par
00107 \par
00108 \{\par
00109     {\cf19 return} HtCreateHandle(PspCidTable, ({\cf18 void}*)Thread, 0);\par
00110 \}\par
00111 \par
00112 PEPROCESS\par
00113 PsLookupProcessByProcessId(\par
00114     IN HANDLE ProcessId\par
00115 )\par
00116 \par
00117 {\cf20 /*++}\par
00118 {\cf20 }\par
00119 {\cf20     Routine description:}\par
00120 {\cf20 }\par
00121 {\cf20         Finds the process associated with the PID given.}\par
00122 {\cf20 }\par
00123 {\cf20     Arguments:}\par
00124 {\cf20 }\par
00125 {\cf20         [IN]    HANDLE ProcessId - The PID of the process.}\par
00126 {\cf20 }\par
00127 {\cf20     Return Values:}\par
00128 {\cf20 }\par
00129 {\cf20         Pointer to Process associated with the PID, or NULL if none.}\par
00130 {\cf20 }\par
00131 {\cf20 --*/}\par
00132 \par
00133 \{\par
00134     {\cf19 return} HtGetObject(PspCidTable, ProcessId, NULL);\par
00135 \}\par
00136 \par
00137 PETHREAD\par
00138 PsLookupThreadByThreadId(\par
00139     IN HANDLE ThreadId\par
00140 )\par
00141 \par
00142 {\cf20 /*++}\par
00143 {\cf20 }\par
00144 {\cf20     Routine description:}\par
00145 {\cf20 }\par
00146 {\cf20         Finds the thread associated with the TID given.}\par
00147 {\cf20 }\par
00148 {\cf20     Arguments:}\par
00149 {\cf20 }\par
00150 {\cf20         [IN]    HANDLE ThreadId - The TID of the thread.}\par
00151 {\cf20 }\par
00152 {\cf20     Return Values:}\par
00153 {\cf20 }\par
00154 {\cf20         Pointer to Thread associated with the TID, or NULL if none.}\par
00155 {\cf20 }\par
00156 {\cf20 --*/}\par
00157 \par
00158 \{\par
00159     {\cf19 return} HtGetObject(PspCidTable, ThreadId, NULL);\par
00160 \}\par
00161 \par
00162 {\cf18 void}\par
00163 PsFreeCid(\par
00164     IN HANDLE Cid\par
00165 )\par
00166 \par
00167 {\cf20 /*++}\par
00168 {\cf20 }\par
00169 {\cf20     Routine description:}\par
00170 {\cf20 }\par
00171 {\cf20         Frees the CID (PID,TID)}\par
00172 {\cf20 }\par
00173 {\cf20     Arguments:}\par
00174 {\cf20 }\par
00175 {\cf20         [IN]    HANDLE Cid - CID Allocated.}\par
00176 {\cf20 }\par
00177 {\cf20     Return Values:}\par
00178 {\cf20 }\par
00179 {\cf20         None.}\par
00180 {\cf20 }\par
00181 {\cf20 --*/}\par
00182 \par
00183 \{\par
00184     HtDeleteHandle(PspCidTable, Cid);\par
00185 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/process.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/process.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/process.c}
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../time.h"}\par
{\f2 #include "../../filesystem/vfs/vfs.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/ms.h"}\par
{\f2 #include "../../includes/ob.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_PID}\~ 4u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_PID}\~ 0xFFFFFFFCUL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALIGN_DELTA}\~ 6u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_FREE_POOL}\~ 1024u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PML4_INDEX}(addr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_PML4_START}\~ ((size_t){\b PML4_INDEX}({\b KernelVaStart}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_INITIAL_STACK_TOP}\~ 0x00007FFFFFFFFFFF\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsCreateProcess} ({\b IN} const char *ExecutablePath, {\b OUT} {\b PHANDLE} ProcessHandle, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b _In_Opt} {\b HANDLE} ParentProcess)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsTerminateProcess} ({\b IN} {\b PEPROCESS} Process)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPROCESS} {\b SystemProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmSystemRangeStart} = {\b PhysicalMemoryOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmHighestUserAddress} = {\b USER_VA_END}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmUserProbeAddress} = 0x00007FFFFFFF0000\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ALIGN_DELTA\:process.c}
{\xe \v process.c\:ALIGN_DELTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALIGN_DELTA\~ 6u}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b process.c}.}\par
}
{\xe \v KERNEL_PML4_START\:process.c}
{\xe \v process.c\:KERNEL_PML4_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_PML4_START\~ ((size_t){\b PML4_INDEX}({\b KernelVaStart}))}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b process.c}.}\par
}
{\xe \v MAX_FREE_POOL\:process.c}
{\xe \v process.c\:MAX_FREE_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_FREE_POOL\~ 1024u}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b process.c}.}\par
}
{\xe \v MAX_PID\:process.c}
{\xe \v process.c\:MAX_PID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_PID\~ 0xFFFFFFFCUL}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b process.c}.}\par
}
{\xe \v MIN_PID\:process.c}
{\xe \v process.c\:MIN_PID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_PID\~ 4u}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b process.c}.}\par
}
{\xe \v PML4_INDEX\:process.c}
{\xe \v process.c\:PML4_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PML4_INDEX( addr)}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((addr) >> 39) & 0x1FFULL)\par
}
{
Definition at line {\b 21} of file {\b process.c}.}\par
}
{\xe \v USER_INITIAL_STACK_TOP\:process.c}
{\xe \v process.c\:USER_INITIAL_STACK_TOP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_INITIAL_STACK_TOP\~ 0x00007FFFFFFFFFFF}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b process.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v PsCreateProcess\:process.c}
{\xe \v process.c\:PsCreateProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsCreateProcess ({\b IN} const char * ExecutablePath, {\b OUT} {\b PHANDLE} ProcessHandle, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b _In_Opt} {\b HANDLE} ParentProcess)}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b process.c}.}\par
}
{\xe \v PsTerminateProcess\:process.c}
{\xe \v process.c\:PsTerminateProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsTerminateProcess ({\b IN} {\b PEPROCESS} Process)}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 231} of file {\b process.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v MmHighestUserAddress\:process.c}
{\xe \v process.c\:MmHighestUserAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmHighestUserAddress = {\b USER_VA_END}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b process.c}.}\par
}
{\xe \v MmSystemRangeStart\:process.c}
{\xe \v process.c\:MmSystemRangeStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmSystemRangeStart = {\b PhysicalMemoryOffset}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b process.c}.}\par
}
{\xe \v MmUserProbeAddress\:process.c}
{\xe \v process.c\:MmUserProbeAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmUserProbeAddress = 0x00007FFFFFFF0000}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b process.c}.}\par
}
{\xe \v SystemProcess\:process.c}
{\xe \v process.c\:SystemProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPROCESS} SystemProcess{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
process.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/process.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/process.c}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     Process Creation Implementation}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "../../time.h"}\par
00008 {\cf21 #include "../../filesystem/vfs/vfs.h"}\par
00009 {\cf21 #include "../../includes/me.h"}\par
00010 {\cf21 #include "../../includes/ps.h"}\par
00011 {\cf21 #include "../../includes/mg.h"}\par
00012 {\cf21 #include "../../includes/ms.h"}\par
00013 {\cf21 #include "../../includes/ob.h"}\par
00014 {\cf21 #include "../../assert.h"}\par
00015 \par
00016 {\cf21 #define MIN_PID           4u}\par
00017 {\cf21 #define MAX_PID           0xFFFFFFFCUL}\par
00018 {\cf21 #define ALIGN_DELTA       6u}\par
00019 {\cf21 #define MAX_FREE_POOL     1024u}\par
00020 \par
00021 {\cf21 #define PML4_INDEX(addr)  (((addr) >> 39) & 0x1FFULL)}\par
00022 {\cf21 #define KERNEL_PML4_START ((size_t)PML4_INDEX(KernelVaStart))}\par
00023 {\cf21 #define USER_INITIAL_STACK_TOP 0x00007FFFFFFFFFFF}\par
00024 {\cf17 extern} EPROCESS SystemProcess;\par
00025 \par
00026 uintptr_t MmSystemRangeStart = PhysicalMemoryOffset; {\cf20 // Changed to PhysicalMemoryOffset, since thats where actual stuff like hypermap, phys to virt, and more happen.}\par
00027 uintptr_t MmHighestUserAddress = USER_VA_END;\par
00028 uintptr_t MmUserProbeAddress = 0x00007FFFFFFF0000;\par
00029 \par
00030 {\cf17 static} \par
00031 {\cf18 bool} \par
00032 GetBaseName({\cf17 const} {\cf18 char}* fullpath, {\cf18 char}* out, {\cf18 size_t} outsz) \{\par
00033     {\cf17 const} {\cf18 char}* ext = {\cf22 ".mtexe"};\par
00034     {\cf18 size_t} ext_len = kstrlen(ext);\par
00035     {\cf19 if} (!fullpath || !out || outsz == 0) {\cf19 return} {\cf17 false};\par
00036 \par
00037     {\cf18 size_t} len = kstrlen(fullpath);\par
00038     {\cf17 const} {\cf18 char}* p = fullpath + len;\par
00039     {\cf19 while} (p > fullpath && *(p - 1) != {\cf23 '/'}) --p;\par
00040 \par
00041     {\cf18 size_t} name_len = kstrlen(p);\par
00042     {\cf19 if} (name_len < ext_len || kstrcmp(p + name_len - ext_len, ext) != 0) {\cf19 return} {\cf17 false};\par
00043 \par
00044     {\cf19 if} (name_len + 1 > outsz) {\cf19 return} {\cf17 false}; {\cf20 // too small}\par
00045     kstrncpy(out, p, name_len + 1);\par
00046     {\cf19 return} {\cf17 true};\par
00047 \}\par
00048 \par
00049 MTSTATUS\par
00050 PsCreateProcess(\par
00051     IN {\cf17 const} {\cf18 char}* ExecutablePath,\par
00052     OUT PHANDLE ProcessHandle,\par
00053     IN ACCESS_MASK DesiredAccess,\par
00054     _In_Opt HANDLE ParentProcess\par
00055 )\par
00056 \par
00057 {\cf20 /*++}\par
00058 {\cf20 }\par
00059 {\cf20     Routine description:}\par
00060 {\cf20 }\par
00061 {\cf20        Creates a process, simple as that.}\par
00062 {\cf20 }\par
00063 {\cf20     Arguments:}\par
00064 {\cf20 }\par
00065 {\cf20         [IN]    const char* ExecutablePath - The process's main executable file.}\par
00066 {\cf20         [OUT]   PHANDLE ProcessHandle - Pointer to store the the process's created handle.}\par
00067 {\cf20         [IN]    ACCESS_MASK DesiredAccess - The maximum access the process should originally have.}\par
00068 {\cf20         [IN OPTIONAL]   HANDLE ParentProcess - Optionally supply a handle to the parent of this process.}\par
00069 {\cf20 }\par
00070 {\cf20     Return Values:}\par
00071 {\cf20 }\par
00072 {\cf20         Various MTSTATUS Status codes.}\par
00073 {\cf20 }\par
00074 {\cf20 --*/}\par
00075 \par
00076 \{\par
00077     MTSTATUS Status;\par
00078     PEPROCESS Process, Parent;\par
00079     {\cf20 // If we have a parent process, attempt to see if the parent process has the access to create another process.}\par
00080     {\cf19 if} (ParentProcess) \{\par
00081         Status = ObReferenceObjectByHandle(\par
00082             ParentProcess,\par
00083             MT_PROCESS_CREATE_PROCESS,\par
00084             PsProcessType,\par
00085             ({\cf18 void}**)&Parent,\par
00086             NULL\par
00087         );\par
00088 \par
00089         {\cf19 if} (MT_FAILURE(Status)) \{\par
00090             {\cf19 return} Status;\par
00091         \}\par
00092     \}\par
00093     {\cf19 else} \{\par
00094         {\cf20 // We have no parent process.}\par
00095         Parent = NULL;\par
00096     \}\par
00097 \par
00098     {\cf20 // Create the EPROCESS Object.}\par
00099     Status = ObCreateObject(PsProcessType, {\cf17 sizeof}(EPROCESS), ({\cf18 void}*)&Process);\par
00100     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} Cleanup;\par
00101 \par
00102     {\cf20 // CleanupWithRef from now on.}\par
00103     {\cf20 // Assume failure status.}\par
00104     Status = MT_GENERAL_FAILURE;\par
00105     {\cf20 // Setup the process now, create its PID.}\par
00106     Process->PID = PsAllocateProcessId(Process);\par
00107 \par
00108     {\cf20 // Set its parent process handle.}\par
00109     Process->ParentProcess = ParentProcess;\par
00110 \par
00111     {\cf20 // Set its image name.}\par
00112     {\cf18 char} filename[24];\par
00113     GetBaseName(ExecutablePath, filename, {\cf17 sizeof}(filename));\par
00114     {\cf19 if} (filename[0] == {\cf23 '\\0'}) {\cf19 goto} CleanupWithRef;\par
00115     kstrncpy(Process->ImageName, filename, {\cf17 sizeof}(Process->ImageName));\par
00116 \par
00117     {\cf20 // Set initial state}\par
00118     Process->InternalProcess.ProcessState |= PROCESS_READY;\par
00119 \par
00120     {\cf20 // Create object table.}\par
00121     PHANDLE_TABLE HandleTable = HtCreateHandleTable(Process);\par
00122     {\cf19 if} (!HandleTable) {\cf19 goto} CleanupWithRef;\par
00123     Process->ObjectTable = HandleTable;\par
00124 \par
00125     {\cf20 // Create address space.}\par
00126     {\cf18 void}* DirectoryTablePhysical = NULL;\par
00127     Status = MmCreateProcessAddressSpace(&DirectoryTablePhysical);\par
00128     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} CleanupWithRef;    \par
00129     Process->InternalProcess.PageDirectoryPhysical = (uintptr_t)DirectoryTablePhysical;\par
00130     gop_printf(COLOR_RED, {\cf22 "Process CR3: %p\\n"}, DirectoryTablePhysical);\par
00131 \par
00132     {\cf20 // Per thread stack calculation.}\par
00133     Process->NextStackTop = USER_INITIAL_STACK_TOP;\par
00134 \par
00135     {\cf20 // Creation time.}\par
00136     Process->CreationTime = MeGetEpoch();\par
00137 \par
00138     {\cf20 // Initialize List heads.}\par
00139     InitializeListHead(&Process->AllThreads);\par
00140 \par
00141     {\cf20 // Load file into memory (TODO Section objects)}\par
00142     {\cf18 void}* file_buffer = NULL;\par
00143     uint32_t FileSize = 0;\par
00144     Status = vfs_read(ExecutablePath, &FileSize, &file_buffer);\par
00145     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} CleanupWithRef;\par
00146     Process->FileBuffer = file_buffer;\par
00147     Process->ImageBase = USER_VA_START; {\cf20 // Dummy VA, FIXME Headers.}\par
00148 \par
00149     {\cf20 // TODO ADD ADDRESS TO WORKING SET OF PROCESS!!}\par
00150 \par
00151     {\cf20 // Calculate the number of pages needed to map the entire file in.}\par
00152     {\cf18 size_t} num_pages = (FileSize + VirtualPageSize - 1) / VirtualPageSize;\par
00153 \par
00154     {\cf20 // Prepare for the copy loop}\par
00155     uintptr_t CurrentVA = Process->ImageBase;\par
00156     uint8_t* SourcePtr = (uint8_t*)file_buffer; {\cf20 // Pointer to the data we read from disk}\par
00157     {\cf18 size_t} BytesRemaining = FileSize;\par
00158 \par
00159     {\cf20 // Attach to process to get corrent PTE pointer.}\par
00160     APC_STATE ApcState;\par
00161     MeAttachProcess(&Process->InternalProcess, &ApcState);\par
00162 \par
00163     {\cf19 for} ({\cf18 size_t} i = 0; i < num_pages; i++) \{\par
00164         {\cf20 // Allocate a physical page.}\par
00165         PAGE_INDEX pfn = MiRequestPhysicalPage(PfnStateZeroed);\par
00166         {\cf19 if} (pfn == PFN_ERROR) {\cf19 break};\par
00167 \par
00168         {\cf20 // Now we change the actual physical address we got, and thats the physical address of CurrentVA.}\par
00169         IRQL oldIrql;\par
00170         {\cf18 void}* PhysicalAddressOfVa = MiMapPageInHyperspace(pfn, &oldIrql);\par
00171 \par
00172         {\cf20 // Calculate how many bytes to copy for this specific iteration.}\par
00173         {\cf20 // It will be 4096 for every page except potentially the last one.}\par
00174         {\cf18 size_t} BytesToCopy = (BytesRemaining > VirtualPageSize) ? VirtualPageSize : BytesRemaining;\par
00175         \par
00176         {\cf20 // Copy the data.}\par
00177         kmemcpy(({\cf18 void}*)PhysicalAddressOfVa, SourcePtr, BytesToCopy);\par
00178 \par
00179         {\cf20 // End hyperspace mapping for physical address.}\par
00180         MiUnmapHyperSpaceMap(oldIrql);\par
00181 \par
00182         {\cf20 // Get the PTE pointer for the current address.}\par
00183         PMMPTE pte = MiGetPtePointer(CurrentVA);\par
00184 \par
00185         {\cf20 // Write to it the physical address.}\par
00186         MI_WRITE_PTE(pte, CurrentVA, PFN_TO_PHYS(pfn), PAGE_PRESENT | PAGE_RW | PAGE_USER);\par
00187 \par
00188         {\cf20 // Advance pointers and decrement counters}\par
00189         CurrentVA += VirtualPageSize;\par
00190         SourcePtr += BytesToCopy;\par
00191         BytesRemaining -= BytesToCopy;\par
00192     \}\par
00193 \par
00194     {\cf20 // The VA has been filed with the executable's instructions, now we do handle creation and yada yada.}\par
00195     {\cf20 // Detach from process address space.}\par
00196     MeDetachProcess(&ApcState);\par
00197 \par
00198     {\cf20 // Create a handle for the process.}\par
00199     HANDLE hProcess;\par
00200     Status = ObCreateHandleForObject(Process, DesiredAccess, &hProcess);\par
00201     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} CleanupWithRef;\par
00202 \par
00203     {\cf20 // Create a main thread for the process.}\par
00204     HANDLE MainThreadHandle;\par
00205     Status = PsCreateThread(hProcess, &MainThreadHandle, (ThreadEntry)Process->ImageBase, NULL, DEFAULT_TIMESLICE_TICKS);\par
00206     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} CleanupWithRef;\par
00207 \par
00208     {\cf20 // Insert main thread to processor queue.}\par
00209     MeEnqueueThreadWithLock(&MeGetCurrentProcessor()->readyQueue, Process->MainThread);\par
00210 \par
00211     {\cf20 // We are, successful.}\par
00212     *ProcessHandle = hProcess;\par
00213     Status = MT_SUCCESS;\par
00214 \par
00215 CleanupWithRef:\par
00216 {\cf21 #ifdef DEBUG}\par
00217     {\cf19 if} (MT_FAILURE(Status)) \{\par
00218         assert({\cf17 false}, {\cf22 "Something went wrong."});\par
00219     \}\par
00220 {\cf21 #endif}\par
00221     {\cf20 // If all went smoothly, this should cancel out the reference made by ObCreateHandleForObject. (so we only have 1 reference left by ObCreateObject)}\par
00222     {\cf20 // If not, it would reach reference 0, and PspDeleteProcessd would execute.}\par
00223     ObDereferenceObject(Process);\par
00224     {\cf20 // [[fallthrough]]}\par
00225 Cleanup:\par
00226     {\cf19 if} (Parent) ObDereferenceObject(Parent);\par
00227     {\cf19 return} Status;\par
00228 \}\par
00229 \par
00230 {\cf18 void}\par
00231 PsTerminateProcess(\par
00232     IN PEPROCESS Process\par
00233 )\par
00234 \par
00235 \{\par
00236     UNREFERENCED_PARAMETER(Process);\par
00237     assert({\cf17 false}, {\cf22 "Unimplemented routine"});\par
00238     MeBugCheck(MANUALLY_INITIATED_CRASH2);\par
00239 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/psmgr.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/psmgr.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/psmgr.c}
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/ob.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsInitializeSystem} ({\b IN} enum {\b _PS_PHASE_ROUTINE} Phase)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POBJECT_TYPE} {\b PsProcessType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POBJECT_TYPE} {\b PsThreadType}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v PsInitializeSystem\:psmgr.c}
{\xe \v psmgr.c\:PsInitializeSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsInitializeSystem ({\b IN} enum {\b _PS_PHASE_ROUTINE} Phase)}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b psmgr.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PsProcessType\:psmgr.c}
{\xe \v psmgr.c\:PsProcessType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POBJECT_TYPE} PsProcessType}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b psmgr.c}.}\par
}
{\xe \v PsThreadType\:psmgr.c}
{\xe \v psmgr.c\:PsThreadType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POBJECT_TYPE} PsThreadType}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b psmgr.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
psmgr.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/psmgr.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/psmgr.c}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     psmgr.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the initialization routines of the Process & Thread subsystem.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/ps.h"}\par
00020 {\cf21 #include "../../includes/ob.h"}\par
00021 \par
00022 {\cf20 // Explanation for future me or anything going over my kernel.}\par
00023 {\cf20 // Instead of creating processes and deleting them when exiting, we use an object manager}\par
00024 {\cf20 // To automatically do this for us when the reference count for the required thread ends.}\par
00025 {\cf20 // It defines how should the process / thread be created (With what pool, what access rights)}\par
00026 {\cf20 // It supplements the core functionality of security for the process & threads life, and access.}\par
00027 \par
00028 {\cf20 // Reference count reaches 0 -> Dump Routine -> Deletion Routine (depends on kind of thread)}\par
00029 \par
00030 POBJECT_TYPE PsProcessType;\par
00031 POBJECT_TYPE PsThreadType;\par
00032 \par
00033 {\cf17 static} {\cf18 void} PsTerminateProcessWrap({\cf18 void}* Object) \{\par
00034     PsTerminateProcess((PEPROCESS)Object);\par
00035 \}\par
00036 \par
00037 {\cf17 static}\par
00038 MTSTATUS\par
00039 PsInitializeProcessThreadManager(\par
00040     {\cf18 void}\par
00041 )\par
00042 \par
00043 {\cf20 /*++}\par
00044 {\cf20 }\par
00045 {\cf20     Routine description:}\par
00046 {\cf20 }\par
00047 {\cf20        Initializes the process & thread subsystem.}\par
00048 {\cf20 }\par
00049 {\cf20     Arguments:}\par
00050 {\cf20 }\par
00051 {\cf20         None.}\par
00052 {\cf20 }\par
00053 {\cf20     Return Values:}\par
00054 {\cf20 }\par
00055 {\cf20         MTSTATUS Status codes representing if succeeded or not.}\par
00056 {\cf20         If we didn't succeed, system should bugcheck with status code.}\par
00057 {\cf20 }\par
00058 {\cf20 --*/}\par
00059 \par
00060 \{\par
00061     {\cf20 // Define how each thread & process be created and deleted.}\par
00062     MTSTATUS status;\par
00063     OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;\par
00064     kmemset(&ObjectTypeInitializer, 0, {\cf17 sizeof}(OBJECT_TYPE_INITIALIZER));\par
00065 \par
00066     {\cf20 // Processes}\par
00067     {\cf18 char}* Name = {\cf22 "Process"};\par
00068     ObjectTypeInitializer.PoolType = NonPagedPool;\par
00069 {\cf21 #ifdef DEBUG}\par
00070     ObjectTypeInitializer.DumpProcedure = NULL; {\cf20 // TODO DUMP PROC!}\par
00071 {\cf21 #else}\par
00072     ObjectTypeInitializer.DumpProcedure = NULL;\par
00073 {\cf21 #endif}\par
00074     ObjectTypeInitializer.DeleteProcedure = NULL; {\cf20 // We will page fault, TODO PROCESS.}\par
00075     ObjectTypeInitializer.ValidAccessRights = MT_PROCESS_ALL_ACCESS;\par
00076     status = ObCreateObjectType(Name, &ObjectTypeInitializer, &PsProcessType);\par
00077     {\cf19 if} (MT_FAILURE(status)) {\cf19 return} status;\par
00078 \par
00079     {\cf20 // Threads}\par
00080     Name = {\cf22 "Thread"};\par
00081     ObjectTypeInitializer.PoolType = NonPagedPool;\par
00082 {\cf21 #ifdef DEBUG}\par
00083     ObjectTypeInitializer.DumpProcedure = NULL; {\cf20 // TODO DUMP PROC!}\par
00084 {\cf21 #else}\par
00085     ObjectTypeInitializer.DumpProcedure = NULL;\par
00086 {\cf21 #endif}\par
00087     ObjectTypeInitializer.DeleteProcedure = &PsDeleteThread;\par
00088     ObjectTypeInitializer.ValidAccessRights = MT_THREAD_ALL_ACCESS;\par
00089     status = ObCreateObjectType(Name, &ObjectTypeInitializer, &PsThreadType);\par
00090     {\cf19 if} (MT_FAILURE(status)) {\cf19 return} status;\par
00091 \par
00092     {\cf19 return} MT_SUCCESS;\par
00093 \}\par
00094 \par
00095 \par
00096 MTSTATUS\par
00097 PsInitializeSystem(\par
00098     IN  {\cf17 enum} _PS_PHASE_ROUTINE Phase\par
00099 )\par
00100 \par
00101 \{\par
00102     {\cf19 if} (Phase == PS_PHASE_INITIALIZE_SYSTEM) \{\par
00103         {\cf20 // Initialize the PS Subsystem.}\par
00104         {\cf20 // Initialize the CID Table.}\par
00105         PsInitializeCidTable();\par
00106 \par
00107         {\cf20 // Initialize the process & thread subsystem.}\par
00108         MTSTATUS st = PsInitializeProcessThreadManager();\par
00109         {\cf19 return} st;\par
00110     \}\par
00111     {\cf19 else} {\cf19 if} (Phase == PS_PHASE_INITIALIZE_WORKER_THREADS) \{\par
00112         PsInitializeWorkerThreads();\par
00113         {\cf19 return} MT_SUCCESS;\par
00114     \}\par
00115     {\cf19 else} \{\par
00116         MeBugCheck(INVALID_INITIALIZATION_PHASE);\par
00117     \}\par
00118 \}\par
00119 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/pswork.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/pswork.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/pswork.c}
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../assert.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PSTACK_REAPER_ENTRY} {\b PopAllStacks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsDeferKernelStackDeletion} (void *StackBase, bool IsLarge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsInitializeWorkerThreads} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile void * {\b g_StackReaperList} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EVENT} {\b g_StackReaperEvent}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v PopAllStacks\:pswork.c}
{\xe \v pswork.c\:PopAllStacks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PSTACK_REAPER_ENTRY} PopAllStacks (void )}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b pswork.c}.}\par
}
{\xe \v PsDeferKernelStackDeletion\:pswork.c}
{\xe \v pswork.c\:PsDeferKernelStackDeletion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsDeferKernelStackDeletion (void * StackBase, bool IsLarge)}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b pswork.c}.}\par
}
{\xe \v PsInitializeWorkerThreads\:pswork.c}
{\xe \v pswork.c\:PsInitializeWorkerThreads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsInitializeWorkerThreads (void )}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b pswork.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v g_StackReaperEvent\:pswork.c}
{\xe \v pswork.c\:g_StackReaperEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EVENT} g_StackReaperEvent}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b pswork.c}.}\par
}
{\xe \v g_StackReaperList\:pswork.c}
{\xe \v pswork.c\:g_StackReaperList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* g_StackReaperList = NULL}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b pswork.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pswork.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/pswork.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/pswork.c}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     pswork.c}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This translation unit contains the implementation of worker threads in the kernel.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #include "../../includes/ps.h"}\par
00020 {\cf21 #include "../../includes/mg.h"}\par
00021 {\cf21 #include "../../assert.h"}\par
00022 {\cf20 // globals}\par
00023 {\cf17 volatile} {\cf18 void}* g_StackReaperList = NULL; {\cf20 // head of LIFO list (casts to PSTACK_REAPER_ENTRY)}\par
00024 EVENT g_StackReaperEvent;\par
00025 \par
00026 {\cf20 // atomically pop all entries (returns head or NULL)}\par
00027 FORCEINLINE PSTACK_REAPER_ENTRY PopAllStacks({\cf18 void})\par
00028 \{\par
00029     {\cf19 return} (PSTACK_REAPER_ENTRY)InterlockedExchangePointer(({\cf17 volatile} {\cf18 void}**)&g_StackReaperList, NULL);\par
00030 \}\par
00031 \par
00032 \par
00033 {\cf17 static} {\cf18 void} PsStackDeleterThread({\cf18 void}) \{\par
00034 {\cf21 #ifdef DEBUG}\par
00035     gop_printf(COLOR_RED, {\cf22 "I have arrived, the reaper of souls n shit (and stacks)\\n"});\par
00036 {\cf21 #endif}\par
00037     {\cf19 for} (;;) \{\par
00038         {\cf20 // Wait until there is work (or force wake).}\par
00039         MsWaitForEvent(&g_StackReaperEvent);\par
00040 \par
00041         {\cf20 // Atomically steal the whole list}\par
00042         PSTACK_REAPER_ENTRY head = PopAllStacks();\par
00043 \par
00044         {\cf20 // If nothing (possible if race condition), continue waiting again}\par
00045         {\cf19 if} (!head) \{\par
00046             {\cf19 continue};\par
00047         \}\par
00048 \par
00049         {\cf20 // Walk and free each stack entry (safe at PASSIVE_LEVEL)}\par
00050         {\cf19 while} (head) \{\par
00051             PSTACK_REAPER_ENTRY cur = head;\par
00052             head = cur->Next;\par
00053 \par
00054             {\cf20 // free the kernel stack safely from this thread's stack}\par
00055             MiFreeKernelStack(cur->StackBase, cur->IsLarge);\par
00056 \par
00057             {\cf20 // free the node}\par
00058             MmFreePool(cur);\par
00059         \}\par
00060 \par
00061         {\cf20 // Loop back to wait for more work, if there is work, i work, on fridays, i work, saturdays - work too.}\par
00062     \}\par
00063 \}\par
00064 \par
00065 {\cf18 void} PsDeferKernelStackDeletion({\cf18 void}* StackBase, {\cf18 bool} IsLarge)\par
00066 \{\par
00067     PSTACK_REAPER_ENTRY node = MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(STACK_REAPER_ENTRY), {\cf22 'rSpR'});\par
00068     {\cf19 if} (!node) {\cf19 return};\par
00069 \par
00070     node->StackBase = StackBase;\par
00071     node->IsLarge = IsLarge;\par
00072 \par
00073     {\cf18 void}* old;\par
00074     {\cf19 do} \{\par
00075         old = ({\cf18 void}*)g_StackReaperList;\par
00076         node->Next = (PSTACK_REAPER_ENTRY)old;\par
00077         {\cf20 // cast target to volatile void** to match prototype}\par
00078     \} {\cf19 while} (InterlockedCompareExchangePointer(({\cf17 volatile} {\cf18 void}* {\cf17 volatile}*)&g_StackReaperList, ({\cf18 void}*)node, old) != old);\par
00079 \par
00080     {\cf20 // Wake the reaper (safe from any context)}\par
00081 {\cf21 #ifdef DEBUG}\par
00082     MTSTATUS status = MsSetEvent(&g_StackReaperEvent);\par
00083     assert(MT_SUCCEEDED(status));\par
00084 {\cf21 #else}\par
00085     MsSetEvent(&g_StackReaperEvent);\par
00086 {\cf21 #endif}\par
00087 \}\par
00088 \par
00089 {\cf18 void} PsInitializeWorkerThreads({\cf18 void}) \{\par
00090     {\cf20 // Setup the event.}\par
00091     g_StackReaperEvent.lock.locked = 0;\par
00092     g_StackReaperEvent.signaled = {\cf17 false};\par
00093     g_StackReaperEvent.type = SynchronizationEvent;\par
00094     g_StackReaperEvent.waitingQueue.head = g_StackReaperEvent.waitingQueue.tail = NULL;\par
00095 \par
00096     {\cf20 // We just create a system thread for freeing stacks.}\par
00097     MTSTATUS status = PsCreateSystemThread((ThreadEntry)PsStackDeleterThread, NULL, LOW_TIMESLICE_TICKS);\par
00098 \par
00099     {\cf19 if} (MT_FAILURE(status)) \{\par
00100         MeBugCheckEx(\par
00101             PSWORKER_INIT_FAILED,\par
00102             ({\cf18 void}*)(uintptr_t)status,\par
00103             NULL,\par
00104             NULL,\par
00105             NULL\par
00106         );\par
00107     \}\par
00108 \}\par
00109 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/thread.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/thread.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/thread.c}
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../../includes/ps.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/ob.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MIN_TID}\~ 3u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_TID}\~ 0xFFFFFFFCu\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALIGN_DELTA}\~ 3u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_FREE_POOL}\~ 1024u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THREAD_STACK_SIZE}\~ (1024*24)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b THREAD_ALIGNMENT}\~ 16\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsCreateThread} ({\b HANDLE} ProcessHandle, {\b PHANDLE} ThreadHandle, {\b ThreadEntry} EntryPoint, {\b THREAD_PARAMETER} ThreadParameter, {\b TimeSliceTicks} TimeSlice)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsCreateSystemThread} ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b TimeSliceTicks} TIMESLICE)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b PsGetCurrentThread} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsTerminateThread} ({\b IN} {\b PETHREAD} Thread, {\b IN} {\b MTSTATUS} ExitStatus)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsDeleteThread} ({\b IN} void *Object)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPROCESS} {\b PsInitialSystemProcess}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ALIGN_DELTA\:thread.c}
{\xe \v thread.c\:ALIGN_DELTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALIGN_DELTA\~ 3u}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b thread.c}.}\par
}
{\xe \v MAX_FREE_POOL\:thread.c}
{\xe \v thread.c\:MAX_FREE_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_FREE_POOL\~ 1024u}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b thread.c}.}\par
}
{\xe \v MAX_TID\:thread.c}
{\xe \v thread.c\:MAX_TID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_TID\~ 0xFFFFFFFCu}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b thread.c}.}\par
}
{\xe \v MIN_TID\:thread.c}
{\xe \v thread.c\:MIN_TID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MIN_TID\~ 3u}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b thread.c}.}\par
}
{\xe \v THREAD_ALIGNMENT\:thread.c}
{\xe \v thread.c\:THREAD_ALIGNMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THREAD_ALIGNMENT\~ 16}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b thread.c}.}\par
}
{\xe \v THREAD_STACK_SIZE\:thread.c}
{\xe \v thread.c\:THREAD_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define THREAD_STACK_SIZE\~ (1024*24)}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b thread.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v PsCreateSystemThread\:thread.c}
{\xe \v thread.c\:PsCreateSystemThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsCreateSystemThread ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b TimeSliceTicks} TIMESLICE)}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b thread.c}.}\par
}
{\xe \v PsCreateThread\:thread.c}
{\xe \v thread.c\:PsCreateThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsCreateThread ({\b HANDLE} ProcessHandle, {\b PHANDLE} ThreadHandle, {\b ThreadEntry} EntryPoint, {\b THREAD_PARAMETER} ThreadParameter, {\b TimeSliceTicks} TimeSlice)}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b thread.c}.}\par
}
{\xe \v PsDeleteThread\:thread.c}
{\xe \v thread.c\:PsDeleteThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsDeleteThread ({\b IN} void * Object)}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b thread.c}.}\par
}
{\xe \v PsGetCurrentThread\:thread.c}
{\xe \v thread.c\:PsGetCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} PsGetCurrentThread (void )}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b thread.c}.}\par
}
{\xe \v PsTerminateThread\:thread.c}
{\xe \v thread.c\:PsTerminateThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsTerminateThread ({\b IN} {\b PETHREAD} Thread, {\b IN} {\b MTSTATUS} ExitStatus)}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b thread.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PsInitialSystemProcess\:thread.c}
{\xe \v thread.c\:PsInitialSystemProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPROCESS} PsInitialSystemProcess{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Stack Overflow check only checks for minor overflows, that don't completely smash the stack, yet do change the canaries (since it only checks in function epilogue) Complete stack smashes are guarded with the guard page in MiCreateKernelStack. \par
}{
Definition at line {\b 162} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
thread.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/thread.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/core/ps/thread.c}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "../../includes/ps.h"}\par
00002 {\cf21 #include "../../assert.h"}\par
00003 {\cf21 #include "../../includes/mg.h"}\par
00004 {\cf21 #include "../../includes/ob.h"}\par
00005 \par
00006 {\cf21 #define MIN_TID           3u}\par
00007 {\cf21 #define MAX_TID           0xFFFFFFFCu}\par
00008 {\cf21 #define ALIGN_DELTA       3u}\par
00009 {\cf21 #define MAX_FREE_POOL     1024u}\par
00010 \par
00011 {\cf21 #define THREAD_STACK_SIZE (1024*24) }{\cf20 // 24 KiB}\par
00012 {\cf21 #define THREAD_ALIGNMENT 16}\par
00013 \par
00014 {\cf20 // Clean exit for a thread\'97never returns!}\par
00015 {\cf17 static} {\cf18 void} ThreadExit({\cf18 void}) \{\par
00016 {\cf21 #ifdef DEBUG}\par
00017     gop_printf(COLOR_RED, {\cf22 "Reached ThreadExit, dereferencing object.\\n"});\par
00018 {\cf21 #endif}\par
00019     {\cf20 // Terminate the thread.}\par
00020     assert(&PsGetCurrentThread()->InternalThread == MeGetCurrentThread());\par
00021     PsTerminateThread(PsGetCurrentThread(), MT_SUCCESS);\par
00022 \}\par
00023 \par
00024 {\cf17 static} {\cf18 void} ThreadWrapperEx(ThreadEntry thread_entry, THREAD_PARAMETER parameter) \{\par
00025     {\cf20 // thread_entry(parameters) -> void func(void*)}\par
00026     thread_entry(parameter); {\cf20 // If thread entry takes no parameters, passing NULL is still fine.}\par
00028     ThreadExit();\par
00029 \}\par
00030 \par
00031 {\cf17 extern} EPROCESS PsInitialSystemProcess;\par
00032 \par
00033 MTSTATUS\par
00034 PsCreateThread(\par
00035     HANDLE ProcessHandle,\par
00036     PHANDLE ThreadHandle,\par
00037     ThreadEntry EntryPoint,\par
00038     THREAD_PARAMETER ThreadParameter,\par
00039     TimeSliceTicks TimeSlice\par
00040 )\par
00041 \par
00042 \{\par
00043     {\cf20 // Checks.}\par
00044     {\cf19 if} (!ProcessHandle || !EntryPoint || !TimeSlice) {\cf19 return} MT_INVALID_PARAM;\par
00045     MTSTATUS Status;\par
00046     PEPROCESS ParentProcess;\par
00047 \par
00048     Status = ObReferenceObjectByHandle(ProcessHandle, MT_PROCESS_CREATE_THREAD, PsProcessType, ({\cf18 void}**)&ParentProcess, NULL);\par
00049     {\cf19 if} (MT_FAILURE(Status)) {\cf19 return} Status;\par
00050 \par
00051     {\cf20 // Acquire process rundown protection.}\par
00052     {\cf19 if} (!MsAcquireRundownProtection(&ParentProcess->ProcessRundown)) \{\par
00053         {\cf20 // Process is, being terminated?}\par
00054         {\cf19 return} MT_PROCESS_IS_TERMINATING;\par
00055     \}\par
00056 \par
00057     {\cf20 // Create a new thread.}\par
00058     PETHREAD Thread;\par
00059     Status = ObCreateObject(PsThreadType, {\cf17 sizeof}(ETHREAD), ({\cf18 void}**) & Thread);\par
00060     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} Cleanup;\par
00061 \par
00062     {\cf20 // Initialize list head.}\par
00063     InitializeListHead(&Thread->ThreadListEntry);\par
00064 \par
00065     {\cf20 // Create a TID for the thread.}\par
00066     Thread->TID = PsAllocateThreadId(Thread);\par
00067 \par
00068     {\cf20 // Create a new stack for the thread's kernel environment.}\par
00069     Thread->InternalThread.KernelStack = MiCreateKernelStack({\cf17 false});\par
00070     {\cf19 if} (!Thread->InternalThread.KernelStack) {\cf19 goto} CleanupWithRef;\par
00071 \par
00072     {\cf20 // Create user mode stack. (FIXME User mode stack creation like in ntdll, but how does it create the first user mode thread stack, helluva i know.)}\par
00073     {\cf18 void}* BaseAddress = ({\cf18 void}*)(USER_VA_END - 4096);\par
00074     Status = MmAllocateVirtualMemory(ParentProcess, &BaseAddress, 4096, VAD_FLAG_WRITE | VAD_FLAG_READ);\par
00075     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} CleanupWithRef;\par
00076     Thread->InternalThread.StackBase = ({\cf18 void}*)(USER_VA_END); {\cf20 // Stack grows downward.}\par
00077 \par
00078     {\cf20 // Setup timeslice.}\par
00079     Thread->InternalThread.TimeSlice = TimeSlice;\par
00080     Thread->InternalThread.TimeSliceAllocated = TimeSlice;\par
00081 \par
00082     {\cf20 // Set registers}\par
00083     TRAP_FRAME ContextFrame;\par
00084     kmemset(&ContextFrame, 0, {\cf17 sizeof}(TRAP_FRAME));\par
00085 \par
00086     ContextFrame.rsp = (uint64_t)Thread->InternalThread.StackBase;\par
00087     ContextFrame.rip = (uint64_t)EntryPoint;\par
00088     ContextFrame.rdi = (uint64_t)ThreadParameter;\par
00089     ContextFrame.rflags = USER_RFLAGS;\par
00090     ContextFrame.cs = USER_CS;\par
00091     ContextFrame.ss = USER_SS;\par
00092     Thread->InternalThread.TrapRegisters = ContextFrame;\par
00093     \par
00094     {\cf20 // Set state}\par
00095     Thread->InternalThread.ThreadState = THREAD_READY;\par
00096     Thread->InternalThread.ApcState.SavedApcProcess = ParentProcess;\par
00097 \par
00098     {\cf20 // Set process's thread properties.}\par
00099     {\cf19 if} (!ParentProcess->MainThread) \{\par
00100         ParentProcess->MainThread = Thread;\par
00101     \}\par
00102 \par
00103     Thread->ParentProcess = ParentProcess;\par
00104 \par
00105     {\cf20 // Create a handle for the thread (and place it in the process's handle table).}\par
00106     Status = ObCreateHandleForObjectEx(Thread, MT_THREAD_ALL_ACCESS, ThreadHandle, ParentProcess->ObjectTable);\par
00107     {\cf19 if} (MT_FAILURE(Status)) {\cf19 goto} CleanupWithRef;\par
00108     \par
00109     {\cf20 // Add to list of all threads in the parent process.}\par
00110     InsertTailList(&ParentProcess->AllThreads, &Thread->ThreadListEntry);\par
00111     InterlockedIncrementU32(({\cf17 volatile} uint32_t*)&ParentProcess->NumThreads);\par
00112     Status = MT_SUCCESS;\par
00113 CleanupWithRef:\par
00114     {\cf20 // If all went smoothly, this should cancel out the reference made by ObCreateHandleForObject. (so we only have 1 reference left by ObCreateObject)}\par
00115     {\cf20 // If not, it would reach reference 0, and PspDeleteThread would execute.}\par
00116     ObDereferenceObject(Thread);\par
00117 Cleanup:\par
00118     MsReleaseRundownProtection(&ParentProcess->ProcessRundown);\par
00119     {\cf19 return} Status;\par
00120 \}\par
00121 \par
00122 MTSTATUS PsCreateSystemThread(ThreadEntry entry, THREAD_PARAMETER parameter, TimeSliceTicks TIMESLICE) \{\par
00123     {\cf19 if} (!PsInitialSystemProcess.PID) {\cf19 return} MT_NOT_FOUND; {\cf20 // The system process, somehow, hasn't been setupped yet.}\par
00124     {\cf19 if} (!entry || !TIMESLICE) {\cf19 return} MT_INVALID_PARAM;\par
00125 \par
00126     {\cf20 // First, allocate a new thread. (using our shiny and glossy new object manager!!!)}\par
00127     MTSTATUS Status;\par
00128     PETHREAD thread; \par
00129     Status = ObCreateObject(PsThreadType, {\cf17 sizeof}(ETHREAD), ({\cf18 void}*) & thread);\par
00130     {\cf19 if} (MT_FAILURE(Status)) \{\par
00131         {\cf19 return} Status;\par
00132     \}\par
00133 \par
00134     InitializeListHead(&thread->ThreadListEntry);\par
00135 \par
00136     {\cf20 // Zero it.}\par
00137     kmemset(({\cf18 void}*)thread, 0, {\cf17 sizeof}(ETHREAD));\par
00138     {\cf18 bool} LargeStack = {\cf17 false};\par
00139     {\cf18 void}* stackStart = MiCreateKernelStack(LargeStack);\par
00140 \par
00141     {\cf19 if} (!stackStart) \{\par
00142         {\cf20 // free thread}\par
00143         ObDereferenceObject(thread);\par
00144         {\cf19 return} MT_NO_MEMORY;\par
00145     \}\par
00146 \par
00147     uintptr_t StackTop = (uintptr_t)stackStart;\par
00148 \par
00149     StackTop &= ~0xF; {\cf20 // Align to 16 bytes (clear lower 4 bits)}\par
00150     StackTop -= 8; {\cf20 // Decrement by 8 to keep 16-byte alignment. (after pushes)}\par
00151 \par
00152     thread->InternalThread.StackBase = stackStart; {\cf20 // The stackbase must be the one gotten from MiCreateKernelStack, as freeing with StackTop will result in incorrect arithmetic, and so assertion failure.}\par
00153     thread->InternalThread.IsLargeStack = LargeStack;\par
00154     thread->InternalThread.KernelStack = stackStart;\par
00155 \par
00156     TRAP_FRAME* cfm = &thread->InternalThread.TrapRegisters;\par
00157     kmemset(cfm, 0, {\cf17 sizeof} * cfm);\par
00158 \par
00159     {\cf20 // Set our timeslice.}\par
00160     thread->InternalThread.TimeSlice = TIMESLICE;\par
00161     thread->InternalThread.TimeSliceAllocated = TIMESLICE;\par
00162 \par
00163     {\cf20 // saved rsp must point to the top (aligned), not sp-8}\par
00164     cfm->rsp = (uint64_t)StackTop;\par
00165     cfm->rip = (uint64_t)ThreadWrapperEx;\par
00166     cfm->rdi = (uint64_t)entry; {\cf20 // first argument to ThreadWrapperEx (the entry point)}\par
00167     cfm->rsi = (uint64_t)parameter; {\cf20 // second arugment to ThreadWrapperEx (the parameter pointer)}\par
00168 \par
00169     cfm->ss = KERNEL_SS;\par
00170     cfm->cs = KERNEL_CS;\par
00171 \par
00172     {\cf20 // Create it's RFLAGS with IF bit set to 1.}\par
00173     cfm->rflags |= (1 << 9ULL);\par
00174 \par
00175     {\cf20 // Set it's registers and others.}\par
00176     thread->InternalThread.TrapRegisters = *cfm;\par
00177     thread->InternalThread.ThreadState = THREAD_READY;\par
00178     thread->TID = PsAllocateThreadId(thread);\par
00179     thread->CurrentEvent = NULL;\par
00180     thread->InternalThread.ApcState.SavedApcProcess = &PsInitialSystemProcess;\par
00181 \par
00182     {\cf20 // Process stuffz}\par
00183     thread->ParentProcess = &PsInitialSystemProcess; {\cf20 // The parent process for the system thread, is the system process.}\par
00184     MeEnqueueThreadWithLock(&MeGetCurrentProcessor()->readyQueue, thread);\par
00185 \par
00186 \par
00187     {\cf19 return} MT_SUCCESS;\par
00188 \}\par
00189 \par
00190 PETHREAD \par
00191 PsGetCurrentThread ({\cf18 void}) \{\par
00192     {\cf19 return} CONTAINING_RECORD(MeGetCurrentThread(), ETHREAD, InternalThread);\par
00193 \}\par
00194 \par
00195 {\cf18 void}\par
00196 PsTerminateThread(\par
00197     IN PETHREAD Thread,\par
00198     IN MTSTATUS ExitStatus\par
00199 )\par
00200 \par
00201 \{\par
00202     {\cf20 // On thread terminations, we only unlink them from global list, delete stacks, and other}\par
00203     {\cf20 // BUT WE DO NOT - Delete the ETHREAD, since thats up to the object manager to do so, we do not interfere}\par
00204     {\cf20 // with its work.}\par
00205     Thread->InternalThread.ThreadState = THREAD_TERMINATING;\par
00206     Thread->ExitStatus = ExitStatus;\par
00207 \par
00208     {\cf20 // Signal all events that the thread is waiting on to execute immediately.}\par
00209     {\cf20 // Todo parse waitblock.}\par
00210 \par
00211     {\cf20 // Since this is marked as TERMINATING, the scheduler will dereference the thread in Ob, and from that if}\par
00212     {\cf20 // the references have reached 0, the Ob will call PsDeleteThread.}\par
00213     {\cf20 // The scheduler WILL NOT schedule this thread anymore due to its TERMINATION flag.}\par
00214 \par
00215     {\cf20 // Schedule away!}\par
00216     Schedule();\par
00217 \}\par
00218 \par
00219 {\cf18 void}\par
00220 PsDeleteThread(\par
00221     IN {\cf18 void}* Object\par
00222 )\par
00223 \par
00224 \{\par
00225     {\cf20 // This function is called when the reference count for this thread has reached 0 (e.g, it is no longer in use)}\par
00226     {\cf20 // (No need to call PsTerminateThread, it is the one that initiated the final dereference, since it set to terminated, and scheduler called dereference)}\par
00227     {\cf20 // We free everything that the thread uses.}\par
00228     {\cf20 // All though, before, we should wait for rundown release (so nobody is changing the fields to avoid UAF)}\par
00229     PETHREAD Thread = (PETHREAD)Object;\par
00230     MsWaitForRundownProtectionRelease(&Thread->ThreadRundown);\par
00231 \par
00232     {\cf18 bool} IsKernelThread = PsIsKernelThread(Thread);\par
00233 \par
00234     {\cf20 // Free TID.}\par
00235     PsFreeCid(Thread->TID);\par
00236 \par
00237     {\cf20 // Free its stack.}\par
00238     {\cf19 if} (IsKernelThread) \{\par
00239         PsDeferKernelStackDeletion(Thread->InternalThread.StackBase, Thread->InternalThread.IsLargeStack);\par
00240     \}\par
00241     {\cf19 else} \{\par
00242         assert({\cf17 false}, {\cf22 "User mode threads are not supported yet."});\par
00243     \}\par
00244 \par
00245     {\cf20 // When we reach here, the function returns, and the ETHREAD is deleted.}\par
00246 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ahci.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/mm.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _AHCI_PORT_CTX}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _AHCI_PORT_CTX} {\b AHCI_PORT_CTX}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_read_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, void *buf, size_t bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single bytes-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_write_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, const void *buf, size_t bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single bytes-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b ahci_get_block_device} (int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ahci_initialized} = false\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v AHCI_PORT_CTX\:ahci.c}
{\xe \v ahci.c\:AHCI_PORT_CTX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _AHCI_PORT_CTX} {\b AHCI_PORT_CTX}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ahci_get_block_device\:ahci.c}
{\xe \v ahci.c\:ahci_get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * ahci_get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the {\b BLOCK_DEVICE} registration.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b BLOCK_DEVICE} struct pointer.\par
}}}{
Definition at line {\b 562} of file {\b ahci.c}.}\par
}
{\xe \v ahci_init\:ahci.c}
{\xe \v ahci.c\:ahci_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_init (void )}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the AHCI Driver.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based if it initialized correctly or not. (if failure = bugcheck)\par
}}}{
Definition at line {\b 292} of file {\b ahci.c}.}\par
}
{\xe \v ahci_read_sector\:ahci.c}
{\xe \v ahci.c\:ahci_read_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_read_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, void * buf, size_t bytes)}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single bytes-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Return buffer to place the data read.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession | buf pointer changes.\par
}}}{
Definition at line {\b 330} of file {\b ahci.c}.}\par
}
{\xe \v ahci_write_sector\:ahci.c}
{\xe \v ahci.c\:ahci_write_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_write_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, const void * buf, size_t bytes)}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single bytes-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{The buffer to write to the specified LBA.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession\par
}}}{
Definition at line {\b 450} of file {\b ahci.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ahci_initialized\:ahci.c}
{\xe \v ahci.c\:ahci_initialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ahci_initialized = false}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 290} of file {\b ahci.c}.}\par
}
{\xe \v boot_info_local\:ahci.c}
{\xe \v ahci.c\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b kernel.c}.}\par
}
{\xe \v gop_local\:ahci.c}
{\xe \v ahci.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ahci.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.c}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      AHCI Driver Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "ahci.h"}\par
00008 {\cf21 #include "../../assert.h"}\par
00009 {\cf21 #include "../../includes/mg.h"}\par
00010 {\cf21 #include "../../includes/mm.h"}\par
00011 \par
00012 {\cf21 #ifdef REMINDER}\par
00013 {\cf17 _Static_assert}({\cf17 false}, {\cf22 "Reminder: AHCI, and other DMA stuff DEAL WITH PHYSICAL ADDRESSES ONLY! not virtual, so supply to them the translated addresses."});\par
00014 {\cf21 #endif}\par
00015 \par
00016 {\cf20 //#define AHCI_DEBUG_PRINT}\par
00017 \par
00018 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00019 {\cf17 static} {\cf18 void} decode_serr(uint32_t serr) \{\par
00020     {\cf19 if} (serr == 0) \{\par
00021         {\cf20 // gop_printf(0xFFFFFF00, "SERR: No errors\\n");}\par
00022         {\cf19 return};\par
00023     \}\par
00024 \par
00025     {\cf20 // gop_printf(0xFFFF0000, "SERR: 0x%08x - Errors detected:\\n", serr);}\par
00026 \par
00027     {\cf20 // ERR bits (0-15) - Recoverable and non-recoverable errors}\par
00028     {\cf20 //if (serr & (1 << 0))  // gop_printf(0xFFFFFF00, "  [0] ERR.I - Recovered Data Integrity Error\\n");}\par
00029     {\cf20 //if (serr & (1 << 1))  // gop_printf(0xFFFFFF00, "  [1] ERR.M - Recovered Communications Error\\n");}\par
00030     {\cf20 //if (serr & (1 << 8))  // gop_printf(0xFFFFFF00, "  [8] ERR.T - Transient Data Integrity Error\\n");}\par
00031     {\cf20 //if (serr & (1 << 9))  // gop_printf(0xFFFFFF00, "  [9] ERR.C - Persistent Communication/Data Integrity Error\\n");}\par
00032     {\cf20 //if (serr & (1 << 10)) // gop_printf(0xFFFFFF00, "  [10] ERR.P - Protocol Error\\n");}\par
00033     {\cf20 //if (serr & (1 << 11)) // gop_printf(0xFFFFFF00, "  [11] ERR.E - Internal Error\\n");}\par
00034     {\cf20 //}\par
00036     {\cf20 //if (serr & (1 << 16)) // gop_printf(0xFFFFFF00, "  [16] DIAG.N - PhyRdy Change\\n");}\par
00037     {\cf20 //if (serr & (1 << 17)) // gop_printf(0xFFFFFF00, "  [17] DIAG.I - Phy Internal Error\\n");}\par
00038     {\cf20 //if (serr & (1 << 18)) // gop_printf(0xFFFFFF00, "  [18] DIAG.W - Comm Wake\\n");}\par
00039     {\cf20 //if (serr & (1 << 19)) // gop_printf(0xFFFFFF00, "  [19] DIAG.B - 10B to 8B Decode Error\\n");}\par
00040     {\cf20 //if (serr & (1 << 20)) // gop_printf(0xFFFFFF00, "  [20] DIAG.D - Disparity Error\\n");}\par
00041     {\cf20 //if (serr & (1 << 21)) // gop_printf(0xFFFFFF00, "  [21] DIAG.C - CRC Error\\n");}\par
00042     {\cf20 //if (serr & (1 << 22)) // gop_printf(0xFFFFFF00, "  [22] DIAG.H - Handshake Error\\n");}\par
00043     {\cf20 //if (serr & (1 << 23)) // gop_printf(0xFFFFFF00, "  [23] DIAG.S - Link Sequence Error\\n");}\par
00044     {\cf20 //if (serr & (1 << 24)) // gop_printf(0xFFFFFF00, "  [24] DIAG.T - Transport State Transition Error\\n");}\par
00045     {\cf20 //if (serr & (1 << 25)) // gop_printf(0xFFFFFF00, "  [25] DIAG.F - Unknown FIS Type\\n");}\par
00046     {\cf20 //if (serr & (1 << 26)) // gop_printf(0xFFFFFF00, "  [26] DIAG.X - Exchanged\\n");}\par
00047 \}\par
00048 {\cf21 #endif}\par
00049 {\cf20 // Context per initialized port}\par
00050 {\cf17 typedef} {\cf17 struct }_AHCI_PORT_CTX \{\par
00051     HBA_PORT* port;             {\cf20 // MMIO base for this port}\par
00052     HBA_CMD_TBL* cmd_tbl;       {\cf20 // Command table memory}\par
00053     {\cf18 void}* clb;                  {\cf20 // Cmd list buffer}\par
00054     {\cf18 void}* fis;                  {\cf20 // FIS receive buffer}\par
00055     BLOCK_DEVICE bdev;          {\cf20 // Associated BLOCK_DEVICE interface}\par
00056 \} AHCI_PORT_CTX;\par
00057 \par
00058 {\cf17 static} HBA_MEM* hba_mem;\par
00059 {\cf17 static} AHCI_PORT_CTX ports[AHCI_MAX_PORTS];\par
00060 {\cf17 static} {\cf18 int} port_count;\par
00061 \par
00062 {\cf20 // Invalidate cache ranges of the CPU to ensure newest data is fetched from RAM.}\par
00063 {\cf17 static} {\cf17 inline} {\cf18 void} cache_flush_invalidate_range({\cf18 void}* addr, {\cf18 size_t} len) \{\par
00064     uintptr_t p = (uintptr_t)addr & ~(uintptr_t)63;\par
00065     uintptr_t end = (uintptr_t)addr + len;\par
00066     {\cf19 for} (; p < end; p += 64) \{\par
00067         __asm__ {\cf17 volatile}({\cf22 "clflush (%0)"} :: {\cf22 "r"}(({\cf18 void}*)p) : {\cf22 "memory"});\par
00068     \}\par
00069     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00070 \}\par
00071 \par
00072 {\cf17 static} {\cf17 inline} {\cf18 void} outl_port(uint16_t port, uint32_t val) \{\par
00073     __asm__ {\cf17 volatile}({\cf22 "outl %0, %1"} :: {\cf22 "a"}(val), {\cf22 "d"}(port));\par
00074 \}\par
00075 {\cf17 static} {\cf17 inline} uint32_t inl_port(uint16_t port) \{\par
00076     uint32_t val;\par
00077     __asm__ {\cf17 volatile}({\cf22 "inl %1, %0"} : {\cf22 "=a"}(val) : {\cf22 "d"}(port));\par
00078     {\cf19 return} val;\par
00079 \}\par
00080 {\cf17 static} uint32_t pci_cfg_read32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) \{\par
00081     uint32_t addr = (1u << 31) | ((uint32_t)bus << 16) | ((uint32_t)slot << 11) |\par
00082         ((uint32_t)func << 8) | (offset & 0xFC);\par
00083     outl_port(0xCF8, addr);\par
00084     {\cf19 return} inl_port(0xCFC);\par
00085 \}\par
00086 {\cf17 static} {\cf18 void} pci_cfg_write32(uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset, uint32_t val) \{\par
00087     uint32_t addr = (1u << 31) | ((uint32_t)bus << 16) | ((uint32_t)slot << 11) |\par
00088         ((uint32_t)func << 8) | (offset & 0xFC);\par
00089     outl_port(0xCF8, addr);\par
00090     outl_port(0xCFC, val);\par
00091 \}\par
00092 \par
00093 {\cf20 // Scans PCI buses and enables Bus Master bit for first AHCI class device found.}\par
00094 {\cf20 // Call this at start of ahci_init() before enable_controller().}\par
00095 {\cf17 static} {\cf18 void} ensure_ahci_busmaster_enabled({\cf18 void}) \{\par
00096     {\cf19 for} (uint8_t bus = 0; bus < 8; ++bus) \{\par
00097         {\cf19 for} (uint8_t slot = 0; slot < 32; ++slot) \{\par
00098             {\cf19 for} (uint8_t func = 0; func < 8; ++func) \{\par
00099                 uint32_t d0 = pci_cfg_read32(bus, slot, func, 0x00);\par
00100                 {\cf19 if} ((d0 & 0xFFFF) == 0xFFFF) {\cf19 continue}; {\cf20 // no device}\par
00101                 uint32_t cl = pci_cfg_read32(bus, slot, func, 0x08);\par
00102                 uint8_t base_class = (cl >> 24) & 0xFF;\par
00103                 uint8_t sub_class = (cl >> 16) & 0xFF;\par
00104                 uint8_t prog_if = (cl >> 8) & 0xFF;\par
00105                 {\cf19 if} (base_class == 0x01 && sub_class == 0x06 && prog_if == 0x01) \{\par
00106 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00107                     uint32_t hdr = pci_cfg_read32(bus, slot, func, 0x00);\par
00108                     uint16_t vendor = hdr & 0xFFFF;\par
00109                     uint16_t device = (hdr >> 16) & 0xFFFF;\par
00110 {\cf21 #endif}\par
00111                     uint32_t cmd32 = pci_cfg_read32(bus, slot, func, 0x04);\par
00112                     uint16_t cmd = cmd32 & 0xFFFF;\par
00113 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00114                     {\cf20 // gop_printf(0xFFFFFF00, "AHCI PCI at %p:%p vendor=%p device=%p\\n", bus, slot, func, vendor, device);}\par
00115                     {\cf20 // gop_printf(0xFFFFFF00, "PCI CMD before: %p\\n", cmd);}\par
00116 {\cf21 #endif}\par
00117                     {\cf19 if} (!(cmd & (1 << 2))) \{\par
00118                         cmd |= (1 << 2); {\cf20 // set Bus Master}\par
00119                         pci_cfg_write32(bus, slot, func, 0x04, (cmd32 & 0xFFFF0000) | (uint32_t)cmd);\par
00120 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00121                         {\cf20 // gop_printf(0xFFFFFF00, "Enabled PCI Bus Master bit for AHCI\\n");}\par
00122 {\cf21 #endif}\par
00123                     \}\par
00124                     {\cf19 else} \{\par
00125 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00126                         {\cf20 // gop_printf(0xFFFFFF00, "PCI Bus Master already enabled\\n");}\par
00127 {\cf21 #endif}\par
00128                     \}\par
00129                     {\cf19 return};\par
00130                 \}\par
00131             \}\par
00132         \}\par
00133     \}\par
00134 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00135     {\cf20 // gop_printf(0xFFFF0000, "AHCI PCI device not found while scanning PCI bus\\n");}\par
00136 {\cf21 #endif}\par
00137 \}\par
00138 \par
00144 {\cf17 static} {\cf18 int} find_free_slot(uint32_t mask) \{\par
00145     {\cf19 for} ({\cf18 int} i = 0; i < 32; i++) \{\par
00146         {\cf19 if} (!(mask & (1u << i))) \{\par
00147             {\cf19 return} i;\par
00148         \}\par
00149     \}\par
00150     {\cf19 return} -1;\par
00151 \}\par
00152 \par
00156 {\cf17 static} {\cf18 void} enable_controller({\cf18 void}) \{\par
00157     hba_mem->ghc |= (1u << 31); {\cf20 // AHCI Enable.}\par
00158     hba_mem->ghc |= (1u << 0); {\cf20 // Global Reset.}\par
00160     {\cf19 while} (hba_mem->ghc & (1u << 0));\par
00161 \}\par
00162 \par
00168 {\cf17 static} {\cf18 bool} init_one_port({\cf18 int} idx) \{\par
00169     HBA_PORT* p = (HBA_PORT*)((uint8_t*)hba_mem + 0x100 + idx * 0x80);\par
00170     uint32_t status = p->ssts;\par
00171     {\cf19 if} ((status & 0x0F) != 3) {\cf19 return} {\cf17 false}; {\cf20 // no device present}\par
00172 \par
00173     {\cf20 // Stop the port before configuration}\par
00174     p->cmd &= ~(1u << 0); {\cf20 // Clear ST (START)}\par
00175     p->cmd &= ~(1u << 4); {\cf20 // Clear PRE (FIS Receive Enable)}\par
00176 \par
00177     {\cf20 // Wait until port is idle}\par
00178     {\cf19 while} ((p->cmd & (1u << 15)) || (p->cmd & (1u << 14))) \{\par
00179         __pause();\par
00180     \}\par
00181 \par
00182     {\cf20 // Allocate and zero CLB (1 KiB)}\par
00183     {\cf18 void}* clb = MmAllocateContigiousMemory(1024, UINT64_T_MAX);\par
00184     {\cf19 if} (!clb) {\cf19 return} {\cf17 false};\par
00185     kmemset(clb, 0, 1024);\par
00186     {\cf20 // pass the PHYSICAL address.}\par
00187     uintptr_t clb_phys = MiTranslateVirtualToPhysical(clb);\par
00188     assert(((uintptr_t)clb_phys & 0x3FF) == 0, {\cf22 "CLB must be 1KiB-aligned (1024 byte multiple)"});\par
00189 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00190     {\cf20 // gop_printf(COLOR_BLUE, "In INIT_ONE_PORT, clb_phys: %p | virt: %p\\n", clb_phys, clb);}\par
00191 {\cf21 #endif}\par
00192     p->clb = (uint32_t)(uintptr_t)clb_phys;\par
00193     p->clbu = (uint32_t)((uintptr_t)clb_phys >> 32);\par
00194 \par
00195     {\cf20 // Allocate and zero FIS receive buffer (256 B)}\par
00196     {\cf18 void}* fis_buf = MmAllocateContigiousMemory(256, UINT64_T_MAX);\par
00197     {\cf19 if} (!fis_buf) {\cf19 return} {\cf17 false};\par
00198     kmemset(fis_buf, 0, 256);\par
00199     {\cf20 // Again, pass the PHYSICAL.}\par
00200     uintptr_t fis_buf_phys = MiTranslateVirtualToPhysical(fis_buf);\par
00201 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00202     {\cf20 // gop_printf(COLOR_BLUE, "In INIT_ONE_PORT, fis_buf_phys: %p | virt: %p\\n", fis_buf_phys, fis_buf);}\par
00203 {\cf21 #endif}\par
00204     p->fb = (uint32_t)(uintptr_t)fis_buf_phys;\par
00205     p->fbu = (uint32_t)((uintptr_t)fis_buf_phys >> 32);\par
00206 \par
00207     {\cf20 // Allocate and zero Command Table buffers: 256 B \'D7 32 slots}\par
00208     {\cf18 size_t} tbl_size = 256 * 32;\par
00209     {\cf18 void}* cmd_tbl = MmAllocateContigiousMemory(tbl_size, UINT64_T_MAX);\par
00210     {\cf19 if} (!cmd_tbl) {\cf19 return} {\cf17 false};\par
00211     kmemset(cmd_tbl, 0, tbl_size);\par
00212     uintptr_t cmd_tbl_phys = MiTranslateVirtualToPhysical(cmd_tbl);\par
00213     assert(((uintptr_t)cmd_tbl_phys & 0xFF) == 0, {\cf22 "Command table block must be 256-byte aligned"});\par
00214 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00215     {\cf20 // gop_printf(COLOR_BLUE, "In INIT_ONE_PORT, cmd_tbl_phys: %p | virt: %p\\n", cmd_tbl_phys, cmd_tbl);}\par
00216 {\cf21 #endif}\par
00217 \par
00218     {\cf20 // Point each command header to its table}\par
00219     {\cf19 for} ({\cf18 int} slot = 0; slot < 32; slot++) \{\par
00220         {\cf20 // Header at clb + slot*32 bytes}\par
00221         HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)clb + slot * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00222         uintptr_t tbl_pa_phys = (uintptr_t)cmd_tbl_phys + slot * 256;\par
00223         hdr->ctba = (uint32_t)(tbl_pa_phys & 0xFFFFFFFF);\par
00224         hdr->ctbau = (uint32_t)(tbl_pa_phys >> 32);\par
00225         hba_cmd_hdr_set_prdtl(hdr, 1); {\cf20 // one PRDT entry}\par
00226     \}\par
00227 \par
00228     {\cf20 // Clear any old errors and start the port}\par
00229     p->serr = ~0U; {\cf20 // Clear all SERROR bits by writing 1 to them.}\par
00230     p->cmd |= (1u << 4); {\cf20 // Set FRE}\par
00231     p->cmd |= (1u << 0); {\cf20 // Set ST}\par
00232 \par
00233     {\cf20 // Add this assertion to ensure the port actually starts}\par
00234     assert((p->cmd & 1) != 0, {\cf22 "Port ST bit failed to set!"});\par
00235 \par
00236     {\cf20 // Save context}\par
00237     AHCI_PORT_CTX* ctx = &ports[port_count];\par
00238     ctx->port = p;\par
00239     ctx->clb = clb;\par
00240     ctx->fis = fis_buf;\par
00241     ctx->cmd_tbl = cmd_tbl;\par
00242     ctx->bdev.read_sector = ahci_read_sector;\par
00243     ctx->bdev.write_sector = ahci_write_sector;\par
00244     ctx->bdev.dev_data = ctx;\par
00245 \par
00246     {\cf20 /* CAP and slot counts */}\par
00247 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00248     uint32_t cap = (uint32_t)hba_mem->cap;\par
00249     uint32_t ncs = (cap >> 8) & 0x1Fu;\par
00250     assert(((ncs + 1) >= 1) && ((ncs + 1) <= 32), {\cf22 "CAP.NCS invalid (command slots out of range)"});\par
00251 \par
00252     {\cf18 bool} s64a = !!((cap >> 31) & 1u);\par
00253 \par
00254     {\cf20 /* Alignment checks */}\par
00255     assert(((uintptr_t)clb_phys & 0x3FF) == 0, {\cf22 "PxCLB must be 1KiB-aligned (1024 bytes)"});\par
00256     assert(((uintptr_t)fis_buf_phys & 0xFF) == 0, {\cf22 "PxFB (FIS) must be 256-byte aligned"});\par
00257     assert(((uintptr_t)cmd_tbl_phys & 0xFF) == 0, {\cf22 "Command table region must start at 256-byte boundary"});\par
00258 \par
00259     {\cf20 /* 64-bit addressing: if device doesn't advertise S64A, upper bits must be zero */}\par
00260     {\cf19 if} (!s64a) \{\par
00261         assert(((uintptr_t)clb_phys >> 32) == 0, {\cf22 "CLB high dword must be zero when CAP.S64A==0"});\par
00262         assert(((uintptr_t)cmd_tbl_phys >> 32) == 0, {\cf22 "CMD_TBL high dword must be zero when CAP.S64A==0"});\par
00263         assert(((uintptr_t)fis_buf_phys >> 32) == 0, {\cf22 "FIS high dword must be zero when CAP.S64A==0"});\par
00264     \}\par
00265 {\cf21 #endif}\par
00266     {\cf20 /* Per-header CTBA programmed correctly (for the number of slots the HBA advertises) */}\par
00267 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00268     {\cf19 for} ({\cf18 unsigned} sl = 0; sl <= ncs; ++sl) \{\par
00269 {\cf21 #ifdef DEBUG}\par
00270         HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)clb + sl * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00271         uintptr_t expected = (uintptr_t)cmd_tbl_phys + sl * 256;\par
00272 {\cf21 #endif}\par
00273         assert(hdr->ctba == (uint32_t)(expected & 0xFFFFFFFFu), {\cf22 "Header CTBA low doesn't match expected CTBA"});\par
00274         {\cf19 if} (s64a) \{\par
00275             assert(hdr->ctbau == (uint32_t)(expected >> 32), {\cf22 "Header CTBAU mismatch (S64A advertised)"});\par
00276         \}\par
00277         {\cf19 else} \{\par
00278             assert(hdr->ctbau == 0, {\cf22 "Header CTBAU must be zero when S64A==0"});\par
00279         \}\par
00280     \}\par
00281 {\cf21 #endif}\par
00282 \par
00283     port_count++;\par
00284     {\cf19 return} {\cf17 true};\par
00285 \}\par
00286 \par
00287 {\cf17 extern} BOOT_INFO boot_info_local;\par
00288 {\cf17 extern} GOP_PARAMS gop_local;\par
00289 \par
00290 {\cf18 bool} ahci_initialized = {\cf17 false};\par
00291 \par
00292 MTSTATUS ahci_init({\cf18 void}) \{\par
00293     {\cf19 if} (ahci_initialized) \{ {\cf19 return} MT_SUCCESS; \} {\cf20 // gop_printf(COLOR_RED, "AHCI Initialization got called again when already init.\\n"); return MT_SUCCESS; \}}\par
00294     {\cf20 // Use BootInfo PCI BARs.}\par
00295     {\cf19 for} ({\cf18 size_t} i = 0; i < boot_info_local.AhciCount; i++) \{\par
00296         uint64_t base = boot_info_local.AhciBarBases[i];\par
00297         {\cf18 void}* virt = MmMapIoSpace(base, VirtualPageSize, MmNonCached);\par
00298 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00299         {\cf20 // gop_printf(COLOR_ORANGE, "Address of AHCI BAR %u (%p) is: %s\\n", i, virt, MmIsAddressPresent((uintptr_t)virt) ? "Valid" : "Invalid");}\par
00300 {\cf21 #endif}\par
00301         {\cf20 // Now change the values in the struct}\par
00302         boot_info_local.AhciBarBases[i] = (uint64_t)virt;\par
00303     \}\par
00304 \par
00305     uint64_t bar = boot_info_local.AhciBarBases[0];\par
00306     hba_mem = (HBA_MEM*)(uintptr_t)bar;\par
00307 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00308     {\cf20 // gop_printf(0xFF00FFFF, "About to touch AHCI %u at %p | It's %s\\n",0, hba_mem, MmIsAddressPresent((uintptr_t)bar) ? "Valid" : "Invalid");}\par
00309     {\cf20 //_cli(); __hlt();}\par
00310 {\cf21 #endif}\par
00311     ensure_ahci_busmaster_enabled();\par
00312     enable_controller();\par
00313     port_count = 0; {\cf20 // Start from 0.}\par
00314     uint32_t pi = hba_mem->pi;\par
00315 \par
00316     {\cf19 for} ({\cf18 int} idx = 0; idx < AHCI_MAX_PORTS; idx++) \{\par
00317         {\cf19 if} (pi & (1u << idx)) \{\par
00318             init_one_port(idx);\par
00319         \}\par
00320     \}\par
00321 \par
00322     {\cf20 // Register ALL block devices.}\par
00323     {\cf19 for} ({\cf18 int} i = 0; i < port_count; i++) \{\par
00324         register_block_device(&ports[i].bdev);\par
00325     \}\par
00326     ahci_initialized = {\cf17 true};\par
00327     {\cf19 return} port_count > 0 ? MT_SUCCESS : MT_AHCI_PORT_FAILURE; {\cf20 // If it could register a port, it will return true, if it couldn't, it will return false (bugcheck)}\par
00328 \}\par
00329 \par
00330 MTSTATUS ahci_read_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf18 void}* buf, {\cf18 size_t} bytes) \{\par
00331 \par
00332     {\cf20 // 1. Input Validation}\par
00333     {\cf19 if} (bytes == 0 || (bytes % 512 != 0)) \{\par
00334         {\cf20 // ATA DMA transfers must typically be sector-aligned}\par
00335         {\cf19 return} MT_INVALID_PARAM;\par
00336     \}\par
00337 \par
00338     AHCI_PORT_CTX* ctx = (AHCI_PORT_CTX*)dev->dev_data;\par
00339     HBA_PORT* p = ctx->port;\par
00340 \par
00341     {\cf20 // 2. Clear Pending Interrupts}\par
00342     p->is = (uint32_t)-1;\par
00343 \par
00344     {\cf18 int} slot = find_free_slot(p->sact | p->ci);\par
00345     {\cf19 if} (slot < 0) {\cf19 return} MT_AHCI_PORT_FAILURE;\par
00346 \par
00347     uint32_t spin = 0;\par
00348     {\cf17 const} uint32_t TIMEOUT = 100000000;\par
00349 \par
00350     {\cf20 // Wait for slot to be clear (sanity check)}\par
00351     {\cf19 while} (p->ci & (1u << slot)) \{\par
00352         {\cf19 if} (++spin >= TIMEOUT) {\cf19 return} MT_AHCI_TIMEOUT;\par
00353     \}\par
00354 \par
00355     {\cf20 // 3. Setup Command Table}\par
00356     HBA_CMD_TBL* cmd = (HBA_CMD_TBL*)((uint8_t*)ctx->cmd_tbl + slot * 256);\par
00357     kmemset(cmd, 0, 256);\par
00358 \par
00359     {\cf20 // 4. Setup Command Header}\par
00360     HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)ctx->clb + slot * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00361     hba_cmd_hdr_set_cfl(hdr, ({\cf17 sizeof}(FIS_REG_H2D) + 3) / 4);\par
00362     hba_cmd_hdr_set_w(hdr, 0);      {\cf20 // Read}\par
00363     hba_cmd_hdr_set_prdtl(hdr, 1);  {\cf20 // One PRDT entry (Assuming bytes <= 4MB)}\par
00364     hdr->prdbc = 0;                 {\cf20 // Reset transferred count}\par
00365 \par
00366     {\cf20 // 5. Calculate Sector Count}\par
00367     {\cf20 // We assume bytes is a multiple of 512 based on the check above.}\par
00368     uint32_t sector_count = bytes / 512;\par
00369 \par
00370     {\cf20 // 6. Build FIS with Dynamic Sector Count}\par
00371     FIS_REG_H2D* fis = (FIS_REG_H2D*)(&cmd->cfis);\par
00372     kmemset(fis, 0, {\cf17 sizeof}(*fis));\par
00373     fis->fis_type = FIS_TYPE_REG_H2D;\par
00374     fis->c = 1; {\cf20 // Command}\par
00375     fis->command = 0x25; {\cf20 // READ DMA EXT}\par
00376 \par
00377     fis->lba0 = (uint8_t)(lba & 0xFF);\par
00378     fis->lba1 = (uint8_t)((lba >> 8) & 0xFF);\par
00379     fis->lba2 = (uint8_t)((lba >> 16) & 0xFF);\par
00380     fis->device = 1 << 6; {\cf20 // LBA mode}\par
00381 \par
00382     fis->lba3 = (uint8_t)((lba >> 24) & 0xFF);\par
00383     fis->lba4 = 0; {\cf20 // Extended LBA not supported in this simplified LBA32 param}\par
00384     fis->lba5 = 0;\par
00385 \par
00386     {\cf20 // Split sector count for LBA48 command structure}\par
00387     fis->countl = (uint8_t)(sector_count & 0xFF);\par
00388     fis->counth = (uint8_t)((sector_count >> 8) & 0xFF);\par
00389 \par
00390     {\cf20 // 7. Setup PRDT}\par
00391     HBA_PRDT_ENTRY* prdt = &cmd->prdt_entry[0];\par
00392     uintptr_t buf_phys = MiTranslateVirtualToPhysical(buf);\par
00393 \par
00394     {\cf20 // Validate PRDT limits (AHCI PRDT dbc is max 4MB)}\par
00395     {\cf19 if} (bytes > 4 * 1024 * 1024) {\cf19 return} MT_INVALID_PARAM;\par
00396 \par
00397     prdt->dba = (uint32_t)(uintptr_t)buf_phys;\par
00398     prdt->dbau = (uint32_t)(((uintptr_t)buf_phys) >> 32);\par
00399     prdt->dbc = bytes - 1; {\cf20 // Zero-based count (e.g., 512 bytes -> 511)}\par
00400     prdt->i = 1; {\cf20 // Interrupt on Completion}\par
00401 \par
00402     {\cf20 // 8. Memory Fences & Cache Flushing}\par
00403     {\cf20 // Ensure the Table and Buffer are in RAM before the HBA fetches them}\par
00404     cache_flush_invalidate_range(ctx->clb, 1024);\par
00405     cache_flush_invalidate_range(cmd, 256);\par
00406     cache_flush_invalidate_range(buf, bytes); {\cf20 // Flush the receiving buffer to be safe (invalidate)}\par
00407     __asm__ {\cf17 volatile}({\cf22 "sfence; mfence"} ::: {\cf22 "memory"});\par
00408 \par
00409     {\cf20 // 9. Start Command}\par
00410     p->ci = (1u << slot);\par
00411 \par
00412     {\cf20 // 10. Wait for Completion}\par
00413     spin = 0;\par
00414     {\cf19 while} (p->ci & (1u << slot)) \{\par
00415         {\cf19 if} (++spin >= TIMEOUT) {\cf19 break};\par
00416     \}\par
00417 \par
00418     {\cf20 // 11. Error Checking}\par
00419     {\cf19 if} ((spin >= TIMEOUT) || (p->tfd & ((1 << 7) | (1 << 0)))) \{\par
00420 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00421         {\cf20 // gop_printf(COLOR_RED, "AHCI Err: TFD: %x, SERR: %x\\n", p->tfd, p->serr);}\par
00422 {\cf21 #endif}\par
00423         {\cf19 return} MT_AHCI_READ_FAILURE;\par
00424     \}\par
00425 \par
00426     {\cf20 // 12. Check Result}\par
00427     {\cf20 // Invalidate header cache so CPU reads the updated prdbc from RAM}\par
00428     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00429     cache_flush_invalidate_range(hdr, {\cf17 sizeof}(HBA_CMD_HEADER));\par
00430     __asm__ {\cf17 volatile}({\cf22 "mfence"} ::: {\cf22 "memory"});\par
00431 \par
00432     {\cf19 if} (hdr->prdbc != bytes) \{\par
00433 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00434         {\cf20 // gop_printf(COLOR_RED, "AHCI Partial Read: Req %u, Got %u\\n", bytes, hdr->prdbc);}\par
00435 {\cf21 #endif}\par
00436         {\cf20 // Even if mismatched, return success if data was moved? }\par
00437         {\cf20 // Usually strictly strictly enforce equality.}\par
00438         {\cf19 return} MT_AHCI_READ_FAILURE;\par
00439     \}\par
00440 \par
00441     {\cf20 // Invalidate data buffer cache so CPU reads new data from RAM}\par
00442     cache_flush_invalidate_range(buf, bytes);\par
00443 \par
00444     {\cf20 // Ack interrupt}\par
00445     p->is = p->is;\par
00446 \par
00447     {\cf19 return} MT_SUCCESS;\par
00448 \}\par
00449 \par
00450 MTSTATUS ahci_write_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf17 const} {\cf18 void}* buf, {\cf18 size_t} bytes) \{\par
00451 \par
00452     {\cf20 // 1. Input Validation}\par
00453     {\cf19 if} (bytes == 0 || (bytes % 512 != 0)) {\cf19 return} MT_INVALID_PARAM;\par
00454     {\cf20 // 4MB Limit per PRDT entry check}\par
00455     {\cf19 if} (bytes > 4 * 1024 * 1024) {\cf19 return} MT_INVALID_PARAM;\par
00456 \par
00457     AHCI_PORT_CTX* ctx = (AHCI_PORT_CTX*)dev->dev_data;\par
00458     HBA_PORT* p = ctx->port;\par
00459 \par
00460     {\cf20 // 2. Clear Pending Interrupts}\par
00461     p->is = (uint32_t)-1;\par
00462 \par
00463     {\cf18 int} slot = find_free_slot(p->sact | p->ci);\par
00464     {\cf19 if} (slot < 0) {\cf19 return} MT_AHCI_GENERAL_FAILURE;\par
00465 \par
00466     {\cf20 // Calculate sector count dynamically}\par
00467     uint32_t sector_count = bytes / 512;\par
00468 \par
00469     {\cf20 /* Command table for this slot */}\par
00470     HBA_CMD_TBL* cmd = (HBA_CMD_TBL*)((uint8_t*)ctx->cmd_tbl + slot * 256);\par
00471     kmemset(cmd, 0, 256);\par
00472 \par
00473     {\cf20 /* Command header */}\par
00474     HBA_CMD_HEADER* hdr = (HBA_CMD_HEADER*)((uint8_t*)ctx->clb + slot * {\cf17 sizeof}(HBA_CMD_HEADER));\par
00475     hba_cmd_hdr_set_cfl(hdr, ({\cf17 sizeof}(FIS_REG_H2D) + 3) / 4);\par
00476     hba_cmd_hdr_set_w(hdr, 1);       {\cf20 /* write */}\par
00477     hdr->prdbc = 0;\par
00478     hba_cmd_hdr_set_prdtl(hdr, 1);\par
00479 \par
00480     {\cf20 /* Build CFIS */}\par
00481     FIS_REG_H2D* fis = (FIS_REG_H2D*)(&cmd->cfis);\par
00482     kmemset(fis, 0, {\cf17 sizeof}(*fis));\par
00483     fis->fis_type = FIS_TYPE_REG_H2D;\par
00484     fis->c = 1;\par
00485     fis->command = 0x35; {\cf20 /* WRITE DMA EXT */}\par
00486     fis->device = 1 << 6; {\cf20 // LBA mode}\par
00487 \par
00488     fis->lba0 = (uint8_t)(lba & 0xFF);\par
00489     fis->lba1 = (uint8_t)((lba >> 8) & 0xFF);\par
00490     fis->lba2 = (uint8_t)((lba >> 16) & 0xFF);\par
00491     fis->lba3 = (uint8_t)((lba >> 24) & 0xFF);\par
00492     fis->lba4 = 0;\par
00493     fis->lba5 = 0;\par
00494 \par
00495     {\cf20 // >>> FIXED: Dynamic Sector Count <<<}\par
00496     fis->countl = (uint8_t)(sector_count & 0xFF);\par
00497     fis->counth = (uint8_t)((sector_count >> 8) & 0xFF);\par
00498 \par
00499     {\cf20 /* PRDT */}\par
00500     HBA_PRDT_ENTRY* prdt = &cmd->prdt_entry[0];\par
00501     {\cf20 // translation DOES NOT write to the buffer, only makes translations.}\par
00502     uintptr_t buf_phys = MiTranslateVirtualToPhysical(({\cf18 void}*)buf);\par
00503 \par
00504 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00505     {\cf20 // gop_printf(COLOR_BLUE, "AHCI WRITE: phys: %p | virt: %p | bytes: %u\\n", buf_phys, buf, bytes);}\par
00506 {\cf21 #endif}\par
00507 \par
00508     prdt->dba = (uint32_t)(uintptr_t)buf_phys;\par
00509     prdt->dbau = (uint32_t)(((uintptr_t)buf_phys) >> 32);\par
00510     prdt->dbc = bytes - 1; {\cf20 // Set byte count (length - 1)}\par
00511     prdt->i = 1;           {\cf20 // Interrupt on completion}\par
00512 \par
00513     {\cf20 // >>> CRITICAL: Cache Flushing for Writes <<<}\par
00514     {\cf20 // For writes, we must ensure the data in the CPU cache is written back to RAM}\par
00515     {\cf20 // before the DMA controller reads it.}\par
00516     cache_flush_invalidate_range(({\cf18 void}*)buf, bytes); {\cf20 // Flush entire buffer, not just 512}\par
00517 \par
00518     {\cf20 // Flush metadata}\par
00519     cache_flush_invalidate_range(ctx->clb, 1024);\par
00520     cache_flush_invalidate_range(cmd, 256);\par
00521 \par
00522     __asm__ {\cf17 volatile}({\cf22 "sfence; mfence"} ::: {\cf22 "memory"});\par
00523 \par
00524     {\cf20 /* Issue */}\par
00525     p->ci = (1u << slot);\par
00526 \par
00527     {\cf20 /* Wait */}\par
00528     uint32_t spin = 0;\par
00529     {\cf17 const} uint32_t TIMEOUT = 100000000;\par
00530     {\cf19 while} (p->ci & (1u << slot)) \{\par
00531         {\cf19 if} (++spin >= TIMEOUT) {\cf19 break};\par
00532     \}\par
00533 \par
00534     {\cf19 if} (spin >= TIMEOUT) \{\par
00535 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00536         {\cf20 // gop_printf(COLOR_RED, "AHCI TIMEOUT ahci_write_sector\\n");}\par
00537 {\cf21 #endif}\par
00538         {\cf19 return} MT_AHCI_TIMEOUT;\par
00539     \}\par
00540 \par
00541     {\cf20 // IMPORTANT: Check for errors from the device}\par
00542     {\cf19 if} (p->tfd & ((1 << 7) | (1 << 0))) \{\par
00543 {\cf21 #ifdef AHCI_DEBUG_PRINT}\par
00544         {\cf20 // gop_printf(0xFFFF0000, "AHCI write error!\\n");}\par
00545         {\cf20 // gop_printf(0xFFFFFF00, "Port TFD: %p, SERR: %p\\n", (void*)(uintptr_t)p->tfd, (void*)(uintptr_t)p->serr);}\par
00546 {\cf21 #endif}\par
00547         {\cf19 return} MT_AHCI_WRITE_FAILURE;\par
00548     \}\par
00549 \par
00550     {\cf20 // Optional: Verify prdbc matches bytes written}\par
00551     {\cf20 // __asm__ volatile("mfence" ::: "memory");}\par
00552     {\cf20 // cache_flush_invalidate_range(hdr, sizeof(HBA_CMD_HEADER));}\par
00553     {\cf20 // if (hdr->prdbc != bytes) \{ /* Warning */ \}}\par
00554 \par
00555     {\cf20 // clear int}\par
00556     p->is = p->is;\par
00557 \par
00558     {\cf19 return} MT_SUCCESS;\par
00559 \}\par
00560 \par
00561 \par
00562 BLOCK_DEVICE* ahci_get_block_device({\cf18 int} index) \{\par
00563     {\cf19 return} get_block_device(index);\par
00564 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include "../blk/block.h"}\par
{\f2 #include "../../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_MEM}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_PORT}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _FIS_REG_H2D}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_PRDT_ENTRY}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_CMD_TBL}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HBA_CMD_HEADER}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_MAX_PORTS}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_CFL_MASK}\~ 0x0000001Fu\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_A_BIT}\~ (1u << 5)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_W_BIT}\~ (1u << 6)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_P_BIT}\~ (1u << 7)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_CMD_HDR_PRDTL_MASK}\~ 0xFFFF0000u\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_DEV_BSY}\~ 0x80\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_DEV_DRQ}\~ 0x08\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_DEV_ERR}\~ 0x01\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_CMD_READ_DMA_EX}\~ 0x25\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATA_CMD_WRITE_DMA_EX}\~ 0x35\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_NULL}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_SATA}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_SEMB}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_PM}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AHCI_DEV_SATAPI}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PORT_IPM_ACTIVE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PORT_DET_PRESENT}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_ST}\~ 0x0001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_FRE}\~ 0x0010\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_FR}\~ 0x4000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxCMD_CR}\~ 0x8000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b HBA_PxIS_TFES}\~ (1 << 30)       /* TFES - Task File Error Status */\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FIS_TYPE} {\b FIS_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef volatile struct {\b _HBA_MEM} {\b HBA_MEM}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef volatile struct {\b _HBA_PORT} {\b HBA_PORT}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _FIS_REG_H2D} {\b FIS_REG_H2D}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HBA_PRDT_ENTRY} {\b HBA_PRDT_ENTRY}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HBA_CMD_TBL} {\b HBA_CMD_TBL}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HBA_CMD_HEADER} {\b HBA_CMD_HEADER}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FIS_TYPE} \{ {\b FIS_TYPE_REG_H2D} = 0x27
, {\b FIS_TYPE_REG_D2H} = 0x34
, {\b FIS_TYPE_DMA_ACT} = 0x39
, {\b FIS_TYPE_DMA_SETUP} = 0x41
, {\b FIS_TYPE_DATA} = 0x46
, {\b FIS_TYPE_BIST} = 0x58
, {\b FIS_TYPE_PIO_SETUP} = 0x5F
, {\b FIS_TYPE_DEV_BITS} = 0xA1
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_read_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, void *buf, size_t bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single bytes-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ahci_write_sector} ({\b BLOCK_DEVICE} *dev, uint32_t lba, const void *buf, size_t bytes)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single bytes-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b ahci_get_block_device} (int index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AHCI_DEV_NULL\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_NULL\~ 0}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_PM\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_PM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_PM\~ 3}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_SATA\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_SATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_SATA\~ 1}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_SATAPI\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_SATAPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_SATAPI\~ 4}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_DEV_SEMB\:ahci.h}
{\xe \v ahci.h\:AHCI_DEV_SEMB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_DEV_SEMB\~ 2}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b ahci.h}.}\par
}
{\xe \v AHCI_MAX_PORTS\:ahci.h}
{\xe \v ahci.h\:AHCI_MAX_PORTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AHCI_MAX_PORTS\~ 32}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b ahci.h}.}\par
}
{\xe \v ATA_CMD_READ_DMA_EX\:ahci.h}
{\xe \v ahci.h\:ATA_CMD_READ_DMA_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_CMD_READ_DMA_EX\~ 0x25}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b ahci.h}.}\par
}
{\xe \v ATA_CMD_WRITE_DMA_EX\:ahci.h}
{\xe \v ahci.h\:ATA_CMD_WRITE_DMA_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_CMD_WRITE_DMA_EX\~ 0x35}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b ahci.h}.}\par
}
{\xe \v ATA_DEV_BSY\:ahci.h}
{\xe \v ahci.h\:ATA_DEV_BSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_DEV_BSY\~ 0x80}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b ahci.h}.}\par
}
{\xe \v ATA_DEV_DRQ\:ahci.h}
{\xe \v ahci.h\:ATA_DEV_DRQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_DEV_DRQ\~ 0x08}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b ahci.h}.}\par
}
{\xe \v ATA_DEV_ERR\:ahci.h}
{\xe \v ahci.h\:ATA_DEV_ERR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATA_DEV_ERR\~ 0x01}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_A_BIT\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_A_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_A_BIT\~ (1u << 5)}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_CFL_MASK\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_CFL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_CFL_MASK\~ 0x0000001Fu}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_P_BIT\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_P_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_P_BIT\~ (1u << 7)}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_PRDTL_MASK\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_PRDTL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_PRDTL_MASK\~ 0xFFFF0000u}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 150} of file {\b ahci.h}.}\par
}
{\xe \v HBA_CMD_HDR_W_BIT\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HDR_W_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_CMD_HDR_W_BIT\~ (1u << 6)}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PORT_DET_PRESENT\:ahci.h}
{\xe \v ahci.h\:HBA_PORT_DET_PRESENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PORT_DET_PRESENT\~ 3}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PORT_IPM_ACTIVE\:ahci.h}
{\xe \v ahci.h\:HBA_PORT_IPM_ACTIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PORT_IPM_ACTIVE\~ 1}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_CR\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_CR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_CR\~ 0x8000}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_FR\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_FR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_FR\~ 0x4000}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_FRE\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_FRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_FRE\~ 0x0010}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxCMD_ST\:ahci.h}
{\xe \v ahci.h\:HBA_PxCMD_ST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxCMD_ST\~ 0x0001}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b ahci.h}.}\par
}
{\xe \v HBA_PxIS_TFES\:ahci.h}
{\xe \v ahci.h\:HBA_PxIS_TFES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define HBA_PxIS_TFES\~ (1 << 30)       /* TFES - Task File Error Status */}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FIS_REG_H2D\:ahci.h}
{\xe \v ahci.h\:FIS_REG_H2D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _FIS_REG_H2D} {\b FIS_REG_H2D}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Register - Host to Device FIS (FIS_TYPE_REG_H2D) }}\par
}
{\xe \v FIS_TYPE\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FIS_TYPE} {\b FIS_TYPE}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HBA_CMD_HEADER\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HBA_CMD_HEADER} {\b HBA_CMD_HEADER}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
HBA Command Header (defines an AHCI Command) }}\par
}
{\xe \v HBA_CMD_TBL\:ahci.h}
{\xe \v ahci.h\:HBA_CMD_TBL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HBA_CMD_TBL} {\b HBA_CMD_TBL}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Command Table: one per slot. }}\par
}
{\xe \v HBA_MEM\:ahci.h}
{\xe \v ahci.h\:HBA_MEM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef volatile struct {\b _HBA_MEM} {\b HBA_MEM}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
AHCI Register layout (Global HBA Registers) }}\par
}
{\xe \v HBA_PORT\:ahci.h}
{\xe \v ahci.h\:HBA_PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef volatile struct {\b _HBA_PORT} {\b HBA_PORT}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Per port registers at {\b HBA_MEM} + 0x100 + (port * 0x80) }}\par
}
{\xe \v HBA_PRDT_ENTRY\:ahci.h}
{\xe \v ahci.h\:HBA_PRDT_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HBA_PRDT_ENTRY} {\b HBA_PRDT_ENTRY}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Physical Region Descriptor Table Entry. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FIS_TYPE\:ahci.h}
{\xe \v ahci.h\:_FIS_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FIS_TYPE}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v FIS_TYPE_REG_H2D\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_REG_H2D}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_REG_H2D{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_REG_D2H\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_REG_D2H}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_REG_D2H{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DMA_ACT\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DMA_ACT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DMA_ACT{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DMA_SETUP\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DMA_SETUP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DMA_SETUP{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DATA\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DATA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DATA{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_BIST\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_BIST}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_BIST{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_PIO_SETUP\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_PIO_SETUP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_PIO_SETUP{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
\cell }{\cell }{\row }
{\xe \v FIS_TYPE_DEV_BITS\:ahci.h}
{\xe \v ahci.h\:FIS_TYPE_DEV_BITS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FIS_TYPE_DEV_BITS{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 19} of file {\b ahci.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ahci_get_block_device\:ahci.h}
{\xe \v ahci.h\:ahci_get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * ahci_get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Retrieve a pointer to the AHCI driver's {\b BLOCK_DEVICE} instance. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index of the {\b BLOCK_DEVICE} registration.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A {\b BLOCK_DEVICE} struct pointer.\par
}}}{
Definition at line {\b 562} of file {\b ahci.c}.}\par
}
{\xe \v ahci_init\:ahci.h}
{\xe \v ahci.h\:ahci_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_init (void )}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define AHCI_DEBUG_PRINT }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the AHCI Driver.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based if it initialized correctly or not. (if failure = bugcheck)\par
}}}{
Definition at line {\b 292} of file {\b ahci.c}.}\par
}
{\xe \v ahci_read_sector\:ahci.h}
{\xe \v ahci.h\:ahci_read_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_read_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, void * buf, size_t bytes)}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Read a single bytes-byte sector from the given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{Return buffer to place the data read.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession | buf pointer changes.\par
}}}{
Definition at line {\b 330} of file {\b ahci.c}.}\par
}
{\xe \v ahci_write_sector\:ahci.h}
{\xe \v ahci.h\:ahci_write_sector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ahci_write_sector ({\b BLOCK_DEVICE} * dev, uint32_t lba, const void * buf, size_t bytes)}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single bytes-byte sector to given LBA on a specific {\b BLOCK_DEVICE}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dev} \cell }{Takes the {\b BLOCK_DEVICE} device pointer (on register_block_device)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lba} \cell }{LBA to read from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{The buffer to write to the specified LBA.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or False based on succession\par
}}}{
Definition at line {\b 450} of file {\b ahci.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ahci.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/ahci/ahci.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      AHCI Driver types and functions.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_DRIVER_AHCI_H}\par
00008 {\cf21 #define X86_DRIVER_AHCI_H}\par
00009 \par
00010 {\cf21 #include <stdint.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stddef.h>}\par
00013 {\cf21 #include "../blk/block.h"}\par
00014 {\cf21 #include "../../mtstatus.h"}\par
00015 \par
00016 {\cf20 // Maximum number of AHCI Ports supported}\par
00017 {\cf21 #define AHCI_MAX_PORTS 32}\par
00018 \par
00019 {\cf17 typedef} {\cf17 enum} _FIS_TYPE \{\par
00020     FIS_TYPE_REG_H2D = 0x27,    {\cf20 // Register FIS - host to device}\par
00021     FIS_TYPE_REG_D2H = 0x34,    {\cf20 // Register FIS - device to host}\par
00022     FIS_TYPE_DMA_ACT = 0x39,    {\cf20 // DMA activate FIS - device to host}\par
00023     FIS_TYPE_DMA_SETUP = 0x41,    {\cf20 // DMA setup FIS - bidirectional}\par
00024     FIS_TYPE_DATA = 0x46,  {\cf20 // Data FIS - bidirectional}\par
00025     FIS_TYPE_BIST = 0x58,  {\cf20 // BIST activate FIS - bidirectional}\par
00026     FIS_TYPE_PIO_SETUP = 0x5F,    {\cf20 // PIO setup FIS - device to host}\par
00027     FIS_TYPE_DEV_BITS = 0xA1,  {\cf20 // Set device bits FIS - device to host}\par
00028 \} FIS_TYPE;\par
00029 \par
00031 {\cf17 typedef} {\cf17 volatile} {\cf17 struct }_HBA_MEM \{\par
00032     uint32_t cap;        {\cf20 // 0x00: Host Capabilities.}\par
00033     uint32_t ghc;        {\cf20 // 0x04: Global host control}\par
00034     uint32_t is;      {\cf20 // 0x08: Interrupt Status}\par
00035     uint32_t pi;      {\cf20 // 0x0C: Ports implemented.}\par
00036     uint32_t vs;      {\cf20 // 0x10: Version}\par
00037     uint32_t ccc_ctl;    {\cf20 // 0x14: Command completion coalescing control}\par
00038     uint32_t ccc_pts;    {\cf20 // 0x18: Command completion coalescing ports.}\par
00039     uint32_t em_loc;  {\cf20 // 0x1C: Enclosure management location}\par
00040     uint32_t em_ctl;  {\cf20 // 0x20: Enclosure management control}\par
00041     uint32_t cap2;      {\cf20 // 0x24: Host capabilities EXTENDED.}\par
00042     uint32_t bohc;      {\cf20 // 0x28: BIOS/OS handoff control and status.}\par
00043     uint8_t  rsv[0xA0 - 0x2C];\par
00044     uint8_t  venor[0x100 - 0xA0];\par
00046 \} HBA_MEM;\par
00047 \par
00049 {\cf17 typedef} {\cf17 volatile} {\cf17 struct }_HBA_PORT \{\par
00050     uint32_t clb;        {\cf20 // 0x00: Command list base address lower 32 bits.}\par
00051     uint32_t clbu;      {\cf20 // 0x04: Command list base address higher 32 bits.}\par
00052     uint32_t fb;      {\cf20 // 0x08: FIS Base address lower 32 bits.}\par
00053     uint32_t fbu;        {\cf20 // 0x0C: FIS Base address higher 32 bits.}\par
00054     uint32_t is;      {\cf20 // 0x10: Interrupt Status.}\par
00055     uint32_t ie;      {\cf20 // 0x14: Interrupt Enable.}\par
00056     uint32_t cmd;        {\cf20 // 0x18: Command And Status.}\par
00057     uint32_t rsv0;      {\cf20 // 0x1C: RESERVED.}\par
00058     uint32_t tfd;        {\cf20 // 0x20: Task File Data.}\par
00059     uint32_t sig;        {\cf20 // 0x24: Signature.}\par
00060     uint32_t ssts;      {\cf20 // 0x28: Serial ATA Status.}\par
00061     uint32_t sctl;      {\cf20 // 0x2C: Serial ATA Control.}\par
00062     uint32_t serr;      {\cf20 // 0x30: Serial ATA Error.}\par
00063     uint32_t sact;      {\cf20 // 0x34: Serial ATA Active.}\par
00064     uint32_t ci;      {\cf20 // 0x38: Command Issue.}\par
00065     uint32_t sntf;      {\cf20 // 0x3C: Serial ATA notification.}\par
00066     uint32_t fbs;        {\cf20 // 0x40: FIS-Based switch control.}\par
00067     uint32_t rsv1[11];  {\cf20 // 0x44 - 0x6F: RESERVED.}\par
00068     uint32_t vendor[4]; {\cf20 // 0x70: Vendor Specific.}\par
00069 \} HBA_PORT;\par
00070 \par
00071 {\cf20 // Data structures for FIS and Command Tables }\par
00072 \par
00074 {\cf21 #pragma pack(push, 1)}\par
00075 {\cf17 typedef} {\cf17 struct }_FIS_REG_H2D \{\par
00076     uint8_t fis_type;\par
00077     uint8_t pmport : 4;\par
00078     uint8_t rsv0 : 3;\par
00079     uint8_t c : 1;       {\cf20 // 1: command, 0: control}\par
00080     uint8_t command;     {\cf20 // ATA command}\par
00081     uint8_t featurel;    {\cf20 // feature low}\par
00082     uint8_t lba0;        {\cf20 // LBA low byte}\par
00083     uint8_t lba1;        {\cf20 // LBA mid byte}\par
00084     uint8_t lba2;        {\cf20 // LBA high byte}\par
00085     uint8_t device;\par
00086     uint8_t lba3;        {\cf20 // LBA byte 3}\par
00087     uint8_t lba4;        {\cf20 // LBA byte 4}\par
00088     uint8_t lba5;        {\cf20 // LBA byte 5}\par
00089     uint8_t featureh;    {\cf20 // feature high}\par
00090     uint8_t countl;      {\cf20 // sector count low}\par
00091     uint8_t counth;      {\cf20 // sector count high}\par
00092     uint8_t icc;         {\cf20 // ISO command completion}\par
00093     uint8_t control;\par
00094     uint8_t rsv1[4];\par
00095 \} FIS_REG_H2D;\par
00096 \par
00098 {\cf17 typedef} {\cf17 struct }_HBA_PRDT_ENTRY \{\par
00099     uint32_t dba;        {\cf20 // Data base address}\par
00100     uint32_t dbau;      {\cf20 // Data base address upper 32 bits}\par
00101     uint32_t rsv0;      {\cf20 // Reserved}\par
00102 \par
00103     {\cf20 // DW3}\par
00104     uint32_t dbc : 22;       {\cf20 // Byte count, 4M max}\par
00105     uint32_t rsv1 : 9;      {\cf20 // Reserved}\par
00106     uint32_t i : 1;        {\cf20 // Interrupt on completionn}\par
00107 \} HBA_PRDT_ENTRY;\par
00108 \par
00110 {\cf17 typedef} {\cf17 struct }_HBA_CMD_TBL \{\par
00111     {\cf20 // 0x00}\par
00112     uint8_t  cfis[64];  {\cf20 // Command FIS}\par
00113 \par
00114     {\cf20 // 0x40}\par
00115     uint8_t  acmd[16];  {\cf20 // ATAPI command, 12 or 16 bytes}\par
00116 \par
00117     {\cf20 // 0x50}\par
00118     uint8_t  rsv[48];    {\cf20 // Reserved}\par
00119 \par
00120     {\cf20 // 0x80}\par
00121     HBA_PRDT_ENTRY    prdt_entry[1];    {\cf20 // Physical region descriptor table entries, 0 ~ 65535}\par
00122 \} HBA_CMD_TBL;\par
00123 {\cf21 #pragma pack(pop)}\par
00124 \par
00128 {\cf17 typedef} {\cf17 struct }_HBA_CMD_HEADER \{\par
00129     {\cf17 volatile} uint32_t dw0;     {\cf20 // control flags + PRDTL}\par
00130     {\cf17 volatile} uint32_t prdbc;   {\cf20 // physical region descriptor byte count transferred}\par
00131     uint32_t ctba;             {\cf20 // command table base address (lower)}\par
00132     uint32_t ctbau;            {\cf20 // command table base address upper}\par
00133     uint32_t rsv1[4];          {\cf20 // reserved}\par
00134 \} HBA_CMD_HEADER;\par
00135 {\cf21 #ifndef _MSC_VER}\par
00136 {\cf17 _Static_assert}({\cf17 sizeof}(HBA_CMD_HEADER) == 32, {\cf22 "SIZEOF HBA_CMD_HEADER ISNT 32 BYTES! -- Misalignment check."});\par
00137 {\cf17 _Static_assert}({\cf17 sizeof}(HBA_PRDT_ENTRY) == 16, {\cf22 "PRDT must be 16 bytes"});\par
00138 {\cf17 _Static_assert}(offsetof(HBA_CMD_TBL, prdt_entry) == 0x80, {\cf22 "PRDT must start at offset 0x80 in CMD_TBL"});\par
00139 {\cf17 _Static_assert}({\cf17 sizeof}(((HBA_CMD_TBL*)0)->cfis) == 64, {\cf22 "cfis must be 64 bytes"});\par
00140 {\cf21 #endif}\par
00141 \par
00142 {\cf20 // AHCI Driver API}\par
00143 \par
00144 {\cf20 // Bit masks / helpers for dw0}\par
00145 {\cf20 // Bit masks / helpers for dw0}\par
00146 {\cf21 #define HBA_CMD_HDR_CFL_MASK    0x0000001Fu}\par
00147 {\cf21 #define HBA_CMD_HDR_A_BIT       (1u << 5)}\par
00148 {\cf21 #define HBA_CMD_HDR_W_BIT       (1u << 6)}\par
00149 {\cf21 #define HBA_CMD_HDR_P_BIT       (1u << 7)}\par
00150 {\cf21 #define HBA_CMD_HDR_PRDTL_MASK  0xFFFF0000u}\par
00151 {\cf21 #define ATA_DEV_BSY 0x80 }{\cf20 // Busy}\par
00152 {\cf21 #define ATA_DEV_DRQ 0x08 }{\cf20 // Data Request}\par
00153 {\cf21 #define ATA_DEV_ERR 0x01 }{\cf20 // Error}\par
00154 \par
00155 {\cf21 #define ATA_CMD_READ_DMA_EX     0x25}\par
00156 {\cf21 #define ATA_CMD_WRITE_DMA_EX    0x35}\par
00157 \par
00158 {\cf21 #define AHCI_DEV_NULL 0}\par
00159 {\cf21 #define AHCI_DEV_SATA 1}\par
00160 {\cf21 #define AHCI_DEV_SEMB 2}\par
00161 {\cf21 #define AHCI_DEV_PM   3}\par
00162 {\cf21 #define AHCI_DEV_SATAPI 4}\par
00163 \par
00164 {\cf21 #define HBA_PORT_IPM_ACTIVE 1}\par
00165 {\cf21 #define HBA_PORT_DET_PRESENT 3}\par
00166 \par
00167 {\cf21 #define HBA_PxCMD_ST    0x0001}\par
00168 {\cf21 #define HBA_PxCMD_FRE   0x0010}\par
00169 {\cf21 #define HBA_PxCMD_FR    0x4000}\par
00170 {\cf21 #define HBA_PxCMD_CR    0x8000}\par
00171 {\cf21 #define HBA_PxIS_TFES   (1 << 30)       }{\cf20 /* TFES - Task File Error Status */}{\cf21 }\par
00172 \par
00173 {\cf17 static} {\cf17 inline} {\cf18 void} hba_cmd_hdr_set_cfl(HBA_CMD_HEADER* h, uint32_t cfl) \{\par
00174     h->dw0 = (h->dw0 & ~HBA_CMD_HDR_CFL_MASK) | ((cfl)&HBA_CMD_HDR_CFL_MASK);\par
00175 \}\par
00176 {\cf17 static} {\cf17 inline} uint32_t hba_cmd_hdr_get_cfl(HBA_CMD_HEADER* h) \{\par
00177     {\cf19 return} h->dw0 & HBA_CMD_HDR_CFL_MASK;\par
00178 \}\par
00179 \par
00180 {\cf17 static} {\cf17 inline} {\cf18 void} hba_cmd_hdr_set_w(HBA_CMD_HEADER* h, {\cf18 int} w) \{\par
00181     {\cf19 if} (w) h->dw0 |= HBA_CMD_HDR_W_BIT;\par
00182     {\cf19 else} h->dw0 &= ~HBA_CMD_HDR_W_BIT;\par
00183 \}\par
00184 {\cf17 static} {\cf17 inline} {\cf18 int} hba_cmd_hdr_get_w(HBA_CMD_HEADER* h) \{\par
00185     {\cf19 return} (h->dw0 & HBA_CMD_HDR_W_BIT) ? 1 : 0;\par
00186 \}\par
00187 \par
00188 {\cf17 static} {\cf17 inline} {\cf18 void} hba_cmd_hdr_set_prdtl(HBA_CMD_HEADER* h, uint32_t prdtl) \{\par
00189     h->dw0 = (h->dw0 & ~HBA_CMD_HDR_PRDTL_MASK) | (((prdtl) & 0xFFFFu) << 16);\par
00190 \}\par
00191 {\cf17 static} {\cf17 inline} uint32_t hba_cmd_hdr_get_prdtl(HBA_CMD_HEADER* h) \{\par
00192     {\cf19 return} (h->dw0 >> 16) & 0xFFFFu;\par
00193 \}\par
00194 \par
00195 {\cf20 /* Uncomment to see AHCI Debug Prints */}\par
00197 \par
00198 \par
00203 MTSTATUS ahci_init({\cf18 void});\par
00204 \par
00212 MTSTATUS ahci_read_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf18 void}* buf, {\cf18 size_t} bytes);\par
00213 \par
00221 MTSTATUS ahci_write_sector(BLOCK_DEVICE* dev, uint32_t lba, {\cf17 const} {\cf18 void}* buf, {\cf18 size_t} bytes);\par
00222 \par
00228 BLOCK_DEVICE* ahci_get_block_device({\cf18 int} index);\par
00229 \par
00230 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "block.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/mg.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_BLK_DEV}\~ 32\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b register_block_device} ({\b BLOCK_DEVICE} *dev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b get_block_device} (int index)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAX_BLK_DEV\:block.c}
{\xe \v block.c\:MAX_BLK_DEV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_BLK_DEV\~ 32}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b block.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_block_device\:block.c}
{\xe \v block.c\:get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b block.c}.}\par
}
{\xe \v register_block_device\:block.c}
{\xe \v block.c\:register_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void register_block_device ({\b BLOCK_DEVICE} * dev)}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b block.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v gop_local\:block.c}
{\xe \v block.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
block.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.c}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Block Device Abstraction Driver Implementation}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "block.h"}\par
00008 {\cf21 #include "../../includes/me.h"}\par
00009 {\cf21 #include "../../includes/mg.h"}\par
00010 \par
00011 {\cf21 #define MAX_BLK_DEV 32 }{\cf20 // AHCI is a maximum of 32, anymore than that and we bugcheck.}\par
00012 \par
00013 {\cf17 static} BLOCK_DEVICE* devices[MAX_BLK_DEV];\par
00014 {\cf17 extern} GOP_PARAMS gop_local;\par
00015 {\cf17 static} {\cf18 int} device_count = 0;\par
00016 \par
00017 {\cf18 void} register_block_device(BLOCK_DEVICE* dev) \{\par
00018     {\cf20 // print the index we\'92re about to use and the device pointer}\par
00019 {\cf21 #ifdef DEBUG}\par
00020     gop_printf(0xFFFFFF00, {\cf22 "Registering block #%d at %llx\\n"}, device_count, ({\cf18 unsigned} {\cf18 long} {\cf18 long})(uintptr_t)dev);\par
00021 {\cf21 #endif}\par
00022     {\cf19 if} (device_count < MAX_BLK_DEV) \{\par
00023         devices[device_count++] = dev;\par
00024     \}\par
00025     {\cf19 else} \{\par
00026         {\cf20 // too many!}\par
00027         MeBugCheck(BLOCK_DEVICE_LIMIT_REACHED);\par
00028     \}\par
00029 \}\par
00030 \par
00031 \par
00032 BLOCK_DEVICE* get_block_device({\cf18 int} index) \{\par
00033     {\cf19 if} (index < 0 || index >= device_count) \{ {\cf19 return} NULL; \}\par
00034     {\cf19 return} devices[index];\par
00035 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BLOCK_DEVICE}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BLOCK_DEVICE} {\b BLOCK_DEVICE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b register_block_device} ({\b BLOCK_DEVICE} *dev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BLOCK_DEVICE} * {\b get_block_device} (int index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BLOCK_DEVICE\:block.h}
{\xe \v block.h\:BLOCK_DEVICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BLOCK_DEVICE} {\b BLOCK_DEVICE}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v get_block_device\:block.h}
{\xe \v block.h\:get_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BLOCK_DEVICE} * get_block_device (int index)}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b block.c}.}\par
}
{\xe \v register_block_device\:block.h}
{\xe \v block.h\:register_block_device}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void register_block_device ({\b BLOCK_DEVICE} * dev)}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b block.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
block.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/blk/block.h}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // kernel/drivers/blk/block.h}\par
00002 {\cf21 #ifndef X86_KERNEL_DRIVER_BLK_BLOCK_H}\par
00003 {\cf21 #define X86_KERNEL_DRIVER_BLK_BLOCK_H}\par
00004 \par
00005 {\cf20 // Standard headers, required.}\par
00006 {\cf21 #include <stddef.h>}\par
00007 {\cf21 #include <stdbool.h>}\par
00008 {\cf21 #include <stdint.h>}\par
00009 {\cf21 #include "../../mtstatus.h"}\par
00010 \par
00011 {\cf17 typedef} {\cf17 struct }_BLOCK_DEVICE \{\par
00012     MTSTATUS(*read_sector)({\cf17 struct }_BLOCK_DEVICE* dev,\par
00013         uint32_t lba,\par
00014         {\cf18 void}* buf,\par
00015         {\cf18 size_t} bytes);\par
00016     MTSTATUS(*write_sector)({\cf17 struct }_BLOCK_DEVICE* dev,\par
00017         uint32_t lba,\par
00018         {\cf17 const} {\cf18 void}* buf,\par
00019         {\cf18 size_t} bytes);\par
00020     {\cf18 void}* dev_data;\par
00021 \} BLOCK_DEVICE;\par
00022 \par
00023 {\cf20 /* Register a block device so `get_block_device()` can find it */}\par
00024 {\cf18 void} register_block_device(BLOCK_DEVICE* dev);\par
00025 \par
00026 {\cf20 /* Get the "n" registered device (0, 1, ...), or NULL if out of range. */}\par
00027 BLOCK_DEVICE* get_block_device({\cf18 int} index);\par
00028 \par
00029 {\cf21 #endif }{\cf20 // X86_KERNEL_DRIVER_BLK_BLOCK_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const uint8_t {\b font8x16} [256][16]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v font8x16\:font8x16.h}
{\xe \v font8x16.h\:font8x16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const uint8_t font8x16[256][16]{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
font8x16.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/font8x16.h}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef FONT8X16_H}\par
00002 {\cf21 #define FONT8X16_H}\par
00003 {\cf21 #ifdef FONT8X16_IMPLEMENTATION}\par
00004 {\cf17 static} {\cf17 const} uint8_t font8x16[256][16] = \{\par
00005   \{ 0x00, 0x00, 0x00, 0x7E, 0x81, 0x99, 0xA5, 0xA1, 0xA5, 0x99, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+00}\par
00006   \{ 0x00, 0x00, 0x00, 0x7E, 0x81, 0xB9, 0xA5, 0xB9, 0xA9, 0xA5, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+01}\par
00007   \{ 0x00, 0x00, 0x3C, 0x43, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0xC2, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+02}\par
00008   \{ 0x00, 0x00, 0xFB, 0x55, 0x55, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+03}\par
00009   \{ 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+04}\par
00010   \{ 0x00, 0x00, 0x00, 0x00, 0x44, 0x38, 0x44, 0x44, 0x44, 0x38, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+05}\par
00011   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+06}\par
00012   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+07}\par
00013   \{ 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+08}\par
00014   \{ 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+09}\par
00015   \{ 0x00, 0x38, 0x04, 0x18, 0x04, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0A}\par
00016   \{ 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0B}\par
00017   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+0C}\par
00018   \{ 0x00, 0x10, 0x30, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0D}\par
00019   \{ 0x00, 0xE0, 0x10, 0x60, 0x12, 0xE4, 0x08, 0x10, 0x22, 0x46, 0x8A, 0x1E, 0x02, 0x02, 0x00, 0x00 \}, {\cf20 // U+0E}\par
00020   \{ 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+0F}\par
00021   \{ 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+10}\par
00022   \{ 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+11}\par
00023   \{ 0x32, 0x4C, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+12}\par
00024   \{ 0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+13}\par
00025   \{ 0x00, 0x00, 0x7E, 0x92, 0x92, 0x92, 0x92, 0x72, 0x12, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+14}\par
00026   \{ 0x00, 0x38, 0x44, 0x40, 0x30, 0x48, 0x44, 0x44, 0x24, 0x18, 0x04, 0x44, 0x38, 0x00, 0x00, 0x00 \}, {\cf20 // U+15}\par
00027   \{ 0x10, 0x08, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+16}\par
00028   \{ 0x18, 0x24, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+17}\par
00029   \{ 0x00, 0x00, 0x10, 0x38, 0x54, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+18}\par
00030   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x54, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+19}\par
00031   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0xFE, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1A}\par
00032   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0xFE, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1B}\par
00033   \{ 0x24, 0x24, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1C}\par
00034   \{ 0x20, 0x10, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1D}\par
00035   \{ 0x08, 0x10, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1E}\par
00036   \{ 0x18, 0x24, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+1F}\par
00037   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+20}\par
00038   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+21}\par
00039   \{ 0x00, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+22}\par
00040   \{ 0x00, 0x00, 0x24, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+23}\par
00041   \{ 0x00, 0x10, 0x10, 0x7C, 0x92, 0x90, 0x90, 0x7C, 0x12, 0x12, 0x92, 0x7C, 0x10, 0x10, 0x00, 0x00 \}, {\cf20 // U+24}\par
00042   \{ 0x00, 0x00, 0x64, 0x94, 0x68, 0x08, 0x10, 0x10, 0x20, 0x2C, 0x52, 0x4C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+25}\par
00043   \{ 0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0x30, 0x4A, 0x44, 0x44, 0x44, 0x3A, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+26}\par
00044   \{ 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+27}\par
00045   \{ 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+28}\par
00046   \{ 0x00, 0x00, 0x20, 0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+29}\par
00047   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x18, 0x7E, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2A}\par
00048   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2B}\par
00049   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00 \}, {\cf20 // U+2C}\par
00050   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2D}\par
00051   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2E}\par
00052   \{ 0x00, 0x00, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+2F}\par
00053   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+30}\par
00054   \{ 0x00, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+31}\par
00055   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+32}\par
00056   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x1C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+33}\par
00057   \{ 0x00, 0x00, 0x02, 0x06, 0x0A, 0x12, 0x22, 0x42, 0x7E, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+34}\par
00058   \{ 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+35}\par
00059   \{ 0x00, 0x00, 0x1C, 0x20, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+36}\par
00060   \{ 0x00, 0x00, 0x7E, 0x02, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+37}\par
00061   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+38}\par
00062   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+39}\par
00063   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3A}\par
00064   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00 \}, {\cf20 // U+3B}\par
00065   \{ 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3C}\par
00066   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3D}\par
00067   \{ 0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3E}\par
00068   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x04, 0x08, 0x08, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+3F}\par
00069   \{ 0x00, 0x00, 0x7C, 0x82, 0x9E, 0xA2, 0xA2, 0xA2, 0xA6, 0x9A, 0x80, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+40}\par
00070   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+41}\par
00071   \{ 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+42}\par
00072   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+43}\par
00073   \{ 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+44}\par
00074   \{ 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+45}\par
00075   \{ 0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+46}\par
00076   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+47}\par
00077   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+48}\par
00078   \{ 0x00, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+49}\par
00079   \{ 0x00, 0x00, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4A}\par
00080   \{ 0x00, 0x00, 0x42, 0x44, 0x48, 0x50, 0x60, 0x60, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4B}\par
00081   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4C}\par
00082   \{ 0x00, 0x00, 0x82, 0xC6, 0xAA, 0x92, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4D}\par
00083   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4E}\par
00084   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+4F}\par
00085   \{ 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+50}\par
00086   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x4A, 0x3C, 0x02, 0x00, 0x00, 0x00 \}, {\cf20 // U+51}\par
00087   \{ 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+52}\par
00088   \{ 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+53}\par
00089   \{ 0x00, 0x00, 0xFE, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+54}\par
00090   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+55}\par
00091   \{ 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+56}\par
00092   \{ 0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x82, 0x92, 0x92, 0xAA, 0xC6, 0x82, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+57}\par
00093   \{ 0x00, 0x00, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x24, 0x24, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+58}\par
00094   \{ 0x00, 0x00, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+59}\par
00095   \{ 0x00, 0x00, 0x7E, 0x02, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5A}\par
00096   \{ 0x00, 0x00, 0x38, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5B}\par
00097   \{ 0x00, 0x00, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5C}\par
00098   \{ 0x00, 0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5D}\par
00099   \{ 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+5E}\par
00100   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00 \}, {\cf20 // U+5F}\par
00101   \{ 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+60}\par
00102   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+61}\par
00103   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+62}\par
00104   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+63}\par
00105   \{ 0x00, 0x00, 0x02, 0x02, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+64}\par
00106   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+65}\par
00107   \{ 0x00, 0x00, 0x0E, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+66}\par
00108   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+67}\par
00109   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+68}\par
00110   \{ 0x00, 0x00, 0x10, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+69}\par
00111   \{ 0x00, 0x00, 0x04, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00 \}, {\cf20 // U+6A}\par
00112   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6B}\par
00113   \{ 0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6C}\par
00114   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6D}\par
00115   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6E}\par
00116   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+6F}\par
00117   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00 \}, {\cf20 // U+70}\par
00118   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x02, 0x00 \}, {\cf20 // U+71}\par
00119   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+72}\par
00120   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+73}\par
00121   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+74}\par
00122   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+75}\par
00123   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+76}\par
00124   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x82, 0x92, 0x92, 0x92, 0x92, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+77}\par
00125   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x24, 0x18, 0x24, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+78}\par
00126   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+79}\par
00127   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7A}\par
00128   \{ 0x00, 0x00, 0x0C, 0x10, 0x10, 0x10, 0x20, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7B}\par
00129   \{ 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7C}\par
00130   \{ 0x00, 0x00, 0x30, 0x08, 0x08, 0x08, 0x04, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7D}\par
00131   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x92, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7E}\par
00132   \{ 0x44, 0x44, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+7F}\par
00133   \{ 0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+80}\par
00134   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+81}\par
00135   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+82}\par
00136   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+83}\par
00137   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+84}\par
00138   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+85}\par
00139   \{ 0x00, 0x00, 0x18, 0x24, 0x18, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+86}\par
00140   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+87}\par
00141   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+88}\par
00142   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+89}\par
00143   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8A}\par
00144   \{ 0x00, 0x00, 0x48, 0x48, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8B}\par
00145   \{ 0x00, 0x00, 0x30, 0x48, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8C}\par
00146   \{ 0x00, 0x00, 0x20, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8D}\par
00147   \{ 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8E}\par
00148   \{ 0x18, 0x24, 0x18, 0x3C, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+8F}\par
00149   \{ 0x08, 0x10, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+90}\par
00150   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0x12, 0x72, 0x9E, 0x90, 0x90, 0x6C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+91}\par
00151   \{ 0x00, 0x00, 0x7E, 0x90, 0x90, 0x90, 0xFC, 0x90, 0x90, 0x90, 0x90, 0x9E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+92}\par
00152   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+93}\par
00153   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+94}\par
00154   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+95}\par
00155   \{ 0x00, 0x00, 0x18, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+96}\par
00156   \{ 0x00, 0x00, 0x10, 0x08, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+97}\par
00157   \{ 0x00, 0x00, 0x24, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+98}\par
00158   \{ 0x24, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+99}\par
00159   \{ 0x24, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9A}\par
00160   \{ 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x92, 0x90, 0x90, 0x90, 0x92, 0x7C, 0x10, 0x10, 0x00, 0x00 \}, {\cf20 // U+9B}\par
00161   \{ 0x00, 0x00, 0x18, 0x24, 0x20, 0x20, 0x78, 0x20, 0x20, 0x20, 0x22, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9C}\par
00162   \{ 0x00, 0x00, 0x82, 0x82, 0x44, 0x28, 0x10, 0x7C, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9D}\par
00163   \{ 0x00, 0x00, 0xF0, 0x88, 0x88, 0x88, 0xF4, 0x84, 0x8E, 0x84, 0x84, 0x82, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+9E}\par
00164   \{ 0x00, 0x00, 0x0C, 0x12, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x90, 0x60, 0x00 \}, {\cf20 // U+9F}\par
00165   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A0}\par
00166   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A1}\par
00167   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A2}\par
00168   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A3}\par
00169   \{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A4}\par
00170   \{ 0x32, 0x4C, 0x00, 0x42, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A5}\par
00171   \{ 0x00, 0x38, 0x04, 0x3C, 0x44, 0x3C, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A6}\par
00172   \{ 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A7}\par
00173   \{ 0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x20, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A8}\par
00174   \{ 0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0xF2, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+A9}\par
00175   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AA}\par
00176   \{ 0x00, 0x20, 0x60, 0x20, 0x22, 0x24, 0x08, 0x10, 0x20, 0x4C, 0x92, 0x04, 0x08, 0x1E, 0x00, 0x00 \}, {\cf20 // U+AB}\par
00177   \{ 0x00, 0x20, 0x60, 0x20, 0x22, 0x24, 0x08, 0x10, 0x22, 0x46, 0x8A, 0x1E, 0x02, 0x02, 0x00, 0x00 \}, {\cf20 // U+AC}\par
00178   \{ 0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AD}\par
00179   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x24, 0x48, 0x90, 0x48, 0x24, 0x12, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AE}\par
00180   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x48, 0x24, 0x12, 0x24, 0x48, 0x90, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+AF}\par
00181   \{ 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22 \}, {\cf20 // U+B0}\par
00182   \{ 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55 \}, {\cf20 // U+B1}\par
00183   \{ 0x10, 0x08, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B2}\par
00184   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+B3}\par
00185   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+B4}\par
00186   \{ 0x08, 0x10, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B5}\par
00187   \{ 0x18, 0x24, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B6}\par
00188   \{ 0x32, 0x4C, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B7}\par
00189   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B8}\par
00190   \{ 0x10, 0x08, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+B9}\par
00191   \{ 0x08, 0x10, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BA}\par
00192   \{ 0x18, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BB}\par
00193   \{ 0x08, 0x10, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BC}\par
00194   \{ 0x00, 0x00, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BD}\par
00195   \{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+BE}\par
00196   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+BF}\par
00197   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C0}\par
00198   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C1}\par
00199   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+C2}\par
00200   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+C3}\par
00201   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C4}\par
00202   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+C5}\par
00203   \{ 0x00, 0x00, 0x28, 0x10, 0x28, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C6}\par
00204   \{ 0x00, 0x00, 0x32, 0x4C, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C7}\par
00205   \{ 0x00, 0x00, 0x00, 0x00, 0x02, 0x3C, 0x46, 0x4A, 0x52, 0x62, 0x42, 0xBC, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+C8}\par
00206   \{ 0x00, 0x00, 0x08, 0x10, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+C9}\par
00207   \{ 0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00 \}, {\cf20 // U+CA}\par
00208   \{ 0x24, 0x18, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CB}\par
00209   \{ 0x00, 0x00, 0x24, 0x18, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00 \}, {\cf20 // U+CC}\par
00210   \{ 0x10, 0x10, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CD}\par
00211   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CE}\par
00212   \{ 0x00, 0x00, 0x7E, 0x90, 0x90, 0x90, 0x9C, 0x90, 0x90, 0x90, 0x90, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+CF}\par
00213   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x92, 0x92, 0x9E, 0x90, 0x90, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D0}\par
00214   \{ 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x42, 0x3C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+D1}\par
00215   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x10, 0x10, 0x20, 0x00 \}, {\cf20 // U+D2}\par
00216   \{ 0x24, 0x18, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D3}\par
00217   \{ 0x00, 0x00, 0x24, 0x18, 0x00, 0x3E, 0x40, 0x40, 0x3C, 0x02, 0x02, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D4}\par
00218   \{ 0x44, 0x44, 0x00, 0x82, 0x82, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D5}\par
00219   \{ 0x24, 0x18, 0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D6}\par
00220   \{ 0x00, 0x00, 0x24, 0x18, 0x00, 0x7E, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D7}\par
00221   \{ 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D8}\par
00222   \{ 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+D9}\par
00223   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10 \}, {\cf20 // U+DA}\par
00224   \{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF \}, {\cf20 // U+DB}\par
00225   \{ 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DC}\par
00226   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DD}\par
00227   \{ 0x00, 0x08, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DE}\par
00228   \{ 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+DF}\par
00229   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00 \}, {\cf20 // U+E0}\par
00230   \{ 0x00, 0x00, 0x38, 0x44, 0x44, 0x48, 0x7C, 0x42, 0x42, 0x42, 0x62, 0x5C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E1}\par
00231   \{ 0x00, 0x12, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E2}\par
00232   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E3}\par
00233   \{ 0x00, 0x12, 0x12, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E4}\par
00234   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x24, 0x48, 0x00, 0x00, 0x00 \}, {\cf20 // U+E5}\par
00235   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x46, 0x7A, 0x40, 0x40, 0x40, 0x00 \}, {\cf20 // U+E6}\par
00236   \{ 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E7}\par
00237   \{ 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E8}\par
00238   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x92, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+E9}\par
00239   \{ 0x00, 0x00, 0x48, 0xA8, 0x50, 0x10, 0x20, 0x20, 0x40, 0x54, 0xAA, 0x94, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EA}\par
00240   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EB}\par
00241   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x92, 0x92, 0x92, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EC}\par
00242   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+ED}\par
00243   \{ 0x00, 0x00, 0x00, 0x1C, 0x22, 0x40, 0xF8, 0x40, 0xF8, 0x40, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EE}\par
00244   \{ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+EF}\par
00245   \{ 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F0}\par
00246   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F1}\par
00247   \{ 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F2}\par
00248   \{ 0x00, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F3}\par
00249   \{ 0x00, 0x00, 0x00, 0x00, 0x02, 0x7E, 0x08, 0x10, 0x7E, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F4}\par
00250   \{ 0x00, 0x00, 0x96, 0x96, 0x96, 0xD0, 0xF0, 0xF0, 0xB0, 0x96, 0x90, 0x96, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F5}\par
00251   \{ 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x7C, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F6}\par
00252   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x4C, 0x00, 0x32, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F7}\par
00253   \{ 0x00, 0x18, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F8}\par
00254   \{ 0x00, 0x00, 0xFE, 0x10, 0x10, 0x1C, 0x70, 0x1C, 0x70, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+F9}\par
00255   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FA}\par
00256   \{ 0x00, 0x00, 0x00, 0x1E, 0x20, 0x40, 0x40, 0x7E, 0x40, 0x40, 0x20, 0x1E, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FB}\par
00257   \{ 0x00, 0x00, 0x38, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FC}\par
00258   \{ 0x00, 0x18, 0x24, 0x04, 0x08, 0x10, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FD}\par
00259   \{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FE}\par
00260   \{ 0x00, 0x00, 0x02, 0x04, 0x7C, 0x8A, 0x92, 0x92, 0xA2, 0x7C, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00 \}, {\cf20 // U+FF}\par
00261 \};\par
00262 {\cf21 #else}\par
00263 {\cf17 extern} {\cf17 const} uint8_t font8x16[256][16];\par
00264 {\cf21 #endif}\par
00265 \par
00266 {\cf21 #endif }{\cf20 // FONT8X16_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gop.h"}\par
{\f2 #include "font8x16.h"}\par
{\f2 #include "../../intrinsics/atomic.h"}\par
{\f2 #include "../../includes/me.h"}\par
{\f2 #include "../../includes/macros.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FONT8X16_IMPLEMENTATION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FONT_SCALE}\~ 1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_clear_screen} ({\b GOP_PARAMS} *gop, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrncat} (char *dest, const char *src, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b kstrlen} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrcpy} (char *dst, const char *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrncpy} (char *dst, const char *src, size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrtok_r} (char *str, const char *delim, char **save_ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ksnprintf} (char *buf, size_t bufsize, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kstrcmp} (const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kstrncmp} (const char *s1, const char *s2, size_t length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_printf} (uint32_t color, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MgAcquireExclusiveGopOwnerShip} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MgReleaseExclusiveGopOwnerShip} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile void * {\b ExclusiveOwnerShip} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b gop_bold_enabled} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_x} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cursor_y} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SPINLOCK} {\b gop_lock} = \{ 0 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v FONT8X16_IMPLEMENTATION\:gop.c}
{\xe \v gop.c\:FONT8X16_IMPLEMENTATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FONT8X16_IMPLEMENTATION}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b gop.c}.}\par
}
{\xe \v FONT_SCALE\:gop.c}
{\xe \v gop.c\:FONT_SCALE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FONT_SCALE\~ 1}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b gop.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v gop_clear_screen\:gop.c}
{\xe \v gop.c\:gop_clear_screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_clear_screen ({\b GOP_PARAMS} * gop, uint32_t color)}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b gop.c}.}\par
}
{\xe \v gop_printf\:gop.c}
{\xe \v gop.c\:gop_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_printf (uint32_t color, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 694} of file {\b gop.c}.}\par
}
{\xe \v ksnprintf\:gop.c}
{\xe \v gop.c\:ksnprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ksnprintf (char * buf, size_t bufsize, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 546} of file {\b gop.c}.}\par
}
{\xe \v kstrcmp\:gop.c}
{\xe \v gop.c\:kstrcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kstrcmp (const char * s1, const char * s2)}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 657} of file {\b gop.c}.}\par
}
{\xe \v kstrcpy\:gop.c}
{\xe \v gop.c\:kstrcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrcpy (char * dst, const char * src)}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b gop.c}.}\par
}
{\xe \v kstrlen\:gop.c}
{\xe \v gop.c\:kstrlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t kstrlen (const char * str)}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b gop.c}.}\par
}
{\xe \v kstrncat\:gop.c}
{\xe \v gop.c\:kstrncat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrncat (char * dest, const char * src, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dest} \cell }{Destination buffer (must be mutable)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i src} \cell }{String to append\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{Total size of the destination buffer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to dest\par
}}}{
Definition at line {\b 365} of file {\b gop.c}.}\par
}
{\xe \v kstrncmp\:gop.c}
{\xe \v gop.c\:kstrncmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kstrncmp (const char * s1, const char * s2, size_t length)}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 666} of file {\b gop.c}.}\par
}
{\xe \v kstrncpy\:gop.c}
{\xe \v gop.c\:kstrncpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrncpy (char * dst, const char * src, size_t n)}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b gop.c}.}\par
}
{\xe \v kstrtok_r\:gop.c}
{\xe \v gop.c\:kstrtok_r}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrtok_r (char * str, const char * delim, char ** save_ptr)}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b gop.c}.}\par
}
{\xe \v MgAcquireExclusiveGopOwnerShip\:gop.c}
{\xe \v gop.c\:MgAcquireExclusiveGopOwnerShip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MgAcquireExclusiveGopOwnerShip (void )}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 794} of file {\b gop.c}.}\par
}
{\xe \v MgReleaseExclusiveGopOwnerShip\:gop.c}
{\xe \v gop.c\:MgReleaseExclusiveGopOwnerShip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MgReleaseExclusiveGopOwnerShip (void )}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 806} of file {\b gop.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v cursor_x\:gop.c}
{\xe \v gop.c\:cursor_x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_x = 0}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b gop.c}.}\par
}
{\xe \v cursor_y\:gop.c}
{\xe \v gop.c\:cursor_y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cursor_y = 0}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b gop.c}.}\par
}
{\xe \v ExclusiveOwnerShip\:gop.c}
{\xe \v gop.c\:ExclusiveOwnerShip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* ExclusiveOwnerShip = NULL}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b gop.c}.}\par
}
{\xe \v gop_bold_enabled\:gop.c}
{\xe \v gop.c\:gop_bold_enabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool gop_bold_enabled = false}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b gop.c}.}\par
}
{\xe \v gop_local\:gop.c}
{\xe \v gop.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b gop.c}.}\par
}
{\xe \v gop_lock\:gop.c}
{\xe \v gop.c\:gop_lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SPINLOCK} gop_lock = \{ 0 \}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 675} of file {\b gop.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gop.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.c}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     GPLv3}\par
00004 {\cf20  * PURPOSE:     GOP Driver to draw onto screen Implementation (8\'D716 font)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "gop.h"}\par
00008 {\cf21 #define FONT8X16_IMPLEMENTATION}\par
00009 {\cf21 #include "font8x16.h"}\par
00010 {\cf21 #include "../../intrinsics/atomic.h"}\par
00011 {\cf21 #include "../../includes/me.h"}\par
00012 {\cf21 #include "../../includes/macros.h"}\par
00013 \par
00014  {\cf20 // integer font scale (1 = native 8\'D716, 2 = 16\'D732, etc)}\par
00015 {\cf21 #define FONT_SCALE 1}\par
00016 \par
00017 {\cf17 volatile} {\cf18 void}* ExclusiveOwnerShip = NULL;\par
00018 \par
00019 {\cf17 static} {\cf17 inline} {\cf18 bool} gop_params_valid({\cf17 const} GOP_PARAMS* gop) \{\par
00020     {\cf19 if} (!gop) {\cf19 return} {\cf17 false};\par
00021     {\cf19 if} (!gop->FrameBufferBase) {\cf19 return} {\cf17 false};\par
00022     {\cf19 if} (gop->Width == 0 || gop->Height == 0) {\cf19 return} {\cf17 false};\par
00023     {\cf19 if} (gop->PixelsPerScanLine == 0) {\cf19 return} {\cf17 false};\par
00024     {\cf19 return} {\cf17 true};\par
00025 \}\par
00026 \par
00027 {\cf17 static} {\cf17 inline} {\cf18 void} plot_pixel(GOP_PARAMS* gop, uint32_t x, uint32_t y, uint32_t color) \{\par
00028     {\cf19 if} (!gop_params_valid(gop)) {\cf19 return};\par
00029     {\cf19 if} (x >= gop->Width || y >= gop->Height) {\cf19 return}; {\cf20 // safeguard}\par
00030     uint32_t* fb = (uint32_t*)(uintptr_t)gop->FrameBufferBase;\par
00031     uint32_t  stride = gop->PixelsPerScanLine;\par
00032     fb[y * stride + x] = color;\par
00033 \}\par
00034 \par
00035 {\cf17 static} {\cf17 inline} uint32_t char_width({\cf18 void}) \{ {\cf19 return}  8 * FONT_SCALE; \}\par
00036 {\cf17 static} {\cf17 inline} uint32_t line_height({\cf18 void}) \{ {\cf19 return} 16 * FONT_SCALE; \}\par
00037 \par
00038 {\cf18 bool} gop_bold_enabled = {\cf17 false}; {\cf20 // default}\par
00039 uint32_t cursor_x = 0, cursor_y = 0;\par
00040 {\cf17 extern} GOP_PARAMS gop_local;\par
00041 \par
00042 {\cf17 static} {\cf18 void} draw_char(GOP_PARAMS* gop, {\cf18 char} c_, uint32_t x, uint32_t y, uint32_t color) \{\par
00043     uint8_t c = (uint8_t)c_;\par
00044     {\cf19 if} (c > 0x7F) {\cf19 return};\par
00045 \par
00046     {\cf17 const} uint8_t* bitmap = font8x16[c];\par
00047     {\cf19 for} ({\cf18 int} row = 0; row < 16; row++) \{\par
00048         uint8_t bits = bitmap[row];\par
00049         {\cf19 for} ({\cf18 int} col = 0; col < 8; col++) \{\par
00050             {\cf20 // PSF bitmaps are MSB-first}\par
00051             {\cf19 if} (!(bits & (1 << (7 - col))))\par
00052                 {\cf19 continue};\par
00053 \par
00054             {\cf20 // scale each pixel up to FONT_SCALE\'D7FONT_SCALE}\par
00055             {\cf19 for} ({\cf18 int} dy = 0; dy < FONT_SCALE; dy++) \{\par
00056                 uint32_t py = y + row * FONT_SCALE + dy;\par
00057                 {\cf19 if} (py >= gop->Height) {\cf19 continue};\par
00058                 {\cf19 for} ({\cf18 int} dx = 0; dx < FONT_SCALE; dx++) \{\par
00059                     uint32_t px = x + col * FONT_SCALE + dx;\par
00060                     {\cf19 if} (px < gop->Width) \{\par
00061                         {\cf19 if} (gop_bold_enabled) \{\par
00062                             {\cf20 // ensure we do not write out of bounds when bold is enabled}\par
00063                             {\cf19 if} (px < gop->Width && py < gop->Height) plot_pixel(gop, px, py, color);\par
00064                             {\cf19 if} ((px + 1) < gop->Width && py < gop->Height) plot_pixel(gop, px + 1, py, color);\par
00065                             {\cf19 if} (px < gop->Width && (py + 1) < gop->Height) plot_pixel(gop, px, py + 1, color);\par
00066                             {\cf19 if} ((px + 1) < gop->Width && (py + 1) < gop->Height) plot_pixel(gop, px + 1, py + 1, color);\par
00067                         \}\par
00068                         {\cf19 else} \{\par
00069                             plot_pixel(gop, px, py, color);\par
00070                         \}\par
00071                     \}\par
00072                 \}\par
00073             \}\par
00074         \}\par
00075     \}\par
00076 \}\par
00077 \par
00078 {\cf17 static} {\cf18 void} draw_string(GOP_PARAMS* gop, {\cf17 const} {\cf18 char}* s, uint32_t x, uint32_t y, uint32_t color) \{\par
00079     {\cf19 while} (*s) \{\par
00080         draw_char(gop, *s, x, y, color);\par
00081         x += char_width();\par
00082         s++;\par
00083     \}\par
00084 \}\par
00085 \par
00086 {\cf17 static} {\cf18 void} fb_memmove32(uint32_t* dest, uint32_t* src, {\cf18 size_t} count) \{\par
00087     {\cf19 if} (dest < src) \{\par
00088         {\cf20 // forward copy}\par
00089         {\cf19 for} ({\cf18 size_t} i = 0; i < count; i++) dest[i] = src[i];\par
00090     \}\par
00091     {\cf19 else} {\cf19 if} (dest > src) \{\par
00092         {\cf20 // backward copy}\par
00093         {\cf19 for} ({\cf18 size_t} i = count; i-- > 0; ) dest[i] = src[i];\par
00094     \}\par
00095 \}\par
00096 \par
00097 {\cf17 static} {\cf18 void} gop_scroll(GOP_PARAMS* gop) \{\par
00098     uint32_t* fb = (uint32_t*)(uintptr_t)gop->FrameBufferBase;\par
00099     uint32_t  stride = gop->PixelsPerScanLine;\par
00100     uint32_t  h = gop->Height;\par
00101     uint32_t  w = gop->Width;\par
00102     uint32_t  lines = line_height();\par
00103 \par
00104     {\cf20 // scroll up - removed kmemcpy as the gop is also used in the bugcheck, and kmemcpy has Max IRQL of DISPATCH_LEVEL, while a bugcheck is HIGH_LEVEL.}\par
00105     {\cf18 size_t} count = (h - lines) * ({\cf18 size_t})stride;\par
00106     fb_memmove32(&fb[0], &fb[lines * stride], count);\par
00107 \par
00108     {\cf20 // clear bottom}\par
00109     {\cf19 for} (uint32_t yy = h - lines; yy < h; yy++)\par
00110         {\cf19 for} (uint32_t xx = 0; xx < w; xx++)\par
00111             fb[yy * stride + xx] = 0;\par
00112 \par
00113     cursor_y = (cursor_y >= lines) ? (cursor_y - lines) : 0;\par
00114 \}\par
00115 \par
00116 {\cf17 static} {\cf18 void} gop_put_char(GOP_PARAMS* gop, {\cf18 char} c, uint32_t color) \{\par
00117     {\cf19 if} (!gop_params_valid(gop)) {\cf19 return}; {\cf20 // defensive}\par
00118     {\cf19 if} (c == {\cf23 '\\b'}) \{\par
00119         {\cf20 // move cursor back one character (and clear it)}\par
00120         {\cf19 if} (cursor_x >= char_width()) \{\par
00121             cursor_x -= char_width();\par
00122         \}\par
00123         {\cf19 else} \{\par
00124             {\cf20 // if at start of line, wrap to end of previous line}\par
00125             {\cf19 if} (cursor_y >= line_height()) \{\par
00126                 cursor_y -= line_height();\par
00127                 cursor_x = gop->Width - char_width();\par
00128             \}\par
00129         \}\par
00130         {\cf20 // clear the old glyph cell:}\par
00131         {\cf19 for} (uint32_t yy = cursor_y; yy < cursor_y + line_height(); yy++) \{\par
00132             {\cf19 for} (uint32_t xx = cursor_x; xx < cursor_x + char_width(); xx++) \{\par
00133                 plot_pixel(gop, xx, yy, color);\par
00134             \}\par
00135         \}\par
00136         {\cf19 return};\par
00137     \}\par
00138     {\cf19 if} (c == {\cf23 '\\n'}) \{\par
00139         cursor_x = 0;\par
00140         cursor_y += line_height();\par
00141         {\cf19 if} (cursor_y + line_height() > gop->Height) gop_scroll(gop);\par
00142         {\cf19 return};\par
00143     \}\par
00144     {\cf19 if} (c == {\cf23 '\\r'}) \{\par
00145         cursor_x = 0;\par
00146         {\cf19 return};\par
00147     \}\par
00148 \par
00149     draw_char(gop, c, cursor_x, cursor_y, color);\par
00150     cursor_x += char_width();\par
00151     {\cf19 if} (cursor_x + char_width() > gop->Width) \{\par
00152         cursor_x = 0;\par
00153         cursor_y += line_height();\par
00154         {\cf19 if} (cursor_y + line_height() > gop->Height) gop_scroll(gop);\par
00155     \}\par
00156 \}\par
00157 \par
00158 {\cf17 static} {\cf18 void} gop_puts(GOP_PARAMS* gop, {\cf17 const} {\cf18 char}* s, uint32_t color) \{\par
00159     {\cf19 while} (*s) \{\par
00160         gop_put_char(gop, *s++, color);\par
00161     \}\par
00162 \}\par
00163 \par
00164 {\cf17 static} {\cf18 void} sprint_dec({\cf18 char}* buf, int64_t v) \{\par
00165     {\cf18 char}* p = buf;\par
00166 \par
00167     {\cf19 if} (v == 0) \{\par
00168         *p++ = {\cf23 '0'};\par
00169         *p = 0;\par
00170         {\cf19 return};\par
00171     \}\par
00172 \par
00173     {\cf18 bool} neg = {\cf17 false};\par
00174     {\cf19 if} (v < 0) \{\par
00175         neg = {\cf17 true};\par
00176         v = -v;\par
00177     \}\par
00178 \par
00179     {\cf18 char} tmp[20];\par
00180     {\cf18 int} i = 0;\par
00181 \par
00182     {\cf19 while} (v > 0) \{\par
00183         tmp[i++] = {\cf23 '0'} + (v % 10);\par
00184         v /= 10;\par
00185     \}\par
00186 \par
00187     {\cf19 if} (neg) *p++ = {\cf23 '-'};\par
00188 \par
00189     {\cf19 while} (i--) \{\par
00190         *p++ = tmp[i];\par
00191     \}\par
00192 \par
00193     *p = 0;\par
00194 \}\par
00195 \par
00196 \par
00197 {\cf17 static} {\cf18 void} gop_print_dec(GOP_PARAMS* gop, int64_t val, uint32_t color) \{\par
00198     {\cf18 char} buf[20];\par
00199     sprint_dec(buf, val);\par
00200     gop_puts(gop, buf, color);\par
00201 \}\par
00202 \par
00203 {\cf17 static} {\cf18 void} buf_print_udec64({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, uint64_t value);\par
00204 {\cf17 static} {\cf18 void} gop_print_udec(GOP_PARAMS* gop, uint64_t val, uint32_t color) \{\par
00205     {\cf18 char} buf[32];\par
00206     {\cf18 size_t} written = 0;\par
00207     buf_print_udec64(buf, {\cf17 sizeof}(buf), &written, val);\par
00208     gop_puts(gop, buf, color);\par
00209 \}\par
00210 \par
00211 {\cf17 static} {\cf18 void} gop_print_hex(GOP_PARAMS* gop, uint64_t val, uint32_t color) \{\par
00212     {\cf18 char} buf[19] = {\cf22 "0x0000000000000000"}; {\cf20 // 64 bit addressing}\par
00213     {\cf19 for} ({\cf18 int} i = 0; i < 16; i++) \{\par
00214         {\cf18 unsigned} nib = (val >> ((15 - i) * 4)) & 0xF;\par
00215         buf[2 + i] = (nib < 10 ? {\cf23 '0'} + nib : {\cf23 'a'} + nib - 10);\par
00216     \}\par
00217     buf[18] = {\cf23 '\\0'}; {\cf20 // null terminator}\par
00218     gop_puts(gop, buf, color);\par
00219 \}\par
00220 \par
00221 {\cf17 static} {\cf18 void} gop_print_hex_minimal(GOP_PARAMS* gop, uint64_t val, uint32_t color) \{\par
00222     {\cf19 if} (val == 0) \{\par
00223         gop_puts(gop, {\cf22 "0x0"}, color);\par
00224         {\cf19 return};\par
00225     \}\par
00226 \par
00227     {\cf18 char} buf[19]; {\cf20 // "0x" + up to 16 hex digits + null}\par
00228     buf[0] = {\cf23 '0'};\par
00229     buf[1] = {\cf23 'x'};\par
00230 \par
00231     {\cf18 int} pos = 2;\par
00232     {\cf18 bool} started = {\cf17 false};\par
00233 \par
00234     {\cf19 for} ({\cf18 int} i = 0; i < 16; i++) \{\par
00235         {\cf18 unsigned} nib = (val >> ((15 - i) * 4)) & 0xF;\par
00236         {\cf19 if} (nib != 0 || started) \{\par
00237             started = {\cf17 true};\par
00238             buf[pos++] = (nib < 10 ? {\cf23 '0'} + nib : {\cf23 'a'} + nib - 10);\par
00239         \}\par
00240     \}\par
00241 \par
00242     buf[pos] = {\cf23 '\\0'};\par
00243     gop_puts(gop, buf, color);\par
00244 \}\par
00245 \par
00246 \par
00247 {\cf17 extern} GOP_PARAMS gop_local;\par
00248 \par
00249 {\cf18 void} gop_clear_screen(GOP_PARAMS* gop, uint32_t color) \{\par
00250     {\cf19 for} (uint32_t y = 0; y < gop->Height; y++)\par
00251         {\cf19 for} (uint32_t x = 0; x < gop->Width; x++)\par
00252             plot_pixel(gop, x, y, color);\par
00253 \}\par
00254 \par
00255 {\cf17 static} {\cf17 inline} {\cf18 void} buf_put_char({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, {\cf18 char} c) \{\par
00256     {\cf19 if} (size > 0 && *written + 1 < size) \{\par
00257         buf[*written] = c;\par
00258     \}\par
00259     (*written)++;\par
00260 \}\par
00261 \par
00262 {\cf17 static} {\cf18 void} buf_puts({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, {\cf17 const} {\cf18 char}* s) \{\par
00263     {\cf19 while} (*s) \{\par
00264         buf_put_char(buf, size, written, *s++);\par
00265     \}\par
00266 \}\par
00267 \par
00268 {\cf17 static} {\cf18 void} buf_print_dec64({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, int64_t value) \{\par
00269     {\cf18 char} tmp[32]; {\cf20 // enough for -2^63 and NUL}\par
00270     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00271     {\cf18 bool} neg = (value < 0);\par
00272     uint64_t u;\par
00273     *t = {\cf23 '\\0'};\par
00274 \par
00275     {\cf19 if} (!neg) \{\par
00276         u = (uint64_t)value;\par
00277     \}\par
00278     {\cf19 else} \{\par
00279         {\cf20 // compute absolute value safely (avoid UB on INT64_MIN)}\par
00280         u = (uint64_t)(-(value + 1)) + 1;\par
00281     \}\par
00282 \par
00283     {\cf19 if} (u == 0) \{\par
00284         *--t = {\cf23 '0'};\par
00285     \}\par
00286     {\cf19 else} \{\par
00287         {\cf19 while} (u) \{\par
00288             *--t = {\cf23 '0'} + (u % 10);\par
00289             u /= 10;\par
00290         \}\par
00291     \}\par
00292     {\cf19 if} (neg) *--t = {\cf23 '-'};\par
00293     buf_puts(buf, size, written, t);\par
00294 \}\par
00295 \par
00296 {\cf17 static} {\cf18 void} buf_print_udec64({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, uint64_t value) \{\par
00297     {\cf18 char} tmp[32];\par
00298     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00299     *t = {\cf23 '\\0'};\par
00300     {\cf19 if} (value == 0) \{\par
00301         *--t = {\cf23 '0'};\par
00302     \}\par
00303     {\cf19 else} \{\par
00304         {\cf19 while} (value) \{\par
00305             *--t = {\cf23 '0'} + (value % 10);\par
00306             value /= 10;\par
00307         \}\par
00308     \}\par
00309     buf_puts(buf, size, written, t);\par
00310 \}\par
00311 \par
00312 {\cf17 static} {\cf18 void} buf_print_hex64({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, uint64_t value) \{\par
00313     {\cf18 char} tmp[17];\par
00314     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00315     {\cf17 const} {\cf18 char}* hex = {\cf22 "0123456789abcdef"};\par
00316     *t = {\cf23 '\\0'};\par
00317     {\cf19 if} (value == 0) \{\par
00318         *--t = {\cf23 '0'};\par
00319     \}\par
00320     {\cf19 else} \{\par
00321         {\cf19 while} (value) \{\par
00322             *--t = hex[value & 0xF];\par
00323             value >>= 4;\par
00324         \}\par
00325     \}\par
00326     buf_puts(buf, size, written, t);\par
00327 \}\par
00328 \par
00329 {\cf17 static} {\cf18 void} buf_print_binary64({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, uint64_t value) \{\par
00330     {\cf18 char} tmp[65];\par
00331     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00332     *t = {\cf23 '\\0'};\par
00333     {\cf19 if} (value == 0) \{\par
00334         *--t = {\cf23 '0'};\par
00335     \}\par
00336     {\cf19 else} \{\par
00337         {\cf19 while} (value) \{\par
00338             *--t = (value & 1) ? {\cf23 '1'} : {\cf22 '0'};\par
00339             value >>= 1;\par
00340         \}\par
00341     \}\par
00342     buf_puts(buf, size, written, t);\par
00343 \}\par
00344 \par
00345 {\cf20 //-----------------------------------------------------------------------------}\par
00346 {\cf20 // Helper: simple strchr for delimiter scanning}\par
00347 {\cf20 //-----------------------------------------------------------------------------}\par
00348 {\cf17 static} {\cf18 char}* strchr({\cf17 const} {\cf18 char}* s, {\cf18 int} c) \{\par
00349     {\cf19 while} (*s) \{\par
00350         {\cf19 if} (*s == ({\cf18 char})c) \{\par
00351             {\cf19 return} ({\cf18 char}*)s;\par
00352         \}\par
00353         s++;\par
00354     \}\par
00355     {\cf19 return} NULL;\par
00356 \}\par
00357 \par
00365 {\cf18 char}* kstrncat({\cf18 char}* dest, {\cf17 const} {\cf18 char}* src, {\cf18 size_t} max_len) \{\par
00366     {\cf19 if} (!dest || !src || max_len == 0) {\cf19 return} dest;\par
00367 \par
00368     {\cf20 // Move dest_ptr to the end of the current string}\par
00369     {\cf18 size_t} dest_len = 0;\par
00370     {\cf19 while} (dest_len < max_len && dest[dest_len] != {\cf23 '\\0'}) \{\par
00371         dest_len++;\par
00372     \}\par
00373 \par
00374     {\cf19 if} (dest_len == max_len) \{\par
00375         {\cf20 // dest is already full, cannot append}\par
00376         {\cf19 return} dest;\par
00377     \}\par
00378 \par
00379     {\cf18 size_t} i = 0;\par
00380     {\cf19 while} (dest_len + i < max_len - 1 && src[i] != {\cf23 '\\0'}) \{\par
00381         dest[dest_len + i] = src[i];\par
00382         i++;\par
00383     \}\par
00384 \par
00385     {\cf20 // Null-terminate}\par
00386     dest[dest_len + i] = {\cf23 '\\0'};\par
00387     {\cf19 return} dest;\par
00388 \}\par
00389 \par
00390 {\cf20 //-----------------------------------------------------------------------------}\par
00391 {\cf20 // kstrlen: Return length of string (excluding null terminator).}\par
00392 {\cf20 //-----------------------------------------------------------------------------}\par
00393 {\cf18 size_t} kstrlen({\cf17 const} {\cf18 char}* str) \{\par
00394     {\cf18 size_t} len = 0;\par
00395     {\cf19 while} (str && str[len] != {\cf23 '\\0'}) \{\par
00396         len++;\par
00397     \}\par
00398     {\cf19 return} len;\par
00399 \}\par
00400 \par
00401 {\cf20 //-----------------------------------------------------------------------------}\par
00402 {\cf20 // kstrcpy: Copy string from src to dst. Assumes dst is large enough.}\par
00403 {\cf20 //-----------------------------------------------------------------------------}\par
00404 {\cf18 char}* kstrcpy({\cf18 char}* dst, {\cf17 const} {\cf18 char}* src) \{\par
00405     {\cf18 char}* ret = dst;\par
00406     {\cf19 while} ((*dst++ = *src++)) \{\par
00407         {\cf20 // copy until null terminator}\par
00408     \}\par
00409     {\cf19 return} ret;\par
00410 \}\par
00411 \par
00412 {\cf20 //-----------------------------------------------------------------------------}\par
00413 {\cf20 // kstrncpy: Copy up to n characters from src to dst.}\par
00414 {\cf20 //           Assumes dst is large enough.}\par
00415 {\cf20 //-----------------------------------------------------------------------------}\par
00416 {\cf18 char}* kstrncpy({\cf18 char}* dst, {\cf17 const} {\cf18 char}* src, {\cf18 size_t} n) \{\par
00417     {\cf19 if} (n == 0) {\cf19 return} dst;\par
00418     {\cf18 size_t} i = 0;\par
00419     {\cf19 while} (i + 1 < n && src[i]) \{\par
00420         dst[i] = src[i];\par
00421         i++;\par
00422     \}\par
00423     dst[i] = {\cf23 '\\0'};\par
00424     {\cf19 return} dst;\par
00425 \}\par
00426 \par
00427 {\cf17 static} {\cf17 inline} {\cf18 size_t} kstrlcpy({\cf18 char}* dst, {\cf17 const} {\cf18 char}* src, {\cf18 size_t} dst_size)\par
00428 \{\par
00429     {\cf17 const} {\cf18 char}* s = src;\par
00430     {\cf18 size_t} n = dst_size;\par
00431 \par
00432     {\cf19 if} (n != 0) \{\par
00433         {\cf19 while} (--n != 0) \{\par
00434             {\cf18 char} c = *s++;\par
00435             *dst++ = c;\par
00436             {\cf19 if} (c == {\cf23 '\\0'}) \{\par
00437                 {\cf19 return} ({\cf18 size_t})(s - src - 1);\par
00438             \}\par
00439         \}\par
00440         {\cf20 /* out of space; NUL-terminate if possible */}\par
00441         *dst = {\cf23 '\\0'};\par
00442     \}\par
00443 \par
00444     {\cf20 /* continue walking src to compute its length */}\par
00445     {\cf19 while} (*s++)\par
00446         ;\par
00447     {\cf19 return} ({\cf18 size_t})(s - src - 1);\par
00448 \}\par
00449 \par
00450 {\cf20 /* -------------------}\par
00451 {\cf20  * kstrspn - like strspn}\par
00452 {\cf20  * -------------------}\par
00453 {\cf20  * Returns length of the initial segment of s consisting only of characters in accept.}\par
00454 {\cf20  */}\par
00455 {\cf17 static} {\cf17 inline} {\cf18 size_t} kstrspn({\cf17 const} {\cf18 char}* s, {\cf17 const} {\cf18 char}* accept)\par
00456 \{\par
00457     {\cf17 const} {\cf18 char}* p = s;\par
00458     {\cf19 for} (; *p != {\cf23 '\\0'}; ++p) \{\par
00459         {\cf17 const} {\cf18 char}* a;\par
00460         {\cf19 for} (a = accept; *a != {\cf23 '\\0'} && *a != *p; ++a)\par
00461             ;\par
00462         {\cf19 if} (*a == {\cf23 '\\0'}) {\cf20 /* char p is NOT in accept */}\par
00463             {\cf19 break};\par
00464     \}\par
00465     {\cf19 return} ({\cf18 size_t})(p - s);\par
00466 \}\par
00467 \par
00468 {\cf20 /* --------------------}\par
00469 {\cf20  * kstrcspn - like strcspn}\par
00470 {\cf20  * --------------------}\par
00471 {\cf20  * Returns length of the initial segment of s consisting of characters NOT in reject.}\par
00472 {\cf20  */}\par
00473 {\cf17 static} {\cf17 inline} {\cf18 size_t} kstrcspn({\cf17 const} {\cf18 char}* s, {\cf17 const} {\cf18 char}* reject)\par
00474 \{\par
00475     {\cf17 const} {\cf18 char}* p = s;\par
00476     {\cf19 for} (; *p != {\cf23 '\\0'}; ++p) \{\par
00477         {\cf17 const} {\cf18 char}* r;\par
00478         {\cf19 for} (r = reject; *r != {\cf23 '\\0'} && *r != *p; ++r)\par
00479             ;\par
00480         {\cf19 if} (*r != {\cf23 '\\0'}) {\cf20 /* p matched a reject char */}\par
00481             {\cf19 break};\par
00482     \}\par
00483     {\cf19 return} ({\cf18 size_t})(p - s);\par
00484 \}\par
00485 \par
00486 {\cf20 //-----------------------------------------------------------------------------}\par
00487 {\cf20 // kstrtok: Tokenize string with delimiters.}\par
00488 {\cf20 // Works like strtok, but without libc.}\par
00489 {\cf20 // Keeps static state across calls unless str != NULL.}\par
00490 {\cf20 //-----------------------------------------------------------------------------}\par
00491 {\cf18 char}* kstrtok_r({\cf18 char}* str, {\cf17 const} {\cf18 char}* delim, {\cf18 char}** save_ptr)\par
00492 \{\par
00493     {\cf18 char}* token_start;\par
00494 \par
00495     {\cf19 if} (!save_ptr) {\cf19 return} NULL; {\cf20 /* defensive */}\par
00496 \par
00497     {\cf19 if} (str != NULL) \{\par
00498         token_start = str;\par
00499     \}\par
00500     {\cf19 else} {\cf19 if} (*save_ptr != NULL) \{\par
00501         token_start = *save_ptr;\par
00502     \}\par
00503     {\cf19 else} \{\par
00504         {\cf19 return} NULL;\par
00505     \}\par
00506 \par
00507     {\cf20 /* skip leading delimiters */}\par
00508     token_start += kstrspn(token_start, delim);\par
00509 \par
00510     {\cf19 if} (*token_start == {\cf23 '\\0'}) \{\par
00511         *save_ptr = NULL;\par
00512         {\cf19 return} NULL;\par
00513     \}\par
00514 \par
00515     {\cf18 char}* token_end = token_start + kstrcspn(token_start, delim);\par
00516 \par
00517     {\cf19 if} (*token_end == {\cf23 '\\0'}) \{\par
00518         *save_ptr = NULL;\par
00519     \}\par
00520     {\cf19 else} \{\par
00521         *token_end = {\cf23 '\\0'};\par
00522         *save_ptr = token_end + 1;\par
00523     \}\par
00524 \par
00525     {\cf19 return} token_start;\par
00526 \}\par
00527 \par
00528 {\cf17 static} {\cf18 void} buf_print_hex64_minimal({\cf18 char}* buf, {\cf18 size_t} size, {\cf18 size_t}* written, uint64_t value) \{\par
00529     {\cf18 char} tmp[17];\par
00530     {\cf18 char}* t = tmp + {\cf17 sizeof}(tmp) - 1;\par
00531     {\cf17 const} {\cf18 char}* hex = {\cf22 "0123456789abcdef"};\par
00532     *t = {\cf23 '\\0'};\par
00533     {\cf19 if} (value == 0) \{\par
00534         *--t = {\cf23 '0'};\par
00535     \}\par
00536     {\cf19 else} \{\par
00537         {\cf19 while} (value) \{\par
00538             *--t = hex[value & 0xF];\par
00539             value >>= 4;\par
00540         \}\par
00541     \}\par
00542     buf_puts(buf, size, written, {\cf22 "0x"});\par
00543     buf_puts(buf, size, written, t);\par
00544 \}\par
00545 \par
00546 {\cf18 int} ksnprintf({\cf18 char}* buf, {\cf18 size_t} bufsize, {\cf17 const} {\cf18 char}* fmt, ...) \{\par
00547     {\cf18 size_t} written = 0;\par
00548     va_list ap;\par
00549     va_start(ap, fmt);\par
00550 \par
00551     {\cf19 for} ({\cf17 const} {\cf18 char}* p = fmt; *p; p++) \{\par
00552         {\cf19 if} (*p == {\cf23 '%'} && p[1]) \{\par
00553             p++;\par
00554             {\cf20 // support optional length modifiers: 'l' and 'll'}\par
00555             {\cf18 int} len = 0;\par
00556             {\cf19 while} (*p == {\cf23 'l'}) \{\par
00557                 len++;\par
00558                 p++;\par
00559                 {\cf19 if} (len >= 2) {\cf19 break};\par
00560             \}\par
00561             {\cf18 char} spec = *p;\par
00562             {\cf19 switch} (spec) \{\par
00563             {\cf19 case} {\cf23 'd'}:\par
00564                 {\cf19 if} (len >= 2) \{\par
00565                     buf_print_dec64(buf, bufsize, &written, va_arg(ap, {\cf18 long} {\cf18 long}));\par
00566                 \}\par
00567                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00568                     buf_print_dec64(buf, bufsize, &written, va_arg(ap, {\cf18 long}));\par
00569                 \}\par
00570                 {\cf19 else} \{\par
00571                     buf_print_dec64(buf, bufsize, &written, (int64_t)va_arg(ap, {\cf18 int}));\par
00572                 \}\par
00573                 {\cf19 break};\par
00574             {\cf19 case} {\cf23 'u'}:\par
00575                 {\cf19 if} (len >= 2) \{\par
00576                     buf_print_udec64(buf, bufsize, &written, va_arg(ap, {\cf18 unsigned} {\cf18 long} {\cf18 long}));\par
00577                 \}\par
00578                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00579                     buf_print_udec64(buf, bufsize, &written, va_arg(ap, {\cf18 unsigned} {\cf18 long}));\par
00580                 \}\par
00581                 {\cf19 else} \{\par
00582                     buf_print_udec64(buf, bufsize, &written, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 int}));\par
00583                 \}\par
00584                 {\cf19 break};\par
00585             {\cf19 case} {\cf23 'x'}:\par
00586                 {\cf19 if} (len >= 2) \{\par
00587                     buf_print_hex64(buf, bufsize, &written, va_arg(ap, {\cf18 unsigned} {\cf18 long} {\cf18 long}));\par
00588                 \}\par
00589                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00590                     buf_print_hex64(buf, bufsize, &written, va_arg(ap, {\cf18 unsigned} {\cf18 long}));\par
00591                 \}\par
00592                 {\cf19 else} \{\par
00593                     buf_print_hex64(buf, bufsize, &written, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 int}));\par
00594                 \}\par
00595                 {\cf19 break};\par
00596             {\cf19 case} {\cf23 'p'}:\par
00597                 buf_puts(buf, bufsize, &written, {\cf22 "0x"});\par
00598                 buf_print_hex64(buf, bufsize, &written, (uint64_t)(uintptr_t)va_arg(ap, {\cf18 void}*));\par
00599                 {\cf19 break};\par
00600             {\cf19 case} {\cf23 'c'}:\par
00601                 buf_put_char(buf, bufsize, &written, ({\cf18 char})va_arg(ap, {\cf18 int})); {\cf20 /* chars promoted to int */}\par
00602                 {\cf19 break};\par
00603             {\cf19 case} {\cf23 'b'}:\par
00604                 {\cf20 // 'b' - binary, treat as 64-bit if ll, otherwise adapt}\par
00605                 {\cf19 if} (len >= 2) \{\par
00606                     buf_print_binary64(buf, bufsize, &written, va_arg(ap, {\cf18 unsigned} {\cf18 long} {\cf18 long}));\par
00607                 \}\par
00608                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00609                     buf_print_binary64(buf, bufsize, &written, va_arg(ap, {\cf18 unsigned} {\cf18 long}));\par
00610                 \}\par
00611                 {\cf19 else} \{\par
00612                     buf_print_binary64(buf, bufsize, &written, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 int}));\par
00613                 \}\par
00614                 {\cf19 break};\par
00615             {\cf19 case} {\cf23 's'}: \{\par
00616                 {\cf17 const} {\cf18 char}* s = va_arg(ap, {\cf17 const} {\cf18 char}*);\par
00617                 buf_puts(buf, bufsize, &written, s ? s : {\cf22 "(null)"});\par
00618                 {\cf19 break};\par
00619             \}\par
00620             {\cf19 case} {\cf23 '%'}:\par
00621                 buf_put_char(buf, bufsize, &written, {\cf23 '%'});\par
00622                 {\cf19 break};\par
00623             {\cf19 default}:\par
00624                 buf_put_char(buf, bufsize, &written, {\cf23 '%'});\par
00625                 buf_put_char(buf, bufsize, &written, spec);\par
00626             \}\par
00627         \}\par
00628         {\cf19 else} \{\par
00629             buf_put_char(buf, bufsize, &written, *p);\par
00630         \}\par
00631     \}\par
00632 \par
00633     va_end(ap);\par
00634     {\cf19 if} (bufsize > 0) \{\par
00635         buf[written < bufsize ? written : bufsize - 1] = {\cf23 '\\0'};\par
00636     \}\par
00637 \par
00638     {\cf19 return} ({\cf18 int})written;\par
00639 \}\par
00640 \par
00641 {\cf17 static} {\cf17 inline} {\cf18 bool} interrupts_enabled({\cf18 void}) \{\par
00642     {\cf18 unsigned} {\cf18 long} flags;\par
00643     __asm__ __volatile__({\cf22 "pushfq; popq %0"} : {\cf22 "=r"}(flags));\par
00644     {\cf19 return} (flags & (1UL << 9)) != 0; {\cf20 // IF is bit 9}\par
00645 \}\par
00646 \par
00647 {\cf17 static} {\cf18 void} gop_print_binary(GOP_PARAMS* gop, uint64_t val, uint32_t color) \{\par
00648     {\cf18 char} buf[65]; {\cf20 // 64 bits + null terminator}\par
00649     {\cf19 for} ({\cf18 int} i = 0; i < 64; i++) \{\par
00650         {\cf20 // fill buffer from MSB to LSB}\par
00651         buf[i] = (val & (1ULL << (63 - i))) ? {\cf23 '1'} : {\cf22 '0'};\par
00652     \}\par
00653     buf[64] = {\cf23 '\\0'};\par
00654     gop_puts(gop, buf, color);\par
00655 \}\par
00656 \par
00657 {\cf18 int} kstrcmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2) \{\par
00658     {\cf19 while} (*s1 && *s2) \{\par
00659         {\cf19 if} (*s1 != *s2) {\cf19 return} ({\cf18 int})(({\cf18 unsigned} char)*s1 - ({\cf18 unsigned} char)*s2);\par
00660         s1++;\par
00661         s2++;\par
00662     \}\par
00663     {\cf19 return} ({\cf18 int})(({\cf18 unsigned} char)*s1 - ({\cf18 unsigned} char)*s2);\par
00664 \}\par
00665 \par
00666 {\cf18 int} kstrncmp({\cf17 const} {\cf18 char}* s1, {\cf17 const} {\cf18 char}* s2, {\cf18 size_t} length) \{\par
00667     {\cf19 if} (!length) {\cf19 return} length;\par
00668     {\cf19 for} ({\cf18 size_t} i = 0; i < length; i++, s1++, s2++) \{\par
00669         {\cf19 if} (*s1 != *s2) {\cf19 return} ({\cf18 int})(({\cf18 unsigned} char)*s1 - ({\cf18 unsigned} char)*s2);\par
00670         {\cf19 if} (*s1 == {\cf23 '\\0'}) {\cf19 return} 0;\par
00671     \}\par
00672     {\cf19 return} 0;\par
00673 \}\par
00674 \par
00675 SPINLOCK gop_lock = \{ 0 \};\par
00676 \par
00677 {\cf17 static} {\cf18 void} acquire_tmp_lock(SPINLOCK* lock) \{\par
00678     {\cf19 if} (!lock) {\cf19 return};\par
00679     {\cf20 // spin until we grab the lock.}\par
00680     {\cf19 while} (__sync_lock_test_and_set(&lock->locked, 1)) \{\par
00681         __asm__ {\cf17 volatile}({\cf22 "pause"} ::: {\cf22 "memory"}); {\cf20 /* x86 pause \'97 CPU relax hint */}\par
00682     \}\par
00683     {\cf20 // Memory barrier to prevent instruction reordering}\par
00684     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00685 \}\par
00686 \par
00687 {\cf17 static} {\cf18 void} release_tmp_lock(SPINLOCK* lock) \{\par
00688     {\cf19 if} (!lock) {\cf19 return};\par
00689     {\cf20 // Memory barrier before release}\par
00690     __asm__ __volatile({\cf22 ""} ::: {\cf22 "memory"});\par
00691     __sync_lock_release(&lock->locked);\par
00692 \}\par
00693 \par
00694 {\cf18 void} gop_printf(uint32_t color, {\cf17 const} {\cf18 char}* fmt, ...) \{\par
00695     {\cf20 // Check for exclusive ownership, if there is none, continue, if we are the owner, continue, if we are not the owner, return.}\par
00696     {\cf20 // Used with unlikely macro since this is only present in bugchecking or other high level scenarios.}\par
00697     {\cf18 void}* owner = InterlockedCompareExchangePointer(({\cf17 volatile} {\cf18 void}* {\cf17 volatile}*)&ExclusiveOwnerShip, NULL, NULL);\par
00698     {\cf19 if} (unlikely(owner && owner != MeGetCurrentProcessor())) {\cf19 return};\par
00699 \par
00700     {\cf18 bool} prev_if = interrupts_enabled();\par
00701     acquire_tmp_lock(&gop_lock);\par
00702     __cli();\par
00703     GOP_PARAMS* gop = &gop_local;\par
00704     va_list ap;\par
00705     va_start(ap, fmt);\par
00706     {\cf19 for} ({\cf17 const} {\cf18 char}* p = fmt; *p; p++) \{\par
00707         {\cf19 if} (*p == {\cf23 '*'} && p[1] == {\cf23 '*'}) \{\par
00708             gop_bold_enabled = !gop_bold_enabled;  {\cf20 // Toggle bold}\par
00709             p++; {\cf20 // skip the second '*'}\par
00710             {\cf19 continue};\par
00711         \}\par
00712         {\cf19 if} (*p == {\cf23 '%'} && p[1]) \{\par
00713             p++;\par
00714             {\cf20 // support optional length modifiers: 'l' and 'll'}\par
00715             {\cf18 int} len = 0;\par
00716             {\cf19 while} (*p == {\cf23 'l'}) \{\par
00717                 len++;\par
00718                 p++;\par
00719                 {\cf19 if} (len >= 2) {\cf19 break};\par
00720             \}\par
00721             {\cf18 char} spec = *p;\par
00722             {\cf19 switch} (spec) \{\par
00723             {\cf19 case} {\cf23 'd'}:\par
00724                 {\cf19 if} (len >= 2) \{\par
00725                     gop_print_dec(gop, (int64_t)va_arg(ap, {\cf18 long} {\cf18 long}), color);\par
00726                 \}\par
00727                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00728                     gop_print_dec(gop, (int64_t)va_arg(ap, {\cf18 long}), color);\par
00729                 \}\par
00730                 {\cf19 else} \{\par
00731                     gop_print_dec(gop, (int64_t)va_arg(ap, {\cf18 int}), color);\par
00732                 \}\par
00733                 {\cf19 break};\par
00734             {\cf19 case} {\cf23 'u'}:\par
00735                 {\cf19 if} (len >= 2) \{\par
00736                     gop_print_udec(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 long} {\cf18 long}), color);\par
00737                 \}\par
00738                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00739                     gop_print_udec(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 long}), color);\par
00740                 \}\par
00741                 {\cf19 else} \{\par
00742                     gop_print_udec(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 int}), color);\par
00743                 \}\par
00744                 {\cf19 break};\par
00745             {\cf19 case} {\cf23 'x'}:\par
00746                 {\cf19 if} (len >= 2) \{\par
00747                     gop_print_hex_minimal(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 long} {\cf18 long}), color);\par
00748                 \}\par
00749                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00750                     gop_print_hex_minimal(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 long}), color);\par
00751                 \}\par
00752                 {\cf19 else} \{\par
00753                     gop_print_hex_minimal(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 int}), color);\par
00754                 \}\par
00755                 {\cf19 break};\par
00756             {\cf19 case} {\cf23 'p'}:\par
00757                 gop_print_hex(gop, (uint64_t)(uintptr_t)va_arg(ap, {\cf18 void}*), color);\par
00758                 {\cf19 break};\par
00759             {\cf19 case} {\cf23 'c'}: \{\par
00760                 {\cf18 int} ch = va_arg(ap, {\cf18 int});\par
00761                 gop_put_char(gop, ({\cf18 char})ch, color);    {\cf20 // chars promoted to int}\par
00762             \} {\cf19 break};\par
00763             {\cf19 case} {\cf23 'b'}:\par
00764                 {\cf20 // binary: accept width modifiers, default to unsigned long long for no ambiguity}\par
00765                 {\cf19 if} (len >= 2) \{\par
00766                     gop_print_binary(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 long} {\cf18 long}), color);\par
00767                 \}\par
00768                 {\cf19 else} {\cf19 if} (len == 1) \{\par
00769                     gop_print_binary(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 long}), color);\par
00770                 \}\par
00771                 {\cf19 else} \{\par
00772                     gop_print_binary(gop, (uint64_t)va_arg(ap, {\cf18 unsigned} {\cf18 int}), color);\par
00773                 \}\par
00774                 {\cf19 break};\par
00775             {\cf19 case} {\cf23 's'}: \{\par
00776                 {\cf17 const} {\cf18 char}* str = va_arg(ap, {\cf17 const} {\cf18 char}*);\par
00777                 {\cf19 if} (str) gop_puts(gop, str, color);\par
00778             \} {\cf19 break};\par
00779             {\cf19 case} {\cf23 '%'}: gop_put_char(gop, {\cf23 '%'}, color); {\cf19 break};\par
00780             {\cf19 default}:\par
00781                 gop_put_char(gop, {\cf23 '%'}, color);\par
00782                 gop_put_char(gop, spec, color);\par
00783             \}\par
00784         \}\par
00785         {\cf19 else} \{\par
00786             gop_put_char(gop, *p, color);\par
00787         \}\par
00788     \}\par
00789     va_end(ap);\par
00790     release_tmp_lock(&gop_lock);\par
00791     {\cf19 if} (prev_if) __sti();\par
00792 \}\par
00793 \par
00794 {\cf18 void} MgAcquireExclusiveGopOwnerShip({\cf18 void}) \{\par
00795     {\cf18 void}* me = ({\cf18 void}*)MeGetCurrentProcessor();\par
00796 \par
00797     {\cf19 for} (;;) \{\par
00798         {\cf18 void}* prev = InterlockedCompareExchangePointer(&ExclusiveOwnerShip, me, NULL);\par
00799         {\cf19 if} (prev == NULL)\par
00800             {\cf19 return}; {\cf20 // acquired}\par
00801 \par
00802         __pause();\par
00803     \}\par
00804 \}\par
00805 \par
00806 {\cf18 void} MgReleaseExclusiveGopOwnerShip({\cf18 void}) \{\par
00807     {\cf20 // Trust the caller, just set the ExclusiveOwnerShip pointer to NULL.}\par
00808     InterlockedExchangePointer(&ExclusiveOwnerShip, NULL);\par
00809 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../includes/stdarg_myos.h"}\par
{\f2 #include "../../intrinsics/intrin.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/ms.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gop.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/drivers/gop/gop.h}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     GOP Driver to draw onto screen (long-mode framebuffer)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_GOP_DRIVER_H}\par
00008 {\cf21 #define X86_GOP_DRIVER_H}\par
00009 \par
00010  {\cf20 // Standard headers, required.}\par
00011 {\cf21 #include <stddef.h>}\par
00012 {\cf21 #include <stdbool.h>}\par
00013 {\cf21 #include <stdint.h>}\par
00014 {\cf21 #include "../../includes/stdarg_myos.h"}\par
00015 {\cf21 #include "../../intrinsics/intrin.h"}\par
00016 {\cf21 #include "../../includes/mg.h"}\par
00017 {\cf21 #include "../../includes/ms.h"}\par
00018 {\cf21 #endif }{\cf20 // X86_GOP_DRIVER_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "fat32.h"}\par
{\f2 #include "../../drivers/blk/block.h"}\par
{\f2 #include "../../assert.h"}\par
{\f2 #include "../../time.h"}\par
{\f2 #include "../../intrinsics/atomic.h"}\par
{\f2 #include "../../includes/mg.h"}\par
{\f2 #include "../../includes/mm.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LFN_ENTRY_BUFFER}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRITE_MODE_APPEND_EXISTING}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WRITE_MODE_CREATE_OR_REPLACE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b le32toh}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_LFN_ENTRIES}\~ 20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_LFN_LEN}\~ 260\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_READ_ERROR}\~ 0xFFFFFFFFu\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BPB_SECTOR_START}\~ 2048\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_init} (int disk_index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fat32_list_root} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_read_file} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_create_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory (/testdir/ or /testdir are both allowed to create 'testdir' inside of 'root') }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_write_file} (const char *path, const void *data, uint32_t size, uint32_t mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_list_directory} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fat32_directory_is_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / deleted / nonexistent) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_file} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b fat_cache_buf2} = NULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile int32_t {\b fat32_called_from_scanner} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BPB_SECTOR_START\:fat32.c}
{\xe \v fat32.c\:BPB_SECTOR_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BPB_SECTOR_START\~ 2048}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 742} of file {\b fat32.c}.}\par
}
{\xe \v FAT32_READ_ERROR\:fat32.c}
{\xe \v fat32.c\:FAT32_READ_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_READ_ERROR\~ 0xFFFFFFFFu}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b fat32.c}.}\par
}
{\xe \v le32toh\:fat32.c}
{\xe \v fat32.c\:le32toh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define le32toh( x)}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (x)\par
}
{
Definition at line {\b 21} of file {\b fat32.c}.}\par
}
{\xe \v MAX_LFN_ENTRIES\:fat32.c}
{\xe \v fat32.c\:MAX_LFN_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_LFN_ENTRIES\~ 20}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b fat32.c}.}\par
}
{\xe \v MAX_LFN_LEN\:fat32.c}
{\xe \v fat32.c\:MAX_LFN_LEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_LFN_LEN\~ 260}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b fat32.c}.}\par
}
{\xe \v WRITE_MODE_APPEND_EXISTING\:fat32.c}
{\xe \v fat32.c\:WRITE_MODE_APPEND_EXISTING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRITE_MODE_APPEND_EXISTING\~ 0}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b fat32.c}.}\par
}
{\xe \v WRITE_MODE_CREATE_OR_REPLACE\:fat32.c}
{\xe \v fat32.c\:WRITE_MODE_CREATE_OR_REPLACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WRITE_MODE_CREATE_OR_REPLACE\~ 1}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fat32_create_directory\:fat32.c}
{\xe \v fat32.c\:fat32_create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_create_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory (/testdir/ or /testdir are both allowed to create 'testdir' inside of 'root') }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1047} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_directory\:fat32.c}
{\xe \v fat32.c\:fat32_delete_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1922} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_file\:fat32.c}
{\xe \v fat32.c\:fat32_delete_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_file (const char * path)}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1954} of file {\b fat32.c}.}\par
}
{\xe \v fat32_directory_is_empty\:fat32.c}
{\xe \v fat32.c\:fat32_directory_is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool fat32_directory_is_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / deleted / nonexistent) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 1663} of file {\b fat32.c}.}\par
}
{\xe \v fat32_init\:fat32.c}
{\xe \v fat32.c\:fat32_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_init (int disk_index)}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 745} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_directory\:fat32.c}
{\xe \v fat32.c\:fat32_list_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_list_directory (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1579} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_root\:fat32.c}
{\xe \v fat32.c\:fat32_list_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fat32_list_root (void )}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 769} of file {\b fat32.c}.}\par
}
{\xe \v fat32_read_file\:fat32.c}
{\xe \v fat32.c\:fat32_read_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_read_file (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 921} of file {\b fat32.c}.}\par
}
{\xe \v fat32_write_file\:fat32.c}
{\xe \v fat32.c\:fat32_write_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_write_file (const char * path, const void * data, uint32_t size, uint32_t file_modification_mode)}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_modification_mode} \cell }{Whether to APPEND or REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1275} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v fat32_called_from_scanner\:fat32.c}
{\xe \v fat32.c\:fat32_called_from_scanner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile int32_t fat32_called_from_scanner = 0}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b fat32.c}.}\par
}
{\xe \v fat_cache_buf2\:fat32.c}
{\xe \v fat32.c\:fat_cache_buf2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* fat_cache_buf2 = NULL}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b fat32.c}.}\par
}
{\xe \v gop_local\:fat32.c}
{\xe \v fat32.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fat32.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.c}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     FAT32 FileSystem Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "fat32.h"}\par
00008 {\cf21 #include "../../drivers/blk/block.h"}\par
00009 {\cf21 #include "../../assert.h"}\par
00010 {\cf21 #include "../../time.h"}\par
00011 {\cf21 #include "../../intrinsics/atomic.h"}\par
00012 {\cf21 #include "../../includes/mg.h"}\par
00013 {\cf21 #include "../../includes/mm.h"}\par
00014 \par
00015 {\cf21 #define WRITE_MODE_APPEND_EXISTING 0}\par
00016 {\cf21 #define WRITE_MODE_CREATE_OR_REPLACE 1}\par
00017 \par
00018 {\cf21 #if defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)}\par
00019 {\cf21 #define le32toh(x) __builtin_bswap32(x)}\par
00020 {\cf21 #else}\par
00021 {\cf21 #define le32toh(x) (x)}\par
00022 {\cf21 #endif}\par
00023 \par
00024 {\cf17 static} FAT32_BPB bpb;\par
00025 {\cf17 static} FAT32_FSINFO fs;\par
00026 {\cf17 static} BLOCK_DEVICE* disk;\par
00027 {\cf17 extern} GOP_PARAMS gop_local;\par
00028 \par
00029 {\cf17 static} SPINLOCK fat32_read_fat_lock = \{ 0 \};\par
00030 {\cf17 static} SPINLOCK fat32_write_fat_lock = \{ 0 \};\par
00031 {\cf17 static} {\cf18 void}* fat_cache_buf = NULL;\par
00032 {\cf18 void}* fat_cache_buf2 = NULL;\par
00033 {\cf17 static} uint32_t fat_cache_sector = UINT32_MAX;\par
00034 \par
00035 {\cf21 #define MAX_LFN_ENTRIES 20       }{\cf20 // Allows up to 260 chars (20*13)}\par
00036 {\cf21 #define MAX_LFN_LEN 260}\par
00037 \par
00038 {\cf17 volatile} int32_t fat32_called_from_scanner = 0;\par
00039 \par
00040 {\cf20 // Internal Error Constants}\par
00041 {\cf21 #define FAT32_READ_ERROR   0xFFFFFFFFu}\par
00042 {\cf17 typedef} {\cf17 struct }\{\par
00043     uint16_t name_chars[13];     {\cf20 // UTF-16 characters from one LFN entry}\par
00044 \} LFN_ENTRY_BUFFER;\par
00045 \par
00046 {\cf20 // Read sector into the buffer.}\par
00047 {\cf17 static} MTSTATUS read_sector(uint32_t lba, {\cf18 void}* buf) \{\par
00048 \par
00049     {\cf18 size_t} NumberOfBytes = fs.bytes_per_sector;\par
00050     {\cf19 if} (!NumberOfBytes) NumberOfBytes = 512;\par
00051 \par
00052     {\cf19 if} (NumberOfBytes % 512 != 0) \{\par
00053         {\cf20 // NumberOfBytes must be in multiples of 512.}\par
00054         {\cf19 return} MT_INVALID_PARAM;\par
00055     \}\par
00056 \par
00057     {\cf19 return} disk->read_sector(disk, lba, buf, NumberOfBytes);\par
00058 \}\par
00059 \par
00060 {\cf20 // Write to sector from buffer}\par
00061 {\cf17 static} MTSTATUS write_sector(uint32_t lba, {\cf17 const} {\cf18 void}* buf) \{\par
00062 \par
00063     {\cf18 size_t} NumberOfBytes = fs.bytes_per_sector;\par
00064     {\cf19 if} (!NumberOfBytes) NumberOfBytes = 512;\par
00065 \par
00066     {\cf19 if} (NumberOfBytes % 512 != 0) \{\par
00067         {\cf20 // NumberOfBytes must be in multiples of 512.}\par
00068         {\cf19 return} MT_INVALID_PARAM;\par
00069     \}\par
00070 \par
00071     {\cf19 return} disk->write_sector(disk, lba, buf, NumberOfBytes);\par
00072 \}\par
00073 \par
00074 {\cf20 // Compute checksum of 8.3 name (from specification)}\par
00075 {\cf17 static} uint8_t lfn_checksum({\cf17 const} uint8_t short_name[11]) \{\par
00076     uint8_t sum = 0;\par
00077     {\cf19 for} ({\cf18 int} i = 0; i < 11; i++) \{\par
00078         sum = ((sum & 1) ? 0x80 : 0) + (sum >> 1) + short_name[i];\par
00079     \}\par
00080     {\cf19 return} sum;\par
00081 \}\par
00082 \par
00083 {\cf20 // Convert to uppercase.}\par
00084 {\cf17 static} {\cf17 inline} {\cf18 int} toupper({\cf18 int} c) \{\par
00085     {\cf19 if} (c >= {\cf23 'a'} && c <= {\cf23 'z'}) \{\par
00086         {\cf19 return} c - ({\cf23 'a'} - {\cf23 'A'}); {\cf20 // Convert lowercase to uppercase}\par
00087     \}\par
00088     {\cf19 return} c; {\cf20 // Return unchanged if not lowercase letter}\par
00089 \}\par
00090 \par
00091 {\cf20 // Compare short name}\par
00092 {\cf17 static} {\cf18 bool} cmp_name({\cf17 const} {\cf18 char}* str_1, {\cf17 const} {\cf18 char}* str_2) \{\par
00093     {\cf18 char} t[12] = \{ 0 \};\par
00094     {\cf19 for} ({\cf18 int} i = 0; i < 11; i++) \{ t[i] = str_1[i]; \}\par
00095     {\cf19 for} ({\cf18 int} i = 0; i < 11; i++) \{\par
00096         {\cf19 if} (toupper(t[i]) != toupper(str_2[i])) \{\par
00097             {\cf19 return} {\cf17 false};\par
00098         \}\par
00099     \}\par
00100     {\cf19 return} {\cf17 true};\par
00101 \}\par
00102 \par
00103 \par
00104 {\cf20 // Helper: convert "NAME.EXT" or "NAMEEXT" to 11-byte FAT short-name (uppercased, space-padded).}\par
00105 {\cf17 static} {\cf18 void} format_short_name({\cf17 const} {\cf18 char}* input, {\cf18 char} out[11]) \{\par
00106     {\cf20 // Fill with spaces}\par
00107     {\cf19 for} ({\cf18 int} i = 0; i < 11; ++i) out[i] = {\cf23 ' '};\par
00108     {\cf20 // Copy name (up to 8 chars)}\par
00109     {\cf18 int} ni = 0;\par
00110     {\cf17 const} {\cf18 unsigned} {\cf18 char}* p = ({\cf17 const} {\cf18 unsigned} {\cf18 char}*)input;\par
00111     {\cf19 while} (*p && *p != {\cf23 '.'} && ni < 8) \{\par
00112         out[ni++] = (char)toupper(*p++);\par
00113     \}\par
00114     {\cf20 // If '.' found, copy extension (up to 3)}\par
00115     {\cf19 if} (*p == {\cf23 '.'}) \{\par
00116         ++p;\par
00117         {\cf18 int} ei = 0;\par
00118         {\cf19 while} (*p && ei < 3) \{\par
00119             out[8 + ei++] = (char)toupper(*p++);\par
00120         \}\par
00121     \}\par
00122 \}\par
00123 \par
00131 {\cf17 static} FAT32_DIR_ENTRY* read_lfn(FAT32_DIR_ENTRY* cur, uint32_t remaining, {\cf18 char}* out_name, uint32_t* out_consumed) \{\par
00132     {\cf19 if} (!cur || remaining == 0) {\cf19 return} NULL;\par
00133     *out_consumed = 0;\par
00134 \par
00135     {\cf20 // Collect LFN pointers (they appear immediately before the 8.3 entry).}\par
00136     FAT32_DIR_ENTRY* lfn_list[MAX_LFN_ENTRIES];\par
00137     uint32_t lfn_count = 0;\par
00138     uint32_t i = 0;\par
00139 \par
00140     {\cf20 // Walk forward while entries are LFN (0x0F). Stop when we hit a non-LFN or end.}\par
00141     {\cf19 while} (i < remaining && ((uint8_t)cur[i].name[0] != 0x00) && (cur[i].attr == ATTR_LONG_NAME)) \{\par
00142         {\cf19 if} (lfn_count < MAX_LFN_ENTRIES) lfn_list[lfn_count++] = &cur[i];\par
00143         i++;\par
00144     \}\par
00145 \par
00146     {\cf20 // i now points to the candidate 8.3 entry (must exist and not be end marker).}\par
00147     {\cf19 if} (i >= remaining) {\cf19 return} NULL;\par
00148     FAT32_DIR_ENTRY* short_entry = &cur[i];\par
00149     {\cf19 if} ((uint8_t)short_entry->name[0] == 0x00 || (uint8_t)short_entry->name[0] == 0xE5) \{\par
00150         {\cf20 // no valid 8.3 here}\par
00151         {\cf19 return} NULL;\par
00152     \}\par
00153 \par
00154     {\cf20 // If no LFN entries collected, just copy short name into out_name and return short_entry.}\par
00155     {\cf19 if} (lfn_count == 0) \{\par
00156         {\cf20 // Convert 11-byte SFN to human readable name "NAME.EXT"}\par
00157         {\cf17 const} {\cf18 unsigned} {\cf18 char}* s = ({\cf17 const} {\cf18 unsigned} {\cf18 char}*)short_entry->name;\par
00158         {\cf18 int} pos = 0;\par
00159 \par
00160         {\cf20 // name part (0..7)}\par
00161         {\cf19 for} ({\cf18 int} n = 0; n < 8; ++n) \{\par
00162             {\cf19 if} (s[n] == {\cf23 ' '}) {\cf19 break};\par
00163             {\cf19 if} (pos < ({\cf18 int})MAX_LFN_LEN - 1) out_name[pos++] = s[n];\par
00164         \}\par
00165 \par
00166         {\cf20 // extension (8..10)}\par
00167         {\cf18 bool} has_ext = {\cf17 false};\par
00168         {\cf19 for} ({\cf18 int} n = 8; n < 11; ++n) {\cf19 if} (s[n] != {\cf23 ' '}) \{ has_ext = {\cf17 true}; {\cf19 break}; \}\par
00169         {\cf19 if} (has_ext) \{\par
00170             {\cf19 if} (pos < ({\cf18 int})MAX_LFN_LEN - 1) out_name[pos++] = {\cf23 '.'};\par
00171             {\cf19 for} ({\cf18 int} n = 8; n < 11; ++n) \{\par
00172                 {\cf19 if} (s[n] == {\cf23 ' '}) {\cf19 break};\par
00173                 {\cf19 if} (pos < ({\cf18 int})MAX_LFN_LEN - 1) out_name[pos++] = s[n];\par
00174             \}\par
00175         \}\par
00176 \par
00177         out_name[pos] = {\cf23 '\\0'};\par
00178         *out_consumed = 1;\par
00179         {\cf19 return} short_entry;\par
00180     \}\par
00181 \par
00182     {\cf20 // Validate checksum of short name against each LFN entry's checksum field (offset 13)}\par
00183     uint8_t cs = lfn_checksum((uint8_t*)short_entry->name);\par
00184     {\cf19 for} (uint32_t j = 0; j < lfn_count; ++j) \{\par
00185         uint8_t entry_checksum = *((uint8_t*)lfn_list[j] + 13);\par
00186         {\cf19 if} (entry_checksum != cs) {\cf19 return} NULL; {\cf20 // mismatch -> invalid chain}\par
00187     \}\par
00188 \par
00189     {\cf20 // Reconstruct name: iterate lfn_list in reverse (last chunk -> first chunk)}\par
00190     uint32_t pos = 0;\par
00191     {\cf19 for} ({\cf18 int} j = ({\cf18 int})lfn_count - 1; j >= 0; --j) \{\par
00192         uint8_t* ebytes = (uint8_t*)lfn_list[j];\par
00193 \par
00194         {\cf20 // Name1 at offset 1, 5 UTF-16 chars}\par
00195         uint16_t* name1 = (uint16_t*)(ebytes + 1);\par
00196         {\cf19 for} ({\cf18 int} c = 0; c < 5; ++c) \{\par
00197             uint16_t ch = name1[c];\par
00198             {\cf19 if} (ch == 0x0000) \{ out_name[pos] = {\cf23 '\\0'}; {\cf19 goto} done; \}\par
00199             {\cf19 if} (pos >= MAX_LFN_LEN - 1) \{ {\cf20 // Check BEFORE writing}\par
00200                 {\cf19 goto} done;\par
00201             \}\par
00202             {\cf19 if} (ch <= 0x7F) out_name[pos++] = (char)ch; {\cf19 else} out_name[pos++] = {\cf23 '?'};\par
00203         \}\par
00204 \par
00205         {\cf20 // Name2 at offset 14, 6 UTF-16 chars}\par
00206         uint16_t* name2 = (uint16_t*)(ebytes + 14);\par
00207         {\cf19 for} ({\cf18 int} c = 0; c < 6; ++c) \{\par
00208             uint16_t ch = name2[c];\par
00209             {\cf19 if} (ch == 0x0000) \{ out_name[pos] = {\cf23 '\\0'}; {\cf19 goto} done; \}\par
00210             {\cf19 if} (pos >= MAX_LFN_LEN - 1) \{\par
00211                 {\cf19 goto} done;\par
00212             \}\par
00213             {\cf19 if} (ch <= 0x7F) out_name[pos++] = (char)ch; {\cf19 else} out_name[pos++] = {\cf23 '?'};\par
00214         \}\par
00215 \par
00216         {\cf20 // Name3 at offset 28, 2 UTF-16 chars}\par
00217         uint16_t* name3 = (uint16_t*)(ebytes + 28);\par
00218         {\cf19 for} ({\cf18 int} c = 0; c < 2; ++c) \{\par
00219             uint16_t ch = name3[c];\par
00220             {\cf19 if} (ch == 0x0000) \{ out_name[pos] = {\cf23 '\\0'}; {\cf19 goto} done; \}\par
00221             {\cf19 if} (pos >= MAX_LFN_LEN - 1) \{\par
00222                 {\cf19 goto} done;\par
00223             \}\par
00224             {\cf19 if} (ch <= 0x7F) out_name[pos++] = (char)ch; {\cf19 else} out_name[pos++] = {\cf23 '?'};\par
00225         \}\par
00226     \}\par
00227 \par
00228 done:\par
00229     out_name[pos] = {\cf23 '\\0'};\par
00230     {\cf20 // consumed entries = number of LFN entries + the 8.3 entry}\par
00231     *out_consumed = (uint32_t)lfn_count + 1;\par
00232     {\cf19 return} short_entry;\par
00233 \}\par
00234 \par
00235 {\cf17 static} {\cf17 inline} uint32_t fat32_total_clusters({\cf18 void}) \{\par
00236     {\cf19 return} (bpb.total_sectors_32 - fs.first_data_sector) / fs.sectors_per_cluster;\par
00237 \}\par
00238 \par
00239 {\cf20 // Read the FAT for the given cluster, to inspect data about this specific cluster, like which sectors are free, used, what's the next sector, and which sector are EOF (end of file = 0x0FFFFFFF)}\par
00240 {\cf17 static} uint32_t fat32_read_fat(uint32_t cluster) \{\par
00241     {\cf18 bool} isScanner = InterlockedCompareExchange32(&fat32_called_from_scanner, 0, 0);\par
00242 \par
00243     {\cf20 // Do not treat reserved clusters as "free" returned to callers that iterate the chain.}\par
00244     {\cf19 if} (cluster < 2) \{\par
00245         {\cf19 if} (isScanner) \{\par
00246             {\cf19 return} FAT32_READ_ERROR;\par
00247         \}\par
00248         {\cf19 return} FAT32_EOC_MIN;\par
00249     \}\par
00250 \par
00251     IRQL oldIrql;\par
00252     MsAcquireSpinlock(&fat32_read_fat_lock, &oldIrql);\par
00253 \par
00254     {\cf20 // allocate cache buffer onceW}\par
00255     {\cf19 if} (!fat_cache_buf) \{\par
00256         fat_cache_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 '1TAF'});\par
00257         {\cf19 if} (!fat_cache_buf) \{\par
00258             gop_printf(0xFFFF0000, {\cf22 "fat32_read_fat: couldn't alloc cache buf\\n"});\par
00259             MsReleaseSpinlock(&fat32_read_fat_lock, oldIrql);\par
00260             {\cf19 if} (isScanner) \{\par
00261                 {\cf19 return} FAT32_READ_ERROR;\par
00262             \}\par
00263             {\cf19 return} FAT32_EOC_MIN;\par
00264         \}\par
00265     \}\par
00266 \par
00267     uint32_t fat_offset = cluster * 4;\par
00268     uint32_t fat_sector = fs.fat_start + (fat_offset / fs.bytes_per_sector);\par
00269     uint32_t ent_offset = fat_offset % fs.bytes_per_sector;\par
00270     uint32_t bps = fs.bytes_per_sector;\par
00271 \par
00272     {\cf20 // read sector only if different from cached one}\par
00273     {\cf19 if} (fat_cache_sector != fat_sector) \{\par
00274         MTSTATUS st = read_sector(fat_sector, fat_cache_buf);\par
00275         {\cf19 if} (MT_FAILURE(st)) \{\par
00276             gop_printf(0xFFFF0000, {\cf22 "fat32_read_fat: read_sector fail for sector %u\\n"}, fat_sector);\par
00277             MsReleaseSpinlock(&fat32_read_fat_lock, oldIrql);\par
00278             {\cf19 if} (isScanner) \{\par
00279                 {\cf19 return} FAT32_READ_ERROR;\par
00280             \}\par
00281             {\cf19 return} FAT32_EOC_MIN;\par
00282         \}\par
00283         fat_cache_sector = fat_sector;\par
00284     \}\par
00285 \par
00286     uint32_t raw = 0;\par
00287     uint32_t val = 0;\par
00288 \par
00289     {\cf19 if} (ent_offset <= bps - 4) \{\par
00290         {\cf20 /* entirely inside cached sector */}\par
00291         kmemcpy(&raw, (uint8_t*)fat_cache_buf + ent_offset, {\cf17 sizeof}(raw));\par
00292         raw = le32toh(raw);\par
00293         val = raw & 0x0FFFFFFF;\par
00294     \}\par
00295     {\cf19 else} \{\par
00296         {\cf20 /* entry spans to next sector */}\par
00297         {\cf19 if} (!fat_cache_buf2) \{\par
00298             fat_cache_buf2 = MmAllocatePoolWithTag(NonPagedPool, bps, {\cf22 '2TAF'});\par
00299             {\cf19 if} (!fat_cache_buf2) \{\par
00300                 gop_printf(0xFFFF0000, {\cf22 "fat32_read_fat: couldn't alloc secondary cache buf\\n"});\par
00301                 MsReleaseSpinlock(&fat32_read_fat_lock, oldIrql);\par
00302                 {\cf19 if} (isScanner) \{\par
00303                     {\cf19 return} FAT32_READ_ERROR;\par
00304                 \}\par
00305                 {\cf19 return} FAT32_EOC_MIN;\par
00306             \}\par
00307         \}\par
00308 \par
00309         MTSTATUS st2 = read_sector(fat_sector + 1, fat_cache_buf2);\par
00310         {\cf19 if} (MT_FAILURE(st2)) \{\par
00311             gop_printf(0xFFFF0000, {\cf22 "fat32_read_fat: read_sector fail for next sector %u\\n"}, fat_sector + 1);\par
00312             MsReleaseSpinlock(&fat32_read_fat_lock, oldIrql);\par
00313             {\cf19 if} (isScanner) \{\par
00314                 {\cf19 return} FAT32_READ_ERROR;\par
00315             \}\par
00316             {\cf19 return} FAT32_EOC_MIN;\par
00317         \}\par
00318 \par
00319         uint8_t tmp[4];\par
00320         {\cf18 size_t} first = bps - ent_offset;             {\cf20 // bytes available in current sector}\par
00321         kmemcpy(tmp, (uint8_t*)fat_cache_buf + ent_offset, first);\par
00322         kmemcpy(tmp + first, (uint8_t*)fat_cache_buf2, 4 - first);\par
00323         kmemcpy(&raw, tmp, {\cf17 sizeof}(raw));\par
00324         raw = le32toh(raw);\par
00325         val = raw & 0x0FFFFFFF;\par
00326     \}\par
00327 \par
00328     {\cf20 /* diagnostic: use the computed raw (not a fresh read from cache which might be wrong if entry spanned) */}\par
00329     {\cf19 if} (val == cluster) \{\par
00330         {\cf19 if} (raw == 0) \{\par
00331             gop_printf(0xFFFF0000, {\cf22 "FAT suspicious: cluster=%u -> raw=0x%08x (ent_off=%u, fat_sector=%u, total=%u)\\n"},\par
00332                 cluster, raw, ent_offset, fat_sector, fat32_total_clusters());\par
00333             MsReleaseSpinlock(&fat32_read_fat_lock, oldIrql);\par
00334             {\cf19 if} (isScanner) \{\par
00335                 {\cf19 return} FAT32_READ_ERROR;\par
00336             \}\par
00337             {\cf19 return} FAT32_EOC_MIN;\par
00338         \}\par
00339     \}\par
00340 \par
00341     MsReleaseSpinlock(&fat32_read_fat_lock, oldIrql);\par
00342     {\cf19 return} val;\par
00343 \}\par
00344 \par
00345 {\cf17 static} {\cf17 inline} uint32_t first_sector_of_cluster(uint32_t cluster) \{\par
00346     {\cf19 return} fs.first_data_sector + (cluster - 2) * fs.sectors_per_cluster;\par
00347 \}\par
00348 \par
00349 \par
00350 {\cf17 static} {\cf18 bool} fat32_write_fat(uint32_t cluster, uint32_t value) \{\par
00351     IRQL oldIrql;\par
00352     MsAcquireSpinlock(&fat32_write_fat_lock, &oldIrql);\par
00353     uint32_t fat_offset = cluster * 4;\par
00354     uint32_t sec_index = fat_offset / fs.bytes_per_sector;\par
00355     uint32_t ent_offset = fat_offset % fs.bytes_per_sector;\par
00356     uint32_t bps = fs.bytes_per_sector;\par
00357     {\cf19 if} (bps == 0) \{ gop_printf(0xFFFF0000, {\cf22 "fat32_write_fat: bps==0!\\n"}); MsReleaseSpinlock(&fat32_write_fat_lock, oldIrql); {\cf19 return} {\cf17 false}; \}\par
00358     {\cf20 // We may need up to two buffers if the entry spans sectors.}\par
00359     {\cf18 void}* buf1 = MmAllocatePoolWithTag(NonPagedPool, bps, {\cf22 '1FUB'});\par
00360     {\cf19 if} (!buf1) \{\par
00361         MsReleaseSpinlock(&fat32_write_fat_lock, oldIrql);\par
00362         {\cf19 return} {\cf17 false};\par
00363     \}\par
00364     gop_printf(0x00FF00FF, {\cf22 "fat32_write_fat: alloc buf1=%p bps=%u ent_off=%u sec=%u\\n"}, buf1, bps, ent_offset, sec_index);\par
00365     {\cf18 void}* buf2 = NULL; {\cf20 // Allocate only if needed}\par
00366 \par
00367     {\cf18 bool} spans = (ent_offset > bps - 4);\par
00368     {\cf19 if} (spans) \{\par
00369         buf2 = MmAllocatePoolWithTag(NonPagedPool, bps, {\cf22 'fat'});\par
00370         {\cf19 if} (!buf2) \{\par
00371             MmFreePool(buf1);\par
00372             MsReleaseSpinlock(&fat32_write_fat_lock, oldIrql);\par
00373             {\cf19 return} {\cf17 false};\par
00374         \}\par
00375     \}\par
00376 \par
00377     {\cf18 bool} ok = {\cf17 true};\par
00378     {\cf19 for} (uint32_t fat_i = 0; fat_i < bpb.num_fats; ++fat_i) \{\par
00379         uint32_t current_fat_base = fs.fat_start + (fat_i * fs.sectors_per_fat);\par
00380         uint32_t sector1_lba = current_fat_base + sec_index;\par
00381         uint32_t sector2_lba = sector1_lba + 1;\par
00382 \par
00383         {\cf19 if} (spans) \{\par
00384             {\cf20 // Read both affected sectors}\par
00385             {\cf19 if} (MT_FAILURE(read_sector(sector1_lba, buf1)) || MT_FAILURE(read_sector(sector2_lba, buf2))) \{\par
00386                 ok = {\cf17 false};\par
00387                 {\cf19 break};\par
00388             \}\par
00389 \par
00390             {\cf20 // Modify the two buffers}\par
00391             uint8_t value_bytes[4];\par
00392             kmemcpy(value_bytes, &value, 4);\par
00393 \par
00394             {\cf18 size_t} first_part_size = bps - ent_offset;\par
00395             {\cf18 size_t} second_part_size = 4 - first_part_size;\par
00396 \par
00397             kmemcpy((uint8_t*)buf1 + ent_offset, value_bytes, first_part_size);\par
00398             kmemcpy(buf2, value_bytes + first_part_size, second_part_size);\par
00399 \par
00400             {\cf20 // Write both sectors back}\par
00401             {\cf19 if} (MT_FAILURE(write_sector(sector1_lba, buf1)) || MT_FAILURE(write_sector(sector2_lba, buf2))) \{\par
00402                 ok = {\cf17 false};\par
00403                 {\cf19 break};\par
00404             \}\par
00405         \}\par
00406         {\cf19 else} \{\par
00407             {\cf20 // Entry is fully contained in one sector}\par
00408             {\cf19 if} (MT_FAILURE(read_sector(sector1_lba, buf1))) \{ ok = {\cf17 false}; {\cf19 break}; \}\par
00409 \par
00410             {\cf20 // Read existing 4-byte raw entry safely (avoid unaligned direct deref)}\par
00411             uint32_t raw_le = 0;\par
00412             kmemcpy(&raw_le, (uint8_t*)buf1 + ent_offset, {\cf17 sizeof}(raw_le));\par
00413             uint32_t raw = le32toh(raw_le);\par
00414 \par
00415             {\cf20 // Modify only the low 28 bits per FAT32}\par
00416             raw = (raw & 0xF0000000) | (value & 0x0FFFFFFF);\par
00417 \par
00418             {\cf20 // Write back in little-endian form}\par
00419             uint32_t new_le = le32toh(raw); {\cf20 // on little-endian this is a no-op; or define htole32 properly}\par
00420             kmemcpy((uint8_t*)buf1 + ent_offset, &new_le, {\cf17 sizeof}(new_le));\par
00421 \par
00422             {\cf19 if} (MT_FAILURE(write_sector(sector1_lba, buf1))) \{ ok = {\cf17 false}; {\cf19 break}; \}\par
00423         \}\par
00424     \}\par
00425 \par
00426     MmFreePool(buf1);\par
00427     {\cf19 if} (buf2) \{\par
00428         MmFreePool(buf2);\par
00429     \}\par
00430     MsReleaseSpinlock(&fat32_write_fat_lock, oldIrql);\par
00431     {\cf19 return} ok;\par
00432 \}\par
00433 \par
00434 \par
00435 {\cf17 static} {\cf17 inline} uint32_t get_dir_cluster(FAT32_DIR_ENTRY* entry) \{\par
00436     {\cf19 return} ((uint32_t)entry->fst_clus_hi << 16) | entry->fst_clus_lo;\par
00437 \}\par
00438 \par
00439 {\cf20 // Free a cluster chain starting at start_cluster (set each entry to FREE)}\par
00440 {\cf17 static} {\cf18 bool} fat32_free_cluster_chain(uint32_t start_cluster) \{\par
00441     {\cf19 if} (start_cluster < 2 || start_cluster >= FAT32_EOC_MIN) {\cf19 return} {\cf17 false};\par
00442 \par
00443     uint32_t cur = start_cluster;\par
00444     {\cf19 while} (cur < FAT32_EOC_MIN) \{\par
00445         uint32_t next = fat32_read_fat(cur);\par
00446         {\cf19 if} (next == cur || next == 0) \{\par
00447             gop_printf(0xFFFF0000, {\cf22 "Detected FAT self-loop/zero at %u -> %u | %s\\n"}, cur, next, __func__);\par
00448             {\cf19 break}; {\cf20 // fail gracefully}\par
00449         \}\par
00450         {\cf20 // mark current as free}\par
00451         {\cf19 if} (!fat32_write_fat(cur, FAT32_FREE_CLUSTER)) {\cf19 return} {\cf17 false};\par
00452         {\cf20 // protect against pathological loops}\par
00453         {\cf19 if} (next == cur) {\cf19 break};\par
00454         cur = next;\par
00455     \}\par
00456     {\cf19 return} {\cf17 true};\par
00457 \}\par
00458 \par
00459 {\cf17 static} uint32_t fat32_find_free_cluster({\cf18 void}) \{\par
00460     {\cf20 // Atomically update.}\par
00461     InterlockedExchange32(&fat32_called_from_scanner, 1);\par
00462     {\cf20 // Start searching from cluster 2 (the first usable cluster)}\par
00463     {\cf20 // In a more advanced implementation, we would use the FSInfo sector to find a hint. But even then that hint can be misleading (read osdev on FAT)}\par
00464     uint32_t total_clusters = fat32_total_clusters();\par
00465     uint32_t retval = 0;\par
00466     {\cf19 for} (uint32_t i = 2; i < total_clusters; i++) \{\par
00467         retval = fat32_read_fat(i);\par
00468         {\cf19 if} (retval == FAT32_FREE_CLUSTER) \{\par
00470             InterlockedExchange32(&fat32_called_from_scanner, 0);\par
00471             {\cf19 return} i;\par
00472         \}\par
00473         {\cf19 else} {\cf19 if} (retval == FAT32_READ_ERROR) \{\par
00475             {\cf19 continue};\par
00476         \}\par
00477     \}\par
00478     InterlockedExchange32(&fat32_called_from_scanner, 0);\par
00480     {\cf19 return} 0; {\cf20 // no free clusters found..}\par
00481 \}\par
00482 \par
00483 {\cf17 static} {\cf18 bool} zero_cluster(uint32_t cluster) \{\par
00484     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'FUBF'});\par
00485     {\cf18 bool} success = {\cf17 true};\par
00486     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
00487     kmemset(buf, 0, fs.bytes_per_sector);\par
00488     MTSTATUS status;\par
00489     uint32_t sector = first_sector_of_cluster(cluster);\par
00490     {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; i++) \{\par
00491         status = write_sector(sector + i, buf);\par
00492         {\cf19 if} (MT_FAILURE(status)) \{\par
00493             success = {\cf17 false};\par
00494             {\cf19 break};\par
00495         \}\par
00496     \}\par
00497 \par
00498     MmFreePool(buf);\par
00499     {\cf19 return} success;\par
00500 \}\par
00501 \par
00502 {\cf20 // Simple, strict compare: dir_name is on-disk 11 bytes, short_name is formatted 11 bytes}\par
00503 {\cf17 static} {\cf18 bool} cmp_short_name({\cf17 const} {\cf18 char}* dir_name, {\cf17 const} {\cf18 char} short_name[11]) \{\par
00504     {\cf19 for} ({\cf18 int} i = 0; i < 11; ++i) \{\par
00505         {\cf19 if} (({\cf18 unsigned} {\cf18 char})dir_name[i] != ({\cf18 unsigned} {\cf18 char})short_name[i]) {\cf19 return} {\cf17 false};\par
00506     \}\par
00507     {\cf19 return} {\cf17 true};\par
00508 \}\par
00509 \par
00510 {\cf20 // ASCII case-insensitive compare}\par
00511 {\cf17 static} {\cf17 inline} {\cf18 bool} ci_equal({\cf17 const} {\cf18 char}* a, {\cf17 const} {\cf18 char}* b) \{\par
00512     {\cf18 size_t} la = kstrlen(a);\par
00513     {\cf18 size_t} lb = kstrlen(b);\par
00514     {\cf19 if} (la != lb) {\cf19 return} {\cf17 false};\par
00515     {\cf19 for} ({\cf18 size_t} i = 0; i < la; ++i) \{\par
00516         {\cf19 if} (({\cf18 char})toupper(({\cf18 int})a[i]) != ({\cf18 char})toupper(({\cf18 int})b[i])) {\cf19 return} {\cf17 false};\par
00517     \}\par
00518     {\cf19 return} {\cf17 true};\par
00519 \}\par
00520 \par
00522 {\cf17 static} uint32_t fat32_create_lfn_entries(FAT32_LFN_ENTRY* entry_buffer, {\cf17 const} {\cf18 char}* long_name, uint8_t sfn_checksum) \{\par
00523     uint32_t len = kstrlen(long_name);\par
00524     uint32_t num_lfn_entries = (len + 12) / 13;  {\cf20 // 13 chars per entry}\par
00525     uint32_t char_idx = 0;\par
00526 \par
00527     {\cf19 for} ({\cf18 int} i = ({\cf18 int})num_lfn_entries - 1; i >= 0; --i) \{\par
00528         FAT32_LFN_ENTRY* lfn = &entry_buffer[i];\par
00529 \par
00530         {\cf20 // Clear the entry}\par
00531         kmemset(lfn, 0, {\cf17 sizeof}(*lfn));\par
00532 \par
00533         uint8_t seq = (uint8_t)(num_lfn_entries - i);\par
00534         {\cf19 if} (i == ({\cf18 int})num_lfn_entries - 1)\par
00535             seq |= 0x40; {\cf20 // last entry marker}\par
00536 \par
00537         lfn->LDIR_Ord = seq;\par
00538         lfn->LDIR_Attr = 0x0F;\par
00539         lfn->LDIR_Type = 0;\par
00540         lfn->LDIR_Chksum = sfn_checksum;\par
00541         lfn->LDIR_FstClusLO = 0;\par
00542 \par
00543         {\cf20 // Fill name fields safely}\par
00544         {\cf19 for} ({\cf18 int} k = 0; k < 13; ++k) \{\par
00545             uint16_t uch = 0xFFFF;\par
00546             {\cf19 if} (char_idx < len)\par
00547                 uch = (uint8_t)long_name[char_idx];\par
00548             {\cf19 else} {\cf19 if} (char_idx == len)\par
00549                 uch = 0x0000; {\cf20 // null terminator}\par
00550 \par
00551             {\cf19 if} (k < 5)\par
00552                 lfn->LDIR_Name1[k] = uch;\par
00553             {\cf19 else} {\cf19 if} (k < 11)\par
00554                 lfn->LDIR_Name2[k - 5] = uch;\par
00555             {\cf19 else}\par
00556                 lfn->LDIR_Name3[k - 11] = uch;\par
00557 \par
00558             {\cf19 if} (char_idx <= len)\par
00559                 ++char_idx;\par
00560         \}\par
00561     \}\par
00562 \par
00563     {\cf19 return} num_lfn_entries;\par
00564 \}\par
00565 \par
00566 \par
00574 {\cf17 static} {\cf18 bool} fat32_find_entry({\cf17 const} {\cf18 char}* path, FAT32_DIR_ENTRY* out_entry, uint32_t* out_parent_cluster) \{\par
00575     {\cf18 char} path_copy[260];\par
00576     kstrncpy(path_copy, path, {\cf17 sizeof}(path_copy));\par
00577     \par
00578     uint32_t current_cluster = fs.root_cluster;\par
00579     uint32_t parent_cluster_of_last_found = fs.root_cluster;\par
00580 \par
00581     {\cf19 if} (kstrcmp(path_copy, {\cf22 "/"}) == 0 || path_copy[0] == {\cf23 '\\0'}) \{\par
00582         {\cf19 if} (out_entry) \{\par
00583             kmemset(out_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00584             out_entry->attr = ATTR_DIRECTORY;\par
00585             out_entry->fst_clus_lo = (uint16_t)(fs.root_cluster & 0xFFFF);\par
00586             out_entry->fst_clus_hi = (uint16_t)(fs.root_cluster >> 16);\par
00587         \}\par
00588         {\cf19 if} (out_parent_cluster) *out_parent_cluster = fs.root_cluster;\par
00589         {\cf19 return} {\cf17 true};\par
00590     \}\par
00591 \par
00592     FAT32_DIR_ENTRY last_found_entry;\par
00593     kmemset(&last_found_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00594     {\cf18 bool} any_token_found = {\cf17 false};\par
00595 \par
00596     {\cf18 char}* save_ptr = NULL;\par
00597     {\cf18 char}* token = kstrtok_r(path_copy, {\cf22 "/"}, &save_ptr);\par
00598 \par
00599     {\cf19 while} (token != NULL) \{\par
00600         {\cf18 bool} found_this_token = {\cf17 false};\par
00601         parent_cluster_of_last_found = current_cluster;\par
00602 \par
00603         {\cf18 void}* sector_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'tecs'});\par
00604         {\cf19 if} (!sector_buf) {\cf19 return} {\cf17 false};\par
00605 \par
00606         uint32_t search_cluster = current_cluster;\par
00607         {\cf19 do} \{\par
00608             uint32_t sector = first_sector_of_cluster(search_cluster);\par
00609             {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; i++) \{\par
00610                 MTSTATUS status = read_sector(sector + i, sector_buf);\par
00611                 {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(sector_buf); {\cf19 return} {\cf17 false}; \}\par
00612 \par
00613                 FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)sector_buf;\par
00614                 uint32_t num_entries = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
00615 \par
00616                 {\cf19 for} (uint32_t j = 0; j < num_entries; ) \{\par
00617                     {\cf19 if} (entries[j].name[0] == END_OF_DIRECTORY) \{\par
00618                         {\cf19 goto} next_cluster; {\cf20 // Break inner loop, continue with next cluster}\par
00619                     \}\par
00620                     {\cf19 if} ((uint8_t)entries[j].name[0] == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
00621 \par
00622                     {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
00623                     uint32_t consumed = 0;\par
00624                     FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], num_entries - j, lfn_buf, &consumed);\par
00625 \par
00626                     {\cf19 if} (sfn) \{\par
00627                         {\cf20 // Using ci_equal for simplicity, assuming it does case-insensitive compare}\par
00628                         {\cf19 if} (ci_equal(lfn_buf, token)) \{\par
00629                             kmemcpy(&last_found_entry, sfn, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00630                             found_this_token = {\cf17 true};\par
00631                             current_cluster = (sfn->fst_clus_hi << 16) | sfn->fst_clus_lo;\par
00632                             {\cf19 goto} token_search_done; {\cf20 // Break all search loops for this token}\par
00633                         \}\par
00634                     \}\par
00635                     j += (consumed > 0) ? consumed : 1;\par
00636                 \}\par
00637             \}\par
00638         next_cluster:\par
00639             search_cluster = fat32_read_fat(search_cluster);\par
00640         \} {\cf19 while} (search_cluster < FAT32_EOC_MIN);\par
00641 \par
00642     token_search_done:\par
00643         MmFreePool(sector_buf); {\cf20 // free buffer}\par
00644 \par
00645         {\cf19 if} (!found_this_token) \{\par
00646             {\cf19 return} {\cf17 false}; {\cf20 // Path component not found}\par
00647         \}\par
00648         any_token_found = {\cf17 true};\par
00649         token = kstrtok_r(NULL, {\cf22 "/"}, &save_ptr);\par
00650 \par
00651         {\cf19 if} (token != NULL && !(last_found_entry.attr & ATTR_DIRECTORY)) \{\par
00652             {\cf19 return} {\cf17 false}; {\cf20 // Trying to traverse into a file}\par
00653         \}\par
00654     \}\par
00655 \par
00656     {\cf19 if} (any_token_found) \{\par
00657         {\cf19 if} (out_entry) kmemcpy(out_entry, &last_found_entry, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00658         {\cf19 if} (out_parent_cluster) *out_parent_cluster = parent_cluster_of_last_found;\par
00659         {\cf19 return} {\cf17 true};\par
00660     \}\par
00661 \par
00662     {\cf19 return} {\cf17 false};\par
00663 \}\par
00664 \par
00665 {\cf17 static} {\cf18 bool} fat32_extend_directory(uint32_t dir_cluster) \{\par
00666     uint32_t new_cluster = fat32_find_free_cluster();\par
00667     {\cf19 if} (new_cluster == 0) {\cf19 return} {\cf17 false};\par
00668 \par
00669     {\cf20 // Zero out the new cluster}\par
00670     {\cf19 if} (!zero_cluster(new_cluster)) \{\par
00671         fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER); {\cf20 // Free it back}\par
00672         {\cf19 return} {\cf17 false};\par
00673     \}\par
00674 \par
00675     fat32_write_fat(new_cluster, FAT32_EOC_MAX); {\cf20 // Mark as new end of chain}\par
00676 \par
00677     {\cf20 // Find the last cluster in the original chain and link it to the new one}\par
00678     uint32_t current = dir_cluster;\par
00679     uint32_t next = 0;\par
00680     {\cf19 while} ((next = fat32_read_fat(current)) < FAT32_EOC_MIN) \{\par
00681         current = next;\par
00682     \}\par
00683 \par
00684     {\cf19 return} fat32_write_fat(current, new_cluster);\par
00685 \}\par
00686 \par
00687 {\cf17 static} {\cf18 bool} fat32_find_free_dir_slots(uint32_t dir_cluster, uint32_t count, uint32_t* out_sector, uint32_t* out_entry_index) \{\par
00688     uint32_t current_cluster = dir_cluster;\par
00689     {\cf18 void}* sector_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'tecs'});\par
00690     {\cf19 if} (!sector_buf) {\cf19 return} {\cf17 false};\par
00691     MTSTATUS status;\par
00692 \par
00693     {\cf19 do} \{\par
00694         uint32_t sector_lba = first_sector_of_cluster(current_cluster);\par
00695         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; i++) \{\par
00696             status = read_sector(sector_lba + i, sector_buf);\par
00697             {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(sector_buf); {\cf19 return} {\cf17 false}; \}\par
00698 \par
00699             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)sector_buf;\par
00700             uint32_t num_entries = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
00701 \par
00702             {\cf20 // --- CRITICAL FIX: Reset counter for each new sector ---}\par
00703             uint32_t consecutive_free = 0;\par
00704 \par
00705             {\cf19 for} (uint32_t j = 0; j < num_entries; j++) \{\par
00706                 uint8_t first_byte = (uint8_t)entries[j].name[0];\par
00707                 {\cf19 if} (first_byte == END_OF_DIRECTORY || first_byte == DELETED_DIR_ENTRY) \{\par
00708                     {\cf19 if} (consecutive_free == 0) \{\par
00709                         {\cf20 // Mark the start of a potential block}\par
00710                         *out_sector = sector_lba + i;\par
00711                         *out_entry_index = j;\par
00712                     \}\par
00713                     consecutive_free++;\par
00714                     {\cf19 if} (consecutive_free == count) \{\par
00715                         MmFreePool(sector_buf);\par
00716                         {\cf19 return} {\cf17 true};\par
00717                     \}\par
00718                 \}\par
00719                 {\cf19 else} \{\par
00720                     consecutive_free = 0;\par
00721                 \}\par
00722             \}\par
00723         \}\par
00724 \par
00725         uint32_t next_cluster = fat32_read_fat(current_cluster);\par
00726         {\cf19 if} (next_cluster >= FAT32_EOC_MIN) \{\par
00727             MmFreePool(sector_buf);\par
00728             {\cf19 if} (fat32_extend_directory(dir_cluster)) \{\par
00729                 {\cf19 return} fat32_find_free_dir_slots(dir_cluster, count, out_sector, out_entry_index);\par
00730             \}\par
00731             {\cf19 else} \{\par
00732                 {\cf19 return} {\cf17 false};\par
00733             \}\par
00734         \}\par
00735         current_cluster = next_cluster;\par
00736     \} {\cf19 while} ({\cf17 true});\par
00737 \par
00738     MmFreePool(sector_buf);\par
00739     {\cf19 return} {\cf17 false};\par
00740 \}\par
00741 \par
00742 {\cf21 #define BPB_SECTOR_START 2048}\par
00743 \par
00744 {\cf20 // Read BPB (Bios Parameter Block) and initialize.}\par
00745 MTSTATUS fat32_init({\cf18 int} disk_index) \{\par
00746     MTSTATUS status;\par
00747     disk = get_block_device(disk_index);\par
00748     {\cf19 if} (!disk) \{ {\cf19 return} MT_GENERAL_FAILURE; \}\par
00749 \par
00750     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, 512, {\cf22 'TAF'});\par
00751     {\cf19 if} (!buf) {\cf19 return} MT_NO_MEMORY;\par
00752     status = read_sector(BPB_SECTOR_START, buf);\par
00753     {\cf19 if} (MT_FAILURE(status)) \{ {\cf19 return} status; \} {\cf20 // First sector contains the BPB for FAT.}\par
00754     kmemcpy(&bpb, buf, {\cf17 sizeof}(bpb)); {\cf20 // So copy that first sector into our local BPB structure.}\par
00755 \par
00756     {\cf20 // Then initialize it.}\par
00757     fs.bytes_per_sector = bpb.bytes_per_sector;\par
00758     fs.sectors_per_cluster = bpb.sectors_per_cluster;\par
00759     fs.reserved_sector_count = bpb.reserved_sector_count;\par
00760     fs.sectors_per_fat = bpb.fat_size_32;\par
00761     fs.root_cluster = bpb.root_cluster;\par
00762     fs.fat_start = BPB_SECTOR_START + bpb.reserved_sector_count; {\cf20 // technically also reserved_sector_count of fs. holds it as well.}\par
00763     fs.first_data_sector = fs.fat_start + bpb.num_fats * fs.sectors_per_fat; \par
00764     MmFreePool(buf);\par
00765     {\cf19 return} MT_SUCCESS;\par
00766 \}\par
00767 \par
00768 {\cf20 // Walk cluster chain and read directory entries.}\par
00769 {\cf18 void} fat32_list_root({\cf18 void}) \{\par
00770     uint32_t cluster = fs.root_cluster;\par
00771 \par
00772     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fatb'});\par
00773     {\cf19 if} (!buf) {\cf19 return};\par
00774 \par
00775     {\cf20 // Temp buffer to accumulate LFN entries (and eventually the 8.3 entry).}\par
00776     FAT32_DIR_ENTRY temp_entries[MAX_LFN_ENTRIES + 1];\par
00777     uint32_t lfn_accum = 0;\par
00778     MTSTATUS status;\par
00779     {\cf19 do} \{\par
00780         uint32_t sector = first_sector_of_cluster(cluster);\par
00781         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; ++i) \{\par
00782             status = read_sector(sector + i, buf);\par
00783             {\cf19 if} (MT_FAILURE(status)) \{\par
00784                 MmFreePool(buf);\par
00785                 {\cf19 return};\par
00786             \}\par
00787             FAT32_DIR_ENTRY* dir = (FAT32_DIR_ENTRY*)buf;\par
00788             uint32_t entries = fs.bytes_per_sector / {\cf17 sizeof}(*dir);\par
00789 \par
00790             {\cf19 for} (uint32_t j = 0; j < entries; ++j, ++dir) \{\par
00791                 uint8_t first = (uint8_t)dir->name[0];\par
00792 \par
00793                 {\cf20 // End of directory: stop everything}\par
00794                 {\cf19 if} (first == 0x00) \{\par
00795                     MmFreePool(buf);\par
00796                     {\cf19 return};\par
00797                 \}\par
00798 \par
00799                 {\cf20 // Deleted entry: if we were accumulating an LFN chain, drop it.}\par
00800                 {\cf19 if} (first == 0xE5) \{\par
00801                     lfn_accum = 0;\par
00802                     {\cf19 continue};\par
00803                 \}\par
00804 \par
00805                 {\cf20 // If it's an LFN entry, copy it into the temp accumulator (preserve order read-on-disk)}\par
00806                 {\cf19 if} (dir->attr == ATTR_LONG_NAME) \{\par
00807                     {\cf19 if} (lfn_accum < MAX_LFN_ENTRIES) \{\par
00808                         kmemcpy(&temp_entries[lfn_accum], dir, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00809                         lfn_accum++;\par
00810                     \}\par
00811                     {\cf19 else} \{\par
00812                         {\cf20 // too many parts: drop accumulator to avoid overflow}\par
00813                         lfn_accum = 0;\par
00814                     \}\par
00815                     {\cf19 continue};\par
00816                 \}\par
00817                 {\cf20 // Non-LFN entry: this is the 8.3 entry that ends any preceding LFN chain (if present).}\par
00818                 {\cf20 // If we have accumulated LFN entries, build a contiguous array: [LFN...][8.3]}\par
00819                 {\cf18 char} bufferLfn[MAX_LFN_LEN];\par
00820                 uint32_t consumed = 0;\par
00821                 FAT32_DIR_ENTRY* real = NULL;\par
00822 \par
00823                 {\cf19 if} (lfn_accum > 0) \{\par
00824                     {\cf20 // copy the 8.3 entry as the last element}\par
00825                     kmemcpy(&temp_entries[lfn_accum], dir, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
00826                     {\cf20 // call read_lfn on our temp buffer (which starts with LFN entries)}\par
00827                     real = read_lfn(temp_entries, lfn_accum + 1, bufferLfn, &consumed);\par
00828                     {\cf20 // reset accumulator regardless (we've handled or attempted to)}\par
00829                     lfn_accum = 0;\par
00830                 \}\par
00831                 {\cf19 else} \{\par
00832                     {\cf20 // No accumulated LFN entries: handle short-name-only entry}\par
00833                     {\cf20 // We can call read_lfn directly on the sector buffer at current position}\par
00834                     uint32_t remaining = entries - j;\par
00835                     real = read_lfn(&dir[0], remaining, bufferLfn, &consumed);\par
00836                     {\cf20 // note: consumed will be at least 1 if successful}\par
00837                 \}\par
00838 \par
00839                 {\cf20 // If read_lfn returned a real 8.3 entry (it should), print the name}\par
00840                 {\cf19 if} (real) \{\par
00841                     gop_printf(0xFF00FFFF, {\cf22 "Found: %s\\n"}, bufferLfn);\par
00842                 \}\par
00843                 {\cf19 else} \{\par
00844                     {\cf20 // Fallback: if read_lfn failed for some reason, print raw 8.3 as a last resort}\par
00845                     {\cf18 char} fallback[12];\par
00846                     {\cf19 for} ({\cf18 int} k = 0; k < 11; ++k) fallback[k] = dir->name[k];\par
00847                     fallback[11] = {\cf23 '\\0'};\par
00848                     gop_printf(0xFF00FFFF, {\cf22 "Found (raw): %s\\n"}, fallback);\par
00849                 \}\par
00850 \par
00851                 {\cf20 // continue to next entry (we already advanced j by loop)}\par
00852             \} {\cf20 // for each dir entry in sector}\par
00853         \} {\cf20 // for each sector in cluster}\par
00854 \par
00855         cluster = fat32_read_fat(cluster);\par
00856     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
00857 \}\par
00858 \par
00859 {\cf20 // Helper to detect if a filename has a slash in it (/), and so the filename is in a directory}\par
00860 {\cf17 static} {\cf18 bool} is_filename_in_dir({\cf17 const} {\cf18 char}* filename) \{\par
00861     {\cf19 if} (!filename) {\cf19 return} {\cf17 false};\par
00862 \par
00863     {\cf19 while} (*filename) \{\par
00864         {\cf19 if} (*filename == {\cf23 '/'}) {\cf19 return} {\cf17 true};\par
00865         filename++;\par
00866     \}\par
00867 \par
00868     {\cf19 return} {\cf17 false};\par
00869 \}\par
00870 \par
00871 {\cf17 static} uint32_t extract_dir_cluster({\cf17 const} {\cf18 char}* filename) \{\par
00872 \par
00873     {\cf19 if} (!filename || filename[0] == {\cf23 '\\0'}) {\cf19 return} fs.root_cluster;\par
00874 \par
00875     {\cf20 // Make a mutable copy}\par
00876     {\cf18 char} path_copy[260];\par
00877     kstrncpy(path_copy, filename, {\cf17 sizeof}(path_copy));\par
00878 \par
00879     {\cf20 // Remove trailing slashes (keep a single leading '/' if path is "/")}\par
00880     {\cf18 int} len = (int)kstrlen(path_copy);\par
00881     {\cf19 while} (len > 1 && path_copy[len - 1] == {\cf23 '/'}) \{\par
00882         path_copy[len - 1] = {\cf23 '\\0'};\par
00883         len--;\par
00884     \}\par
00885 \par
00886     {\cf20 // Find last slash}\par
00887     {\cf18 int} last_slash = -1;\par
00888     {\cf19 for} ({\cf18 int} i = len - 1; i >= 0; --i) \{\par
00889         {\cf19 if} (path_copy[i] == {\cf23 '/'}) \{ last_slash = i; {\cf19 break}; \}\par
00890     \}\par
00891 \par
00892     {\cf20 // No slash -> file is in root}\par
00893     {\cf19 if} (last_slash == -1) \{\par
00894         {\cf19 return} fs.root_cluster;\par
00895     \}\par
00896 \par
00897     {\cf20 // Parent path is "/" if last_slash == 0, otherwise substring [0..last_slash-1]}\par
00898     {\cf18 char} parent[260];\par
00899     {\cf19 if} (last_slash == 0) \{\par
00900         parent[0] = {\cf23 '/'};\par
00901         parent[1] = {\cf23 '\\0'};\par
00902     \}\par
00903     {\cf19 else} \{\par
00904         {\cf20 // copy up to last_slash}\par
00905         {\cf19 for} ({\cf18 int} i = 0; i < last_slash; ++i) parent[i] = path_copy[i];\par
00906         parent[last_slash] = {\cf23 '\\0'};\par
00907     \}\par
00908 \par
00909     {\cf20 // Resolve the parent path to a directory entry}\par
00910     FAT32_DIR_ENTRY parent_entry;\par
00911     {\cf19 if} (!fat32_find_entry(parent, &parent_entry, NULL)) {\cf19 return} 0;\par
00912 \par
00913     {\cf20 // Ensure it's a directory}\par
00914     {\cf19 if} (!(parent_entry.attr & ATTR_DIRECTORY)) {\cf19 return} 0;\par
00915 \par
00916     uint32_t cluster = ((uint32_t)parent_entry.fst_clus_hi << 16) | parent_entry.fst_clus_lo;\par
00917     {\cf19 if} (cluster == 0) cluster = fs.root_cluster; {\cf20 // safety fallback}\par
00918     {\cf19 return} cluster;\par
00919 \}\par
00920 \par
00921 MTSTATUS fat32_read_file({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out) \{\par
00922     MTSTATUS status;\par
00923     {\cf20 // We still need a temporary buffer for reading sectors}\par
00924     {\cf18 void}* sblk = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'sblk'});\par
00925     {\cf19 if} (!sblk) {\cf19 return} MT_NO_MEMORY;\par
00926 \par
00927     {\cf20 // Get the cluster of the directory filename points to (e.g "tmp/folder/myfile.txt", we need the "folder" cluster.)}\par
00928     uint32_t cluster = 0;\par
00929 \par
00930     {\cf19 if} (is_filename_in_dir(filename)) \{\par
00931         cluster = extract_dir_cluster(filename);\par
00932         {\cf19 if} (!cluster) \{\par
00933             MmFreePool(sblk);\par
00934             {\cf19 return} MT_FAT32_INVALID_CLUSTER;\par
00935         \}\par
00936     \}\par
00937     {\cf19 else} \{\par
00938         cluster = fs.root_cluster;\par
00939     \}\par
00940 \par
00941     {\cf19 do} \{\par
00942         uint32_t sector = first_sector_of_cluster(cluster);\par
00943         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; ++i) \{\par
00944             status = read_sector(sector + i, sblk);\par
00945             {\cf19 if} (MT_FAILURE(status)) \{\par
00946                 {\cf20 // Free sblk before returning}\par
00947                 MmFreePool(sblk);\par
00948                 {\cf19 return} status;\par
00949             \}\par
00950 \par
00951             FAT32_DIR_ENTRY* dir_entries = (FAT32_DIR_ENTRY*)sblk;\par
00952             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
00953 \par
00954             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
00955                 FAT32_DIR_ENTRY* current_entry = &dir_entries[j];\par
00956 \par
00957                 {\cf19 if} (current_entry->name[0] == END_OF_DIRECTORY) \{\par
00958                     {\cf20 // Free sblk}\par
00959                     MmFreePool(sblk);\par
00960                     {\cf19 return} MT_FAT32_FILE_NOT_FOUND; {\cf20 // End of directory, file not found}\par
00961                 \}\par
00962                 {\cf19 if} ((uint8_t)current_entry->name[0] == DELETED_DIR_ENTRY) \{\par
00963                     j++;\par
00964                     {\cf19 continue};\par
00965                 \}\par
00966 \par
00967                 {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
00968                 uint32_t consumed_entries = 0;\par
00969                 FAT32_DIR_ENTRY* sfn_entry = read_lfn(current_entry, entries_per_sector - j, lfn_buf, &consumed_entries);\par
00970 \par
00971                 {\cf19 if} (sfn_entry) \{\par
00972                     {\cf20 // Check if either the long or short filename matches}\par
00973                     {\cf19 if} (kstrcmp(filename, lfn_buf) == 0) \{\par
00974                         {\cf19 goto} file_found;\par
00975                     \}\par
00976 \par
00977                     {\cf18 char} shortname_formatted[11];\par
00978                     format_short_name(filename, shortname_formatted);\par
00979                     {\cf19 if} (cmp_short_name(sfn_entry->name, shortname_formatted)) \{\par
00980                         {\cf19 goto} file_found;\par
00981                     \}\par
00982 \par
00983                     j += consumed_entries; {\cf20 // Skip past all LFN entries and the SFN entry}\par
00984                     {\cf19 continue};\par
00985 \par
00986                 file_found:\par
00987                     \{\par
00988                         uint32_t file_size = sfn_entry->file_size;\par
00989                         {\cf19 if} (file_size_out) \{\par
00990                             *file_size_out = file_size;\par
00991                         \}\par
00992 \par
00993                         {\cf20 // Now allocate the final buffer for the file content}\par
00994                         {\cf18 void}* file_buffer = MmAllocatePoolWithTag(NonPagedPool, file_size, {\cf22 'file'});\par
00995                         {\cf19 if} (!file_buffer) \{\par
00996                             {\cf20 // Free sblk}\par
00997                             MmFreePool(sblk);\par
00998                             {\cf19 return} MT_NO_MEMORY;\par
00999                         \}\par
01000 \par
01001                         uint32_t file_cluster = (uint32_t)((sfn_entry->fst_clus_hi << 16) | sfn_entry->fst_clus_lo);\par
01002                         uint32_t remaining_bytes = file_size;\par
01003                         uint8_t* dst = (uint8_t*)file_buffer;\par
01004 \par
01005                         {\cf19 while} (file_cluster < FAT32_EOC_MIN && remaining_bytes > 0) \{\par
01006                             uint32_t current_sector = first_sector_of_cluster(file_cluster);\par
01007                             {\cf19 for} (uint32_t sc = 0; sc < fs.sectors_per_cluster && remaining_bytes > 0; ++sc) \{\par
01008                                 status = read_sector(current_sector + sc, sblk);\par
01009                                 {\cf19 if} (MT_FAILURE(status)) \{\par
01010                                     {\cf20 // Free both buffers}\par
01011                                     MmFreePool(file_buffer);\par
01012                                     MmFreePool(sblk);\par
01013                                     {\cf19 return} status;\par
01014                                 \}\par
01015 \par
01016                                 uint32_t bytes_to_copy = fs.bytes_per_sector;\par
01017                                 {\cf19 if} (bytes_to_copy > remaining_bytes) \{\par
01018                                     bytes_to_copy = remaining_bytes;\par
01019                                 \}\par
01020 \par
01021                                 kmemcpy(dst, sblk, bytes_to_copy);\par
01022                                 dst += bytes_to_copy;\par
01023                                 remaining_bytes -= bytes_to_copy;\par
01024                             \}\par
01025                             file_cluster = fat32_read_fat(file_cluster);\par
01026                         \}\par
01027 \par
01028                         {\cf20 // Free the temporary sector buffer and return the file buffer}\par
01029                         MmFreePool(sblk);\par
01030                         *buffer_out = file_buffer;\par
01031                         {\cf19 return} MT_SUCCESS;\par
01032                     \}\par
01033                 \}\par
01034                 {\cf19 else} \{\par
01035                     j++; {\cf20 // Move to the next entry if read_lfn fails}\par
01036                 \}\par
01037             \}\par
01038         \}\par
01039         cluster = fat32_read_fat(cluster);\par
01040     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01041 \par
01042     {\cf20 // Free sblk}\par
01043     MmFreePool(sblk);\par
01044     {\cf19 return} MT_FAT32_FILE_NOT_FOUND; {\cf20 // File not found after searching the entire directory}\par
01045 \}\par
01046 \par
01047 MTSTATUS fat32_create_directory({\cf17 const} {\cf18 char}* path) \{\par
01048     {\cf20 // Check if an entry already exists at this path}\par
01049     {\cf19 if} (fat32_find_entry(path, NULL, NULL)) \{\par
01050 {\cf21 #ifdef DEBUG}\par
01051         gop_printf(0xFFFF0000, {\cf22 "Error: Path '%s' already exists.\\n"}, path);\par
01052 {\cf21 #endif}\par
01053         {\cf19 return} MT_FAT32_DIRECTORY_ALREADY_EXISTS;\par
01054     \}\par
01055     MTSTATUS status = MT_GENERAL_FAILURE;\par
01056     {\cf20 // Separate parent path and new directory name}\par
01057     {\cf18 char} path_copy[260];\par
01058     kstrncpy(path_copy, path, {\cf17 sizeof}(path_copy));\par
01059 \par
01060     {\cf18 char}* new_dir_name = NULL;\par
01061     {\cf18 char}* parent_path = {\cf22 "/"};\par
01062 \par
01063     {\cf20 // Remove trailing slashes (except if path is just "/")}\par
01064     {\cf18 int} len = kstrlen(path_copy);\par
01065     {\cf19 while} (len > 1 && path_copy[len - 1] == {\cf23 '/'}) \{\par
01066         path_copy[len - 1] = {\cf23 '\\0'};\par
01067         len--;\par
01068     \}\par
01069 \par
01070     {\cf20 // Find last slash}\par
01071     {\cf18 int} last_slash = -1;\par
01072     {\cf19 for} ({\cf18 int} i = 0; path_copy[i] != {\cf23 '\\0'}; i++) \{\par
01073         {\cf19 if} (path_copy[i] == {\cf23 '/'}) last_slash = i;\par
01074     \}\par
01075 \par
01076     {\cf20 // Split parent path and new directory name}\par
01077     {\cf19 if} (last_slash != -1) \{\par
01078         new_dir_name = &path_copy[last_slash + 1];   {\cf20 // name after last slash}\par
01079         {\cf19 if} (last_slash > 0) \{\par
01080             path_copy[last_slash] = {\cf23 '\\0'};           {\cf20 // terminate parent path}\par
01081             parent_path = path_copy;\par
01082         \}\par
01083         {\cf20 // If last_slash == 0, parent_path stays "/"}\par
01084     \}\par
01085     {\cf19 else} \{\par
01086         {\cf20 // No slashes at all: directory is in root}\par
01087         new_dir_name = path_copy;\par
01088     \}\par
01089 \par
01090 \par
01091     {\cf20 // Find the parent directory cluster}\par
01092     FAT32_DIR_ENTRY parent_entry;\par
01093     uint32_t parent_cluster;\par
01094     {\cf19 if} (!fat32_find_entry(parent_path, &parent_entry, NULL)) \{\par
01095 {\cf21 #ifdef DEBUG}\par
01096         gop_printf(0xFFFF0000, {\cf22 "Error: Parent path '%s' not found.\\n"}, parent_path);\par
01097 {\cf21 #endif}\par
01098         {\cf19 return} MT_FAT32_PARENT_PATH_NOT_FOUND;\par
01099     \}\par
01100     {\cf19 if} (!(parent_entry.attr & ATTR_DIRECTORY)) \{\par
01101 {\cf21 #ifdef DEBUG}\par
01102         gop_printf(0xFFFF0000, {\cf22 "Error: Parent path is not a directory. PATH: %s\\n"}, parent_path);\par
01103 {\cf21 #endif}\par
01104         {\cf19 return} MT_FAT32_PARENT_PATH_NOT_DIR;\par
01105     \}\par
01106     parent_cluster = (parent_entry.fst_clus_hi << 16) | parent_entry.fst_clus_lo;\par
01107 \par
01108     {\cf20 // Allocate a new cluster for this directory's contents}\par
01109     uint32_t new_cluster = fat32_find_free_cluster();\par
01110     {\cf19 if} (new_cluster == 0) {\cf19 return} MT_FAT32_CLUSTERS_FULL;\par
01111 \par
01112     fat32_write_fat(new_cluster, FAT32_EOC_MAX);\par
01113     zero_cluster(new_cluster);\par
01114 \par
01115     {\cf20 // Create '.' and '..' entries in the new cluster}\par
01116     {\cf18 void}* sector_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01117     {\cf19 if} (!sector_buf) \{ {\cf20 /* handle error */} {\cf19 return} MT_MEMORY_LIMIT; \}\par
01118     kmemset(sector_buf, 0, fs.bytes_per_sector);\par
01119     FAT32_DIR_ENTRY* dot_entries = (FAT32_DIR_ENTRY*)sector_buf;\par
01120 \par
01121     kmemcpy(dot_entries[0].name, {\cf22 ".          "}, 11);\par
01122     dot_entries[0].attr = ATTR_DIRECTORY;\par
01123     dot_entries[0].fst_clus_lo = (uint16_t)new_cluster;\par
01124     dot_entries[0].fst_clus_hi = (uint16_t)(new_cluster >> 16);\par
01125 \par
01126     kmemcpy(dot_entries[1].name, {\cf22 "..         "}, 11);\par
01127     dot_entries[1].attr = ATTR_DIRECTORY;\par
01128     dot_entries[1].fst_clus_lo = (uint16_t)parent_cluster;\par
01129     dot_entries[1].fst_clus_hi = (uint16_t)(parent_cluster >> 16);\par
01130 \par
01131     write_sector(first_sector_of_cluster(new_cluster), sector_buf);\par
01132 \par
01133     {\cf20 // Create the entry in the parent directory}\par
01134     {\cf20 // For simplicity, we'll use a simple SFN.}\par
01135     {\cf18 char} sfn[11];\par
01136     format_short_name(new_dir_name, sfn);\par
01137 \par
01138     {\cf20 // Decide whether we need LFN entries:}\par
01139     {\cf18 int} name_len = kstrlen(new_dir_name);\par
01140     {\cf18 int} need_lfn = 0;\par
01141     {\cf19 if} (name_len > 11) need_lfn = 1;\par
01142     {\cf19 else} \{\par
01143         {\cf19 for} ({\cf18 int} i = 0; i < name_len; i++) \{\par
01144             {\cf18 char} c = new_dir_name[i];\par
01145             {\cf19 if} (c >= {\cf23 'a'} && c <= {\cf23 'z'}) \{ need_lfn = 1; {\cf19 break}; \}\par
01146         \}\par
01147     \}\par
01148 \par
01149     uint32_t entry_sector = 0, entry_index = 0;\par
01150 \par
01151     {\cf19 if} (need_lfn) \{\par
01152         {\cf20 // Create LFN + SFN (allocate contiguous slots)}\par
01153         uint8_t checksum = lfn_checksum((uint8_t*)sfn);\par
01154         uint32_t num_lfn_entries = (name_len + 12) / 13;\par
01155         uint32_t total_slots = num_lfn_entries + 1; {\cf20 // LFN entries + SFN}\par
01156 \par
01157         {\cf19 if} (!fat32_find_free_dir_slots(parent_cluster, total_slots, &entry_sector, &entry_index)) \{\par
01158             {\cf20 // free sector_buf, free cluster...}\par
01159             MmFreePool(sector_buf);\par
01160             fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER);\par
01161             {\cf19 return} MT_FAT32_DIR_FULL;\par
01162         \}\par
01163 \par
01164         {\cf20 // Prepare temporary buffer with LFN entries followed by SFN}\par
01165         FAT32_LFN_ENTRY* temp_entries = (FAT32_LFN_ENTRY*)MmAllocatePoolWithTag(NonPagedPool, total_slots * {\cf17 sizeof}(FAT32_LFN_ENTRY), {\cf22 'fat'});\par
01166         {\cf19 if} (!temp_entries) \{\par
01167             MmFreePool(sector_buf);\par
01168             fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER);\par
01169             {\cf19 return} MT_MEMORY_LIMIT;\par
01170         \}\par
01171 \par
01172         kmemset(temp_entries, 0, total_slots * {\cf17 sizeof}(FAT32_LFN_ENTRY));\par
01173 \par
01174         {\cf20 // Fill LFN entries into temp_entries[0 .. num_lfn_entries-1]}\par
01175         fat32_create_lfn_entries(temp_entries, new_dir_name, checksum);\par
01176 \par
01177         {\cf20 // Fill SFN at the end}\par
01178         FAT32_DIR_ENTRY* sfn_entry = (FAT32_DIR_ENTRY*)&temp_entries[num_lfn_entries];\par
01179         kmemset(sfn_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01180         kmemcpy(sfn_entry->name, sfn, 11);\par
01181         sfn_entry->attr = ATTR_DIRECTORY;\par
01182         sfn_entry->fst_clus_lo = (uint16_t)new_cluster;\par
01183         sfn_entry->fst_clus_hi = (uint16_t)(new_cluster >> 16);\par
01184 \par
01185         {\cf20 // Write temp_entries sequentially into parent directory slots (may span sectors)}\par
01186         {\cf17 const} {\cf18 int} entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01187         uint32_t cur_sector = entry_sector;\par
01188         {\cf18 int} cur_index = (int)entry_index;\par
01189         uint32_t remaining = total_slots;\par
01190         uint32_t temp_idx = 0;\par
01191 \par
01192         {\cf19 while} (remaining > 0) \{\par
01193             status = read_sector(cur_sector, sector_buf);\par
01194             {\cf19 if} (MT_FAILURE(status)) \{\par
01195                 {\cf20 // cleanup: free temp, free sector_buf, free cluster}\par
01196                 MmFreePool(temp_entries);\par
01197                 MmFreePool(sector_buf);\par
01198                 fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER);\par
01199                 {\cf19 return} status;\par
01200             \}\par
01201 \par
01202             {\cf18 int} can = entries_per_sector - cur_index;\par
01203             {\cf18 int} to_write = (remaining < (uint32_t)can) ? remaining : (uint32_t)can;\par
01204 \par
01205             {\cf19 for} ({\cf18 int} j = 0; j < to_write; j++) \{\par
01206                 FAT32_DIR_ENTRY* dst = &((FAT32_DIR_ENTRY*)sector_buf)[cur_index + j];\par
01207                 FAT32_DIR_ENTRY* src = (FAT32_DIR_ENTRY*)&temp_entries[temp_idx + j];\par
01208                 kmemcpy(dst, src, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01209             \}\par
01210 \par
01211             status = write_sector(cur_sector, sector_buf);\par
01212             {\cf19 if} (MT_FAILURE(status)) \{\par
01213                 MmFreePool(temp_entries);\par
01214                 MmFreePool(sector_buf);\par
01215                 fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER);\par
01216                 {\cf19 return} status;\par
01217             \}\par
01218 \par
01219             remaining -= to_write;\par
01220             temp_idx += to_write;\par
01221             cur_sector++;\par
01222             cur_index = 0;\par
01223         \}\par
01224 \par
01225         {\cf20 // cleanup temp buffer}\par
01226         MmFreePool(temp_entries);\par
01227         {\cf20 // free sector_buf and return last write status}\par
01228         MmFreePool(sector_buf);\par
01229         {\cf19 return} status;\par
01230     \}\par
01231     {\cf19 else} \{\par
01232         {\cf20 // No LFN needed: simple single-slot SFN write (original behaviour)}\par
01233         {\cf19 if} (!fat32_find_free_dir_slots(parent_cluster, 1, &entry_sector, &entry_index)) \{\par
01234             {\cf20 // free sector_buf, free cluster...}\par
01235             MmFreePool(sector_buf);\par
01236             fat32_write_fat(new_cluster, FAT32_FREE_CLUSTER);\par
01237             {\cf19 return} MT_FAT32_DIR_FULL;\par
01238         \}\par
01239 \par
01240         {\cf20 // Read the target sector, modify it, write it back}\par
01241         status = read_sector(entry_sector, sector_buf);\par
01242         {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(sector_buf); {\cf19 return} status; \}\par
01243 \par
01244         FAT32_DIR_ENTRY* new_entry = &((FAT32_DIR_ENTRY*)sector_buf)[entry_index];\par
01245         kmemset(new_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01246         kmemcpy(new_entry->name, sfn, 11);\par
01247         new_entry->attr = ATTR_DIRECTORY;\par
01248         new_entry->fst_clus_lo = (uint16_t)new_cluster;\par
01249         new_entry->fst_clus_hi = (uint16_t)(new_cluster >> 16);\par
01250 \par
01251         status = write_sector(entry_sector, sector_buf);\par
01252 \par
01253         {\cf20 // free sector_buf}\par
01254         MmFreePool(sector_buf);\par
01255         {\cf19 return} status;\par
01256     \}\par
01257 \}\par
01258 \par
01259 {\cf17 static} TIME_ENTRY convertFat32ToRealtime(uint16_t fat32Time, uint16_t fat32Date) \{\par
01260     TIME_ENTRY time;\par
01261     uint8_t h, m, s;\par
01262     uint8_t mon, day;\par
01263     uint16_t y;\par
01264     fat32_decode_date(fat32Date, &y, &mon, &day);\par
01265     fat32_decode_time(fat32Time, &h, &m, &s);\par
01266     time.hour = h;\par
01267     time.minute = m;\par
01268     time.second = s;\par
01269     time.month = mon;\par
01270     time.day = day;\par
01271     time.year = y;\par
01272     {\cf19 return} time;\par
01273 \}\par
01274 \par
01275 MTSTATUS fat32_write_file({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, uint32_t mode) \{\par
01276     {\cf20 // Safety check.}\par
01277     {\cf19 if} (mode != WRITE_MODE_CREATE_OR_REPLACE && mode != WRITE_MODE_APPEND_EXISTING) \{\par
01278         {\cf19 return} MT_FAT32_INVALID_WRITE_MODE;\par
01279     \}\par
01280     MTSTATUS status = MT_GENERAL_FAILURE;\par
01281     uint32_t first_cluster = 0;\par
01282 \par
01283     {\cf20 // --- Step 1: Safely parse parent path and filename ---}\par
01284     {\cf18 char} parent_path_buf[260];\par
01285     {\cf18 char} filename_buf[260];\par
01286     {\cf18 int} last_slash = -1;\par
01287     {\cf19 for} ({\cf18 int} len = 0; path[len] != {\cf23 '\\0'}; len++) \{\par
01288         {\cf19 if} (path[len] == {\cf23 '/'}) \{\par
01289             last_slash = len;\par
01290         \}\par
01291     \}\par
01292 \par
01293     {\cf19 if} (last_slash == -1) \{\par
01294         {\cf20 // No slash, e.g., "file.txt". Parent is root.}\par
01295         kstrcpy(parent_path_buf, {\cf22 "/"});\par
01296         kstrncpy(filename_buf, path, {\cf17 sizeof}(filename_buf) - 1);\par
01297         filename_buf[{\cf17 sizeof}(filename_buf) - 1] = {\cf23 '\\0'};\par
01298     \}\par
01299     {\cf19 else} \{\par
01300         {\cf20 // Slash found.}\par
01301         kstrncpy(filename_buf, &path[last_slash + 1], {\cf17 sizeof}(filename_buf) - 1);\par
01302         filename_buf[{\cf17 sizeof}(filename_buf) - 1] = {\cf23 '\\0'};\par
01303         {\cf19 if} (last_slash == 0) \{\par
01304             {\cf20 // Path is "/file.txt". Parent is root.}\par
01305             kstrcpy(parent_path_buf, {\cf22 "/"});\par
01306         \}\par
01307         {\cf19 else} \{\par
01308             {\cf20 // Path is "/testdir/file.txt". Copy the parent part.}\par
01309             {\cf18 size_t} parent_len = last_slash;\par
01310             {\cf19 if} (parent_len >= {\cf17 sizeof}(parent_path_buf)) \{\par
01311                 parent_len = {\cf17 sizeof}(parent_path_buf) - 1; {\cf20 // Truncate}\par
01312             \}\par
01313             kmemcpy(parent_path_buf, path, parent_len);\par
01314             parent_path_buf[parent_len] = {\cf23 '\\0'};\par
01315         \}\par
01316     \}\par
01317 \par
01318     {\cf18 char}* filename = filename_buf;\par
01319     {\cf18 char}* parent_path = parent_path_buf;\par
01320 \par
01321     {\cf20 // --- Step 2: Find parent directory and check for existing file ---}\par
01322     FAT32_DIR_ENTRY parent_entry;\par
01323     {\cf19 if} (!fat32_find_entry(parent_path, &parent_entry, NULL) || !(parent_entry.attr & ATTR_DIRECTORY)) \{\par
01324         {\cf19 return} MT_FAT32_CLUSTER_NOT_FOUND;\par
01325     \}\par
01326     uint32_t parent_cluster = (parent_entry.fst_clus_hi << 16) | parent_entry.fst_clus_lo;\par
01327 \par
01328     FAT32_DIR_ENTRY existing_entry;\par
01329     {\cf18 bool} exists = fat32_find_entry(path, &existing_entry, NULL);\par
01330 \par
01331     {\cf20 // Helper: locate on-disk sector + index for the entry (so we can update SFN/LFN in-place)}\par
01332     uint32_t located_sector = 0;\par
01333     uint32_t located_index = 0;\par
01334     uint32_t located_consumed = 0;\par
01335     {\cf18 bool} located = {\cf17 false};\par
01336     {\cf19 if} (exists) \{\par
01337         {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01338         {\cf19 if} (!buf) {\cf19 return} MT_NO_MEMORY;\par
01339         uint32_t cluster = parent_cluster;\par
01340         {\cf19 do} \{\par
01341             uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01342             {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01343                 status = read_sector(sector_lba + s, buf);\par
01344                 {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} status; \}\par
01345                 FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01346                 uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01347 \par
01348                 {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01349                     uint8_t first = (uint8_t)entries[j].name[0];\par
01350                     {\cf19 if} (first == END_OF_DIRECTORY) \{ MmFreePool(buf); {\cf19 goto} locate_done; \}\par
01351                     {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01352 \par
01353                     {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
01354                     uint32_t consumed = 0;\par
01355                     FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_buf, &consumed);\par
01356                     {\cf19 if} (sfn) \{\par
01357                         {\cf19 if} (ci_equal(lfn_buf, filename)) \{\par
01358                             located_sector = sector_lba + s;\par
01359                             located_index = j;\par
01360                             located_consumed = consumed;\par
01361                             located = {\cf17 true};\par
01362                             MmFreePool(buf);\par
01363                             {\cf19 goto} locate_done;\par
01364                         \}\par
01365                         j += consumed;\par
01366                     \}\par
01367                     {\cf19 else} \{\par
01368                         j++;\par
01369                     \}\par
01370                 \}\par
01371             \}\par
01372             cluster = fat32_read_fat(cluster);\par
01373         \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01374         MmFreePool(buf);\par
01375     \}\par
01376 locate_done:\par
01377 \par
01378     {\cf20 // Step 3: Handle existing file based on write mode}\par
01379     {\cf19 if} (exists) first_cluster = (existing_entry.fst_clus_hi << 16) | existing_entry.fst_clus_lo;\par
01380 \par
01381     {\cf19 if} (mode == WRITE_MODE_CREATE_OR_REPLACE) \{\par
01382         {\cf19 if} (exists && first_cluster >= 2) \{\par
01383             {\cf19 if} (!fat32_free_cluster_chain(first_cluster)) \{\par
01384                 {\cf19 return} MT_FAT32_INVALID_CLUSTER;\par
01385             \}\par
01386         \}\par
01387         first_cluster = 0;\par
01388     \}\par
01389 \par
01390     {\cf20 // Step 4: Allocate clusters and write file data}\par
01391     {\cf19 if} (size > 0) \{\par
01392         uint32_t cluster_size = fs.sectors_per_cluster * fs.bytes_per_sector;\par
01393         uint32_t clusters_needed = 0;\par
01394         uint32_t last_cluster = 0;\par
01395         uint32_t append_offset = 0;\par
01396 \par
01397         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists && first_cluster != 0) \{\par
01398             uint32_t cur = first_cluster;\par
01399             {\cf19 if} (existing_entry.file_size > 0) \{\par
01400                 {\cf19 while} (cur < FAT32_EOC_MIN) \{\par
01401                     uint32_t next = fat32_read_fat(cur);\par
01402                     {\cf19 if} (next >= FAT32_EOC_MIN) \{ last_cluster = cur; {\cf19 break}; \}\par
01403                     cur = next;\par
01404                 \}\par
01405                 append_offset = existing_entry.file_size % cluster_size;\par
01406             \}\par
01407         \}\par
01408 \par
01409         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists && append_offset > 0) \{\par
01410             uint32_t bytes_fit = cluster_size - append_offset;\par
01411             {\cf19 if} (size > bytes_fit) \{\par
01412                 clusters_needed = (size - bytes_fit + cluster_size - 1) / cluster_size;\par
01413             \}\par
01414         \}\par
01415         {\cf19 else} \{\par
01416             clusters_needed = (size + cluster_size - 1) / cluster_size;\par
01417         \}\par
01418 \par
01419         uint32_t first_new = 0;\par
01420         uint32_t prev_cluster = 0;\par
01421         {\cf19 for} (uint32_t i = 0; i < clusters_needed; ++i) \{\par
01422             uint32_t nc = fat32_find_free_cluster();\par
01423             {\cf19 if} (nc == 0) \{\par
01424                 {\cf19 if} (first_new) fat32_free_cluster_chain(first_new);\par
01425                 {\cf19 return} MT_FAT32_CLUSTERS_FULL;\par
01426             \}\par
01427             zero_cluster(nc);\par
01428             {\cf19 if} (first_new == 0) first_new = nc;\par
01429             {\cf19 if} (prev_cluster != 0) fat32_write_fat(prev_cluster, nc);\par
01430             prev_cluster = nc;\par
01431         \}\par
01432         {\cf19 if} (prev_cluster != 0) fat32_write_fat(prev_cluster, FAT32_EOC_MAX);\par
01433 \par
01434         {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists && first_new != 0) \{\par
01435             {\cf19 if} (last_cluster == 0) \{\par
01436                 first_cluster = first_new;\par
01437             \}\par
01438             {\cf19 else} \{\par
01439                 fat32_write_fat(last_cluster, first_new);\par
01440             \}\par
01441         \}\par
01442         {\cf19 else} {\cf19 if} (mode != WRITE_MODE_APPEND_EXISTING || !exists) \{\par
01443             {\cf19 if} (first_new != 0) first_cluster = first_new;\par
01444         \}\par
01445 \par
01446         {\cf18 void}* sector_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01447         {\cf19 if} (!sector_buf) \{\par
01448             {\cf19 if} (first_new) fat32_free_cluster_chain(first_new);\par
01449             {\cf19 return} MT_NO_MEMORY;\par
01450         \}\par
01451 \par
01452         {\cf17 const} uint8_t* src = ({\cf17 const} uint8_t*)data;\par
01453         uint32_t bytes_left = size;\par
01454         uint32_t write_cluster = (mode == WRITE_MODE_APPEND_EXISTING && exists && append_offset > 0) ? last_cluster : first_cluster;\par
01455 \par
01456         {\cf19 while} (bytes_left > 0 && write_cluster < FAT32_EOC_MIN) \{\par
01457             uint32_t sector_lba = first_sector_of_cluster(write_cluster);\par
01458             uint32_t start_offset_in_cluster = (write_cluster == last_cluster && append_offset > 0) ? append_offset : 0;\par
01459 \par
01460             {\cf19 for} (uint32_t s = start_offset_in_cluster / fs.bytes_per_sector; s < fs.sectors_per_cluster && bytes_left > 0; ++s) \{\par
01461                 uint32_t off_in_sector = (s == start_offset_in_cluster / fs.bytes_per_sector) ? start_offset_in_cluster % fs.bytes_per_sector : 0;\par
01462                 uint32_t to_write = fs.bytes_per_sector - off_in_sector;\par
01463                 {\cf19 if} (to_write > bytes_left) to_write = bytes_left;\par
01464 \par
01465                 {\cf19 if} (off_in_sector > 0 || to_write < fs.bytes_per_sector) \{\par
01466                     read_sector(sector_lba + s, sector_buf);\par
01467                 \}\par
01468                 kmemcpy((uint8_t*)sector_buf + off_in_sector, src, to_write);\par
01469                 write_sector(sector_lba + s, sector_buf);\par
01470 \par
01471                 src += to_write;\par
01472                 bytes_left -= to_write;\par
01473             \}\par
01474             append_offset = 0; {\cf20 // Only matters for the very first cluster write in an append op}\par
01475             write_cluster = fat32_read_fat(write_cluster);\par
01476         \}\par
01477         MmFreePool(sector_buf);\par
01478     \}\par
01479 \par
01480     {\cf20 // --- Step 5: Prepare directory entry data (LFN + SFN) ---}\par
01481     {\cf18 char} sfn[11];\par
01482     format_short_name(filename, sfn);\par
01483     uint8_t checksum = lfn_checksum((uint8_t*)sfn);\par
01484 \par
01485     uint32_t lfn_count = (kstrlen(filename) + 12) / 13;\par
01486     uint32_t total_entries = lfn_count + 1;\par
01487     FAT32_LFN_ENTRY* entry_buf = (FAT32_LFN_ENTRY*)MmAllocatePoolWithTag(NonPagedPool, total_entries * {\cf17 sizeof}(FAT32_LFN_ENTRY), {\cf22 'fat'});\par
01488     {\cf19 if} (!entry_buf) \{\par
01489         {\cf19 if} (mode != WRITE_MODE_APPEND_EXISTING || !exists) \{\par
01490             {\cf19 if} (first_cluster) fat32_free_cluster_chain(first_cluster);\par
01491         \}\par
01492         {\cf19 return} MT_NO_MEMORY;\par
01493     \}\par
01494 \par
01495     fat32_create_lfn_entries(entry_buf, filename, checksum);\par
01496 \par
01497     FAT32_DIR_ENTRY* sfn_entry = (FAT32_DIR_ENTRY*)&entry_buf[lfn_count];\par
01498     kmemset(sfn_entry, 0, {\cf17 sizeof}(FAT32_DIR_ENTRY));\par
01499     kmemcpy(sfn_entry->name, sfn, 11);\par
01500     sfn_entry->attr = 0; {\cf20 // File attribute}\par
01501     uint32_t final_size = size;\par
01502     {\cf19 if} (mode == WRITE_MODE_APPEND_EXISTING && exists) final_size = existing_entry.file_size + size;\par
01503     sfn_entry->file_size = final_size;\par
01504     sfn_entry->fst_clus_lo = (uint16_t)first_cluster;\par
01505     sfn_entry->fst_clus_hi = (uint16_t)(first_cluster >> 16);\par
01506 \par
01507     {\cf20 // --- Step 6: Safely find space and write directory entries ---}\par
01508 \par
01509     {\cf20 // If the file existed before, we must mark its old directory entries as deleted.}\par
01510     {\cf19 if} (exists && located) \{\par
01511         {\cf18 void}* delete_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01512         {\cf19 if} (delete_buf) \{\par
01513             {\cf20 // This logic assumes old entries are in one sector. A more complex implementation}\par
01514             {\cf20 // would loop across sectors if located_consumed + located_index > entries_per_sector.}\par
01515             status = read_sector(located_sector, delete_buf);\par
01516             {\cf19 if} (MT_SUCCEEDED(status)) \{\par
01517                 FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)delete_buf;\par
01518                 {\cf19 for} (uint32_t k = 0; k < located_consumed; ++k) \{\par
01519                     {\cf19 if} ((located_index + k) < (fs.bytes_per_sector / 32)) \{\par
01520                         entries[located_index + k].name[0] = DELETED_DIR_ENTRY;\par
01521                     \}\par
01522                 \}\par
01523                 write_sector(located_sector, delete_buf);\par
01524             \}\par
01525             MmFreePool(delete_buf);\par
01526         \}\par
01527     \}\par
01528 \par
01529     uint32_t entry_sector, entry_index;\par
01530     {\cf19 if} (!fat32_find_free_dir_slots(parent_cluster, total_entries, &entry_sector, &entry_index)) \{\par
01531         {\cf19 if} (mode != WRITE_MODE_APPEND_EXISTING || !exists) \{\par
01532             {\cf19 if} (first_cluster) fat32_free_cluster_chain(first_cluster);\par
01533         \}\par
01534         MmFreePool(entry_buf);\par
01535         {\cf19 return} MT_FAT32_DIR_FULL;\par
01536     \}\par
01537 \par
01538     {\cf18 void}* write_buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01539     {\cf19 if} (!write_buf) \{ MmFreePool(entry_buf); {\cf19 return} MT_NO_MEMORY; \}\par
01540 \par
01541     uint32_t current_sector = entry_sector;\par
01542     uint32_t current_index_in_sector = entry_index;\par
01543     uint32_t entries_remaining = total_entries;\par
01544     uint8_t* source_entry = (uint8_t*)entry_buf;\par
01545     {\cf17 const} uint32_t entries_per_sector = fs.bytes_per_sector / 32;\par
01546 \par
01547     {\cf19 while} (entries_remaining > 0) \{\par
01548         status = read_sector(current_sector, write_buf);\par
01549         {\cf19 if} (MT_FAILURE(status)) \{\par
01550             MmFreePool(write_buf);\par
01551             MmFreePool(entry_buf);\par
01552             {\cf19 return} status;\par
01553         \}\par
01554 \par
01555         uint32_t space_in_sector = entries_per_sector - current_index_in_sector;\par
01556         uint32_t entries_to_write = (entries_remaining < space_in_sector) ? entries_remaining : space_in_sector;\par
01557 \par
01558         kmemcpy((uint8_t*)write_buf + current_index_in_sector * 32, source_entry, entries_to_write * 32);\par
01559 \par
01560         status = write_sector(current_sector, write_buf);\par
01561         {\cf19 if} (MT_FAILURE(status)) \{\par
01562             MmFreePool(write_buf);\par
01563             MmFreePool(entry_buf);\par
01564             {\cf19 return} status;\par
01565         \}\par
01566 \par
01567         entries_remaining -= entries_to_write;\par
01568         source_entry += entries_to_write * 32;\par
01569 \par
01570         current_sector++; {\cf20 // Assumes contiguous sectors within a cluster}\par
01571         current_index_in_sector = 0;\par
01572     \}\par
01573 \par
01574     MmFreePool(write_buf);\par
01575     MmFreePool(entry_buf);\par
01576     {\cf19 return} status;\par
01577 \}\par
01578 \par
01579 MTSTATUS fat32_list_directory({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len) \{\par
01580     MTSTATUS status;\par
01581     {\cf20 // Find the directory entry for the given path to get its starting cluster.}\par
01582     FAT32_DIR_ENTRY dir_entry;\par
01583     {\cf19 if} (!fat32_find_entry(path, &dir_entry, NULL) || !(dir_entry.attr & ATTR_DIRECTORY)) \{\par
01584         gop_printf(0xFFFF0000, {\cf22 "Error: Directory not found or path is not a directory: %s\\n"}, path);\par
01585         {\cf19 return} MT_FAT32_DIRECTORY_NOT_FOUND;\par
01586     \}\par
01587 \par
01588     uint32_t cluster = (uint32_t)((dir_entry.fst_clus_hi << 16) | dir_entry.fst_clus_lo);\par
01589     {\cf19 if} (cluster == 0) \{ {\cf20 // Root directory special case on some FAT16/12, but for FAT32 it should be root_cluster.}\par
01590         cluster = fs.root_cluster;\par
01591     \}\par
01592 \par
01593     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01594     {\cf19 if} (!buf) {\cf19 return} MT_NO_MEMORY;\par
01595 \par
01596     {\cf19 if} (max_len > 0) listings[0] = {\cf23 '\\0'};\par
01597     {\cf18 size_t} used = 0;\par
01598 \par
01599     {\cf19 do} \{\par
01600         uint32_t sector = first_sector_of_cluster(cluster);\par
01601         {\cf18 bool} end_of_dir = {\cf17 false};\par
01602 \par
01603         {\cf19 for} (uint32_t i = 0; i < fs.sectors_per_cluster; ++i) \{\par
01604             status = read_sector(sector + i, buf);\par
01605             {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} status; \}\par
01606 \par
01607             FAT32_DIR_ENTRY* dir = (FAT32_DIR_ENTRY*)buf;\par
01608             uint32_t entries = fs.bytes_per_sector / {\cf17 sizeof}(*dir);\par
01609 \par
01610             {\cf19 for} (uint32_t j = 0; j < entries; ) \{\par
01611                 FAT32_DIR_ENTRY* current_entry = &dir[j];\par
01612 \par
01613                 {\cf19 if} (current_entry->name[0] == END_OF_DIRECTORY) \{\par
01614                     end_of_dir = {\cf17 true};\par
01615                     {\cf19 break}; {\cf20 // stop scanning entries in this sector -> will break outer loops below}\par
01616                 \}\par
01617 \par
01618                 {\cf19 if} ((uint8_t)current_entry->name[0] == DELETED_DIR_ENTRY ||\par
01619                     (current_entry->name[0] == {\cf23 '.'} && (current_entry->name[1] == {\cf23 '\\0'} || current_entry->name[1] == {\cf23 '.'}))) \{\par
01620                     j++;\par
01621                     {\cf19 continue};\par
01622                 \}\par
01623 \par
01624                 {\cf18 char} lfn_name[MAX_LFN_LEN];\par
01625                 uint32_t consumed = 0;\par
01626                 FAT32_DIR_ENTRY* sfn_entry = read_lfn(current_entry, entries - j, lfn_name, &consumed);\par
01627                 {\cf18 char} line_buf[256];\par
01628                 {\cf19 if} (sfn_entry) \{\par
01629                     {\cf19 if} (sfn_entry->attr & ATTR_DIRECTORY) \{\par
01630                         ksnprintf(line_buf, {\cf17 sizeof}(line_buf), {\cf22 "<DIR>  %s\\n"}, lfn_name);\par
01631                     \}\par
01632                     {\cf19 else} \{\par
01633                         ksnprintf(line_buf, {\cf17 sizeof}(line_buf), {\cf22 "%s   (%u bytes)\\n"}, lfn_name, sfn_entry->file_size);\par
01634                     \}\par
01635                     {\cf20 // safe append: compute remaining and append up to remaining-1}\par
01636                     {\cf18 size_t} avail = (used < max_len) ? (max_len - used) : 0;\par
01637                     {\cf19 if} (avail > 1) \{\par
01638                         {\cf20 // write directly into listings+used}\par
01639                         ksnprintf(listings + used, avail, {\cf22 "%s"}, line_buf);\par
01640                         used = kstrlen(listings);\par
01641                     \}\par
01642                     j += consumed;\par
01643                 \}\par
01644                 {\cf19 else} \{\par
01645                     j++;\par
01646                 \}\par
01647             \}\par
01648 \par
01649             {\cf19 if} (end_of_dir) {\cf19 break};\par
01650         \}\par
01651 \par
01652         {\cf19 if} (end_of_dir) {\cf19 break};\par
01653 \par
01654         cluster = fat32_read_fat(cluster);\par
01655     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01656 \par
01657     MmFreePool(buf);\par
01658     {\cf19 return} MT_SUCCESS;\par
01659 \}\par
01660 \par
01661 {\cf20 // Check that a directory cluster contains only '.' and '..' (and deleted entries).}\par
01662 {\cf20 // Returns true if empty ,false if non-empty or error.}\par
01663 {\cf18 bool} fat32_directory_is_empty({\cf17 const} {\cf18 char}* path) \{\par
01664 \par
01665     FAT32_DIR_ENTRY entry;\par
01666     uint32_t parent_cluster = 0;\par
01667     fat32_find_entry(path, &entry, &parent_cluster);\par
01668 \par
01669     uint32_t dir_cluster = get_dir_cluster(&entry);\par
01670     {\cf19 if} (dir_cluster == 0) {\cf19 return} {\cf17 false};\par
01671 \par
01672     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01673     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
01674 \par
01675     uint32_t cluster = dir_cluster;\par
01676     MTSTATUS status;\par
01677     {\cf19 do} \{\par
01678         uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01679         {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01680             status = read_sector(sector_lba + s, buf);\par
01681             {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} {\cf17 false}; \}\par
01682 \par
01683             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01684             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01685 \par
01686             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01687                 uint8_t first = (uint8_t)entries[j].name[0];\par
01688 \par
01689                 {\cf19 if} (first == END_OF_DIRECTORY) \{ MmFreePool(buf); {\cf19 return} {\cf17 true}; \} {\cf20 // no more entries}\par
01690                 {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01691 \par
01692                 {\cf20 // Build full name (LFN or SFN)}\par
01693                 {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
01694                 uint32_t consumed = 0;\par
01695                 FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_buf, &consumed);\par
01696                 {\cf19 if} (!sfn) \{ j++; {\cf19 continue}; \}\par
01697 \par
01698                 {\cf20 // skip '.' and '..'}\par
01699                 {\cf19 if} (({\cf18 unsigned} {\cf18 char})sfn->name[0] == {\cf23 '.'}) \{\par
01700                     j += consumed;\par
01701                     {\cf19 continue};\par
01702                 \}\par
01703 \par
01704                 {\cf20 // There is a non-deleted entry that is not '.'/'..' -> directory not empty}\par
01705                 MmFreePool(buf);\par
01706                 {\cf19 return} {\cf17 false};\par
01707             \}\par
01708         \}\par
01709         cluster = fat32_read_fat(cluster);\par
01710     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01711 \par
01712     MmFreePool(buf);\par
01713     {\cf19 return} {\cf17 true};\par
01714 \}\par
01715 \par
01716 {\cf20 // Mark the SFN and all preceding LFN entries for `filename` in parent_cluster as deleted.}\par
01717 {\cf20 // `path` is the full path. parent_cluster is cluster of parent directory.}\par
01718 {\cf20 // Returns true on success (sector written), false otherwise.}\par
01719 {\cf17 static} {\cf18 bool} mark_entry_and_lfns_deleted({\cf17 const} {\cf18 char}* path, uint32_t parent_cluster) \{\par
01720     {\cf20 // extract filename (last component)}\par
01721     {\cf18 char} path_copy[260];\par
01722     kstrncpy(path_copy, path, {\cf17 sizeof}(path_copy));\par
01723     {\cf18 int} len = (int)kstrlen(path_copy);\par
01724     {\cf20 // strip trailing slashes}\par
01725     {\cf19 while} (len > 1 && path_copy[len - 1] == {\cf23 '/'}) \{ path_copy[--len] = {\cf23 '\\0'}; \}\par
01726 \par
01727     {\cf18 int} last_slash = -1;\par
01728     {\cf19 for} ({\cf18 int} i = len - 1; i >= 0; --i) \{\par
01729         {\cf19 if} (path_copy[i] == {\cf23 '/'}) \{ last_slash = i; {\cf19 break}; \}\par
01730     \}\par
01731 \par
01732     {\cf17 const} {\cf18 char}* filename = (last_slash == -1) ? path_copy : &path_copy[last_slash + 1];\par
01733 \par
01734     {\cf20 // Prepare SFN format for short-name comparison}\par
01735     {\cf18 char} sfn_formatted[11];\par
01736     format_short_name(filename, sfn_formatted);\par
01737 \par
01738     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01739     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
01740 \par
01741     uint32_t cluster = parent_cluster;\par
01742     MTSTATUS status;\par
01743     {\cf19 do} \{\par
01744         uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01745         {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01746             status = read_sector(sector_lba + s, buf);\par
01747             {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} {\cf17 false}; \}\par
01748 \par
01749             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01750             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01751 \par
01752             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01753                 uint8_t first = (uint8_t)entries[j].name[0];\par
01754 \par
01755                 {\cf19 if} (first == END_OF_DIRECTORY) \{ MmFreePool(buf); {\cf19 return} {\cf17 false}; \} {\cf20 // not found in parent}\par
01756                 {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01757 \par
01758                 {\cf18 char} lfn_buf[MAX_LFN_LEN];\par
01759                 uint32_t consumed = 0;\par
01760                 FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_buf, &consumed);\par
01761 \par
01762                 {\cf19 if} (sfn) \{\par
01763                     {\cf20 // Match by LFN (exact), LFN (case-insensitive), or SFN bytes}\par
01764                     {\cf18 bool} match = {\cf17 false};\par
01765 \par
01766                     {\cf20 // 1) exact LFN match}\par
01767                     {\cf19 if} (kstrcmp(lfn_buf, filename) == 0) \{\par
01768                         match = {\cf17 true};\par
01769                     \}\par
01770 \par
01771                     {\cf20 // 2) case-insensitive LFN match}\par
01772                     {\cf19 if} (!match && ci_equal(lfn_buf, filename)) \{\par
01773                         match = {\cf17 true};\par
01774                     \}\par
01775 \par
01776                     {\cf20 // 3) SFN byte-wise compare (token formatted)}\par
01777                     {\cf19 if} (!match && cmp_short_name(sfn->name, sfn_formatted)) \{\par
01778                         match = {\cf17 true};\par
01779                     \}\par
01780 \par
01781                     {\cf19 if} (match) \{\par
01782                         {\cf20 // Mark all consumed entries (LFN...SFN) as deleted (0xE5)}\par
01783                         {\cf19 for} (uint32_t k = 0; k < consumed; ++k) \{\par
01784                             ((uint8_t*)entries[j + k].name)[0] = DELETED_DIR_ENTRY;\par
01785                         \}\par
01786 \par
01787                         {\cf20 // Write sector back to disk}\par
01788                         {\cf18 bool} ok = write_sector(sector_lba + s, buf);\par
01789                         MmFreePool(buf);\par
01790                         {\cf19 return} ok;\par
01791                     \}\par
01792 \par
01793                     j += consumed;\par
01794                     {\cf19 continue};\par
01795                 \}\par
01796                 {\cf19 else} \{\par
01797                     {\cf20 // read_lfn failed (corrupted LFN chain?), skip this entry}\par
01798                     j++;\par
01799                 \}\par
01800             \}\par
01801         \}\par
01802         cluster = fat32_read_fat(cluster);\par
01803     \} {\cf19 while} (cluster < FAT32_EOC_MIN);\par
01804 \par
01805     MmFreePool(buf);\par
01806     {\cf19 return} {\cf17 false}; {\cf20 // not found}\par
01807 \}\par
01808 \par
01809 \par
01810 {\cf20 // Recursively delete directory contents and free the directory's cluster chain.}\par
01811 {\cf20 // This function deletes all children (files & subdirs) found inside dir_cluster,}\par
01812 {\cf20 // marks their directory entries as DELETED on disk, and finally frees dir_cluster itself.}\par
01813 {\cf20 // Returns true on success, false on any error.}\par
01814 {\cf17 static} {\cf18 bool} fat32_rm_rf_dir(uint32_t dir_cluster) \{\par
01815 \par
01816     {\cf19 if} (dir_cluster == 0 || dir_cluster == fs.root_cluster) {\cf19 return} {\cf17 false}; {\cf20 // never delete root here}\par
01817 \par
01818     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, fs.bytes_per_sector, {\cf22 'fat'});\par
01819     {\cf19 if} (!buf) {\cf19 return} {\cf17 false};\par
01820 \par
01821     uint32_t cluster = dir_cluster;\par
01822     {\cf20 // Iterate cluster chain}\par
01823     MTSTATUS status;\par
01824     {\cf19 while} (cluster < FAT32_EOC_MIN) \{\par
01825         uint32_t sector_lba = first_sector_of_cluster(cluster);\par
01826 \par
01827         {\cf19 for} (uint32_t s = 0; s < fs.sectors_per_cluster; ++s) \{\par
01828             status = read_sector(sector_lba + s, buf);\par
01829             {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} {\cf17 false}; \}\par
01830 \par
01831             FAT32_DIR_ENTRY* entries = (FAT32_DIR_ENTRY*)buf;\par
01832             uint32_t entries_per_sector = fs.bytes_per_sector / {\cf17 sizeof}(FAT32_DIR_ENTRY);\par
01833 \par
01834             {\cf19 for} (uint32_t j = 0; j < entries_per_sector; ) \{\par
01835                 uint8_t first = (uint8_t)entries[j].name[0];\par
01836 \par
01837                 {\cf20 // End of directory: nothing after this in this directory}\par
01838                 {\cf19 if} (first == END_OF_DIRECTORY) \{\par
01839                     {\cf20 // we can stop scanning this directory entirely}\par
01840                     {\cf20 // free buffer and break out to free cluster chain}\par
01841                     MmFreePool(buf);\par
01842                     {\cf19 goto} free_and_return;\par
01843                 \}\par
01844 \par
01845                 {\cf20 // Deleted entry: skip}\par
01846                 {\cf19 if} (first == DELETED_DIR_ENTRY) \{ j++; {\cf19 continue}; \}\par
01847 \par
01848                 {\cf20 // Attempt to read LFN + SFN at this position}\par
01849                 {\cf18 char} lfn_name[MAX_LFN_LEN];\par
01850                 uint32_t consumed = 0;\par
01851                 FAT32_DIR_ENTRY* sfn = read_lfn(&entries[j], entries_per_sector - j, lfn_name, &consumed);\par
01852 \par
01853                 {\cf19 if} (!sfn) \{\par
01854                     {\cf20 // corrupted chain or not an entry we can parse: skip single entry}\par
01855                     j++;\par
01856                     {\cf19 continue};\par
01857                 \}\par
01858 \par
01859                 {\cf20 // Skip '.' and '..' entries}\par
01860                 {\cf19 if} (({\cf18 unsigned} {\cf18 char})sfn->name[0] == {\cf23 '.'}) \{\par
01861                     j += consumed;\par
01862                     {\cf19 continue};\par
01863                 \}\par
01864 \par
01865                 {\cf20 // If directory -> recurse}\par
01866                 {\cf19 if} (sfn->attr & ATTR_DIRECTORY) \{\par
01867                     uint32_t child_cluster = get_dir_cluster(sfn);\par
01868                     {\cf19 if} (child_cluster != 0 && child_cluster != 1 && child_cluster != dir_cluster) \{\par
01869                         {\cf20 // Recursively delete child directory contents and free its clusters.}\par
01870                         {\cf19 if} (!fat32_rm_rf_dir(child_cluster)) \{\par
01871                             {\cf20 // recursion failed \'EF\'BF\'BD return false}\par
01872                             MmFreePool(buf);\par
01873                             {\cf19 return} {\cf17 false};\par
01874                         \}\par
01875                         {\cf20 // At this point child's clusters are freed by the recursive call.}\par
01876                     \}\par
01877                     {\cf20 // After child deleted, mark child's LFN+SFN entries as deleted in this parent sector}\par
01878                     {\cf19 for} (uint32_t k = 0; k < consumed; ++k) \{\par
01879                         ((uint8_t*)entries[j + k].name)[0] = DELETED_DIR_ENTRY;\par
01880                     \}\par
01881                     {\cf20 // write this sector back}\par
01882                     status = write_sector(sector_lba + s, buf);\par
01883                     {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} {\cf17 false}; \}\par
01884                     {\cf20 // advance past consumed entries}\par
01885                     j += consumed;\par
01886                     {\cf19 continue};\par
01887                 \}\par
01888                 {\cf19 else} \{\par
01889                     {\cf20 // It's a file: free its cluster chain (if any) then mark entries deleted}\par
01890                     uint32_t file_cluster = get_dir_cluster(sfn);\par
01891                     {\cf19 if} (file_cluster >= 2) \{\par
01892                         {\cf19 if} (!fat32_free_cluster_chain(file_cluster)) \{\par
01893                             MmFreePool(buf);\par
01894                             {\cf19 return} {\cf17 false};\par
01895                         \}\par
01896                     \}\par
01897                     {\cf20 // mark the LFN+SFN entries as deleted}\par
01898                     {\cf19 for} (uint32_t k = 0; k < consumed; ++k) \{\par
01899                         ((uint8_t*)entries[j + k].name)[0] = DELETED_DIR_ENTRY;\par
01900                     \}\par
01901                     {\cf20 // write sector back}\par
01902                     status = write_sector(sector_lba + s, buf);\par
01903                     {\cf19 if} (MT_FAILURE(status)) \{ MmFreePool(buf); {\cf19 return} {\cf17 false}; \}\par
01904                     j += consumed;\par
01905                     {\cf19 continue};\par
01906                 \}\par
01907             \} {\cf20 // for each entry in sector}\par
01908         \} {\cf20 // for each sector in cluster}\par
01909 \par
01910         cluster = fat32_read_fat(cluster);\par
01911     \} {\cf20 // while cluster chain}\par
01912 \par
01913 free_and_return:\par
01914     {\cf20 // Free this directory's own cluster chain (we deleted contents)}\par
01915     {\cf19 if} (!fat32_free_cluster_chain(dir_cluster)) \{\par
01916         {\cf20 // if freeing fails, we still consider it an error}\par
01917         {\cf19 return} {\cf17 false};\par
01918     \}\par
01919     {\cf19 return} {\cf17 true};\par
01920 \}\par
01921 \par
01922 MTSTATUS fat32_delete_directory({\cf17 const} {\cf18 char}* path) \{\par
01923 \par
01924     {\cf20 // Find entry & its parent cluster}\par
01925     FAT32_DIR_ENTRY entry;\par
01926     uint32_t parent_cluster;\par
01927     {\cf19 if} (!fat32_find_entry(path, &entry, &parent_cluster)) {\cf19 return} MT_FAT32_DIRECTORY_NOT_FOUND;\par
01928 \par
01929     {\cf20 // Must be a directory}\par
01930     {\cf19 if} (!(entry.attr & ATTR_DIRECTORY)) {\cf19 return} MT_FAT32_INVALID_FILENAME;\par
01931 \par
01932     uint32_t dir_cluster = get_dir_cluster(&entry);\par
01933     {\cf19 if} (dir_cluster == 0) dir_cluster = fs.root_cluster;\par
01934 \par
01935     {\cf20 // Don't allow removing root via this function}\par
01936     {\cf19 if} (dir_cluster == fs.root_cluster) {\cf19 return} MT_GENERAL_FAILURE;\par
01937 \par
01938     {\cf20 // Recursively delete children and free the directory's clusters.}\par
01939     {\cf19 if} (!fat32_rm_rf_dir(dir_cluster)) {\cf19 return} MT_GENERAL_FAILURE;\par
01940 \par
01941     {\cf20 // Now mark this directory's entry (LFN+SFN) in parent as deleted.}\par
01942     {\cf19 if} (!mark_entry_and_lfns_deleted(path, parent_cluster)) {\cf19 return} MT_GENERAL_FAILURE;\par
01943 \par
01944     {\cf19 return} MT_SUCCESS;\par
01945 \}\par
01946 \par
01947 {\cf17 static} {\cf17 inline} {\cf18 bool} is_file(FAT32_DIR_ENTRY* entry) \{\par
01948     uint8_t attr = entry->attr;\par
01949     {\cf19 if} ((attr & ATTR_LONG_NAME) == ATTR_LONG_NAME) {\cf19 return} {\cf17 false}; {\cf20 // skip LFN}\par
01950     {\cf19 if} (attr & ATTR_DIRECTORY) {\cf19 return} {\cf17 false}; {\cf20 // skip directories}\par
01951     {\cf19 return} {\cf17 true}; {\cf20 // it's a regular file}\par
01952 \}\par
01953 \par
01954 MTSTATUS fat32_delete_file({\cf17 const} {\cf18 char}* path) \{\par
01955 \par
01956     {\cf20 // Find the file entry and its parent cluster}\par
01957     FAT32_DIR_ENTRY entry;\par
01958     uint32_t parent_cluster;\par
01959     {\cf19 if} (!fat32_find_entry(path, &entry, &parent_cluster)) \{\par
01960         {\cf19 return} MT_FAT32_DIRECTORY_NOT_FOUND; {\cf20 // File not found}\par
01961     \}\par
01962 \par
01963     {\cf20 // Must be a file (not a directory)}\par
01964     {\cf19 if} (!is_file(&entry)) \{\par
01965         {\cf19 return} MT_FAT32_INVALID_FILENAME; {\cf20 // Not a file}\par
01966     \}\par
01967 \par
01968     {\cf20 // Get the file's first cluster}\par
01969     uint32_t file_cluster = get_dir_cluster(&entry);\par
01970 \par
01971     {\cf20 // Free the file's cluster chain (if it has any clusters allocated)}\par
01972     {\cf19 if} (file_cluster >= 2 && file_cluster < FAT32_EOC_MIN) \{\par
01973         {\cf19 if} (!fat32_free_cluster_chain(file_cluster)) \{\par
01974             {\cf19 return} MT_GENERAL_FAILURE; {\cf20 // Failed to free cluster chain}\par
01975         \}\par
01976     \}\par
01977 \par
01978     {\cf20 // Mark the file's directory entry (LFN + SFN) as deleted in the parent directory}\par
01979     {\cf19 if} (!mark_entry_and_lfns_deleted(path, parent_cluster)) \{\par
01980         {\cf19 return} MT_GENERAL_FAILURE; {\cf20 // Failed to mark directory entries as deleted}\par
01981     \}\par
01982 \par
01983     {\cf19 return} MT_SUCCESS; {\cf20 // Success}\par
01984 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "../../drivers/gop/gop.h"}\par
{\f2 #include "../../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b FAT32_LFN_ENTRY}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _FAT32_FSINFO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b END_OF_DIRECTORY}\~ 0x00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DELETED_DIR_ENTRY}\~ 0xE5\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_FAT_MASK}\~ 0x0FFFFFFFU\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_FREE_CLUSTER}\~ 0x00000000U\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_BAD_CLUSTER}\~ 0x0FFFFFF7U\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_EOC_MIN}\~ 0x0FFFFFF8U /* inclusive */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FAT32_EOC_MAX}\~ 0x0FFFFFFFU /* inclusive */\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _FAT32_FSINFO} {\b FAT32_FSINFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FAT32_ATTRIBUTES} {\b FAT32_ATTRIBUTES}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FAT32_ATTRIBUTES} \{ {\b ATTR_READ_ONLY} = 0x01
, {\b ATTR_HIDDEN} = 0x02
, {\b ATTR_SYSTEM} = 0x04
, {\b ATTR_VOLUME_ID} = 0x08
, {\b ATTR_DIRECTORY} = 0x10
, {\b ATTR_ARCHIVE} = 0x20
, {\b ATTR_LONG_NAME} = 0x0F
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __attribute__} ((packed)) _FAT32_BPB\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_init} (int disk_index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fat32_list_root} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_read_file} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_create_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory (/testdir/ or /testdir are both allowed to create 'testdir' inside of 'root') }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_write_file} (const char *path, const void *data, uint32_t size, uint32_t file_modification_mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_list_directory} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_directory} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b fat32_delete_file} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b fat32_directory_is_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / deleted / nonexistent) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FAT32_BPB}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FAT32_DIR_ENTRY}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DELETED_DIR_ENTRY\:fat32.h}
{\xe \v fat32.h\:DELETED_DIR_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DELETED_DIR_ENTRY\~ 0xE5}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b fat32.h}.}\par
}
{\xe \v END_OF_DIRECTORY\:fat32.h}
{\xe \v fat32.h\:END_OF_DIRECTORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define END_OF_DIRECTORY\~ 0x00}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_BAD_CLUSTER\:fat32.h}
{\xe \v fat32.h\:FAT32_BAD_CLUSTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_BAD_CLUSTER\~ 0x0FFFFFF7U}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_EOC_MAX\:fat32.h}
{\xe \v fat32.h\:FAT32_EOC_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_EOC_MAX\~ 0x0FFFFFFFU /* inclusive */}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_EOC_MIN\:fat32.h}
{\xe \v fat32.h\:FAT32_EOC_MIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_EOC_MIN\~ 0x0FFFFFF8U /* inclusive */}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_FAT_MASK\:fat32.h}
{\xe \v fat32.h\:FAT32_FAT_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_FAT_MASK\~ 0x0FFFFFFFU}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_FREE_CLUSTER\:fat32.h}
{\xe \v fat32.h\:FAT32_FREE_CLUSTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FAT32_FREE_CLUSTER\~ 0x00000000U}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FAT32_ATTRIBUTES\:fat32.h}
{\xe \v fat32.h\:FAT32_ATTRIBUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FAT32_ATTRIBUTES} {\b FAT32_ATTRIBUTES}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FAT32_FSINFO\:fat32.h}
{\xe \v fat32.h\:FAT32_FSINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _FAT32_FSINFO} {\b FAT32_FSINFO}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FAT32_ATTRIBUTES\:fat32.h}
{\xe \v fat32.h\:_FAT32_ATTRIBUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FAT32_ATTRIBUTES}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ATTR_READ_ONLY\:fat32.h}
{\xe \v fat32.h\:ATTR_READ_ONLY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_READ_ONLY{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
\cell }{\cell }{\row }
{\xe \v ATTR_HIDDEN\:fat32.h}
{\xe \v fat32.h\:ATTR_HIDDEN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_HIDDEN{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
\cell }{\cell }{\row }
{\xe \v ATTR_SYSTEM\:fat32.h}
{\xe \v fat32.h\:ATTR_SYSTEM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_SYSTEM{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
\cell }{\cell }{\row }
{\xe \v ATTR_VOLUME_ID\:fat32.h}
{\xe \v fat32.h\:ATTR_VOLUME_ID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_VOLUME_ID{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
\cell }{\cell }{\row }
{\xe \v ATTR_DIRECTORY\:fat32.h}
{\xe \v fat32.h\:ATTR_DIRECTORY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_DIRECTORY{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
\cell }{\cell }{\row }
{\xe \v ATTR_ARCHIVE\:fat32.h}
{\xe \v fat32.h\:ATTR_ARCHIVE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_ARCHIVE{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
\cell }{\cell }{\row }
{\xe \v ATTR_LONG_NAME\:fat32.h}
{\xe \v fat32.h\:ATTR_LONG_NAME}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTR_LONG_NAME{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 113} of file {\b fat32.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:fat32.h}
{\xe \v fat32.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b fat32.h}.}\par
}
{\xe \v fat32_create_directory\:fat32.h}
{\xe \v fat32.h\:fat32_create_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_create_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory (/testdir/ or /testdir are both allowed to create 'testdir' inside of 'root') }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1047} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_directory\:fat32.h}
{\xe \v fat32.h\:fat32_delete_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_directory (const char * path)}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1922} of file {\b fat32.c}.}\par
}
{\xe \v fat32_delete_file\:fat32.h}
{\xe \v fat32.h\:fat32_delete_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_delete_file (const char * path)}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1954} of file {\b fat32.c}.}\par
}
{\xe \v fat32_directory_is_empty\:fat32.h}
{\xe \v fat32.h\:fat32_directory_is_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool fat32_directory_is_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / deleted / nonexistent) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 1663} of file {\b fat32.c}.}\par
}
{\xe \v fat32_init\:fat32.h}
{\xe \v fat32.h\:fat32_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_init (int disk_index)}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 745} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_directory\:fat32.h}
{\xe \v fat32.h\:fat32_list_directory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_list_directory (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1579} of file {\b fat32.c}.}\par
}
{\xe \v fat32_list_root\:fat32.h}
{\xe \v fat32.h\:fat32_list_root}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fat32_list_root (void )}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 769} of file {\b fat32.c}.}\par
}
{\xe \v fat32_read_file\:fat32.h}
{\xe \v fat32.h\:fat32_read_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_read_file (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A FAT32 Function that reads the file requested into a dynamically allocated buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 921} of file {\b fat32.c}.}\par
}
{\xe \v fat32_write_file\:fat32.h}
{\xe \v fat32.h\:fat32_write_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} fat32_write_file (const char * path, const void * data, uint32_t size, uint32_t file_modification_mode)}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_modification_mode} \cell }{Whether to APPEND or REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 1275} of file {\b fat32.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v FAT32_BPB\:fat32.h}
{\xe \v fat32.h\:FAT32_BPB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FAT32_BPB}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b fat32.h}.}\par
}
{\xe \v FAT32_DIR_ENTRY\:fat32.h}
{\xe \v fat32.h\:FAT32_DIR_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FAT32_DIR_ENTRY}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b fat32.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fat32.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/fat32/fat32.h}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     FAT32 FileSystem Headers.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_KERNEL_FILESYSTEM_FAT32_HEADER}\par
00008 {\cf21 #define X86_KERNEL_FILESYSTEM_FAT32_HEADER}\par
00009  {\cf20 // Standard headers, required.}\par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdbool.h>}\par
00012 {\cf21 #include <stdint.h>}\par
00013 {\cf21 #include "../../drivers/gop/gop.h"}\par
00014 {\cf21 #include "../../mtstatus.h"}\par
00015 \par
00016 {\cf21 #define END_OF_DIRECTORY 0x00}\par
00017 {\cf21 #define DELETED_DIR_ENTRY 0xE5}\par
00018 \par
00019 \par
00020 {\cf21 #define FAT32_FAT_MASK        0x0FFFFFFFU}\par
00021 {\cf21 #define FAT32_FREE_CLUSTER    0x00000000U}\par
00022 {\cf21 #define FAT32_BAD_CLUSTER     0x0FFFFFF7U}\par
00023 {\cf21 #define FAT32_EOC_MIN         0x0FFFFFF8U }{\cf20 /* inclusive */}{\cf21 }\par
00024 {\cf21 #define FAT32_EOC_MAX         0x0FFFFFFFU }{\cf20 /* inclusive */}{\cf21 }\par
00025 \par
00026 \par
00027 \par
00028 {\cf21 #ifdef _MSC_VER}\par
00029 {\cf21 #pragma pack(push, 1)}\par
00030 {\cf17 typedef} {\cf17 struct }_FAT32_BPB \{\par
00031 {\cf21 #else}\par
00032 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _FAT32_BPB \{\par
00033 {\cf21 #endif}\par
00034     uint8_t jump[3];\par
00035     uint8_t oem[8];\par
00036     uint16_t bytes_per_sector;\par
00037     uint8_t sectors_per_cluster;\par
00038     uint16_t reserved_sector_count;\par
00039     uint8_t num_fats;\par
00040     uint16_t root_entry_count;\par
00041     uint16_t total_sectors_16;\par
00042     uint8_t media;\par
00043     uint16_t fat_size_16;\par
00044     uint16_t sectors_per_track;\par
00045     uint16_t num_heads;\par
00046     uint32_t hidden_sectors;\par
00047     uint32_t total_sectors_32;\par
00048     uint32_t fat_size_32;\par
00049     uint16_t ext_flags;\par
00050     uint16_t fs_version;\par
00051     uint32_t root_cluster;\par
00052     uint16_t fs_info_sector;\par
00053     uint16_t backup_root_sector;\par
00054 \} FAT32_BPB;\par
00055 {\cf21 #ifdef _MSC_VER}\par
00056 {\cf21 #pragma pack(pop)}\par
00057 {\cf21 #endif}\par
00058 \par
00059 {\cf21 #ifdef _MSC_VER}\par
00060 {\cf21 #pragma pack(push, 1)}\par
00061 {\cf17 typedef} {\cf17 struct }_FAT32_DIR_ENTRY \{\par
00062 {\cf21 #else}\par
00063 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _FAT32_DIR_ENTRY \{\par
00064 {\cf21 #endif}\par
00065     {\cf18 char} name[11];\par
00066     uint8_t attr;\par
00067     uint8_t nt_res;\par
00068     uint8_t crt_time_tenth;\par
00069     uint16_t crt_time;\par
00070     uint16_t crt_date;\par
00071     uint16_t lst_acc_date;\par
00072     uint16_t fst_clus_hi;\par
00073     uint16_t wrt_time;\par
00074     uint16_t wrt_date;\par
00075     uint16_t fst_clus_lo;\par
00076     uint32_t file_size;\par
00077 \} FAT32_DIR_ENTRY;\par
00078 {\cf21 #ifdef _MSC_VER}\par
00079 {\cf21 #pragma pack(pop)}\par
00080 {\cf21 #endif}\par
00081 \par
00082 {\cf21 #pragma pack(push,1)}\par
00083 {\cf17 typedef} {\cf17 struct }\{\par
00084     uint8_t  LDIR_Ord;\par
00085     uint16_t LDIR_Name1[5];\par
00086     uint8_t  LDIR_Attr;   {\cf20 // always 0x0F}\par
00087     uint8_t  LDIR_Type;\par
00088     uint8_t  LDIR_Chksum;\par
00089     uint16_t LDIR_Name2[6];\par
00090     uint16_t LDIR_FstClusLO;\par
00091     uint16_t LDIR_Name3[2];\par
00092 \} FAT32_LFN_ENTRY;\par
00093 {\cf21 #pragma pack(pop)}\par
00094 \par
00095 {\cf17 typedef} {\cf17 struct }_FAT32_FSINFO \{\par
00096     uint32_t first_data_sector;\par
00097     uint32_t root_cluster;\par
00098     uint32_t sectors_per_fat;\par
00099     uint32_t bytes_per_sector;\par
00100     uint32_t sectors_per_cluster;\par
00101     uint32_t fat_start;\par
00102     uint16_t reserved_sector_count;\par
00103     uint32_t total_sectors;\par
00104     uint32_t total_clusters;\par
00105 \} FAT32_FSINFO;\par
00106 \par
00107 {\cf20 // Initialize a FAT32 FileSystem on a given block device.}\par
00108 MTSTATUS fat32_init({\cf18 int} disk_index);\par
00109 \par
00110 {\cf20 // List files in root dir}\par
00111 {\cf18 void} fat32_list_root({\cf18 void});\par
00112 \par
00113 {\cf17 typedef} {\cf17 enum} _FAT32_ATTRIBUTES \{\par
00114     ATTR_READ_ONLY = 0x01,  {\cf20 // File is read-only}\par
00115     ATTR_HIDDEN = 0x02,  {\cf20 // File is hidden}\par
00116     ATTR_SYSTEM = 0x04,  {\cf20 // System file}\par
00117     ATTR_VOLUME_ID = 0x08,  {\cf20 // Volume label}\par
00118     ATTR_DIRECTORY = 0x10,  {\cf20 // Entry is a directory}\par
00119     ATTR_ARCHIVE = 0x20,  {\cf20 // File should be archived}\par
00120     {\cf20 // Special combination values}\par
00121     ATTR_LONG_NAME = 0x0F,  {\cf20 // Long File Name entry (ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID)}\par
00122 \} FAT32_ATTRIBUTES;\par
00123 \par
00124 {\cf17 static} {\cf17 inline} uint16_t fat32_encode_date(uint16_t year, uint8_t month, uint8_t day) \{\par
00125     {\cf20 // FAT date: YYYYYYYMMMMDDDDD (since 1980)}\par
00126     {\cf19 return} ((year - 1980) << 9) | (month << 5) | (day);\par
00127 \}\par
00128 \par
00129 {\cf17 static} {\cf17 inline} uint16_t fat32_encode_time(uint8_t hour, uint8_t min, uint8_t sec) \{\par
00130     {\cf20 // FAT time: HHHHHMMMMMMSSSSS (seconds / 2)}\par
00131     {\cf19 return} (hour << 11) | (min << 5) | (sec / 2);\par
00132 \}\par
00133 \par
00134 {\cf17 static} {\cf17 inline} {\cf18 void} fat32_decode_date(uint16_t date, uint16_t* year, uint8_t* month, uint8_t* day) \{\par
00135     *year = 1980 + ((date >> 9) & 0x7F); {\cf20 // 7 bits for year}\par
00136     *month = (date >> 5) & 0x0F;          {\cf20 // 4 bits for month}\par
00137     *day = date & 0x1F;                 {\cf20 // 5 bits for day}\par
00138 \}\par
00139 \par
00140 {\cf17 static} {\cf17 inline} {\cf18 void} fat32_decode_time(uint16_t time, uint8_t* hour, uint8_t* min, uint8_t* sec) \{\par
00141     *hour = (time >> 11) & 0x1F;          {\cf20 // 5 bits for hours}\par
00142     *min = (time >> 5) & 0x3F;           {\cf20 // 6 bits for minutes}\par
00143     *sec = (time & 0x1F) * 2;            {\cf20 // 5 bits for seconds (2-second resolution)}\par
00144 \}\par
00145 \par
00153 MTSTATUS fat32_read_file({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out);\par
00154 \par
00160 MTSTATUS fat32_create_directory({\cf17 const} {\cf18 char}* path);\par
00161 \par
00170 MTSTATUS fat32_write_file({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, uint32_t file_modification_mode);\par
00171 \par
00179 MTSTATUS fat32_list_directory({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len);\par
00180 \par
00186 MTSTATUS fat32_delete_directory({\cf17 const} {\cf18 char}* path);\par
00187 \par
00193 MTSTATUS fat32_delete_file({\cf17 const} {\cf18 char}* path);\par
00199 {\cf18 bool} fat32_directory_is_empty({\cf17 const} {\cf18 char}* path);\par
00200 \par
00201 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "vfs.h"}\par
{\f2 #include "../../drivers/ahci/ahci.h"}\par
{\f2 #include "../fat32/fat32.h"}\par
{\f2 #include "../../includes/macros.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MOUNTED_FS}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MOUNTS}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAIN_FS_DEVICE}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct MOUNTED_FS {\b MOUNTED_FS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_read} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_write} (const char *path, const void *data, uint32_t size, {\b FS_WRITE_MODES} write_mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_delete} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_listdir} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_mkdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_rmdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system along with its file (marks as deleted). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vfs_is_dir_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / is nonexistent / is deleted) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vfs_listrootdir} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FS_DRIVER} {\b fat32_driver}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MAIN_FS_DEVICE\:vfs.c}
{\xe \v vfs.c\:MAIN_FS_DEVICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAIN_FS_DEVICE\~ 0}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b vfs.c}.}\par
}
{\xe \v MAX_MOUNTS\:vfs.c}
{\xe \v vfs.c\:MAX_MOUNTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MOUNTS\~ 4}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v MOUNTED_FS\:vfs.c}
{\xe \v vfs.c\:MOUNTED_FS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct MOUNTED_FS MOUNTED_FS}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vfs_delete\:vfs.c}
{\xe \v vfs.c\:vfs_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_delete (const char * path)}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 101} of file {\b vfs.c}.}\par
}
{\xe \v vfs_init\:vfs.c}
{\xe \v vfs.c\:vfs_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_init (void )}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 42} of file {\b vfs.c}.}\par
}
{\xe \v vfs_is_dir_empty\:vfs.c}
{\xe \v vfs.c\:vfs_is_dir_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool vfs_is_dir_empty (const char * path)}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / is nonexistent / is deleted) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 129} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listdir\:vfs.c}
{\xe \v vfs.c\:vfs_listdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_listdir (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 108} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listrootdir\:vfs.c}
{\xe \v vfs.c\:vfs_listrootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vfs_listrootdir (void )}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }}\par
{
Definition at line {\b 136} of file {\b vfs.c}.}\par
}
{\xe \v vfs_mkdir\:vfs.c}
{\xe \v vfs.c\:vfs_mkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_mkdir (const char * path)}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 115} of file {\b vfs.c}.}\par
}
{\xe \v vfs_read\:vfs.c}
{\xe \v vfs.c\:vfs_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_read (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 87} of file {\b vfs.c}.}\par
}
{\xe \v vfs_rmdir\:vfs.c}
{\xe \v vfs.c\:vfs_rmdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_rmdir (const char * path)}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system along with its file (marks as deleted). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 122} of file {\b vfs.c}.}\par
}
{\xe \v vfs_write\:vfs.c}
{\xe \v vfs.c\:vfs_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_write (const char * path, const void * data, uint32_t size, {\b FS_WRITE_MODES} write_mode)}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i write_mode} \cell }{Whether to APPEND or CREATE/REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 94} of file {\b vfs.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v fat32_driver\:vfs.c}
{\xe \v vfs.c\:fat32_driver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FS_DRIVER} fat32_driver}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{\par
    .init = fat32_fs_init,\par
    .read = fat32_read_file,\par
    .write = fat32_write_file,\par
    .delete = fat32_delete_file,\par
    .listdir = fat32_list_directory,\par
    .mkdir = fat32_create_directory,\par
    .rmdir = fat32_delete_directory,\par
    .is_dir_empty = fat32_directory_is_empty,\par
    .listrootdir = fat32_list_root,\par
\}\par
}
{
Definition at line {\b 30} of file {\b vfs.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vfs.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.c}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Virtual File System (VFS) Implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "vfs.h"}\par
00008 \par
00009 {\cf21 #include "../../drivers/ahci/ahci.h"}\par
00010 {\cf21 #include "../fat32/fat32.h"}\par
00011 {\cf21 #include "../../includes/macros.h"}\par
00012 \par
00013 {\cf17 typedef} {\cf17 struct }MOUNTED_FS \{\par
00014     FS_DRIVER* driver;\par
00015     uint8_t device_id;\par
00016     {\cf17 const} {\cf18 char}* mount_point;  {\cf20 // e.g., "/", "/ext2"}\par
00017 \} MOUNTED_FS;\par
00018 \par
00019 {\cf21 #define MAX_MOUNTS 4}\par
00020 {\cf17 static} MOUNTED_FS mounted_fs[MAX_MOUNTS];\par
00021 {\cf17 static} uint8_t mount_count = 0;\par
00022 \par
00023 {\cf21 #define MAIN_FS_DEVICE 0}\par
00024 \par
00025 {\cf20 // Adapter for VFS FS_DRIVER}\par
00026 {\cf17 static} MTSTATUS fat32_fs_init(uint8_t device_id) \{\par
00027     {\cf19 return} fat32_init(device_id);\par
00028 \}\par
00029 \par
00030 FS_DRIVER fat32_driver = \{\par
00031     .init = fat32_fs_init,\par
00032     .read = fat32_read_file,\par
00033     .write = fat32_write_file,\par
00034     .delete = fat32_delete_file,\par
00035     .listdir = fat32_list_directory,\par
00036     .mkdir = fat32_create_directory,\par
00037     .rmdir = fat32_delete_directory,\par
00038     .is_dir_empty = fat32_directory_is_empty,\par
00039     .listrootdir = fat32_list_root,\par
00040 \};\par
00041 \par
00042 MTSTATUS vfs_init({\cf18 void}) \{\par
00043     {\cf20 // First initialize other FS Related stuff (FAT32, AHCI, etc..)}\par
00044     MTSTATUS status = ahci_init();\par
00045     {\cf19 if} (MT_FAILURE(status)) \{\par
00046         gop_printf(COLOR_RED, {\cf22 "AHCI | Status failure: %x"}, status);\par
00047         FREEZE();\par
00048         {\cf19 return} status;\par
00049     \}\par
00050     {\cf20 // Mount FAT32 on MAIN_FS_DEVICE}\par
00051     status = fat32_driver.init(MAIN_FS_DEVICE);\par
00052     {\cf19 if} (MT_FAILURE(status)) \{\par
00053         gop_printf(COLOR_RED, {\cf22 "FAT32 | Status failure: %x"}, status);\par
00054         FREEZE();\par
00055         {\cf19 return} status;\par
00056     \}\par
00057     mounted_fs[mount_count++] = (MOUNTED_FS)\{ .driver = &fat32_driver, .device_id = MAIN_FS_DEVICE, .mount_point = {\cf22 "/"} \};\par
00058 \par
00059     {\cf19 return} MT_SUCCESS;\par
00060 \}\par
00061 \par
00062 {\cf17 static} MOUNTED_FS* vfs_find_fs_for_path({\cf17 const} {\cf18 char}* path) \{\par
00063     {\cf19 if} (!path) {\cf19 return} NULL;\par
00064     {\cf19 for} (uint8_t i = 0; i < mount_count; i++) \{\par
00065         {\cf17 const} {\cf18 char}* mount = mounted_fs[i].mount_point;\par
00066         {\cf20 // root mount should match anything}\par
00067         {\cf19 if} (mount[0] == {\cf23 '/'} && mount[1] == {\cf23 '\\0'}) {\cf19 return} &mounted_fs[i];\par
00068 \par
00069         {\cf20 // compute mount_len}\par
00070         {\cf18 size_t} mount_len = 0;\par
00071         {\cf19 while} (mount[mount_len]) mount_len++;\par
00072 \par
00073         {\cf20 // path must be at least mount_len}\par
00074         {\cf18 size_t} path_len = 0;\par
00075         {\cf19 while} (path[path_len]) path_len++;\par
00076         {\cf19 if} (path_len < mount_len) {\cf19 continue};\par
00077 \par
00078         {\cf18 bool} match = {\cf17 true};\par
00079         {\cf19 for} ({\cf18 size_t} j = 0; j < mount_len; j++) \{\par
00080             {\cf19 if} (path[j] != mount[j]) \{ match = {\cf17 false}; {\cf19 break}; \}\par
00081         \}\par
00082         {\cf19 if} (match) {\cf19 return} &mounted_fs[i];\par
00083     \}\par
00084     {\cf19 return} NULL;\par
00085 \}\par
00086 \par
00087 MTSTATUS vfs_read({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out) \{\par
00088     MOUNTED_FS* fs = vfs_find_fs_for_path(filename);\par
00089     {\cf19 if} (!fs || !fs->driver || !fs->driver->read) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00090 \par
00091     {\cf19 return} fs->driver->read(filename, file_size_out, buffer_out);\par
00092 \}\par
00093 \par
00094 MTSTATUS vfs_write({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, FS_WRITE_MODES write_mode) \{\par
00095     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00096     {\cf19 if} (!fs || !fs->driver || !fs->driver->write) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00097 \par
00098     {\cf19 return} fs->driver->write(path, data, size, (uint32_t)write_mode);\par
00099 \}\par
00100 \par
00101 MTSTATUS vfs_delete({\cf17 const} {\cf18 char}* path) \{\par
00102     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00103     {\cf19 if} (!fs || !fs->driver || !fs->driver->delete) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00104 \par
00105     {\cf19 return} fs->driver->delete(path);\par
00106 \}\par
00107 \par
00108 MTSTATUS vfs_listdir({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len) \{\par
00109     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00110     {\cf19 if} (!fs || !fs->driver || !fs->driver->listdir) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00111 \par
00112     {\cf19 return} fs->driver->listdir(path, listings, max_len);\par
00113 \}\par
00114 \par
00115 MTSTATUS vfs_mkdir({\cf17 const} {\cf18 char}* path) \{\par
00116     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00117     {\cf19 if} (!fs || !fs->driver || !fs->driver->mkdir) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00118 \par
00119     {\cf19 return} fs->driver->mkdir(path);\par
00120 \}\par
00121 \par
00122 MTSTATUS vfs_rmdir({\cf17 const} {\cf18 char}* path) \{\par
00123     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00124     {\cf19 if} (!fs || !fs->driver || !fs->driver->rmdir) {\cf19 return} MT_NOT_IMPLEMENTED;\par
00125 \par
00126     {\cf19 return} fs->driver->rmdir(path);\par
00127 \}\par
00128 \par
00129 {\cf18 bool} vfs_is_dir_empty({\cf17 const} {\cf18 char}* path) \{\par
00130     MOUNTED_FS* fs = vfs_find_fs_for_path(path);\par
00131     {\cf19 if} (!fs || !fs->driver || !fs->driver->is_dir_empty) {\cf19 return} {\cf17 false};\par
00132 \par
00133     {\cf19 return} fs->driver->is_dir_empty(path);\par
00134 \}\par
00135 \par
00136 {\cf18 void} vfs_listrootdir({\cf18 void}) \{\par
00137     MOUNTED_FS* fs = vfs_find_fs_for_path({\cf22 "/"});\par
00138     {\cf19 if} (!fs || !fs->driver || !fs->driver->listrootdir) {\cf19 return};\par
00139 \par
00140     fs->driver->listrootdir();\par
00141     {\cf19 return};\par
00142 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../fat32/fat32.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b FS_DRIVER}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FS_WRITE_MODES} {\b FS_WRITE_MODES}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct FS_DRIVER {\b FS_DRIVER}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FS_WRITE_MODES} \{ {\b WRITE_MODE_APPEND_EXISTING}
, {\b WRITE_MODE_CREATE_OR_REPLACE}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_init} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_read} (const char *filename, uint32_t *file_size_out, void **buffer_out)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_write} (const char *path, const void *data, uint32_t size, {\b FS_WRITE_MODES} write_mode)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_delete} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_listdir} (const char *path, char *listings, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_mkdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b vfs_rmdir} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system along with its file (marks as deleted). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b vfs_is_dir_empty} (const char *path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / is nonexistent / is deleted) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b vfs_listrootdir} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FS_DRIVER\:vfs.h}
{\xe \v vfs.h\:FS_DRIVER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct FS_DRIVER FS_DRIVER}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v FS_WRITE_MODES\:vfs.h}
{\xe \v vfs.h\:FS_WRITE_MODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FS_WRITE_MODES} {\b FS_WRITE_MODES}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FS_WRITE_MODES\:vfs.h}
{\xe \v vfs.h\:_FS_WRITE_MODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FS_WRITE_MODES}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v WRITE_MODE_APPEND_EXISTING\:vfs.h}
{\xe \v vfs.h\:WRITE_MODE_APPEND_EXISTING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid WRITE_MODE_APPEND_EXISTING{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
\cell }{\cell }{\row }
{\xe \v WRITE_MODE_CREATE_OR_REPLACE\:vfs.h}
{\xe \v vfs.h\:WRITE_MODE_CREATE_OR_REPLACE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid WRITE_MODE_CREATE_OR_REPLACE{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 13} of file {\b vfs.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v vfs_delete\:vfs.h}
{\xe \v vfs.h\:vfs_delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_delete (const char * path)}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the file given to the function from the system. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete file.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 101} of file {\b vfs.c}.}\par
}
{\xe \v vfs_init\:vfs.h}
{\xe \v vfs.h\:vfs_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_init (void )}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the Virtual File System (initializes other filesystem needed services as well) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 42} of file {\b vfs.c}.}\par
}
{\xe \v vfs_is_dir_empty\:vfs.h}
{\xe \v vfs.h\:vfs_is_dir_empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool vfs_is_dir_empty (const char * path)}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns if the directory given to the function is empty (e.g, has only '.' and '..' entries / is nonexistent / is deleted) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to dir\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
True or false based if empty or not.\par
}}}{
Definition at line {\b 129} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listdir\:vfs.h}
{\xe \v vfs.h\:vfs_listdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_listdir (const char * path, char * listings, size_t max_len)}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lists the directory given. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Path to directory, e.g "mydir/" \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i listings} \cell }{[OUT] Pointer to directory listing. (each seperated with a newline character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{[IN] Max size of listings buffer.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 108} of file {\b vfs.c}.}\par
}
{\xe \v vfs_listrootdir\:vfs.h}
{\xe \v vfs.h\:vfs_listrootdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void vfs_listrootdir (void )}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function will list the root directory of the main mount device. }}\par
{
Definition at line {\b 136} of file {\b vfs.c}.}\par
}
{\xe \v vfs_mkdir\:vfs.h}
{\xe \v vfs.h\:vfs_mkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_mkdir (const char * path)}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new directory. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path to the new directory\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 115} of file {\b vfs.c}.}\par
}
{\xe \v vfs_read\:vfs.h}
{\xe \v vfs.h\:vfs_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_read (const char * filename, uint32_t * file_size_out, void ** buffer_out)}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the file into a buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i filename} \cell }{The Filename to read, e.g "file.txt" or "tmp/folder/myfile.txt"\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i file_size_out} \cell }{A pointer to put the file size in bytes\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferOut} \cell }{A pointer to put the file buffer in (doesn't need to be dynamically allocated)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code.\par
}}}{
Definition at line {\b 87} of file {\b vfs.c}.}\par
}
{\xe \v vfs_rmdir\:vfs.h}
{\xe \v vfs.h\:vfs_rmdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_rmdir (const char * path)}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function deletes the directory given to the function from the system along with its file (marks as deleted). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{Full path to delete directory.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status code.\par
}}}{
Definition at line {\b 122} of file {\b vfs.c}.}\par
}
{\xe \v vfs_write\:vfs.h}
{\xe \v vfs.h\:vfs_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} vfs_write (const char * path, const void * data, uint32_t size, {\b FS_WRITE_MODES} write_mode)}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new file (or opens existing) and writes data to it. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{The full path of the file to create\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{A pointer to the data to write.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{The number of bytes to write\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i write_mode} \cell }{Whether to APPEND or CREATE/REPLACE the file. (in {\b FS_WRITE_MODES} enum)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b MTSTATUS} Status Code\par
}}}{
Definition at line {\b 94} of file {\b vfs.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
vfs.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/filesystem/vfs/vfs.h}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Virtual File System (VFS) Header Functions & Structures.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_VFS_H}\par
00008 {\cf21 #define X86_VFS_H}\par
00009 \par
00010 {\cf20 // Include the FAT32 Header.}\par
00011 {\cf21 #include "../fat32/fat32.h"}\par
00012 \par
00013 {\cf17 typedef} {\cf17 enum} _FS_WRITE_MODES \{\par
00014     WRITE_MODE_APPEND_EXISTING,\par
00015     WRITE_MODE_CREATE_OR_REPLACE,\par
00016 \} FS_WRITE_MODES;\par
00017 \par
00018 {\cf17 typedef} {\cf17 struct }FS_DRIVER \{\par
00019     MTSTATUS(*init)(uint8_t device_id);\par
00020     MTSTATUS(*read)({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out);\par
00021     MTSTATUS(*write)({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, uint32_t mode);\par
00022     MTSTATUS(*{\cf17 delete})({\cf17 const} {\cf18 char}* path);\par
00023     MTSTATUS(*mkdir)({\cf17 const} {\cf18 char}* path);\par
00024     MTSTATUS(*rmdir)({\cf17 const} {\cf18 char}* path);\par
00025     bool(*is_dir_empty)({\cf17 const} {\cf18 char}* path);\par
00026     MTSTATUS(*listdir)({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len);\par
00027     void(*listrootdir)(void);\par
00028 \} FS_DRIVER;\par
00029 \par
00034 MTSTATUS vfs_init({\cf18 void});\par
00035 \par
00043 MTSTATUS vfs_read({\cf17 const} {\cf18 char}* filename, uint32_t* file_size_out, {\cf18 void}** buffer_out);\par
00044 \par
00053 MTSTATUS vfs_write({\cf17 const} {\cf18 char}* path, {\cf17 const} {\cf18 void}* data, uint32_t size, FS_WRITE_MODES write_mode);\par
00054 \par
00060 MTSTATUS vfs_delete({\cf17 const} {\cf18 char}* path);\par
00061 \par
00069 MTSTATUS vfs_listdir({\cf17 const} {\cf18 char}* path, {\cf18 char}* listings, {\cf18 size_t} max_len);\par
00070 \par
00076 MTSTATUS vfs_mkdir({\cf17 const} {\cf18 char}* path);\par
00077 \par
00083 MTSTATUS vfs_rmdir({\cf17 const} {\cf18 char}* path);\par
00084 \par
00090 {\cf18 bool} vfs_is_dir_empty({\cf17 const} {\cf18 char}* path);\par
00091 \par
00095 {\cf18 void} vfs_listrootdir({\cf18 void});\par
00096 \par
00097 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/gen_offsets.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/gen_offsets.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/gen_offsets.c}
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "includes/annotations.h"}\par
{\f2 #include "includes/ms.h"}\par
{\f2 #include "includes/mm.h"}\par
{\f2 #include "includes/ps.h"}\par
{\f2 #include "includes/me.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __OFFSET_GENERATOR__}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GEN_COMMENT}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GEN_DEFINE}(name,  val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GEN_OFFSET}(struct_name,  member)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b GEN_SIZE}(struct_name)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __OFFSET_GENERATOR__\:gen_offsets.c}
{\xe \v gen_offsets.c\:__OFFSET_GENERATOR__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __OFFSET_GENERATOR__}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b gen_offsets.c}.}\par
}
{\xe \v GEN_COMMENT\:gen_offsets.c}
{\xe \v gen_offsets.c\:GEN_COMMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GEN_COMMENT( msg)}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     printf({\cf22 "\\n; %s\\n"}, msg)\par
}
{
Definition at line {\b 24} of file {\b gen_offsets.c}.}\par
}
{\xe \v GEN_DEFINE\:gen_offsets.c}
{\xe \v gen_offsets.c\:GEN_DEFINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GEN_DEFINE( name,  val)}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     printf({\cf22 "%%define %-40s 0x%lX\\n"}, #name, (uint64_t)(val))\par
}
{
Definition at line {\b 27} of file {\b gen_offsets.c}.}\par
}
{\xe \v GEN_OFFSET\:gen_offsets.c}
{\xe \v gen_offsets.c\:GEN_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GEN_OFFSET( struct_name,  member)}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     printf({\cf22 "%%define %-40s 0x%lX\\n"}, #struct_name {\cf22 "_"} #member, offsetof(struct_name, member))\par
}
{
Definition at line {\b 30} of file {\b gen_offsets.c}.}\par
}
{\xe \v GEN_SIZE\:gen_offsets.c}
{\xe \v gen_offsets.c\:GEN_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define GEN_SIZE( struct_name)}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     printf({\cf22 "%%define SIZEOF_%-33s 0x%lX\\n"}, #struct_name, {\cf17 sizeof}(struct_name))\par
}
{
Definition at line {\b 33} of file {\b gen_offsets.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:gen_offsets.c}
{\xe \v gen_offsets.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (void )}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b gen_offsets.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gen_offsets.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/gen_offsets.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/gen_offsets.c}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * gen_offsets.c}\par
00003 {\cf20  * * Compiles with MatanelOS headers to generate NASM-compatible}\par
00004 {\cf20  * definitions for struct offsets, sizes, and enums.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #define __OFFSET_GENERATOR__}\par
00008 \par
00009 {\cf21 #include <stdio.h>}\par
00010 {\cf21 #include <stddef.h>}\par
00011 {\cf21 #include <stdint.h>}\par
00012 {\cf21 #include <stdbool.h>}\par
00013 \par
00014 {\cf21 #include "includes/annotations.h"}\par
00015 {\cf21 #include "includes/ms.h"}\par
00016 {\cf21 #include "includes/mm.h"}\par
00017 {\cf21 #include "includes/ps.h"}\par
00018 {\cf21 #include "includes/me.h"} \par
00019 \par
00020 {\cf20 // --------------------------------------------------------------------------}\par
00021 {\cf20 // MACROS FOR GENERATION}\par
00022 {\cf20 // --------------------------------------------------------------------------}\par
00023 \par
00024 {\cf21 #define GEN_COMMENT(msg) \\}\par
00025 {\cf21     printf("\\n; %s\\n", msg)}\par
00026 \par
00027 {\cf21 #define GEN_DEFINE(name, val) \\}\par
00028 {\cf21     printf("%%define %-40s 0x%lX\\n", #name, (uint64_t)(val))}\par
00029 \par
00030 {\cf21 #define GEN_OFFSET(struct_name, member) \\}\par
00031 {\cf21     printf("%%define %-40s 0x%lX\\n", #struct_name "_" #member, offsetof(struct_name, member))}\par
00032 \par
00033 {\cf21 #define GEN_SIZE(struct_name) \\}\par
00034 {\cf21     printf("%%define SIZEOF_%-33s 0x%lX\\n", #struct_name, sizeof(struct_name))}\par
00035 \par
00036 {\cf18 int} main({\cf18 void}) \{\par
00037     printf({\cf22 "; ===============================================================\\n"});\par
00038     printf({\cf22 "; AUTOMATICALLY GENERATED FILE - DO NOT EDIT MANUALLY\\n"});\par
00039     printf({\cf22 "; Generated by gen_offsets.c\\n"});\par
00040     printf({\cf22 "; ===============================================================\\n\\n"});\par
00041 \par
00042     {\cf20 // GENERALS}\par
00043     GEN_DEFINE(NULL, 0);\par
00044 \par
00045     {\cf20 // ========================================================================}\par
00046     {\cf20 // 1. EXECUTIVE / PROCESSOR (me.h)}\par
00047     {\cf20 // ========================================================================}\par
00048     GEN_COMMENT({\cf22 "PROCESSOR Structure Offsets (gs:[...])"});\par
00049     GEN_OFFSET(PROCESSOR, self);\par
00050     GEN_OFFSET(PROCESSOR, currentIrql);\par
00051     GEN_OFFSET(PROCESSOR, schedulerEnabled);\par
00052     GEN_OFFSET(PROCESSOR, currentThread);\par
00053     GEN_OFFSET(PROCESSOR, readyQueue);\par
00054     GEN_OFFSET(PROCESSOR, ID);\par
00055     GEN_OFFSET(PROCESSOR, lapic_ID);\par
00056     GEN_OFFSET(PROCESSOR, VirtStackTop);\par
00057     GEN_OFFSET(PROCESSOR, tss);\par
00058     GEN_OFFSET(PROCESSOR, flags);\par
00059     GEN_OFFSET(PROCESSOR, schedulePending);\par
00060     GEN_OFFSET(PROCESSOR, LapicAddressVirt);\par
00061     GEN_OFFSET(PROCESSOR, TimerExpirationDPC);\par
00062     GEN_SIZE(PROCESSOR);\par
00063 \par
00064     GEN_COMMENT({\cf22 "TRAP_FRAME Offsets (Context Saving/Restoring)"});\par
00065     GEN_OFFSET(TRAP_FRAME, rax);\par
00066     GEN_OFFSET(TRAP_FRAME, rbx);\par
00067     GEN_OFFSET(TRAP_FRAME, rcx);\par
00068     GEN_OFFSET(TRAP_FRAME, rdx);\par
00069     GEN_OFFSET(TRAP_FRAME, rsi);\par
00070     GEN_OFFSET(TRAP_FRAME, rdi);\par
00071     GEN_OFFSET(TRAP_FRAME, rbp);\par
00072     GEN_OFFSET(TRAP_FRAME, r8);\par
00073     GEN_OFFSET(TRAP_FRAME, r9);\par
00074     GEN_OFFSET(TRAP_FRAME, r10);\par
00075     GEN_OFFSET(TRAP_FRAME, r11);\par
00076     GEN_OFFSET(TRAP_FRAME, r12);\par
00077     GEN_OFFSET(TRAP_FRAME, r13);\par
00078     GEN_OFFSET(TRAP_FRAME, r14);\par
00079     GEN_OFFSET(TRAP_FRAME, r15);\par
00080     GEN_OFFSET(TRAP_FRAME, vector);\par
00081     GEN_OFFSET(TRAP_FRAME, error_code);\par
00082     GEN_OFFSET(TRAP_FRAME, rip);\par
00083     GEN_OFFSET(TRAP_FRAME, cs);\par
00084     GEN_OFFSET(TRAP_FRAME, rflags);\par
00085     GEN_OFFSET(TRAP_FRAME, rsp);\par
00086     GEN_OFFSET(TRAP_FRAME, ss);\par
00087     GEN_SIZE(TRAP_FRAME);\par
00088 \par
00089     GEN_COMMENT({\cf22 "ITHREAD Offsets (Internal Thread)"});\par
00090     GEN_OFFSET(ITHREAD, TrapRegisters);\par
00091     GEN_OFFSET(ITHREAD, ThreadState);\par
00092     GEN_OFFSET(ITHREAD, StackBase);\par
00093     GEN_OFFSET(ITHREAD, IsLargeStack);\par
00094     GEN_OFFSET(ITHREAD, PreviousMode);\par
00095 \par
00096     GEN_COMMENT({\cf22 "IPROCESS Offsets (Internal Process)"});\par
00097     GEN_OFFSET(IPROCESS, PageDirectoryPhysical);\par
00098 \par
00099     GEN_COMMENT({\cf22 "Processor Constants"});\par
00100     GEN_DEFINE(KERNEL_CS, KERNEL_CS);\par
00101     GEN_DEFINE(KERNEL_DS, KERNEL_DS);\par
00102     GEN_DEFINE(USER_CS, USER_CS);\par
00103     GEN_DEFINE(USER_DS, USER_DS);\par
00104     GEN_DEFINE(INITIAL_RFLAGS, INITIAL_RFLAGS);\par
00105     GEN_DEFINE(USER_RFLAGS, USER_RFLAGS);\par
00106     GEN_DEFINE(MAX_CPUS, MAX_CPUS);\par
00107 \par
00108     GEN_COMMENT({\cf22 "Bugcheck Codes"});\par
00109     GEN_DEFINE(IRQL_NOT_LESS_OR_EQUAL, IRQL_NOT_LESS_OR_EQUAL);\par
00110     GEN_DEFINE(IRQL_NOT_GREATER_OR_EQUAL, IRQL_NOT_GREATER_OR_EQUAL);\par
00111     GEN_DEFINE(KERNEL_STACK_OVERFLOWN, KERNEL_STACK_OVERFLOWN);\par
00112     GEN_DEFINE(MANUALLY_INITIATED_CRASH, MANUALLY_INITIATED_CRASH);\par
00113     GEN_DEFINE(PAGE_FAULT, PAGE_FAULT);\par
00114     GEN_DEFINE(DOUBLE_FAULT, DOUBLE_FAULT);\par
00115     GEN_DEFINE(GENERAL_PROTECTION_FAULT, GENERAL_PROTECTION_FAULT);\par
00116     GEN_DEFINE(ATTEMPTED_SWITCH_FROM_DPC, ATTEMPTED_SWITCH_FROM_DPC);\par
00117 \par
00118     GEN_COMMENT({\cf22 "IRQL Levels"});\par
00119     GEN_DEFINE(PASSIVE_LEVEL, PASSIVE_LEVEL);\par
00120     GEN_DEFINE(APC_LEVEL, APC_LEVEL);\par
00121     GEN_DEFINE(DISPATCH_LEVEL, DISPATCH_LEVEL);\par
00122     GEN_DEFINE(PROFILE_LEVEL, PROFILE_LEVEL);\par
00123     GEN_DEFINE(CLOCK_LEVEL, CLOCK_LEVEL);\par
00124     GEN_DEFINE(IPI_LEVEL, IPI_LEVEL);\par
00125     GEN_DEFINE(POWER_LEVEL, POWER_LEVEL);\par
00126     GEN_DEFINE(HIGH_LEVEL, HIGH_LEVEL);\par
00127 \par
00128     GEN_COMMENT({\cf22 "TPR Levels"});\par
00129     GEN_DEFINE(VECTOR_APC, VECTOR_APC);\par
00130     GEN_DEFINE(VECTOR_DPC, VECTOR_DPC);\par
00131     GEN_DEFINE(VECTOR_IPI, VECTOR_IPI);\par
00132 \par
00133     {\cf20 // ========================================================================}\par
00134     {\cf20 // 2. PROCESS & THREAD (ps.h)}\par
00135     {\cf20 // ========================================================================}\par
00136     GEN_COMMENT({\cf22 "EPROCESS Offsets"});\par
00137     GEN_OFFSET(EPROCESS, InternalProcess);\par
00138     GEN_OFFSET(EPROCESS, PID);\par
00139     GEN_OFFSET(EPROCESS, ParentProcess);\par
00140     GEN_OFFSET(EPROCESS, MainThread);\par
00141     GEN_OFFSET(EPROCESS, VadRoot);\par
00142     GEN_OFFSET(EPROCESS, NextStackTop);\par
00143 \par
00144     GEN_COMMENT({\cf22 "ETHREAD Offsets"});\par
00145     GEN_OFFSET(ETHREAD, InternalThread);\par
00146     GEN_OFFSET(ETHREAD, TID);\par
00147     GEN_OFFSET(ETHREAD, ParentProcess);\par
00148     GEN_OFFSET(ETHREAD, CurrentEvent);\par
00149 \par
00150     GEN_COMMENT({\cf22 "Thread State Enums"});\par
00151     GEN_DEFINE(THREAD_RUNNING, THREAD_RUNNING);\par
00152     GEN_DEFINE(THREAD_READY, THREAD_READY);\par
00153     GEN_DEFINE(THREAD_TERMINATED, THREAD_TERMINATED);\par
00154 \par
00155     {\cf20 // ========================================================================}\par
00156     {\cf20 // 3. MEMORY SYSTEM (mm.h)}\par
00157     {\cf20 // ========================================================================}\par
00158     GEN_COMMENT({\cf22 "Memory Management Constants"});\par
00159     GEN_DEFINE(VirtualPageSize, VirtualPageSize);\par
00160     GEN_DEFINE(KernelVaStart, KernelVaStart);\par
00161     {\cf20 // Note: PhysicalMemoryOffset is a large ULL, we cast to preserve generic print}\par
00162     GEN_DEFINE(PhysicalMemoryOffset, PhysicalMemoryOffset);\par
00163 \par
00164     GEN_COMMENT({\cf22 "MMPTE Offsets & Flags"});\par
00165     GEN_OFFSET(MMPTE, Value);\par
00166     GEN_DEFINE(PAGE_PRESENT, PAGE_PRESENT);\par
00167     GEN_DEFINE(PAGE_RW, PAGE_RW);\par
00168     GEN_DEFINE(PAGE_USER, PAGE_USER);\par
00169     GEN_DEFINE(PAGE_NX, PAGE_NX);\par
00170 \par
00171     {\cf20 // ========================================================================}\par
00172     {\cf20 // 4. SYNCHRONIZATION (ms.h)}\par
00173     {\cf20 // ========================================================================}\par
00174     GEN_COMMENT({\cf22 "Spinlock & Mutex"});\par
00175     GEN_OFFSET(SPINLOCK, locked);\par
00176     GEN_OFFSET(MUTEX, ownerTid);\par
00177     GEN_OFFSET(MUTEX, locked);\par
00178     GEN_OFFSET(MUTEX, ownerThread);\par
00179 \par
00180     {\cf19 return} 0;\par
00181 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/annotations.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/annotations.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/annotations.h}
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OUT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _In_Opt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _Out_Opt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NORETURN}\~ {\b __attribute__}((noreturn))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FORCEINLINE}\~ static inline\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FORCEINLINE_NOHEADER}\~ inline\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USED}\~ {\b __attribute__}((used))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _In_Opt\:annotations.h}
{\xe \v annotations.h\:_In_Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _In_Opt}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b annotations.h}.}\par
}
{\xe \v _Out_Opt\:annotations.h}
{\xe \v annotations.h\:_Out_Opt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _Out_Opt}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b annotations.h}.}\par
}
{\xe \v FORCEINLINE\:annotations.h}
{\xe \v annotations.h\:FORCEINLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FORCEINLINE\~ static inline}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b annotations.h}.}\par
}
{\xe \v FORCEINLINE_NOHEADER\:annotations.h}
{\xe \v annotations.h\:FORCEINLINE_NOHEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FORCEINLINE_NOHEADER\~ inline}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b annotations.h}.}\par
}
{\xe \v IN\:annotations.h}
{\xe \v annotations.h\:IN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IN}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b annotations.h}.}\par
}
{\xe \v NORETURN\:annotations.h}
{\xe \v annotations.h\:NORETURN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NORETURN\~ {\b __attribute__}((noreturn))}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b annotations.h}.}\par
}
{\xe \v OUT\:annotations.h}
{\xe \v annotations.h\:OUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OUT}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b annotations.h}.}\par
}
{\xe \v USED\:annotations.h}
{\xe \v annotations.h\:USED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USED\~ {\b __attribute__}((used))}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b annotations.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
annotations.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/annotations.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/annotations.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_ANNOTATIONS_H}\par
00002 {\cf21 #define X86_ANNOTATIONS_H}\par
00003 \par
00004 {\cf20 // Annotations (and macros) for documentation, and potential future analyzing.}\par
00005 \par
00006 {\cf20 // Parameter Annotations}\par
00007 {\cf21 #define IN }{\cf20 // Takes REQUIRED INPUT}\par
00008 {\cf21 #define OUT }{\cf20 // Supplies REQUIRED OUTPUT}\par
00009 {\cf21 #define _In_Opt }{\cf20 // Takes OPTIONAL INPUT if given.}\par
00010 {\cf21 #define _Out_Opt }{\cf20 // OPTIONALLY Supplies OUTPUT if given.}\par
00011 \par
00012 {\cf20 // Function will not return.}\par
00013 {\cf21 #define NORETURN __attribute__((noreturn))}\par
00014 \par
00015 {\cf20 // Function will be forcefully inlined by the compiler.}\par
00016 {\cf21 #ifndef FORCEINLINE}\par
00017 {\cf21 #if defined(__clang__) || defined(__GNUC__)}\par
00018 {\cf21 #define FORCEINLINE static inline __attribute__((always_inline))}\par
00019 {\cf21 #elif defined(_MSC_VER)}\par
00020 {\cf21 #define FORCEINLINE static __forceinline}\par
00021 {\cf21 #else}\par
00022 {\cf21 #define FORCEINLINE static inline}\par
00023 {\cf21 #endif}\par
00024 {\cf21 #endif}\par
00025 \par
00026 {\cf20 // Function will be forcefully inlined by the compiler. (between translation files)}\par
00027 {\cf21 #ifndef FORCEINLINE_NOHEADER}\par
00028 {\cf21 #if defined(__clang__) || defined(__GNUC__)}\par
00029 {\cf21 #define FORCEINLINE_NOHEADER __attribute__((always_inline))}\par
00030 {\cf21 #elif defined(_MSC_VER)}\par
00031 {\cf21 #define FORCEINLINE_NOHEADER __forceinline}\par
00032 {\cf21 #else}\par
00033 {\cf21 #define FORCEINLINE_NOHEADER inline}\par
00034 {\cf21 #endif}\par
00035 {\cf21 #endif}\par
00036 \par
00037 {\cf20 // Function / Object is signaled as used, even though it is not used in any translation unit.}\par
00038 {\cf21 #define USED __attribute__((used))}\par
00039 \par
00040 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/behavior.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/behavior.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/behavior.h}
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
behavior.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/behavior.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/behavior.h}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     me.h}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This module contains the macros & definitions that affect the behavior of the OS by changing preprocessor directives.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #ifndef X86_MATANEL_BEHAVIOR_H}\par
00020 {\cf21 #define X86_MATANEL_BEHAVIOR_H}\par
00021 \par
00022 {\cf20 //#define MT_UP // Uncomment to define the system to run in UniProcessor mode (will NOT enable SMP, undefs spinlocks)}\par
00023 \par
00024 {\cf20 //#define DISABLE_CACHE // Uncomment to disable CPU Caching on ALL CPUs (if SMP, if not, only BSP)}\par
00025 \par
00026 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/core.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/core.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/core.h}
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "behavior.h"}\par
{\f2 #include "macros.h"}\par
{\f2 #include "annotations.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SINGLE_LINKED_LIST}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DOUBLY_LINKED_LIST}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _IRQL} {\b IRQL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _IRQL} * {\b PIRQL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _SINGLE_LINKED_LIST} {\b SINGLE_LINKED_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _SINGLE_LINKED_LIST} * {\b PSINGLE_LINKED_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DOUBLY_LINKED_LIST} {\b DOUBLY_LINKED_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DOUBLY_LINKED_LIST} * {\b PDOUBLY_LINKED_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _ITHREAD} {\b ITHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b ITHREAD} * {\b PITHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IPROCESS} {\b IPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b IPROCESS} * {\b PIPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _ETHREAD} {\b ETHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b ETHREAD} * {\b PETHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _PROCESSOR} {\b PROCESSOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b PROCESSOR} * {\b PPROCESSOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EPROCESS} {\b EPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b EPROCESS} * {\b PEPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _TRAP_FRAME} {\b TRAP_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b TRAP_FRAME} * {\b PTRAP_FRAME}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _IRQL} \{ {\b PASSIVE_LEVEL} = 0
, {\b APC_LEVEL} = 1
, {\b DISPATCH_LEVEL} = 2
, {\b PROFILE_LEVEL} = 27
, {\b CLOCK_LEVEL} = 28
, {\b IPI_LEVEL} = 29
, {\b POWER_LEVEL} = 30
, {\b HIGH_LEVEL} = 31
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v DOUBLY_LINKED_LIST\:core.h}
{\xe \v core.h\:DOUBLY_LINKED_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DOUBLY_LINKED_LIST} {\b DOUBLY_LINKED_LIST}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EPROCESS\:core.h}
{\xe \v core.h\:EPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EPROCESS} {\b EPROCESS}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b core.h}.}\par
}
{\xe \v ETHREAD\:core.h}
{\xe \v core.h\:ETHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _ETHREAD} {\b ETHREAD}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b core.h}.}\par
}
{\xe \v IPROCESS\:core.h}
{\xe \v core.h\:IPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IPROCESS} {\b IPROCESS}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b core.h}.}\par
}
{\xe \v IRQL\:core.h}
{\xe \v core.h\:IRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _IRQL} {\b IRQL}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ITHREAD\:core.h}
{\xe \v core.h\:ITHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _ITHREAD} {\b ITHREAD}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b core.h}.}\par
}
{\xe \v PDOUBLY_LINKED_LIST\:core.h}
{\xe \v core.h\:PDOUBLY_LINKED_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DOUBLY_LINKED_LIST} * {\b PDOUBLY_LINKED_LIST}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PEPROCESS\:core.h}
{\xe \v core.h\:PEPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b EPROCESS}* {\b PEPROCESS}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b core.h}.}\par
}
{\xe \v PETHREAD\:core.h}
{\xe \v core.h\:PETHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b ETHREAD}* {\b PETHREAD}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b core.h}.}\par
}
{\xe \v PIPROCESS\:core.h}
{\xe \v core.h\:PIPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b IPROCESS}* {\b PIPROCESS}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b core.h}.}\par
}
{\xe \v PIRQL\:core.h}
{\xe \v core.h\:PIRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _IRQL} * {\b PIRQL}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PITHREAD\:core.h}
{\xe \v core.h\:PITHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b ITHREAD}* {\b PITHREAD}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b core.h}.}\par
}
{\xe \v PPROCESSOR\:core.h}
{\xe \v core.h\:PPROCESSOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b PROCESSOR}* {\b PPROCESSOR}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b core.h}.}\par
}
{\xe \v PROCESSOR\:core.h}
{\xe \v core.h\:PROCESSOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _PROCESSOR} {\b PROCESSOR}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b core.h}.}\par
}
{\xe \v PSINGLE_LINKED_LIST\:core.h}
{\xe \v core.h\:PSINGLE_LINKED_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _SINGLE_LINKED_LIST} * {\b PSINGLE_LINKED_LIST}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PTRAP_FRAME\:core.h}
{\xe \v core.h\:PTRAP_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b TRAP_FRAME}* {\b PTRAP_FRAME}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b core.h}.}\par
}
{\xe \v SINGLE_LINKED_LIST\:core.h}
{\xe \v core.h\:SINGLE_LINKED_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _SINGLE_LINKED_LIST} {\b SINGLE_LINKED_LIST}}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TRAP_FRAME\:core.h}
{\xe \v core.h\:TRAP_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _TRAP_FRAME} {\b TRAP_FRAME}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b core.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _IRQL\:core.h}
{\xe \v core.h\:_IRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _IRQL}}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PASSIVE_LEVEL\:core.h}
{\xe \v core.h\:PASSIVE_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PASSIVE_LEVEL{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
\cell }{\cell }{\row }
{\xe \v APC_LEVEL\:core.h}
{\xe \v core.h\:APC_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid APC_LEVEL{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
\cell }{\cell }{\row }
{\xe \v DISPATCH_LEVEL\:core.h}
{\xe \v core.h\:DISPATCH_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DISPATCH_LEVEL{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
\cell }{\cell }{\row }
{\xe \v PROFILE_LEVEL\:core.h}
{\xe \v core.h\:PROFILE_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROFILE_LEVEL{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
\cell }{\cell }{\row }
{\xe \v CLOCK_LEVEL\:core.h}
{\xe \v core.h\:CLOCK_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CLOCK_LEVEL{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
\cell }{\cell }{\row }
{\xe \v IPI_LEVEL\:core.h}
{\xe \v core.h\:IPI_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IPI_LEVEL{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
\cell }{\cell }{\row }
{\xe \v POWER_LEVEL\:core.h}
{\xe \v core.h\:POWER_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid POWER_LEVEL{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
\cell }{\cell }{\row }
{\xe \v HIGH_LEVEL\:core.h}
{\xe \v core.h\:HIGH_LEVEL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HIGH_LEVEL{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 12} of file {\b core.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
core.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/core.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/core.h}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef MATANEL_CORE_H}\par
00002 {\cf21 #define MATANEL_CORE_H}\par
00003 \par
00004 {\cf20 /* minimal shared types to avoid circular includes */}\par
00005 \par
00006 {\cf21 #include <stdbool.h>}\par
00007 {\cf21 #include <stdint.h>}\par
00008 {\cf21 #include "behavior.h"}\par
00009 {\cf21 #include "macros.h"}\par
00010 {\cf21 #include "annotations.h"}\par
00011 \par
00012 {\cf17 typedef} {\cf17 enum} _IRQL \{\par
00013     PASSIVE_LEVEL = 0,\par
00014     APC_LEVEL = 1,\par
00015     DISPATCH_LEVEL = 2,\par
00016     PROFILE_LEVEL = 27,\par
00017     CLOCK_LEVEL = 28,\par
00018     IPI_LEVEL = 29,\par
00019     POWER_LEVEL = 30,\par
00020     HIGH_LEVEL = 31\par
00021 \} IRQL, * PIRQL;\par
00022 \par
00023 {\cf17 typedef} {\cf17 struct }_SINGLE_LINKED_LIST \{\par
00024     {\cf17 struct }_SINGLE_LINKED_LIST* Next;\par
00025 \} SINGLE_LINKED_LIST, * PSINGLE_LINKED_LIST;\par
00026 \par
00027 {\cf17 typedef} {\cf17 struct }_DOUBLY_LINKED_LIST \{\par
00028     {\cf17 struct }_DOUBLY_LINKED_LIST* Blink;\par
00029     {\cf17 struct }_DOUBLY_LINKED_LIST* Flink;\par
00030 \} DOUBLY_LINKED_LIST, * PDOUBLY_LINKED_LIST;\par
00031 \par
00032 {\cf17 struct }_ITHREAD;\par
00033 {\cf17 typedef} {\cf17 struct }_ITHREAD ITHREAD;\par
00034 {\cf17 typedef} ITHREAD* PITHREAD;\par
00035 \par
00036 {\cf17 struct }_IPROCESS;\par
00037 {\cf17 typedef} {\cf17 struct }_IPROCESS IPROCESS;\par
00038 {\cf17 typedef} IPROCESS* PIPROCESS;\par
00039 \par
00040 {\cf17 struct }_ETHREAD;\par
00041 {\cf17 typedef} {\cf17 struct }_ETHREAD ETHREAD;\par
00042 {\cf17 typedef} ETHREAD* PETHREAD;\par
00043 \par
00044 {\cf17 struct }_PROCESSOR;\par
00045 {\cf17 typedef} {\cf17 struct }_PROCESSOR PROCESSOR;\par
00046 {\cf17 typedef} PROCESSOR* PPROCESSOR;\par
00047 \par
00048 {\cf17 struct }_EPROCESS;\par
00049 {\cf17 typedef} {\cf17 struct }_EPROCESS EPROCESS;\par
00050 {\cf17 typedef} EPROCESS* PEPROCESS;\par
00051 \par
00052 {\cf17 struct }_TRAP_FRAME;\par
00053 {\cf17 typedef} {\cf17 struct }_TRAP_FRAME TRAP_FRAME;\par
00054 {\cf17 typedef} TRAP_FRAME* PTRAP_FRAME;\par
00055 \par
00056 {\cf21 #endif }{\cf20 // MATANEL_CORE_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/efi.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/efi.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/efi.h}
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EFI_MEMORY_DESCRIPTOR}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _GOP_PARAMS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _BOOT_INFO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_STACK_SIZE_IN_BYTES}\~ (8 * 4096)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiReservedMemoryType}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiLoaderCode}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiLoaderData}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiBootServicesCode}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiBootServicesData}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiRuntimeServicesCode}\~ 5\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiRuntimeServicesData}\~ 6\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiConventionalMemory}\~ 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiUnusableMemory}\~ 8\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiACPIReclaimMemory}\~ 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiACPIMemoryNVS}\~ 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiMemoryMappedIO}\~ 11\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiMemoryMappedIOPort}\~ 12\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiPalCode}\~ 13\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EfiPersistentMemory}\~ 14\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EFI_MEMORY_DESCRIPTOR} {\b EFI_MEMORY_DESCRIPTOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EFI_MEMORY_DESCRIPTOR} * {\b PEFI_MEMORY_DESCRIPTOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _GOP_PARAMS} {\b GOP_PARAMS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BOOT_INFO} {\b BOOT_INFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _BOOT_INFO} * {\b PBOOT_INFO}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v EfiACPIMemoryNVS\:efi.h}
{\xe \v efi.h\:EfiACPIMemoryNVS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiACPIMemoryNVS\~ 10}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 95} of file {\b efi.h}.}\par
}
{\xe \v EfiACPIReclaimMemory\:efi.h}
{\xe \v efi.h\:EfiACPIReclaimMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiACPIReclaimMemory\~ 9}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b efi.h}.}\par
}
{\xe \v EfiBootServicesCode\:efi.h}
{\xe \v efi.h\:EfiBootServicesCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiBootServicesCode\~ 3}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b efi.h}.}\par
}
{\xe \v EfiBootServicesData\:efi.h}
{\xe \v efi.h\:EfiBootServicesData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiBootServicesData\~ 4}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b efi.h}.}\par
}
{\xe \v EfiConventionalMemory\:efi.h}
{\xe \v efi.h\:EfiConventionalMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiConventionalMemory\~ 7}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b efi.h}.}\par
}
{\xe \v EfiLoaderCode\:efi.h}
{\xe \v efi.h\:EfiLoaderCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiLoaderCode\~ 1}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b efi.h}.}\par
}
{\xe \v EfiLoaderData\:efi.h}
{\xe \v efi.h\:EfiLoaderData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiLoaderData\~ 2}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b efi.h}.}\par
}
{\xe \v EfiMemoryMappedIO\:efi.h}
{\xe \v efi.h\:EfiMemoryMappedIO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiMemoryMappedIO\~ 11}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b efi.h}.}\par
}
{\xe \v EfiMemoryMappedIOPort\:efi.h}
{\xe \v efi.h\:EfiMemoryMappedIOPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiMemoryMappedIOPort\~ 12}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b efi.h}.}\par
}
{\xe \v EfiPalCode\:efi.h}
{\xe \v efi.h\:EfiPalCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiPalCode\~ 13}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b efi.h}.}\par
}
{\xe \v EfiPersistentMemory\:efi.h}
{\xe \v efi.h\:EfiPersistentMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiPersistentMemory\~ 14}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b efi.h}.}\par
}
{\xe \v EfiReservedMemoryType\:efi.h}
{\xe \v efi.h\:EfiReservedMemoryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiReservedMemoryType\~ 0}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b efi.h}.}\par
}
{\xe \v EfiRuntimeServicesCode\:efi.h}
{\xe \v efi.h\:EfiRuntimeServicesCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiRuntimeServicesCode\~ 5}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b efi.h}.}\par
}
{\xe \v EfiRuntimeServicesData\:efi.h}
{\xe \v efi.h\:EfiRuntimeServicesData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiRuntimeServicesData\~ 6}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b efi.h}.}\par
}
{\xe \v EfiUnusableMemory\:efi.h}
{\xe \v efi.h\:EfiUnusableMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EfiUnusableMemory\~ 8}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b efi.h}.}\par
}
{\xe \v KERNEL_STACK_SIZE_IN_BYTES\:efi.h}
{\xe \v efi.h\:KERNEL_STACK_SIZE_IN_BYTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_STACK_SIZE_IN_BYTES\~ (8 * 4096)}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b efi.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v BOOT_INFO\:efi.h}
{\xe \v efi.h\:BOOT_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BOOT_INFO} {\b BOOT_INFO}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EFI_MEMORY_DESCRIPTOR\:efi.h}
{\xe \v efi.h\:EFI_MEMORY_DESCRIPTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EFI_MEMORY_DESCRIPTOR} {\b EFI_MEMORY_DESCRIPTOR}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GOP_PARAMS\:efi.h}
{\xe \v efi.h\:GOP_PARAMS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _GOP_PARAMS} {\b GOP_PARAMS}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PBOOT_INFO\:efi.h}
{\xe \v efi.h\:PBOOT_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _BOOT_INFO} * {\b PBOOT_INFO}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PEFI_MEMORY_DESCRIPTOR\:efi.h}
{\xe \v efi.h\:PEFI_MEMORY_DESCRIPTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EFI_MEMORY_DESCRIPTOR} * {\b PEFI_MEMORY_DESCRIPTOR}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v boot_info_local\:efi.h}
{\xe \v efi.h\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
efi.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/efi.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/efi.h}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_UEFI_MEMORY_H}\par
00002 {\cf21 #define X86_UEFI_MEMORY_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     efi.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for interacting with UEFI properties}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf20 // Standard headers, required.}\par
00023 {\cf21 #include <stddef.h>}\par
00024 {\cf21 #include <stdbool.h>}\par
00025 {\cf21 #include <stdint.h>}\par
00026 \par
00027 {\cf20 // global}\par
00028 {\cf17 typedef} {\cf17 struct }_BLOCK_DEVICE BLOCK_DEVICE;\par
00029 \par
00030 {\cf20 // Minimal UEFI memory descriptor for kernel use}\par
00031 {\cf20 // Matches UEFI spec EFI_MEMORY_DESCRIPTOR up to PhysicalStart, NumberOfPages, Type}\par
00032 \par
00033 {\cf17 typedef} {\cf17 struct }_EFI_MEMORY_DESCRIPTOR \{\par
00034     uint32_t Type;         {\cf20 // What this memory region is used for}\par
00035     uint32_t Pad;          {\cf20 // Alignment / padding}\par
00036     uint64_t PhysicalStart; {\cf20 // Physical start address of the region}\par
00037     uint64_t VirtualStart;  {\cf20 // Virtual start (usually 0 during boot)}\par
00038     uint64_t NumberOfPages; {\cf20 // Size of the region in pages (usually 4 KB)}\par
00039     uint64_t Attribute;     {\cf20 // Flags (cacheable, runtime, etc.)}\par
00040 \} EFI_MEMORY_DESCRIPTOR, *PEFI_MEMORY_DESCRIPTOR;\par
00041 \par
00042 {\cf17 typedef} {\cf17 struct }_GOP_PARAMS \{\par
00043     uint64_t FrameBufferBase;\par
00044     uint64_t FrameBufferSize;\par
00045     uint32_t Width;               {\cf20 // Visible width in pixels}\par
00046     uint32_t Height;              {\cf20 // Visible height in pixels}\par
00047     uint32_t PixelsPerScanLine;   {\cf20 // Actual pixels per row in framebuffer (stride)}\par
00048 \} GOP_PARAMS;\par
00049 \par
00050 {\cf21 #define KERNEL_STACK_SIZE_IN_BYTES (8 * 4096) }{\cf20 // 32768 Bytes}\par
00051 \par
00052 {\cf17 typedef} {\cf17 struct }_BOOT_INFO \{\par
00053     GOP_PARAMS Gop;\par
00054     EFI_MEMORY_DESCRIPTOR* MemoryMap;\par
00055     {\cf18 size_t}                    MapSize;\par
00056     {\cf18 size_t}                    DescriptorSize;\par
00057     uint32_t                  DescriptorVersion;\par
00058     {\cf18 size_t}                  AhciCount;\par
00059     uint64_t AhciBarBases[32];\par
00060     uint64_t KernelStackTop;\par
00061     uintptr_t Pml4Phys;\par
00062     uintptr_t AcpiRsdpPhys;\par
00063 \} BOOT_INFO, *PBOOT_INFO;\par
00064 \par
00065 {\cf21 #ifndef _MSC_VER }\par
00066 {\cf17 _Static_assert}({\cf17 sizeof}(BOOT_INFO) == 352, {\cf22 "Size of BOOT_INFO doesn't equal 344 bytes. Update the struct."});\par
00067 {\cf17 _Static_assert}(offsetof(BOOT_INFO, KernelStackTop) == 0x148, {\cf22 "KernelStackTop isnt 0x148"});\par
00068 {\cf21 #endif}\par
00069 \par
00070 {\cf20 /*}\par
00071 {\cf20 Gop                 : offset 0x00   (0)}\par
00072 {\cf20 MemoryMap           : offset 0x20   (32)}\par
00073 {\cf20 MapSize             : offset 0x28   (40)}\par
00074 {\cf20 DescriptorSize      : offset 0x30   (48)}\par
00075 {\cf20 DescriptorVersion   : offset 0x38   (56)}\par
00076 {\cf20 AhciCount           : offset 0x40   (64)}\par
00077 {\cf20 AhciBarBases        : offset 0x48   (72) }\par
00078 {\cf20 KernelStackTop      : offset 0x148  (328)}\par
00079 {\cf20 Pml4Phys            : offset 0x150  (336)}\par
00080 {\cf20 AcpiRsdpPhys        : offset 0x158  (352)}\par
00081 {\cf20 sizeof(BOOT_INFO)   : 352 (0x160)}\par
00082 {\cf20 */}\par
00083 \par
00084 {\cf20 // Memory types (we only need ConventionalMemory here)}\par
00085 {\cf21 #define EfiReservedMemoryType          0}\par
00086 {\cf21 #define EfiLoaderCode                  1 }{\cf20 // Unusable, marked when we allocated something.}\par
00087 {\cf21 #define EfiLoaderData                  2 }{\cf20 // Unusable, marked when we alocated something.}\par
00088 {\cf21 #define EfiBootServicesCode            3 }\par
00089 {\cf21 #define EfiBootServicesData            4 }\par
00090 {\cf21 #define EfiRuntimeServicesCode         5}\par
00091 {\cf21 #define EfiRuntimeServicesData         6}\par
00092 {\cf21 #define EfiConventionalMemory          7 }\par
00093 {\cf21 #define EfiUnusableMemory              8}\par
00094 {\cf21 #define EfiACPIReclaimMemory           9}\par
00095 {\cf21 #define EfiACPIMemoryNVS               10}\par
00096 {\cf21 #define EfiMemoryMappedIO              11}\par
00097 {\cf21 #define EfiMemoryMappedIOPort          12}\par
00098 {\cf21 #define EfiPalCode                     13}\par
00099 {\cf21 #define EfiPersistentMemory            14}\par
00100 \par
00101 {\cf17 extern} BOOT_INFO boot_info_local;\par
00102 \par
00103 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/exception.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/exception.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/exception.h}
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include "me.h"}\par
{\f2 #include "core.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EXCEPTION_RECORD}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _CONTEXT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EXCEPTION_REGISTRATION_RECORD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EX_FRAME_REGISTRATION}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXCEPTION_MAXIMUM_PARAMETERS}\~ 15\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _try}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _except}(FilterExpression)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _end_except}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EXCEPTION_RECORD} {\b EXCEPTION_RECORD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EXCEPTION_RECORD} * {\b PEXCEPTION_RECORD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _EXCEPTION_DISPOSITION} {\b EXCEPTION_DISPOSITION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _CONTEXT} {\b CONTEXT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _CONTEXT} * {\b PCONTEXT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EXCEPTION_REGISTRATION_RECORD} {\b EXCEPTION_REGISTRATION_RECORD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EX_FRAME_REGISTRATION} {\b EX_FRAME_REGISTRATION}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _EXCEPTION_DISPOSITION} \{ {\b ExceptionContinueExecution} = 0
, {\b ExceptionContinueSearch} = 1
, {\b ExceptionNestedException} = 2
, {\b ExceptionCollidedUnwind} = 3
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b PsGetCurrentThread} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ExpCaptureContext} ({\b IN} {\b PCONTEXT} Context)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EXCEPTION_DISPOSITION} {\b MeStandardHandler} ({\b PEXCEPTION_RECORD} ExceptionRecord, void *EstablisherFrame, {\b PCONTEXT} ContextRecord, void *DispatcherContext)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ExpIsExceptionHandlerPresent} ({\b IN} {\b PETHREAD} Thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ExpDispatchException} ({\b IN} {\b PTRAP_FRAME} TrapFrame, {\b IN} {\b PCONTEXT} ContextRecord, {\b IN} {\b PEXCEPTION_RECORD} ExceptionRecord)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _end_except\:exception.h}
{\xe \v exception.h\:_end_except}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _end_except}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid             \} \\\par
        \} \\\par
    \}\par
}
{
Definition at line {\b 121} of file {\b exception.h}.}\par
}
{\xe \v _except\:exception.h}
{\xe \v exception.h\:_except}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _except( FilterExpression)}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid             {\cf20 /* Success path: Unlink frame */} \\\par
            _CurrentThread->ExceptionList = _MyFrame.Next; \\\par
        \} {\cf19 else} \{ \\\par
            {\cf20 /* Crash path: We just "landed" here from the handler! */} \\\par
            {\cf20 /* Unlink frame (safe to do again) */} \\\par
            _CurrentThread->ExceptionList = _MyFrame.Next; \\\par
            {\cf20 /* You can access _MyFrame.ExceptionCode here if needed */} \\\par
            \{ \\\par
               {\cf20 /* User Code inside except block */}\par
}
{
Definition at line {\b 110} of file {\b exception.h}.}\par
}
{\xe \v _try\:exception.h}
{\xe \v exception.h\:_try}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _try}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     \{ \\\par
        PETHREAD _CurrentThread = PsGetCurrentThread(); \\\par
        ME_EXCEPTION_FRAME _MyFrame; \\\par
        _MyFrame.Next = (PME_EXCEPTION_FRAME)_CurrentThread->ExceptionList; \\\par
        _MyFrame.Handler = MeStandardHandler; \\\par
        _CurrentThread->ExceptionList = &_MyFrame; \\\par
        {\cf20 /* Save Context. Returns 0 initially. Returns 1 if we crashed. */} \\\par
        if (ExpCaptureContext(&_MyFrame) == 0) \{ \\\par
}
{
Definition at line {\b 100} of file {\b exception.h}.}\par
}
{\xe \v EXCEPTION_MAXIMUM_PARAMETERS\:exception.h}
{\xe \v exception.h\:EXCEPTION_MAXIMUM_PARAMETERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXCEPTION_MAXIMUM_PARAMETERS\~ 15}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CONTEXT\:exception.h}
{\xe \v exception.h\:CONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _CONTEXT} {\b CONTEXT}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EX_FRAME_REGISTRATION\:exception.h}
{\xe \v exception.h\:EX_FRAME_REGISTRATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EX_FRAME_REGISTRATION} {\b EX_FRAME_REGISTRATION}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXCEPTION_DISPOSITION\:exception.h}
{\xe \v exception.h\:EXCEPTION_DISPOSITION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _EXCEPTION_DISPOSITION} {\b EXCEPTION_DISPOSITION}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXCEPTION_RECORD\:exception.h}
{\xe \v exception.h\:EXCEPTION_RECORD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EXCEPTION_RECORD} {\b EXCEPTION_RECORD}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v EXCEPTION_REGISTRATION_RECORD\:exception.h}
{\xe \v exception.h\:EXCEPTION_REGISTRATION_RECORD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EXCEPTION_REGISTRATION_RECORD} {\b EXCEPTION_REGISTRATION_RECORD}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PCONTEXT\:exception.h}
{\xe \v exception.h\:PCONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _CONTEXT} * {\b PCONTEXT}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PEXCEPTION_RECORD\:exception.h}
{\xe \v exception.h\:PEXCEPTION_RECORD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EXCEPTION_RECORD} * {\b PEXCEPTION_RECORD}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _EXCEPTION_DISPOSITION\:exception.h}
{\xe \v exception.h\:_EXCEPTION_DISPOSITION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _EXCEPTION_DISPOSITION}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v ExceptionContinueExecution\:exception.h}
{\xe \v exception.h\:ExceptionContinueExecution}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExceptionContinueExecution{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
\cell }{\cell }{\row }
{\xe \v ExceptionContinueSearch\:exception.h}
{\xe \v exception.h\:ExceptionContinueSearch}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExceptionContinueSearch{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
\cell }{\cell }{\row }
{\xe \v ExceptionNestedException\:exception.h}
{\xe \v exception.h\:ExceptionNestedException}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExceptionNestedException{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\cell }{\cell }{\row }
{\xe \v ExceptionCollidedUnwind\:exception.h}
{\xe \v exception.h\:ExceptionCollidedUnwind}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExceptionCollidedUnwind{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 43} of file {\b exception.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v ExpCaptureContext\:exception.h}
{\xe \v exception.h\:ExpCaptureContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExpCaptureContext ({\b IN} {\b PCONTEXT} Context){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ExpDispatchException\:exception.h}
{\xe \v exception.h\:ExpDispatchException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ExpDispatchException ({\b IN} {\b PTRAP_FRAME} TrapFrame, {\b IN} {\b PCONTEXT} ContextRecord, {\b IN} {\b PEXCEPTION_RECORD} ExceptionRecord)}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b exception.c}.}\par
}
{\xe \v ExpIsExceptionHandlerPresent\:exception.h}
{\xe \v exception.h\:ExpIsExceptionHandlerPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ExpIsExceptionHandlerPresent ({\b IN} {\b PETHREAD} Thread)}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b exception.c}.}\par
}
{\xe \v MeStandardHandler\:exception.h}
{\xe \v exception.h\:MeStandardHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EXCEPTION_DISPOSITION} MeStandardHandler ({\b PEXCEPTION_RECORD} ExceptionRecord, void * EstablisherFrame, {\b PCONTEXT} ContextRecord, void * DispatcherContext)}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PsGetCurrentThread\:exception.h}
{\xe \v exception.h\:PsGetCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} PsGetCurrentThread (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b thread.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
exception.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/exception.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/exception.h}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_EXCEPTION}\par
00002 {\cf21 #define X86_MATANEL_EXCEPTION}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     exception.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for runtime exception handling of the OS.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf20 // Base includes}\par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stddef.h>}\par
00025 \par
00026 {\cf20 // Other file includes}\par
00027 {\cf21 #include "me.h"}\par
00028 {\cf21 #include "core.h"}\par
00029 \par
00030 {\cf20 // ------------------ STRUCTURES ------------------}\par
00031 \par
00032 {\cf20 //struct _CONTEXT;}\par
00033 \par
00034 {\cf21 #define EXCEPTION_MAXIMUM_PARAMETERS 15}\par
00035 {\cf17 typedef} {\cf17 struct }_EXCEPTION_RECORD \{\par
00036     MTSTATUS ExceptionCode;\par
00037     uint32_t ExceptionFlags;\par
00038     {\cf17 struct }_EXCEPTION_RECORD* ExceptionRecord; {\cf20 // For nested exceptions}\par
00039     {\cf18 void}* ExceptionAddress;                     {\cf20 // RIP at time of fault}\par
00040     {\cf20 //struct _CONTEXT ExceptionContext;}\par
00041 \} EXCEPTION_RECORD, * PEXCEPTION_RECORD;\par
00042 \par
00043 {\cf17 typedef} {\cf17 enum} _EXCEPTION_DISPOSITION \{\par
00044     ExceptionContinueExecution = 0,\par
00045     ExceptionContinueSearch = 1,\par
00046     ExceptionNestedException = 2,\par
00047     ExceptionCollidedUnwind = 3\par
00048 \} EXCEPTION_DISPOSITION;\par
00049 \par
00050 {\cf17 typedef} {\cf17 struct }_CONTEXT \{\par
00051     uint64_t RFlags;\par
00052     uint64_t Dr0;\par
00053     uint64_t Dr1;\par
00054     uint64_t Dr2;\par
00055     uint64_t Dr3;\par
00056     uint64_t Dr6;\par
00057     uint64_t Dr7;\par
00058     uint64_t Rax;\par
00059     uint64_t Rcx;\par
00060     uint64_t Rdx;\par
00061     uint64_t Rbx;\par
00062     uint64_t Rsp;\par
00063     uint64_t Rbp;\par
00064     uint64_t Rsi;\par
00065     uint64_t Rdi;\par
00066     uint64_t R8;\par
00067     uint64_t R9;\par
00068     uint64_t R10;\par
00069     uint64_t R11;\par
00070     uint64_t R12;\par
00071     uint64_t R13;\par
00072     uint64_t R14;\par
00073     uint64_t R15;\par
00074     uint64_t Rip;\par
00075 \} CONTEXT, * PCONTEXT;\par
00076 \par
00077 {\cf17 typedef} {\cf17 struct }_EXCEPTION_REGISTRATION_RECORD \{\par
00078     {\cf17 struct }_EXCEPTION_REGISTRATION_RECORD* Next;\par
00079     {\cf17 enum} _EXCEPTION_DISPOSITION(*Handler)({\cf17 struct }_EXCEPTION_RECORD* arg1, {\cf18 void}* Frame, {\cf17 struct }_CONTEXT* arg2, {\cf18 void}* DispCtx);\par
00080 \} EXCEPTION_REGISTRATION_RECORD;\par
00081 \par
00082 {\cf17 typedef} {\cf17 struct }_EX_FRAME_REGISTRATION \{\par
00083     PETHREAD Thread;\par
00084     EXCEPTION_REGISTRATION_RECORD* RegistrationPointer;\par
00085 \} EX_FRAME_REGISTRATION;\par
00086 \par
00087 {\cf20 // ------------------ FUNCTIONS ------------------}\par
00088 \par
00089 {\cf17 extern} PETHREAD PsGetCurrentThread({\cf18 void});\par
00090 {\cf17 extern} {\cf18 bool} ExpCaptureContext(IN PCONTEXT Context);\par
00091 \par
00092 EXCEPTION_DISPOSITION MeStandardHandler(\par
00093     PEXCEPTION_RECORD ExceptionRecord,\par
00094     {\cf18 void}* EstablisherFrame,\par
00095     PCONTEXT ContextRecord,\par
00096     {\cf18 void}* DispatcherContext\par
00097 );\par
00098 \par
00099 {\cf20 // macros}\par
00100 {\cf21 #define _try \\}\par
00101 {\cf21     \{ \\}\par
00102 {\cf21         PETHREAD _CurrentThread = PsGetCurrentThread(); \\}\par
00103 {\cf21         ME_EXCEPTION_FRAME _MyFrame; \\}\par
00104 {\cf21         _MyFrame.Next = (PME_EXCEPTION_FRAME)_CurrentThread->ExceptionList; \\}\par
00105 {\cf21         _MyFrame.Handler = MeStandardHandler; \\}\par
00106 {\cf21         _CurrentThread->ExceptionList = &_MyFrame; \\}\par
00107 {\cf21         }{\cf20 /* Save Context. Returns 0 initially. Returns 1 if we crashed. */}{\cf21  \\}\par
00108 {\cf21         if (ExpCaptureContext(&_MyFrame) == 0) \{ \\}\par
00109 {\cf21 }\par
00110 {\cf21 #define _except(FilterExpression) \\}\par
00111 {\cf21             }{\cf20 /* Success path: Unlink frame */}{\cf21  \\}\par
00112 {\cf21             _CurrentThread->ExceptionList = _MyFrame.Next; \\}\par
00113 {\cf21         \} else \{ \\}\par
00114 {\cf21             }{\cf20 /* Crash path: We just "landed" here from the handler! */}{\cf21  \\}\par
00115 {\cf21             }{\cf20 /* Unlink frame (safe to do again) */}{\cf21  \\}\par
00116 {\cf21             _CurrentThread->ExceptionList = _MyFrame.Next; \\}\par
00117 {\cf21             }{\cf20 /* You can access _MyFrame.ExceptionCode here if needed */}{\cf21  \\}\par
00118 {\cf21             \{ \\}\par
00119 {\cf21                }{\cf20 /* User Code inside except block */}{\cf21 }\par
00120 \par
00121 {\cf21 #define _end_except \\}\par
00122 {\cf21             \} \\}\par
00123 {\cf21         \} \\}\par
00124 {\cf21     \}}\par
00125 \par
00126 {\cf18 bool}\par
00127 ExpIsExceptionHandlerPresent(\par
00128     IN PETHREAD Thread\par
00129 );\par
00130 \par
00131 {\cf18 void}\par
00132 ExpDispatchException(\par
00133     IN PTRAP_FRAME TrapFrame,\par
00134     IN PCONTEXT ContextRecord,\par
00135     IN PEXCEPTION_RECORD ExceptionRecord\par
00136 );\par
00137 \par
00138 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ht.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ht.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ht.h}
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "core.h"}\par
{\f2 #include "ms.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HANDLE_TABLE_ENTRY}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _HANDLE_TABLE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOW_LEVEL_ENTRIES}\~ ({\b VirtualPageSize} / sizeof({\b HANDLE_TABLE_ENTRY}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TABLE_LEVEL_MASK}\~ 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HANDLE_TABLE_ENTRY} {\b HANDLE_TABLE_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HANDLE_TABLE_ENTRY} * {\b PHANDLE_TABLE_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HANDLE_TABLE} {\b HANDLE_TABLE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _HANDLE_TABLE} * {\b PHANDLE_TABLE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int32_t {\b HANDLE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int32_t * {\b PHANDLE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint32_t {\b ACCESS_MASK}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b HtGetObject} ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle, {\b PHANDLE_TABLE_ENTRY} *OutEntry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HtDeleteHandle} ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b HtCreateHandle} ({\b PHANDLE_TABLE} Table, void *Object, uint32_t Access)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PHANDLE_TABLE} {\b HtCreateHandleTable} ({\b IN} {\b PEPROCESS} Process)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HtDeleteHandleTable} ({\b IN} {\b PHANDLE_TABLE} Table)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v LOW_LEVEL_ENTRIES\:ht.h}
{\xe \v ht.h\:LOW_LEVEL_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOW_LEVEL_ENTRIES\~ ({\b VirtualPageSize} / sizeof({\b HANDLE_TABLE_ENTRY}))}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b ht.h}.}\par
}
{\xe \v TABLE_LEVEL_MASK\:ht.h}
{\xe \v ht.h\:TABLE_LEVEL_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TABLE_LEVEL_MASK\~ 3}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b ht.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v ACCESS_MASK\:ht.h}
{\xe \v ht.h\:ACCESS_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef uint32_t {\b ACCESS_MASK}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b ht.h}.}\par
}
{\xe \v HANDLE\:ht.h}
{\xe \v ht.h\:HANDLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int32_t {\b HANDLE}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ht.h}.}\par
}
{\xe \v HANDLE_TABLE\:ht.h}
{\xe \v ht.h\:HANDLE_TABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HANDLE_TABLE} {\b HANDLE_TABLE}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HANDLE_TABLE_ENTRY\:ht.h}
{\xe \v ht.h\:HANDLE_TABLE_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HANDLE_TABLE_ENTRY} {\b HANDLE_TABLE_ENTRY}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PHANDLE\:ht.h}
{\xe \v ht.h\:PHANDLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int32_t * {\b PHANDLE}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b ht.h}.}\par
}
{\xe \v PHANDLE_TABLE\:ht.h}
{\xe \v ht.h\:PHANDLE_TABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HANDLE_TABLE} * {\b PHANDLE_TABLE}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PHANDLE_TABLE_ENTRY\:ht.h}
{\xe \v ht.h\:PHANDLE_TABLE_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _HANDLE_TABLE_ENTRY} * {\b PHANDLE_TABLE_ENTRY}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v HtCreateHandle\:ht.h}
{\xe \v ht.h\:HtCreateHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} HtCreateHandle ({\b PHANDLE_TABLE} Table, void * Object, uint32_t Access)}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b handle.c}.}\par
}
{\xe \v HtCreateHandleTable\:ht.h}
{\xe \v ht.h\:HtCreateHandleTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PHANDLE_TABLE} HtCreateHandleTable ({\b IN} {\b PEPROCESS} Process)}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b handle.c}.}\par
}
{\xe \v HtDeleteHandle\:ht.h}
{\xe \v ht.h\:HtDeleteHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HtDeleteHandle ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle)}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 333} of file {\b handle.c}.}\par
}
{\xe \v HtDeleteHandleTable\:ht.h}
{\xe \v ht.h\:HtDeleteHandleTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HtDeleteHandleTable ({\b IN} {\b PHANDLE_TABLE} Table)}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 434} of file {\b handle.c}.}\par
}
{\xe \v HtGetObject\:ht.h}
{\xe \v ht.h\:HtGetObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * HtGetObject ({\b PHANDLE_TABLE} Table, {\b HANDLE} Handle, {\b PHANDLE_TABLE_ENTRY} * OutEntry)}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 389} of file {\b handle.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ht.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ht.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ht.h}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     ht.h}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This module contains the header files & prototypes required for the Handle Table implementation of MatanelOS.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #ifndef X86_MATANEL_HT_H}\par
00020 {\cf21 #define X86_MATANEL_HT_H}\par
00021 \par
00022 {\cf21 #include "core.h"}\par
00023 {\cf21 #include "ms.h"}\par
00024 \par
00025 {\cf20 // --------------- STRUCTURES ---------------}\par
00026 \par
00027 {\cf17 typedef} {\cf17 struct }_HANDLE_TABLE_ENTRY \{\par
00028     {\cf17 union }\{\par
00029         {\cf18 void}* Object;       {\cf20 // [USED IF ALLOCATED] Pointer to the Kernel Object}\par
00030         uint64_t Value;     {\cf20 // Generic value access}\par
00031     \};\par
00032     {\cf17 union }\{\par
00033         uint32_t GrantedAccess;       {\cf20 // [USED IF ALLOCATED] Access Mask (Read, Write, etc.)}\par
00034         uint32_t NextFreeTableEntry;  {\cf20 // [USED IF FREE] Index of the next empty slot}\par
00035     \};\par
00036 \} HANDLE_TABLE_ENTRY, *PHANDLE_TABLE_ENTRY;\par
00037 \par
00038 {\cf21 #define LOW_LEVEL_ENTRIES   (VirtualPageSize / sizeof(HANDLE_TABLE_ENTRY)) }{\cf20 // 256 entries per page}\par
00039 {\cf21 #define TABLE_LEVEL_MASK    3}\par
00040 \par
00041 {\cf17 typedef} {\cf17 struct }_HANDLE_TABLE \{\par
00042     {\cf20 // Linked list of next table (if any)}\par
00043     DOUBLY_LINKED_LIST TableList;\par
00044     SPINLOCK TableLock;\par
00045 \par
00046     {\cf20 // Storage}\par
00047     uint64_t TableCode;     {\cf20 // Pointer | Level}\par
00048     PEPROCESS QuotaProcess;\par
00049 \par
00050     {\cf20 // Free List Logic}\par
00051     PHANDLE_TABLE_ENTRY LastFreeHandleEntry;\par
00052     uint32_t FirstFreeHandle;    {\cf20 // Index of first free handle, or 0 if none.}\par
00053     uint32_t NextHandleNeedingPool;\par
00054     uint32_t HandleCount;\par
00055 \} HANDLE_TABLE, *PHANDLE_TABLE;\par
00056 \par
00057 {\cf20 // --------------- TYPE DEFINES ---------------}\par
00058 \par
00059 {\cf17 typedef} int32_t HANDLE, * PHANDLE;\par
00060 \par
00061 {\cf20 // --------------- FUNCTIONS ---------------}\par
00062 \par
00063 {\cf17 typedef} uint32_t ACCESS_MASK;\par
00064 \par
00065 {\cf18 void}*\par
00066 HtGetObject(\par
00067     PHANDLE_TABLE Table,\par
00068     HANDLE Handle,\par
00069     PHANDLE_TABLE_ENTRY* OutEntry\par
00070 );\par
00071 \par
00072 {\cf18 void}\par
00073 HtDeleteHandle(\par
00074     PHANDLE_TABLE Table,\par
00075     HANDLE Handle\par
00076 );\par
00077 \par
00078 HANDLE\par
00079 HtCreateHandle(\par
00080     PHANDLE_TABLE Table,\par
00081     {\cf18 void}* Object,\par
00082     uint32_t Access\par
00083 );\par
00084 \par
00085 PHANDLE_TABLE\par
00086 HtCreateHandleTable(\par
00087     IN  PEPROCESS Process\par
00088 );\par
00089 \par
00090 {\cf18 void}\par
00091 HtDeleteHandleTable(\par
00092     IN PHANDLE_TABLE Table\par
00093 );\par
00094 \par
00095 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/macros.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/macros.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/macros.h}
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CONTAINING_RECORD}(ptr,  type,  member)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SIZE_T_MAX}\~ (size_t)-1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UINT64_T_MAX}\~ (uint64_t)-1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LK_KERNEL_START}\~ &{\b kernel_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LK_KERNEL_END}\~ &{\b kernel_end}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LK_KERNEL_SIZE}\~ ({\b LK_KERNEL_END} - {\b LK_KERNEL_START})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX}(a,  b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RETADDR}(level)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b likely}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b unlikely}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FREEZE}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FIELD_OFFSET}(t,  f)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b kernel_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b kernel_end}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CONTAINING_RECORD\:macros.h}
{\xe \v macros.h\:CONTAINING_RECORD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CONTAINING_RECORD( ptr,  type,  member)}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ((type *)(({\cf18 char} *)(ptr) - offsetof(type, member)))\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This example is using the legacy kernel structures. Usage: {\b CONTAINING_RECORD(ptr, struct, ptr_member)} Example: CTX_FRAME* ctxframeptr = 0x1234; // Hypothetical address of the pointer. Thread* threadAssociated = {\b CONTAINING_RECORD(ctxframeptr, Thread, ctx)}; // Note that ctx is the member name for CTX_FRAME in the Thread struct. \par
}{
Definition at line {\b 11} of file {\b macros.h}.}\par
}
{\xe \v FIELD_OFFSET\:macros.h}
{\xe \v macros.h\:FIELD_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FIELD_OFFSET( t,  f)}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((uint32_t)(uint32_t*)&(((t*) 0)->f))\par
}
{
Definition at line {\b 52} of file {\b macros.h}.}\par
}
{\xe \v FREEZE\:macros.h}
{\xe \v macros.h\:FREEZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FREEZE()}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __cli(); __hlt()\par
}
{
Definition at line {\b 49} of file {\b macros.h}.}\par
}
{\xe \v likely\:macros.h}
{\xe \v macros.h\:likely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define likely( x)}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_expect(!!(x), 1)\par
}
{
Definition at line {\b 43} of file {\b macros.h}.}\par
}
{\xe \v LK_KERNEL_END\:macros.h}
{\xe \v macros.h\:LK_KERNEL_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LK_KERNEL_END\~ &{\b kernel_end}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b macros.h}.}\par
}
{\xe \v LK_KERNEL_SIZE\:macros.h}
{\xe \v macros.h\:LK_KERNEL_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LK_KERNEL_SIZE\~ ({\b LK_KERNEL_END} - {\b LK_KERNEL_START})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b macros.h}.}\par
}
{\xe \v LK_KERNEL_START\:macros.h}
{\xe \v macros.h\:LK_KERNEL_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LK_KERNEL_START\~ &{\b kernel_start}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b macros.h}.}\par
}
{\xe \v MAX\:macros.h}
{\xe \v macros.h\:MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX( a,  b)}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((a) > (b)) ? (a) : (b))\par
}
{
Definition at line {\b 33} of file {\b macros.h}.}\par
}
{\xe \v RETADDR\:macros.h}
{\xe \v macros.h\:RETADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RETADDR( level)}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (void)(level)\par
}
{
Definition at line {\b 38} of file {\b macros.h}.}\par
}
{\xe \v SIZE_T_MAX\:macros.h}
{\xe \v macros.h\:SIZE_T_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SIZE_T_MAX\~ (size_t)-1}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b macros.h}.}\par
}
{\xe \v UINT64_T_MAX\:macros.h}
{\xe \v macros.h\:UINT64_T_MAX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UINT64_T_MAX\~ (uint64_t)-1}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b macros.h}.}\par
}
{\xe \v unlikely\:macros.h}
{\xe \v macros.h\:unlikely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define unlikely( x)}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_expect(!!(x), 0)\par
}
{
Definition at line {\b 47} of file {\b macros.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v kernel_end\:macros.h}
{\xe \v macros.h\:kernel_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t kernel_end{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v kernel_start\:macros.h}
{\xe \v macros.h\:kernel_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t kernel_start{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
macros.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/macros.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/macros.h}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_MACROS_H}\par
00002 {\cf21 #define X86_MATANEL_MACROS_H}\par
00003 {\cf21 #include <stdint.h>}\par
00004 \par
00010 {\cf21 #ifndef CONTAINING_RECORD}\par
00011 {\cf21 #define CONTAINING_RECORD(ptr, type, member) \\}\par
00012 {\cf21     ((type *)((char *)(ptr) - offsetof(type, member)))}\par
00013 {\cf21 #endif}\par
00014 \par
00015 {\cf21 #undef SIZE_T_MAX}\par
00016 {\cf21 #ifndef SIZE_T_MAX}\par
00017 {\cf21 #define SIZE_T_MAX (size_t)-1}\par
00018 {\cf21 #endif}\par
00019 \par
00020 {\cf21 #undef UINT64_T_MAX}\par
00021 {\cf21 #ifndef UINT64_T_MAX}\par
00022 {\cf21 #define UINT64_T_MAX (uint64_t)-1}\par
00023 {\cf21 #endif}\par
00024 \par
00025 {\cf17 extern} uint8_t kernel_start;\par
00026 {\cf21 #define LK_KERNEL_START &kernel_start}\par
00027 \par
00028 {\cf17 extern} uint8_t kernel_end;\par
00029 {\cf21 #define LK_KERNEL_END &kernel_end}\par
00030 \par
00031 {\cf21 #define LK_KERNEL_SIZE (LK_KERNEL_END - LK_KERNEL_START)}\par
00032 \par
00033 {\cf21 #define MAX(a, b) (((a) > (b)) ? (a) : (b))}\par
00034 \par
00035 {\cf21 #if defined __GNUC__}\par
00036 {\cf21 #define RETADDR(level) __builtin_return_address(level)}\par
00037 {\cf21 #else}\par
00038 {\cf21 #define RETADDR(level) (void)(level)}\par
00039 {\cf21 #endif}\par
00040 \par
00041 {\cf20 // 'likely' hints to the compiler that the condition is expected to be true most of the time.}\par
00042 {\cf20 // It allows the compiler to optimize branch prediction.}\par
00043 {\cf21 #define likely(x)       __builtin_expect(!!(x), 1)}\par
00044 \par
00045 {\cf20 // 'unlikely' hints to the compiler that the condition is expected to be false most of the time.}\par
00046 {\cf20 // Useful for error handling or rare cases.}\par
00047 {\cf21 #define unlikely(x)     __builtin_expect(!!(x), 0)}\par
00048 \par
00049 {\cf21 #define FREEZE() __cli(); __hlt()}\par
00050 \par
00051 {\cf21 #if !defined(__GNUC__)}\par
00052 {\cf21 #define FIELD_OFFSET(t,f)       ((uint32_t)(uint32_t*)&(((t*) 0)->f))}\par
00053 {\cf21 #else}\par
00054 {\cf21 #define FIELD_OFFSET(t,f)       ((uint32_t)__builtin_offsetof(t,f))}\par
00055 {\cf21 #endif}\par
00056 \par
00057 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/md.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/md.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/md.h}
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "me.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b MdGetFunctionRipAddress} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MdDebugBreak} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MdSetHardwareBreakpoint} ({\b DebugCallback} CallbackFunction, void *BreakpointAddress, {\b DEBUG_ACCESS_MODE} AccessMode, {\b DEBUG_LENGTH} {\b Length})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MdClearHardwareBreakpointByIndex} (int index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MdClearHardwareBreakpointByAddress} (void *BreakpointAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b find_available_debug_reg} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v find_available_debug_reg\:md.h}
{\xe \v md.h\:find_available_debug_reg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int find_available_debug_reg (void )}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b debugfunctions.c}.}\par
}
{\xe \v MdClearHardwareBreakpointByAddress\:md.h}
{\xe \v md.h\:MdClearHardwareBreakpointByAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MdClearHardwareBreakpointByAddress (void * BreakpointAddress)}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b debugfunctions.c}.}\par
}
{\xe \v MdClearHardwareBreakpointByIndex\:md.h}
{\xe \v md.h\:MdClearHardwareBreakpointByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MdClearHardwareBreakpointByIndex (int index)}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b debugfunctions.c}.}\par
}
{\xe \v MdDebugBreak\:md.h}
{\xe \v md.h\:MdDebugBreak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MdDebugBreak (void )}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b md.h}.}\par
}
{\xe \v MdGetFunctionRipAddress\:md.h}
{\xe \v md.h\:MdGetFunctionRipAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * MdGetFunctionRipAddress (void )}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b md.h}.}\par
}
{\xe \v MdSetHardwareBreakpoint\:md.h}
{\xe \v md.h\:MdSetHardwareBreakpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MdSetHardwareBreakpoint ({\b DebugCallback} CallbackFunction, void * BreakpointAddress, {\b DEBUG_ACCESS_MODE} AccessMode, {\b DEBUG_LENGTH} Length)}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b debugfunctions.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
md.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/md.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/md.h}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_DEBUG_H}\par
00002 {\cf21 #define X86_MATANEL_DEBUG_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     md.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for the debugger of MatanelOS. This may include non-debugger functions as well, but those that are useful for runtime.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf21 #include "me.h"}\par
00023 \par
00024 FORCEINLINE\par
00025 {\cf18 void}*\par
00026 MdGetFunctionRipAddress(\par
00027     {\cf18 void}\par
00028 )\par
00029 \par
00030 {\cf20 /*++}\par
00031 {\cf20 }\par
00032 {\cf20     Routine description : Retrieves the address of the RIP slot in the current stack frame, used for debugging a stack smashing where the return address get overwritten}\par
00033 {\cf20 }\par
00034 {\cf20     Arguments:}\par
00035 {\cf20 }\par
00036 {\cf20         None.}\par
00037 {\cf20 }\par
00038 {\cf20     Return Values:}\par
00039 {\cf20 }\par
00040 {\cf20         Address of RIP Slot in stack.}\par
00041 {\cf20 }\par
00042 {\cf20 --*/}\par
00043 \par
00044 \{\par
00045     {\cf18 void}** frame = ({\cf18 void}**)__builtin_frame_address(0); {\cf20 // returns RBP}\par
00046     {\cf19 return} ({\cf18 void}*)(frame + 1);  {\cf20 // address of saved RIP slot}\par
00047 \}\par
00048 \par
00049 FORCEINLINE\par
00050 {\cf18 void}\par
00051 MdDebugBreak(\par
00052     {\cf18 void}\par
00053 )\par
00054 \par
00055 {\cf20 // Description: Emit a debug break instruction. (INT3)}\par
00056 \par
00057 \{\par
00058     __asm__ {\cf17 volatile}({\cf22 "int3"});\par
00059 \}\par
00060 \par
00061 MTSTATUS MdSetHardwareBreakpoint(DebugCallback CallbackFunction, {\cf18 void}* BreakpointAddress, DEBUG_ACCESS_MODE AccessMode, DEBUG_LENGTH Length);\par
00062 MTSTATUS MdClearHardwareBreakpointByIndex({\cf18 int} index);\par
00063 MTSTATUS MdClearHardwareBreakpointByAddress({\cf18 void}* BreakpointAddress);\par
00064 {\cf18 int} find_available_debug_reg({\cf18 void});\par
00065 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/me.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/me.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/me.h}
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "annotations.h"}\par
{\f2 #include "macros.h"}\par
{\f2 #include "../mtstatus.h"}\par
{\f2 #include "../intrinsics/intrin.h"}\par
{\f2 #include "../intrinsics/atomic.h"}\par
{\f2 #include "mm.h"}\par
{\f2 #include "mh.h"}\par
{\f2 #include "ms.h"}\par
{\f2 #include "core.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DEBUG_ENTRY}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _WAIT_BLOCK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _TRAP_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DBG_CALLBACK_INFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DPC_DATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _APC_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ITHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _PROCESSOR}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MSR_IA32_DEBUGCTL}\~ 0x1D9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MSR_LASTBRANCH_TOS}\~ 0x1C9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MSR_LASTBRANCH_FROM0}\~ 0x680\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MSR_LASTBRANCH_TO0}\~ 0x6C0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DPC_TARGET_CURRENT}\~ 0xFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TICK_MS}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LASTFUNC_BUFFER_SIZE}\~ 128\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LASTFUNC_HISTORY_SIZE}\~ 25\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEFAULT_TIMESLICE}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_CS}\~ 0x08\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_DS}\~ 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KERNEL_SS}\~ 0x10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_CS}\~ 0x1B\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_DS}\~ 0x23\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_SS}\~ 0x23\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INITIAL_RFLAGS}\~ 0x202\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_RFLAGS}\~ 0x246\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _TimeSliceTicks} {\b TimeSliceTicks}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _TimeSliceTicks} * {\b PTimeSliceTicks}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _WAIT_REASON} {\b WAIT_REASON}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _DPC_PRIORITY} {\b DPC_PRIORITY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _BUGCHECK_CODES} {\b BUGCHECK_CODES}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b DebugCallback}) (void *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DEBUG_ENTRY} {\b DEBUG_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _WAIT_BLOCK} {\b WAIT_BLOCK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _WAIT_BLOCK} * {\b PWAIT_BLOCK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _TRAP_FRAME} {\b TRAP_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _TRAP_FRAME} * {\b PTRAP_FRAME}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _DEBUG_ACCESS_MODE} {\b DEBUG_ACCESS_MODE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _DEBUG_LENGTH} {\b DEBUG_LENGTH}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DBG_CALLBACK_INFO} {\b DBG_CALLBACK_INFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void {\b DEFERRED_ROUTINE}(struct {\b _DPC} *Dpc, void *DeferredContext, void *SystemArgument1, void *SystemArgument2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b DEFERRED_ROUTINE} * {\b PDEFERRED_ROUTINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DPC} {\b DPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DPC} * {\b PDPC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _CPU_FLAGS} {\b CPU_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DPC_DATA} {\b DPC_DATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DPC_DATA} * {\b PDPC_DATA}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _APC_STATE} {\b APC_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _APC_STATE} * {\b PAPC_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IPROCESS} {\b IPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IPROCESS} * {\b PIPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _ITHREAD} {\b ITHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _ITHREAD} * {\b PITHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _PROCESSOR} {\b PROCESSOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _PROCESSOR} * {\b PPROCESSOR}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _TimeSliceTicks} \{ {\b LOW_TIMESLICE_TICKS} = 16 / TICK_MS
, {\b DEFAULT_TIMESLICE_TICKS} = 40 / TICK_MS
, {\b HIGH_TIMESLICE_TICKS} = 100 / TICK_MS
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _WAIT_REASON} \{ {\b Mutex} = 0
, {\b Sleeping} = 1
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _DPC_PRIORITY} \{ {\b NO_PRIORITY} = 0
, {\b LOW_PRIORITY} = 25
, {\b MEDIUM_PRIORITY} = 50
, {\b HIGH_PRIORITY} = 75
, {\b SYSTEM_PRIORITY} = 99
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _BUGCHECK_CODES} \{ {\b DIVIDE_BY_ZERO}
, {\b SINGLE_STEP}
, {\b NON_MASKABLE_INTERRUPT}
, {\b BREAKPOINT}
, {\b OVERFLOW}
, {\b BOUNDS_CHECK}
, {\b INVALID_OPCODE}
, {\b NO_COPROCESSOR}
, {\b DOUBLE_FAULT}
, {\b COPROCESSOR_SEGMENT_OVERRUN}
, {\b INVALID_TSS}
, {\b SEGMENT_SELECTOR_NOTPRESENT}
, {\b STACK_SEGMENT_OVERRUN}
, {\b GENERAL_PROTECTION_FAULT}
, {\b PAGE_FAULT}
, {\b RESERVED}
, {\b FLOATING_POINT_ERROR}
, {\b ALIGNMENT_CHECK}
, {\b SEVERE_MACHINE_CHECK}
, {\b MEMORY_MAP_SIZE_OVERRUN} = 0xBEEF
, {\b MANUALLY_INITIATED_CRASH} = 0xBABE
, {\b BAD_PAGING} = 0xBAD
, {\b BLOCK_DEVICE_LIMIT_REACHED} = 0x420
, {\b NULL_POINTER_DEREFERENCE} = 0xDEAD
, {\b FILESYSTEM_PANIC} = 0xFA11
, {\b UNABLE_TO_INIT_TRACELASTFUNC} = 0xACE
, {\b FRAME_LIMIT_REACHED} = 0xBADA55
, {\b IRQL_NOT_LESS_OR_EQUAL} = 0x1337
, {\b IRQL_NOT_GREATER_OR_EQUAL} = 0x1338
, {\b INVALID_IRQL_SUPPLIED} = 0x69420
, {\b NULL_CTX_RECEIVED} = 0xF1FA
, {\b THREAD_EXIT_FAILURE} = 0x123123FF
, {\b BAD_AHCI_COUNT}
, {\b AHCI_INIT_FAILED}
, {\b MEMORY_LIMIT_REACHED}
, {\b HEAP_ALLOCATION_FAILED}
, {\b NULL_THREAD}
, {\b FATAL_IRQL_CORRUPTION}
, {\b THREAD_ID_CREATION_FAILURE}
, {\b FRAME_ALLOCATION_FAILED}
, {\b FRAME_BITMAP_CREATION_FAILURE}
, {\b ASSERTION_FAILURE}
, {\b MEMORY_INVALID_FREE}
, {\b MEMORY_CORRUPT_HEADER}
, {\b MEMORY_DOUBLE_FREE}
, {\b MEMORY_CORRUPT_FOOTER}
, {\b GUARD_PAGE_DEREFERENCE}
, {\b KERNEL_STACK_OVERFLOWN}
, {\b KMODE_EXCEPTION_NOT_HANDLED}
, {\b PFN_DATABASE_INIT_FAILURE}
, {\b VA_SPACE_INIT_FAILURE}
, {\b POOL_INIT_FAILURE}
, {\b BAD_POOL_CALLER}
, {\b ATTEMPTED_WRITE_TO_READONLY_MEMORY}
, {\b INVALID_INITIALIZATION_PHASE}
, {\b PAGE_FAULT_IN_FREED_NONPAGED_POOL}
, {\b PAGE_FAULT_IN_FREED_PAGED_POOL}
, {\b ATTEMPTED_SWITCH_FROM_DPC}
, {\b INVALID_INTERRUPT_REQUEST}
, {\b MANUALLY_INITIATED_CRASH2}
, {\b PSMGR_INIT_FAILED}
, {\b PSWORKER_INIT_FAILED}
, {\b DPC_NOT_INITIALIZED}
, {\b CID_TABLE_NULL}
, {\b INVALID_PROCESS_ATTACH_ATTEMPT}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _DEBUG_ACCESS_MODE} \{ {\b DEBUG_ACCESS_EXECUTE} = 0b00
, {\b DEBUG_ACCESS_WRITE} = 0b01
, {\b DEBUG_ACCESS_IO} = 0b10
, {\b DEBUG_ACCESS_READWRITE} = 0b11
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _DEBUG_LENGTH} \{ {\b DEBUG_LEN_BYTE} = 0b00
, {\b DEBUG_LEN_WORD} = 0b01
, {\b DEBUG_LEN_QWORD} = 0b10
, {\b DEBUG_LEN_DWORD} = 0b11
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _CPU_FLAGS} \{ {\b CPU_ONLINE} = 1 << 0
, {\b CPU_HALTED} = 1 << 1
, {\b CPU_DOING_IPI} = 1 << 2
, {\b CPU_UNAVAILABLE} = 1 << 3
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MeBugCheck} ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MeBugCheckEx} ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode, {\b IN} void *BugCheckParameter1, {\b IN} void *BugCheckParameter2, {\b IN} void *BugCheckParameter3, {\b IN} void *BugCheckParameter4)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PPROCESSOR} {\b MeGetCurrentProcessor} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MeAcquireSchedulerLock} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MeReleaseSchedulerLock} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b MeGetActiveProcessorCount} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b IRQL} {\b MeGetCurrentIrql} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PITHREAD} {\b MeGetCurrentThread} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b MeIsExecutingDpc} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeInitializeProcessor} ({\b IN} {\b PPROCESSOR} CPU, {\b IN} bool InitializeStandardRoutine, {\b IN} bool AreYouAP)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeRaiseIrql} ({\b IN} {\b IRQL} NewIrql, {\b OUT} {\b PIRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeLowerIrql} ({\b IN} {\b IRQL} NewIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _MeSetIrql} ({\b IN} {\b IRQL} NewIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeSetTargetProcessorDpc} ({\b IN} {\b PDPC} Dpc, {\b IN} uint32_t CpuNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeInitializeDpc} ({\b IN} {\b PDPC} DpcAllocated, {\b IN} {\b PDEFERRED_ROUTINE} DeferredRoutine, {\b IN} void *DeferredContext, {\b IN} {\b DPC_PRIORITY} DeferredPriority)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeInsertQueueDpc} ({\b IN} {\b PDPC} Dpc, {\b IN} void *SystemArgument1, {\b IN} void *SystemArgument2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeRemoveQueueDpc} ({\b IN} {\b PDPC} Dpc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeRetireDPCs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CleanStacks} ({\b DPC} *dpc, void *thread, void *allocatedDPC, void *arg4)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReapOb} ({\b DPC} *dpc, void *DeferredContext, void *SystemArgument1, void *SystemArgument2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitScheduler} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeAttachProcess} ({\b IN} {\b PIPROCESS} Process, {\b OUT} {\b PAPC_STATE} ApcState)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeDetachProcess} ({\b IN} {\b PAPC_STATE} ApcState)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b Schedule} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PRIVILEGE_MODE} {\b MeGetPreviousMode} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MeEnableInterrupts} ({\b IN} bool EnabledBefore)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeDisableInterrupts} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MeAreInterruptsEnabled} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PPROCESSOR} {\b MeGetProcessorBlock} (uint8_t ProcessorNumber)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b g_cpuCount}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DEFAULT_TIMESLICE\:me.h}
{\xe \v me.h\:DEFAULT_TIMESLICE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEFAULT_TIMESLICE\~ 1}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 236} of file {\b me.h}.}\par
}
{\xe \v DPC_TARGET_CURRENT\:me.h}
{\xe \v me.h\:DPC_TARGET_CURRENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DPC_TARGET_CURRENT\~ 0xFF}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b me.h}.}\par
}
{\xe \v INITIAL_RFLAGS\:me.h}
{\xe \v me.h\:INITIAL_RFLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INITIAL_RFLAGS\~ 0x202}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b me.h}.}\par
}
{\xe \v KERNEL_CS\:me.h}
{\xe \v me.h\:KERNEL_CS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_CS\~ 0x08}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 238} of file {\b me.h}.}\par
}
{\xe \v KERNEL_DS\:me.h}
{\xe \v me.h\:KERNEL_DS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_DS\~ 0x10}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b me.h}.}\par
}
{\xe \v KERNEL_SS\:me.h}
{\xe \v me.h\:KERNEL_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KERNEL_SS\~ 0x10}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 240} of file {\b me.h}.}\par
}
{\xe \v LASTFUNC_BUFFER_SIZE\:me.h}
{\xe \v me.h\:LASTFUNC_BUFFER_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LASTFUNC_BUFFER_SIZE\~ 128}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b me.h}.}\par
}
{\xe \v LASTFUNC_HISTORY_SIZE\:me.h}
{\xe \v me.h\:LASTFUNC_HISTORY_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LASTFUNC_HISTORY_SIZE\~ 25}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 234} of file {\b me.h}.}\par
}
{\xe \v MSR_IA32_DEBUGCTL\:me.h}
{\xe \v me.h\:MSR_IA32_DEBUGCTL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSR_IA32_DEBUGCTL\~ 0x1D9}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b me.h}.}\par
}
{\xe \v MSR_LASTBRANCH_FROM0\:me.h}
{\xe \v me.h\:MSR_LASTBRANCH_FROM0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSR_LASTBRANCH_FROM0\~ 0x680}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b me.h}.}\par
}
{\xe \v MSR_LASTBRANCH_TO0\:me.h}
{\xe \v me.h\:MSR_LASTBRANCH_TO0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSR_LASTBRANCH_TO0\~ 0x6C0}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b me.h}.}\par
}
{\xe \v MSR_LASTBRANCH_TOS\:me.h}
{\xe \v me.h\:MSR_LASTBRANCH_TOS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MSR_LASTBRANCH_TOS\~ 0x1C9}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b me.h}.}\par
}
{\xe \v TICK_MS\:me.h}
{\xe \v me.h\:TICK_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TICK_MS\~ 4}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b me.h}.}\par
}
{\xe \v USER_CS\:me.h}
{\xe \v me.h\:USER_CS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_CS\~ 0x1B}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 241} of file {\b me.h}.}\par
}
{\xe \v USER_DS\:me.h}
{\xe \v me.h\:USER_DS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_DS\~ 0x23}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 242} of file {\b me.h}.}\par
}
{\xe \v USER_RFLAGS\:me.h}
{\xe \v me.h\:USER_RFLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_RFLAGS\~ 0x246}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 245} of file {\b me.h}.}\par
}
{\xe \v USER_SS\:me.h}
{\xe \v me.h\:USER_SS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_SS\~ 0x23}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 243} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v APC_STATE\:me.h}
{\xe \v me.h\:APC_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _APC_STATE} {\b APC_STATE}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v BUGCHECK_CODES\:me.h}
{\xe \v me.h\:BUGCHECK_CODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _BUGCHECK_CODES} {\b BUGCHECK_CODES}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPU_FLAGS\:me.h}
{\xe \v me.h\:CPU_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _CPU_FLAGS} {\b CPU_FLAGS}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DBG_CALLBACK_INFO\:me.h}
{\xe \v me.h\:DBG_CALLBACK_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DBG_CALLBACK_INFO} {\b DBG_CALLBACK_INFO}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEBUG_ACCESS_MODE\:me.h}
{\xe \v me.h\:DEBUG_ACCESS_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _DEBUG_ACCESS_MODE} {\b DEBUG_ACCESS_MODE}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEBUG_ENTRY\:me.h}
{\xe \v me.h\:DEBUG_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DEBUG_ENTRY} {\b DEBUG_ENTRY}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEBUG_LENGTH\:me.h}
{\xe \v me.h\:DEBUG_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _DEBUG_LENGTH} {\b DEBUG_LENGTH}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DebugCallback\:me.h}
{\xe \v me.h\:DebugCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* DebugCallback) (void *)}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b me.h}.}\par
}
{\xe \v DEFERRED_ROUTINE\:me.h}
{\xe \v me.h\:DEFERRED_ROUTINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void DEFERRED_ROUTINE(struct {\b _DPC} *Dpc, void *DeferredContext, void *SystemArgument1, void *SystemArgument2)}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b me.h}.}\par
}
{\xe \v DPC\:me.h}
{\xe \v me.h\:DPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DPC} {\b DPC}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DPC_DATA\:me.h}
{\xe \v me.h\:DPC_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DPC_DATA} {\b DPC_DATA}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DPC_PRIORITY\:me.h}
{\xe \v me.h\:DPC_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _DPC_PRIORITY} {\b DPC_PRIORITY}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IPROCESS\:me.h}
{\xe \v me.h\:IPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IPROCESS} {\b IPROCESS}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ITHREAD\:me.h}
{\xe \v me.h\:ITHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _ITHREAD} {\b ITHREAD}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PAPC_STATE\:me.h}
{\xe \v me.h\:PAPC_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _APC_STATE} * {\b PAPC_STATE}}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PDEFERRED_ROUTINE\:me.h}
{\xe \v me.h\:PDEFERRED_ROUTINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b DEFERRED_ROUTINE}* {\b PDEFERRED_ROUTINE}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b me.h}.}\par
}
{\xe \v PDPC\:me.h}
{\xe \v me.h\:PDPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DPC} * {\b PDPC}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PDPC_DATA\:me.h}
{\xe \v me.h\:PDPC_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DPC_DATA} * {\b PDPC_DATA}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PIPROCESS\:me.h}
{\xe \v me.h\:PIPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IPROCESS} * {\b PIPROCESS}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PITHREAD\:me.h}
{\xe \v me.h\:PITHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _ITHREAD} * {\b PITHREAD}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PPROCESSOR\:me.h}
{\xe \v me.h\:PPROCESSOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _PROCESSOR} * {\b PPROCESSOR}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PROCESSOR\:me.h}
{\xe \v me.h\:PROCESSOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _PROCESSOR} {\b PROCESSOR}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PTimeSliceTicks\:me.h}
{\xe \v me.h\:PTimeSliceTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _TimeSliceTicks} * {\b PTimeSliceTicks}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PTRAP_FRAME\:me.h}
{\xe \v me.h\:PTRAP_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _TRAP_FRAME} * {\b PTRAP_FRAME}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PWAIT_BLOCK\:me.h}
{\xe \v me.h\:PWAIT_BLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _WAIT_BLOCK} * {\b PWAIT_BLOCK}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TimeSliceTicks\:me.h}
{\xe \v me.h\:TimeSliceTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _TimeSliceTicks} {\b TimeSliceTicks}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TRAP_FRAME\:me.h}
{\xe \v me.h\:TRAP_FRAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _TRAP_FRAME} {\b TRAP_FRAME}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WAIT_BLOCK\:me.h}
{\xe \v me.h\:WAIT_BLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _WAIT_BLOCK} {\b WAIT_BLOCK}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WAIT_REASON\:me.h}
{\xe \v me.h\:WAIT_REASON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _WAIT_REASON} {\b WAIT_REASON}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _BUGCHECK_CODES\:me.h}
{\xe \v me.h\:_BUGCHECK_CODES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _BUGCHECK_CODES}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DIVIDE_BY_ZERO\:me.h}
{\xe \v me.h\:DIVIDE_BY_ZERO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DIVIDE_BY_ZERO{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
\cell }{\cell }{\row }
{\xe \v SINGLE_STEP\:me.h}
{\xe \v me.h\:SINGLE_STEP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SINGLE_STEP{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
\cell }{\cell }{\row }
{\xe \v NON_MASKABLE_INTERRUPT\:me.h}
{\xe \v me.h\:NON_MASKABLE_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NON_MASKABLE_INTERRUPT{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
\cell }{\cell }{\row }
{\xe \v BREAKPOINT\:me.h}
{\xe \v me.h\:BREAKPOINT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BREAKPOINT{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
\cell }{\cell }{\row }
{\xe \v OVERFLOW\:me.h}
{\xe \v me.h\:OVERFLOW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid OVERFLOW{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
\cell }{\cell }{\row }
{\xe \v BOUNDS_CHECK\:me.h}
{\xe \v me.h\:BOUNDS_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BOUNDS_CHECK{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
\cell }{\cell }{\row }
{\xe \v INVALID_OPCODE\:me.h}
{\xe \v me.h\:INVALID_OPCODE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_OPCODE{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
\cell }{\cell }{\row }
{\xe \v NO_COPROCESSOR\:me.h}
{\xe \v me.h\:NO_COPROCESSOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NO_COPROCESSOR{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
\cell }{\cell }{\row }
{\xe \v DOUBLE_FAULT\:me.h}
{\xe \v me.h\:DOUBLE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DOUBLE_FAULT{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
\cell }{\cell }{\row }
{\xe \v COPROCESSOR_SEGMENT_OVERRUN\:me.h}
{\xe \v me.h\:COPROCESSOR_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid COPROCESSOR_SEGMENT_OVERRUN{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
\cell }{\cell }{\row }
{\xe \v INVALID_TSS\:me.h}
{\xe \v me.h\:INVALID_TSS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_TSS{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
\cell }{\cell }{\row }
{\xe \v SEGMENT_SELECTOR_NOTPRESENT\:me.h}
{\xe \v me.h\:SEGMENT_SELECTOR_NOTPRESENT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SEGMENT_SELECTOR_NOTPRESENT{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
\cell }{\cell }{\row }
{\xe \v STACK_SEGMENT_OVERRUN\:me.h}
{\xe \v me.h\:STACK_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid STACK_SEGMENT_OVERRUN{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
\cell }{\cell }{\row }
{\xe \v GENERAL_PROTECTION_FAULT\:me.h}
{\xe \v me.h\:GENERAL_PROTECTION_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid GENERAL_PROTECTION_FAULT{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
\cell }{\cell }{\row }
{\xe \v PAGE_FAULT\:me.h}
{\xe \v me.h\:PAGE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_FAULT{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
\cell }{\cell }{\row }
{\xe \v RESERVED\:me.h}
{\xe \v me.h\:RESERVED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid RESERVED{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
\cell }{\cell }{\row }
{\xe \v FLOATING_POINT_ERROR\:me.h}
{\xe \v me.h\:FLOATING_POINT_ERROR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FLOATING_POINT_ERROR{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
\cell }{\cell }{\row }
{\xe \v ALIGNMENT_CHECK\:me.h}
{\xe \v me.h\:ALIGNMENT_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ALIGNMENT_CHECK{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
\cell }{\cell }{\row }
{\xe \v SEVERE_MACHINE_CHECK\:me.h}
{\xe \v me.h\:SEVERE_MACHINE_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SEVERE_MACHINE_CHECK{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
\cell }{\cell }{\row }
{\xe \v MEMORY_MAP_SIZE_OVERRUN\:me.h}
{\xe \v me.h\:MEMORY_MAP_SIZE_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_MAP_SIZE_OVERRUN{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Custom ones. \par
}\cell }{\row }
{\xe \v MANUALLY_INITIATED_CRASH\:me.h}
{\xe \v me.h\:MANUALLY_INITIATED_CRASH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MANUALLY_INITIATED_CRASH{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
\cell }{\cell }{\row }
{\xe \v BAD_PAGING\:me.h}
{\xe \v me.h\:BAD_PAGING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BAD_PAGING{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
\cell }{\cell }{\row }
{\xe \v BLOCK_DEVICE_LIMIT_REACHED\:me.h}
{\xe \v me.h\:BLOCK_DEVICE_LIMIT_REACHED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BLOCK_DEVICE_LIMIT_REACHED{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
\cell }{\cell }{\row }
{\xe \v NULL_POINTER_DEREFERENCE\:me.h}
{\xe \v me.h\:NULL_POINTER_DEREFERENCE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NULL_POINTER_DEREFERENCE{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
\cell }{\cell }{\row }
{\xe \v FILESYSTEM_PANIC\:me.h}
{\xe \v me.h\:FILESYSTEM_PANIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FILESYSTEM_PANIC{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
\cell }{\cell }{\row }
{\xe \v UNABLE_TO_INIT_TRACELASTFUNC\:me.h}
{\xe \v me.h\:UNABLE_TO_INIT_TRACELASTFUNC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid UNABLE_TO_INIT_TRACELASTFUNC{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
\cell }{\cell }{\row }
{\xe \v FRAME_LIMIT_REACHED\:me.h}
{\xe \v me.h\:FRAME_LIMIT_REACHED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FRAME_LIMIT_REACHED{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
\cell }{\cell }{\row }
{\xe \v IRQL_NOT_LESS_OR_EQUAL\:me.h}
{\xe \v me.h\:IRQL_NOT_LESS_OR_EQUAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQL_NOT_LESS_OR_EQUAL{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
\cell }{\cell }{\row }
{\xe \v IRQL_NOT_GREATER_OR_EQUAL\:me.h}
{\xe \v me.h\:IRQL_NOT_GREATER_OR_EQUAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid IRQL_NOT_GREATER_OR_EQUAL{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
\cell }{\cell }{\row }
{\xe \v INVALID_IRQL_SUPPLIED\:me.h}
{\xe \v me.h\:INVALID_IRQL_SUPPLIED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_IRQL_SUPPLIED{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
\cell }{\cell }{\row }
{\xe \v NULL_CTX_RECEIVED\:me.h}
{\xe \v me.h\:NULL_CTX_RECEIVED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NULL_CTX_RECEIVED{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
\cell }{\cell }{\row }
{\xe \v THREAD_EXIT_FAILURE\:me.h}
{\xe \v me.h\:THREAD_EXIT_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_EXIT_FAILURE{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
\cell }{\cell }{\row }
{\xe \v BAD_AHCI_COUNT\:me.h}
{\xe \v me.h\:BAD_AHCI_COUNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BAD_AHCI_COUNT{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
\cell }{\cell }{\row }
{\xe \v AHCI_INIT_FAILED\:me.h}
{\xe \v me.h\:AHCI_INIT_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid AHCI_INIT_FAILED{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
\cell }{\cell }{\row }
{\xe \v MEMORY_LIMIT_REACHED\:me.h}
{\xe \v me.h\:MEMORY_LIMIT_REACHED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_LIMIT_REACHED{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
\cell }{\cell }{\row }
{\xe \v HEAP_ALLOCATION_FAILED\:me.h}
{\xe \v me.h\:HEAP_ALLOCATION_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HEAP_ALLOCATION_FAILED{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
\cell }{\cell }{\row }
{\xe \v NULL_THREAD\:me.h}
{\xe \v me.h\:NULL_THREAD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NULL_THREAD{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
\cell }{\cell }{\row }
{\xe \v FATAL_IRQL_CORRUPTION\:me.h}
{\xe \v me.h\:FATAL_IRQL_CORRUPTION}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FATAL_IRQL_CORRUPTION{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
\cell }{\cell }{\row }
{\xe \v THREAD_ID_CREATION_FAILURE\:me.h}
{\xe \v me.h\:THREAD_ID_CREATION_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_ID_CREATION_FAILURE{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
\cell }{\cell }{\row }
{\xe \v FRAME_ALLOCATION_FAILED\:me.h}
{\xe \v me.h\:FRAME_ALLOCATION_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FRAME_ALLOCATION_FAILED{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
\cell }{\cell }{\row }
{\xe \v FRAME_BITMAP_CREATION_FAILURE\:me.h}
{\xe \v me.h\:FRAME_BITMAP_CREATION_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FRAME_BITMAP_CREATION_FAILURE{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
\cell }{\cell }{\row }
{\xe \v ASSERTION_FAILURE\:me.h}
{\xe \v me.h\:ASSERTION_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ASSERTION_FAILURE{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
\cell }{\cell }{\row }
{\xe \v MEMORY_INVALID_FREE\:me.h}
{\xe \v me.h\:MEMORY_INVALID_FREE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_INVALID_FREE{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
\cell }{\cell }{\row }
{\xe \v MEMORY_CORRUPT_HEADER\:me.h}
{\xe \v me.h\:MEMORY_CORRUPT_HEADER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_CORRUPT_HEADER{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
\cell }{\cell }{\row }
{\xe \v MEMORY_DOUBLE_FREE\:me.h}
{\xe \v me.h\:MEMORY_DOUBLE_FREE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_DOUBLE_FREE{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
\cell }{\cell }{\row }
{\xe \v MEMORY_CORRUPT_FOOTER\:me.h}
{\xe \v me.h\:MEMORY_CORRUPT_FOOTER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEMORY_CORRUPT_FOOTER{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
\cell }{\cell }{\row }
{\xe \v GUARD_PAGE_DEREFERENCE\:me.h}
{\xe \v me.h\:GUARD_PAGE_DEREFERENCE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid GUARD_PAGE_DEREFERENCE{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
\cell }{\cell }{\row }
{\xe \v KERNEL_STACK_OVERFLOWN\:me.h}
{\xe \v me.h\:KERNEL_STACK_OVERFLOWN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid KERNEL_STACK_OVERFLOWN{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
\cell }{\cell }{\row }
{\xe \v KMODE_EXCEPTION_NOT_HANDLED\:me.h}
{\xe \v me.h\:KMODE_EXCEPTION_NOT_HANDLED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid KMODE_EXCEPTION_NOT_HANDLED{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
\cell }{\cell }{\row }
{\xe \v PFN_DATABASE_INIT_FAILURE\:me.h}
{\xe \v me.h\:PFN_DATABASE_INIT_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PFN_DATABASE_INIT_FAILURE{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
\cell }{\cell }{\row }
{\xe \v VA_SPACE_INIT_FAILURE\:me.h}
{\xe \v me.h\:VA_SPACE_INIT_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VA_SPACE_INIT_FAILURE{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
\cell }{\cell }{\row }
{\xe \v POOL_INIT_FAILURE\:me.h}
{\xe \v me.h\:POOL_INIT_FAILURE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid POOL_INIT_FAILURE{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
\cell }{\cell }{\row }
{\xe \v BAD_POOL_CALLER\:me.h}
{\xe \v me.h\:BAD_POOL_CALLER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid BAD_POOL_CALLER{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
\cell }{\cell }{\row }
{\xe \v ATTEMPTED_WRITE_TO_READONLY_MEMORY\:me.h}
{\xe \v me.h\:ATTEMPTED_WRITE_TO_READONLY_MEMORY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTEMPTED_WRITE_TO_READONLY_MEMORY{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
\cell }{\cell }{\row }
{\xe \v INVALID_INITIALIZATION_PHASE\:me.h}
{\xe \v me.h\:INVALID_INITIALIZATION_PHASE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_INITIALIZATION_PHASE{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
\cell }{\cell }{\row }
{\xe \v PAGE_FAULT_IN_FREED_NONPAGED_POOL\:me.h}
{\xe \v me.h\:PAGE_FAULT_IN_FREED_NONPAGED_POOL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_FAULT_IN_FREED_NONPAGED_POOL{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
\cell }{\cell }{\row }
{\xe \v PAGE_FAULT_IN_FREED_PAGED_POOL\:me.h}
{\xe \v me.h\:PAGE_FAULT_IN_FREED_PAGED_POOL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_FAULT_IN_FREED_PAGED_POOL{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
\cell }{\cell }{\row }
{\xe \v ATTEMPTED_SWITCH_FROM_DPC\:me.h}
{\xe \v me.h\:ATTEMPTED_SWITCH_FROM_DPC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATTEMPTED_SWITCH_FROM_DPC{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
\cell }{\cell }{\row }
{\xe \v INVALID_INTERRUPT_REQUEST\:me.h}
{\xe \v me.h\:INVALID_INTERRUPT_REQUEST}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_INTERRUPT_REQUEST{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
\cell }{\cell }{\row }
{\xe \v MANUALLY_INITIATED_CRASH2\:me.h}
{\xe \v me.h\:MANUALLY_INITIATED_CRASH2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MANUALLY_INITIATED_CRASH2{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
\cell }{\cell }{\row }
{\xe \v PSMGR_INIT_FAILED\:me.h}
{\xe \v me.h\:PSMGR_INIT_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PSMGR_INIT_FAILED{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
\cell }{\cell }{\row }
{\xe \v PSWORKER_INIT_FAILED\:me.h}
{\xe \v me.h\:PSWORKER_INIT_FAILED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PSWORKER_INIT_FAILED{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
\cell }{\cell }{\row }
{\xe \v DPC_NOT_INITIALIZED\:me.h}
{\xe \v me.h\:DPC_NOT_INITIALIZED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DPC_NOT_INITIALIZED{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
\cell }{\cell }{\row }
{\xe \v CID_TABLE_NULL\:me.h}
{\xe \v me.h\:CID_TABLE_NULL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CID_TABLE_NULL{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
\cell }{\cell }{\row }
{\xe \v INVALID_PROCESS_ATTACH_ATTEMPT\:me.h}
{\xe \v me.h\:INVALID_PROCESS_ATTACH_ATTEMPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid INVALID_PROCESS_ATTACH_ATTEMPT{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 68} of file {\b me.h}.}\par
}
{\xe \v _CPU_FLAGS\:me.h}
{\xe \v me.h\:_CPU_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _CPU_FLAGS}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CPU_ONLINE\:me.h}
{\xe \v me.h\:CPU_ONLINE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ONLINE{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
\cell }{\cell }{\row }
{\xe \v CPU_HALTED\:me.h}
{\xe \v me.h\:CPU_HALTED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_HALTED{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
\cell }{\cell }{\row }
{\xe \v CPU_DOING_IPI\:me.h}
{\xe \v me.h\:CPU_DOING_IPI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_DOING_IPI{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
\cell }{\cell }{\row }
{\xe \v CPU_UNAVAILABLE\:me.h}
{\xe \v me.h\:CPU_UNAVAILABLE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_UNAVAILABLE{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 218} of file {\b me.h}.}\par
}
{\xe \v _DEBUG_ACCESS_MODE\:me.h}
{\xe \v me.h\:_DEBUG_ACCESS_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _DEBUG_ACCESS_MODE}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DEBUG_ACCESS_EXECUTE\:me.h}
{\xe \v me.h\:DEBUG_ACCESS_EXECUTE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_ACCESS_EXECUTE{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
\cell }{\cell }{\row }
{\xe \v DEBUG_ACCESS_WRITE\:me.h}
{\xe \v me.h\:DEBUG_ACCESS_WRITE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_ACCESS_WRITE{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
\cell }{\cell }{\row }
{\xe \v DEBUG_ACCESS_IO\:me.h}
{\xe \v me.h\:DEBUG_ACCESS_IO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_ACCESS_IO{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
\cell }{\cell }{\row }
{\xe \v DEBUG_ACCESS_READWRITE\:me.h}
{\xe \v me.h\:DEBUG_ACCESS_READWRITE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_ACCESS_READWRITE{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 164} of file {\b me.h}.}\par
}
{\xe \v _DEBUG_LENGTH\:me.h}
{\xe \v me.h\:_DEBUG_LENGTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _DEBUG_LENGTH}}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v DEBUG_LEN_BYTE\:me.h}
{\xe \v me.h\:DEBUG_LEN_BYTE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_LEN_BYTE{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
\cell }{\cell }{\row }
{\xe \v DEBUG_LEN_WORD\:me.h}
{\xe \v me.h\:DEBUG_LEN_WORD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_LEN_WORD{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
\cell }{\cell }{\row }
{\xe \v DEBUG_LEN_QWORD\:me.h}
{\xe \v me.h\:DEBUG_LEN_QWORD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_LEN_QWORD{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
\cell }{\cell }{\row }
{\xe \v DEBUG_LEN_DWORD\:me.h}
{\xe \v me.h\:DEBUG_LEN_DWORD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEBUG_LEN_DWORD{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 171} of file {\b me.h}.}\par
}
{\xe \v _DPC_PRIORITY\:me.h}
{\xe \v me.h\:_DPC_PRIORITY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _DPC_PRIORITY}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NO_PRIORITY\:me.h}
{\xe \v me.h\:NO_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NO_PRIORITY{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
\cell }{\cell }{\row }
{\xe \v LOW_PRIORITY\:me.h}
{\xe \v me.h\:LOW_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LOW_PRIORITY{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
\cell }{\cell }{\row }
{\xe \v MEDIUM_PRIORITY\:me.h}
{\xe \v me.h\:MEDIUM_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MEDIUM_PRIORITY{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
\cell }{\cell }{\row }
{\xe \v HIGH_PRIORITY\:me.h}
{\xe \v me.h\:HIGH_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HIGH_PRIORITY{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
\cell }{\cell }{\row }
{\xe \v SYSTEM_PRIORITY\:me.h}
{\xe \v me.h\:SYSTEM_PRIORITY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SYSTEM_PRIORITY{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 57} of file {\b me.h}.}\par
}
{\xe \v _TimeSliceTicks\:me.h}
{\xe \v me.h\:_TimeSliceTicks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _TimeSliceTicks}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v LOW_TIMESLICE_TICKS\:me.h}
{\xe \v me.h\:LOW_TIMESLICE_TICKS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LOW_TIMESLICE_TICKS{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
\cell }{\cell }{\row }
{\xe \v DEFAULT_TIMESLICE_TICKS\:me.h}
{\xe \v me.h\:DEFAULT_TIMESLICE_TICKS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid DEFAULT_TIMESLICE_TICKS{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
\cell }{\cell }{\row }
{\xe \v HIGH_TIMESLICE_TICKS\:me.h}
{\xe \v me.h\:HIGH_TIMESLICE_TICKS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid HIGH_TIMESLICE_TICKS{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 46} of file {\b me.h}.}\par
}
{\xe \v _WAIT_REASON\:me.h}
{\xe \v me.h\:_WAIT_REASON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _WAIT_REASON}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Mutex\:me.h}
{\xe \v me.h\:Mutex}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Mutex{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
\cell }{\cell }{\row }
{\xe \v Sleeping\:me.h}
{\xe \v me.h\:Sleeping}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid Sleeping{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 52} of file {\b me.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _MeSetIrql\:me.h}
{\xe \v me.h\:_MeSetIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _MeSetIrql ({\b IN} {\b IRQL} NewIrql)}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b irql.c}.}\par
}
{\xe \v CleanStacks\:me.h}
{\xe \v me.h\:CleanStacks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CleanStacks ({\b DPC} * dpc, void * thread, void * allocatedDPC, void * arg4)}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v InitScheduler\:me.h}
{\xe \v me.h\:InitScheduler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InitScheduler (void )}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b scheduler.c}.}\par
}
{\xe \v MeAcquireSchedulerLock\:me.h}
{\xe \v me.h\:MeAcquireSchedulerLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MeAcquireSchedulerLock (void )}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 365} of file {\b me.h}.}\par
}
{\xe \v MeAreInterruptsEnabled\:me.h}
{\xe \v me.h\:MeAreInterruptsEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeAreInterruptsEnabled (void )}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b irql.c}.}\par
}
{\xe \v MeAttachProcess\:me.h}
{\xe \v me.h\:MeAttachProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeAttachProcess ({\b IN} {\b PIPROCESS} Process, {\b OUT} {\b PAPC_STATE} ApcState)}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b attach.c}.}\par
}
{\xe \v MeBugCheck\:me.h}
{\xe \v me.h\:MeBugCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MeBugCheck ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode)}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b bugcheck.c}.}\par
}
{\xe \v MeBugCheckEx\:me.h}
{\xe \v me.h\:MeBugCheckEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MeBugCheckEx ({\b IN} enum {\b _BUGCHECK_CODES} BugCheckCode, {\b IN} void * BugCheckParameter1, {\b IN} void * BugCheckParameter2, {\b IN} void * BugCheckParameter3, {\b IN} void * BugCheckParameter4)}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 305} of file {\b bugcheck.c}.}\par
}
{\xe \v MeDetachProcess\:me.h}
{\xe \v me.h\:MeDetachProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeDetachProcess ({\b IN} {\b PAPC_STATE} ApcState)}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b attach.c}.}\par
}
{\xe \v MeDisableInterrupts\:me.h}
{\xe \v me.h\:MeDisableInterrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeDisableInterrupts (void )}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 186} of file {\b irql.c}.}\par
}
{\xe \v MeEnableInterrupts\:me.h}
{\xe \v me.h\:MeEnableInterrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeEnableInterrupts ({\b IN} bool EnabledBefore)}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b irql.c}.}\par
}
{\xe \v MeGetActiveProcessorCount\:me.h}
{\xe \v me.h\:MeGetActiveProcessorCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t MeGetActiveProcessorCount (void )}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 394} of file {\b me.h}.}\par
}
{\xe \v MeGetCurrentIrql\:me.h}
{\xe \v me.h\:MeGetCurrentIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b IRQL} MeGetCurrentIrql (void )}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 402} of file {\b me.h}.}\par
}
{\xe \v MeGetCurrentProcessor\:me.h}
{\xe \v me.h\:MeGetCurrentProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PPROCESSOR} MeGetCurrentProcessor (void )}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 356} of file {\b me.h}.}\par
}
{\xe \v MeGetCurrentThread\:me.h}
{\xe \v me.h\:MeGetCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PITHREAD} MeGetCurrentThread (void )}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b me.h}.}\par
}
{\xe \v MeGetPreviousMode\:me.h}
{\xe \v me.h\:MeGetPreviousMode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PRIVILEGE_MODE} MeGetPreviousMode (void )}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 534} of file {\b me.h}.}\par
}
{\xe \v MeGetProcessorBlock\:me.h}
{\xe \v me.h\:MeGetProcessorBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PPROCESSOR} MeGetProcessorBlock (uint8_t ProcessorNumber)}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b smp.c}.}\par
}
{\xe \v MeInitializeDpc\:me.h}
{\xe \v me.h\:MeInitializeDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeInitializeDpc ({\b IN} {\b PDPC} DpcAllocated, {\b IN} {\b PDEFERRED_ROUTINE} DeferredRoutine, {\b IN} void * DeferredContext, {\b IN} {\b DPC_PRIORITY} DeferredPriority)}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 384} of file {\b dpc.c}.}\par
}
{\xe \v MeInitializeProcessor\:me.h}
{\xe \v me.h\:MeInitializeProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeInitializeProcessor ({\b IN} {\b PPROCESSOR} CPU, {\b IN} bool InitializeStandardRoutine, {\b IN} bool AreYouAP)}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b meinit.c}.}\par
}
{\xe \v MeInsertQueueDpc\:me.h}
{\xe \v me.h\:MeInsertQueueDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeInsertQueueDpc ({\b IN} {\b PDPC} Dpc, {\b IN} void * SystemArgument1, {\b IN} void * SystemArgument2)}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b dpc.c}.}\par
}
{\xe \v MeIsExecutingDpc\:me.h}
{\xe \v me.h\:MeIsExecutingDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool MeIsExecutingDpc (void )}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 453} of file {\b me.h}.}\par
}
{\xe \v MeLowerIrql\:me.h}
{\xe \v me.h\:MeLowerIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeLowerIrql ({\b IN} {\b IRQL} NewIrql)}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b irql.c}.}\par
}
{\xe \v MeRaiseIrql\:me.h}
{\xe \v me.h\:MeRaiseIrql}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeRaiseIrql ({\b IN} {\b IRQL} NewIrql, {\b OUT} {\b PIRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b irql.c}.}\par
}
{\xe \v MeReleaseSchedulerLock\:me.h}
{\xe \v me.h\:MeReleaseSchedulerLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MeReleaseSchedulerLock (void )}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 380} of file {\b me.h}.}\par
}
{\xe \v MeRemoveQueueDpc\:me.h}
{\xe \v me.h\:MeRemoveQueueDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MeRemoveQueueDpc ({\b IN} {\b PDPC} Dpc)}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b dpc.c}.}\par
}
{\xe \v MeRetireDPCs\:me.h}
{\xe \v me.h\:MeRetireDPCs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeRetireDPCs (void )}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 222} of file {\b dpc.c}.}\par
}
{\xe \v MeSetTargetProcessorDpc\:me.h}
{\xe \v me.h\:MeSetTargetProcessorDpc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MeSetTargetProcessorDpc ({\b IN} {\b PDPC} Dpc, {\b IN} uint32_t CpuNumber)}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 350} of file {\b dpc.c}.}\par
}
{\xe \v ReapOb\:me.h}
{\xe \v me.h\:ReapOb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ReapOb ({\b DPC} * dpc, void * DeferredContext, void * SystemArgument1, void * SystemArgument2)}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b dpc.c}.}\par
}
{\xe \v Schedule\:me.h}
{\xe \v me.h\:Schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void Schedule (void )}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b scheduler.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v g_cpuCount\:me.h}
{\xe \v me.h\:g_cpuCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t g_cpuCount{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b smp.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
me.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/me.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/me.h}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef MATANEL_EXECUTIVE_H}\par
00002 {\cf21 #define MATANEL_EXECUTIVE_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     me.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for the executive layer of MatanelOS.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf21 #define MSR_IA32_DEBUGCTL   0x1D9}\par
00023 {\cf21 #define MSR_LASTBRANCH_TOS  0x1C9}\par
00024 {\cf21 #define MSR_LASTBRANCH_FROM0 0x680}\par
00025 {\cf21 #define MSR_LASTBRANCH_TO0   0x6C0}\par
00026 {\cf21 #define DPC_TARGET_CURRENT  0xFF}\par
00027 \par
00028 {\cf21 #include <stdint.h>}\par
00029 {\cf21 #include <stdbool.h>}\par
00030 {\cf21 #include "annotations.h"}\par
00031 {\cf21 #include "macros.h"}\par
00032 {\cf21 #include "../mtstatus.h"}\par
00033 {\cf21 #include "../intrinsics/intrin.h"}\par
00034 {\cf21 #include "../intrinsics/atomic.h"}\par
00035 \par
00036 {\cf20 // Other includes:  }\par
00037 {\cf21 #include "mm.h"}\par
00038 {\cf21 #include "mh.h"}\par
00039 {\cf21 #include "ms.h"}\par
00040 {\cf21 #include "core.h"}\par
00041 {\cf20 // ------------------ UNIONS ------------------}\par
00042 \par
00043 {\cf20 // ------------------ ENUMERATORS ------------------}\par
00044 \par
00045 {\cf21 #define TICK_MS 4}\par
00046 {\cf17 typedef} {\cf17 enum} _TimeSliceTicks \{\par
00047     LOW_TIMESLICE_TICKS = 16 / TICK_MS,  {\cf20 /* 40 ms  */}\par
00048     DEFAULT_TIMESLICE_TICKS = 40 / TICK_MS,  {\cf20 /* 100 ms */}\par
00049     HIGH_TIMESLICE_TICKS = 100 / TICK_MS   {\cf20 /* 250 ms */}\par
00050 \} TimeSliceTicks, *PTimeSliceTicks;\par
00051 \par
00052 {\cf17 typedef} {\cf17 enum} _WAIT_REASON \{\par
00053     Mutex = 0,\par
00054     Sleeping = 1,\par
00055 \} WAIT_REASON;\par
00056 \par
00057 {\cf17 typedef} {\cf17 enum} _DPC_PRIORITY \{\par
00058     NO_PRIORITY = 0,\par
00059     LOW_PRIORITY = 25,\par
00060     MEDIUM_PRIORITY = 50,\par
00061     HIGH_PRIORITY = 75,\par
00062     SYSTEM_PRIORITY = 99\par
00063 \} DPC_PRIORITY;\par
00064 \par
00065 \par
00066 {\cf20 // DEPRECATED - New list should be in BUGCODES.H explaining each with its parameters. TODO}\par
00067 {\cf20 // Bugcheck error code enums, use same exception list from CPU.}\par
00068 {\cf17 typedef} {\cf17 enum} _BUGCHECK_CODES \{\par
00069     DIVIDE_BY_ZERO,\par
00070     SINGLE_STEP,\par
00071     NON_MASKABLE_INTERRUPT,\par
00072     BREAKPOINT,\par
00073     OVERFLOW,\par
00074     BOUNDS_CHECK,\par
00075     INVALID_OPCODE,\par
00076     NO_COPROCESSOR,\par
00077     DOUBLE_FAULT,\par
00078     COPROCESSOR_SEGMENT_OVERRUN,\par
00079     INVALID_TSS,\par
00080     SEGMENT_SELECTOR_NOTPRESENT,\par
00081     STACK_SEGMENT_OVERRUN,\par
00082     GENERAL_PROTECTION_FAULT,\par
00083     PAGE_FAULT,\par
00084     RESERVED,\par
00085     FLOATING_POINT_ERROR,\par
00086     ALIGNMENT_CHECK,\par
00087     SEVERE_MACHINE_CHECK,\par
00089     MEMORY_MAP_SIZE_OVERRUN = 0xBEEF, {\cf20 // The memory map has grown beyond the limit (unused).}\par
00090     MANUALLY_INITIATED_CRASH = 0xBABE, {\cf20 // A function has manually initiated a bugcheck for testing/unknown reasons with this specific code.}\par
00091     BAD_PAGING = 0xBAD, {\cf20 // A paging function that fails when it shouldn't.}\par
00092     BLOCK_DEVICE_LIMIT_REACHED = 0x420, {\cf20 // Something tried to register a block device, but the limit has been reached, bugcheck system.}\par
00093     NULL_POINTER_DEREFERENCE = 0xDEAD, {\cf20 // Attempted dereference of a null pointer.}\par
00094     FILESYSTEM_PANIC = 0xFA11, {\cf20 // FileSystem PANIC, usually something wrong has happened}\par
00095     UNABLE_TO_INIT_TRACELASTFUNC = 0xACE, {\cf20 // TraceLastFunc init failed in kernel_main}\par
00096     FRAME_LIMIT_REACHED = 0xBADA55, {\cf20 // frame limit reached when trying to allocate a physical frame.}\par
00097     IRQL_NOT_LESS_OR_EQUAL = 0x1337, {\cf20 // Access to functions while going over the max IRQL set for them. Or lowering to higher IRQL than current IRQL.}\par
00098     IRQL_NOT_GREATER_OR_EQUAL = 0x1338, {\cf20 // Raising IRQL to an IRQL level that is lower than the current one.}\par
00099     INVALID_IRQL_SUPPLIED = 0x69420, {\cf20 // Invalid IRQL supplied to raising / lowering IRQL.}\par
00100     NULL_CTX_RECEIVED = 0xF1FA, {\cf20 // A null context frame has been received to a function.}\par
00101     THREAD_EXIT_FAILURE = 0x123123FF, {\cf20 // A thread exitted but did not schedule (somehow).}\par
00102     BAD_AHCI_COUNT, {\cf20 // AHCI Count has went over the required limit}\par
00103     AHCI_INIT_FAILED, {\cf20 // Initialization of AHCI has failed..}\par
00104     MEMORY_LIMIT_REACHED, {\cf20 // The amount of physical memory has reached its maximum, allocation has failed.}\par
00105     HEAP_ALLOCATION_FAILED, {\cf20 // Allocating from the HEAP failed for an unknown reason.}\par
00106     NULL_THREAD, {\cf20 // A thread given to the scheduler is NULL.}\par
00107     FATAL_IRQL_CORRUPTION, {\cf20 // IRQL Has been corrupted, somehow. Probably a buffer overflow.}\par
00108     THREAD_ID_CREATION_FAILURE, {\cf20 // Creation of a TID (Thread ID) has failed due to reaching maximum TIDs in use by the system.}\par
00109     FRAME_ALLOCATION_FAILED, {\cf20 // Allocating a physical frame from the frame bitmap has failed.}\par
00110     FRAME_BITMAP_CREATION_FAILURE, {\cf20 // Creating the frame bitmap resulted in a failure.}\par
00111     ASSERTION_FAILURE, {\cf20 // Runtime Assertion Failure (assert())}\par
00112     MEMORY_INVALID_FREE,\par
00113     MEMORY_CORRUPT_HEADER,\par
00114     MEMORY_DOUBLE_FREE,\par
00115     MEMORY_CORRUPT_FOOTER,\par
00116     GUARD_PAGE_DEREFERENCE, {\cf20 // A guard page has been dereferenced.}\par
00117     KERNEL_STACK_OVERFLOWN, {\cf20 // A kernel stack has been overflown (and didnt hit the guard page) (detected by canary)}\par
00118     KMODE_EXCEPTION_NOT_HANDLED, {\cf20 // A kernel mode exception hasn't been handled (an __except block hasn't been handled)}\par
00119     PFN_DATABASE_INIT_FAILURE,\par
00120     VA_SPACE_INIT_FAILURE,\par
00121     POOL_INIT_FAILURE,\par
00122     BAD_POOL_CALLER,\par
00123     ATTEMPTED_WRITE_TO_READONLY_MEMORY,\par
00124     INVALID_INITIALIZATION_PHASE,\par
00125     PAGE_FAULT_IN_FREED_NONPAGED_POOL,\par
00126     PAGE_FAULT_IN_FREED_PAGED_POOL,\par
00127     ATTEMPTED_SWITCH_FROM_DPC,\par
00128     INVALID_INTERRUPT_REQUEST,\par
00129     MANUALLY_INITIATED_CRASH2,\par
00130     PSMGR_INIT_FAILED,\par
00131     PSWORKER_INIT_FAILED,\par
00132     DPC_NOT_INITIALIZED,\par
00133     CID_TABLE_NULL,\par
00134     INVALID_PROCESS_ATTACH_ATTEMPT,\par
00135 \} BUGCHECK_CODES;\par
00136 \par
00137 {\cf20 // ------------------ STRUCTURES ------------------}\par
00138 \par
00139 {\cf17 typedef} void (*DebugCallback)({\cf18 void}*);\par
00140 \par
00141 {\cf17 typedef} {\cf17 struct }_DEBUG_ENTRY \{\par
00142     {\cf18 void}* Address;\par
00143     DebugCallback Callback;\par
00144 \} DEBUG_ENTRY;\par
00145 \par
00146 {\cf17 typedef} {\cf17 struct }_WAIT_BLOCK \{\par
00147     {\cf17 struct }_SINGLE_LINKED_LIST WaitBlockList;   {\cf20 // List entry of the current wait block of the thread.}\par
00148     {\cf18 void}* Object;                             {\cf20 // Pointer to the object it is currently waiting on (indicated which one by WaitReason)}\par
00149     {\cf17 enum} _WAIT_REASON WaitReason;             {\cf20 // Defines which object the thread is currently waiting on (indicated by the _WAIT_REASON Enumerator)}\par
00150 \} WAIT_BLOCK, *PWAIT_BLOCK;\par
00151 \par
00152 {\cf17 typedef} {\cf17 struct }_TRAP_FRAME \{\par
00153     uint64_t r15, r14, r13, r12, r11, r10, r9, r8;\par
00154     uint64_t rbp, rdi, rsi, rdx, rcx, rbx, rax;\par
00155     uint64_t vector;\par
00156     uint64_t error_code;\par
00157     uint64_t rip;\par
00158     uint64_t cs;\par
00159     uint64_t rflags;\par
00160     uint64_t rsp;\par
00161     uint64_t ss; \par
00162 \} TRAP_FRAME, *PTRAP_FRAME;\par
00163 \par
00164 {\cf17 typedef} {\cf17 enum} _DEBUG_ACCESS_MODE \{\par
00165     DEBUG_ACCESS_EXECUTE = 0b00,    {\cf20 // Break on instruction execution}\par
00166     DEBUG_ACCESS_WRITE = 0b01,    {\cf20 // Break on data writes}\par
00167     DEBUG_ACCESS_IO = 0b10,    {\cf20 // Break on I/O read or write (legacy)}\par
00168     DEBUG_ACCESS_READWRITE = 0b11   {\cf20 // Break on data reads or writes}\par
00169 \} DEBUG_ACCESS_MODE;\par
00170 \par
00171 {\cf17 typedef} {\cf17 enum} _DEBUG_LENGTH \{\par
00172     DEBUG_LEN_BYTE = 0b00,\par
00173     DEBUG_LEN_WORD = 0b01,\par
00174     DEBUG_LEN_QWORD = 0b10, {\cf20 // Only valid in long mode}\par
00175     DEBUG_LEN_DWORD = 0b11\par
00176 \} DEBUG_LENGTH;\par
00177 \par
00178 {\cf17 typedef} {\cf17 struct }_DBG_CALLBACK_INFO \{\par
00179     {\cf18 void}* Address;           {\cf20 /* breakpoint address (DRx) */}\par
00180     PTRAP_FRAME trap;        {\cf20 /* trap frame captured */}\par
00181     {\cf18 int}   BreakIdx;         {\cf20 /* which DRx (0..3) fired */}\par
00182     uint64_t Dr6;           {\cf20 /* raw DR6 value at time of trap */}\par
00183 \} DBG_CALLBACK_INFO;\par
00184 \par
00185 {\cf20 // Forward declaration}\par
00186 {\cf17 struct }_DPC;\par
00187 \par
00188 {\cf17 typedef} void (DEFERRED_ROUTINE)(\par
00189     {\cf17 struct }_DPC* Dpc,\par
00190     {\cf18 void}* DeferredContext,\par
00191     {\cf18 void}* SystemArgument1,\par
00192     {\cf18 void}* SystemArgument2\par
00193     );\par
00194 \par
00195 {\cf17 typedef} DEFERRED_ROUTINE* PDEFERRED_ROUTINE;\par
00196 \par
00197 {\cf17 typedef} {\cf17 struct }_DPC \{\par
00198     {\cf20 // Next/Prev pointers for doubly linked list of DPCs.}\par
00199     DOUBLY_LINKED_LIST DpcListEntry;\par
00200 \par
00201     {\cf20 // Pointer to deferred routine.}\par
00202     PDEFERRED_ROUTINE DeferredRoutine;\par
00203     {\cf18 void}* DeferredContext;\par
00204     {\cf18 void}* SystemArgument1;\par
00205     {\cf18 void}* SystemArgument2;\par
00206 \par
00207     {\cf20 // Points to the DPC_DATA struct of the current processor when queued}\par
00208     {\cf20 // If NULL, the DPC is NOT queued.}\par
00209     {\cf17 volatile} {\cf18 void}* DpcData;\par
00210 \par
00211     {\cf20 // Determines if it goes to tail or head of queue.}\par
00212     {\cf17 enum} _DPC_PRIORITY priority;\par
00213 \par
00214     {\cf20 // Determines to which CPU this DPC is supposed to be executed on, this allows multiple re-entracy.}\par
00215     uint8_t CpuNumber; {\cf20 // 0xFF means current CPU, else its per lapic id.}\par
00216 \} DPC, *PDPC;\par
00217 \par
00218 {\cf17 typedef} {\cf17 enum} _CPU_FLAGS \{\par
00219     CPU_ONLINE = 1 << 0,  {\cf20 // 0b0001}\par
00220     CPU_HALTED = 1 << 1,  {\cf20 // 0b0010}\par
00221     CPU_DOING_IPI = 1 << 2,  {\cf20 // 0b0100}\par
00222     CPU_UNAVAILABLE = 1 << 3   {\cf20 // 0b1000}\par
00223 \} CPU_FLAGS;\par
00224 \par
00225 {\cf20 // DPC Embedded struct into CPU.}\par
00226 {\cf17 typedef} {\cf17 struct }_DPC_DATA \{\par
00227     DOUBLY_LINKED_LIST DpcListHead;\par
00228     SPINLOCK DpcLock;\par
00229     {\cf17 volatile} uint32_t DpcQueueDepth;\par
00230     {\cf17 volatile} uint32_t DpcCount; {\cf20 // Statistics}\par
00231 \} DPC_DATA, *PDPC_DATA;\par
00232 \par
00233 {\cf21 #define LASTFUNC_BUFFER_SIZE 128}\par
00234 {\cf21 #define LASTFUNC_HISTORY_SIZE 25}\par
00235 {\cf20 // Default timeslice for a new thread.}\par
00236 {\cf21 #define DEFAULT_TIMESLICE 1}\par
00237 \par
00238 {\cf21 #define KERNEL_CS       0x08    }{\cf20 // Entry 1: Kernel Code}\par
00239 {\cf21 #define KERNEL_DS       0x10    }{\cf20 // Entry 2: Kernel Data  }\par
00240 {\cf21 #define KERNEL_SS       0x10    }{\cf20 // Same as KERNEL_DS (data segment used for stack)}\par
00241 {\cf21 #define USER_CS         0x1B    }{\cf20 // Entry 3: User Code (for future)}\par
00242 {\cf21 #define USER_DS         0x23    }{\cf20 // Entry 4: User Data (for future)}\par
00243 {\cf21 #define USER_SS         0x23    }{\cf20 // Same as USER_DS (for future)}\par
00244 {\cf21 #define INITIAL_RFLAGS  0x202}\par
00245 {\cf21 #define USER_RFLAGS     0x246 }{\cf20 // IF=1, IOPL=0, CPL=3}\par
00246 \par
00247 {\cf17 typedef} {\cf17 struct }_APC_STATE \{\par
00248     uint64_t SavedCr3;\par
00249     PEPROCESS SavedApcProcess;\par
00250     {\cf18 bool} AttachedToProcess;\par
00251     IRQL PreviousIrql;\par
00252 \} APC_STATE, *PAPC_STATE;\par
00253 \par
00254 {\cf17 typedef} {\cf17 struct }_IPROCESS \{\par
00255     uintptr_t PageDirectoryPhysical;       {\cf20 // Physical Address of the PML4 of the process.}\par
00256     uint64_t* PageDirectoryVirtual;         {\cf20 // Virtual Address of the PML4 of the process. (accessible in kernel pages)}\par
00257     {\cf17 struct }_SPINLOCK ProcessLock;           {\cf20 // Internal Spinlock for process field manipulation safety.}\par
00258     uint32_t ProcessState;                  {\cf20 // Current process state.}\par
00259 \} IPROCESS, *PIPROCESS;\par
00260 \par
00261 {\cf17 typedef} {\cf17 struct }_ITHREAD \{\par
00262     {\cf17 struct }_TRAP_FRAME TrapRegisters;                      {\cf20 // Trap Registers used for context switching, saving, and alternation.}\par
00263     uint32_t ThreadState;                                   {\cf20 // Current thread state, presented by the THREAD_STATE enumerator.}\par
00264     {\cf18 void}* StackBase;                                      {\cf20 // Base of the thread's stack (allocated), used for also freeing it by the memory manager (Mm).}\par
00265     {\cf18 bool} IsLargeStack;                                     {\cf20 // Indicates if the stack allocated to the thread is a LargeStack or not. (Kernel stack only)}\par
00266     {\cf18 void}* KernelStack;                                      {\cf20 // The threads stack when in kernel space.}\par
00267     {\cf17 enum} _TimeSliceTicks TimeSlice;                        {\cf20 // Current timeslice remaining until thread's forceful pre-emption.}\par
00268     {\cf17 enum} _TimeSliceTicks TimeSliceAllocated;              {\cf20 // Original timeslice given to the thread, used for restoration when it's current one is over.}\par
00269     {\cf17 enum} _PRIVILEGE_MODE PreviousMode;                      {\cf20 // Previous mode of the thread (used to indicate whether it called a kernel service in kernel mode, or in user mode)         }\par
00270     {\cf17 struct }_APC_STATE ApcState;                              {\cf20 // Current thread's APC State.}\par
00271     {\cf17 struct }_WAIT_BLOCK WaitBlock;                          {\cf20 // Wait block of the current thread, defines a list of which events the thread is waiting on (mutex event, general sleeping)}\par
00272 \} ITHREAD, *PITHREAD;\par
00273 \par
00274 {\cf17 typedef} {\cf17 struct }_PROCESSOR \{\par
00275     {\cf17 struct }_PROCESSOR* self; {\cf20 // A pointer to the current CPU Struct, used internally by functions, see MtStealThread in scheduler.c, or MeGetCurrentProcessor.}\par
00276     {\cf17 enum} _IRQL currentIrql; {\cf20 // An integer that represents the current interrupt request level of the CPU. Declares which LAPIC & IOAPIC interrupts are masked}\par
00277     {\cf17 volatile} {\cf18 bool} schedulerEnabled; {\cf20 // A boolean value that indicates if the scheduler is allowed to be called after an interrupt.}\par
00278     {\cf17 struct }_ITHREAD* currentThread; {\cf20 // Current thread that is being executed in the CPU.}\par
00279     {\cf17 struct }_Queue readyQueue; {\cf20 // Queue of thread pointers to be scheduled.}\par
00280     uint32_t ID; {\cf20 // ID is also the index for cpus (e.g cpus[3] so .ID is 3)}\par
00281     uint32_t lapic_ID; {\cf20 // Internal APIC id of the CPU.}\par
00282     {\cf18 void}* VirtStackTop; {\cf20 // Pointer to top of CPU Stack.}\par
00283     {\cf18 void}* tss; {\cf20 // Task State Segment ptr.}\par
00284     {\cf18 void}* Rsp0; {\cf20 // General RSP for interrupts & syscalls (entry only) & exceptions.}\par
00285     {\cf18 void}* IstPFStackTop; {\cf20 // Page Fault IST Stack}\par
00286     {\cf18 void}* IstDFStackTop; {\cf20 // Double Fault IST Stack}\par
00287     {\cf17 volatile} uint64_t flags; {\cf20 // CPU Flags (CPU_FLAGS enum), contains the current state of the CPU, in bitfields.}\par
00288     {\cf18 bool} schedulePending; {\cf20 // A boolean value that indicates if a schedule is currently pending on the CPU}\par
00289     uint64_t* gdt; {\cf20 // A pointer to the current GDT of the CPU (set in the CPUs AP entry), does not include BSP GDT.}\par
00290     {\cf17 struct }_DPC* CurrentDeferredRoutine; {\cf20 // Current deferred routine that is executed by the CPU.}\par
00291     {\cf17 struct }_ETHREAD* idleThread; {\cf20 // Idle thread for the current CPU.}\par
00292     {\cf17 volatile} uint64_t IpiSeq;\par
00293     {\cf17 volatile} {\cf17 enum} _CPU_ACTION IpiAction; {\cf20 // IPI Action specified in the function.}\par
00294     {\cf17 volatile} IPI_PARAMS IpiParameter; {\cf20 // Optional parameter for IPI's, usually used for functions, primarily TLB Shootdowns.}\par
00295     {\cf17 volatile} uint32_t* LapicAddressVirt; {\cf20 // Virtual address of the Local APIC MMIO Address (mapped)}\par
00296     uintptr_t LapicAddressPhys; {\cf20 // Physical address of the Local APIC MMIO}\par
00297 \par
00298     {\cf20 /* Statically Special Allocated DPCs */}\par
00299     {\cf17 struct }_DPC TimerExpirationDPC;\par
00300     {\cf17 struct }_DPC ReaperDPC;\par
00301     {\cf20 /* End Statically Special Allocated DPCs */}\par
00302 \par
00303     {\cf20 // Additional DPC Fields}\par
00304     DPC_DATA DpcData;                     {\cf20 // The main DPC queue}\par
00305     {\cf17 volatile} {\cf18 bool} DpcRoutineActive;      {\cf20 // TRUE if inside MeRetireDPCs}\par
00306     {\cf17 volatile} uint32_t TimerRequest;      {\cf20 // Non-zero if timers need processing (unused)}\par
00307     uintptr_t TimerHand;                 {\cf20 // Context for timer expiration (unused)}\par
00308 \par
00309     {\cf20 // Additional APC Fields}\par
00310     {\cf17 volatile} {\cf18 bool} ApcRoutineActive; {\cf20 // True if inside MeRetireAPCs}\par
00311 \par
00312     {\cf20 // Fields for depth and performance analysis}\par
00313     uint32_t MaximumDpcQueueDepth;\par
00314     uint32_t MinimumDpcRate;\par
00315     uint32_t DpcRequestRate;\par
00316 \par
00317     {\cf20 // Interrupt requests}\par
00318     {\cf17 volatile} {\cf18 bool} DpcInterruptRequested; {\cf20 // True if we requested an interrupt to handle deferred procedure calls.}\par
00319     {\cf17 volatile} {\cf18 bool} ApcInterruptRequested; {\cf20 // (Undeveloped yet) True if we requested an interrupt for APCs.}\par
00320 \par
00321     {\cf20 // Scheduler Lock}\par
00322     SPINLOCK SchedulerLock;\par
00323 \par
00324     {\cf20 // Per CPU Lookaside pools}\par
00325     POOL_DESCRIPTOR LookasidePools[MAX_POOL_DESCRIPTORS];\par
00326 \par
00327     {\cf17 struct }_DEBUG_ENTRY DebugEntry[4]; {\cf20 // Per CPU Structure that contains debug entries for each debug register.}\par
00328     {\cf18 void}* IstTimerStackTop;\par
00329     {\cf18 void}* IstIpiStackTop;\par
00330 \par
00331     {\cf20 // Zombie Thread (for deferred reference deletion)}\par
00332     PITHREAD ZombieThread;\par
00333 \} PROCESSOR, *PPROCESSOR;\par
00334 \par
00335 {\cf20 // ------------------ FUNCTIONS ------------------}\par
00336 \par
00337 \par
00338 NORETURN\par
00339 {\cf18 void}\par
00340 MeBugCheck(\par
00341     IN {\cf17 enum} _BUGCHECK_CODES BugCheckCode\par
00342 );\par
00343 \par
00344 NORETURN\par
00345 {\cf18 void}\par
00346 MeBugCheckEx(\par
00347     IN {\cf17 enum} _BUGCHECK_CODES    BugCheckCode,\par
00348     IN {\cf18 void}* BugCheckParameter1,\par
00349     IN {\cf18 void}* BugCheckParameter2,\par
00350     IN {\cf18 void}* BugCheckParameter3,\par
00351     IN {\cf18 void}* BugCheckParameter4\par
00352 );\par
00353 \par
00354 FORCEINLINE\par
00355 PPROCESSOR\par
00356 MeGetCurrentProcessor ({\cf18 void})\par
00357     {\cf20 // Routine Description:}\par
00358     {\cf20 // This function returns the current address of the PROCESSOR struct. - Note this should only be used in kernel mode with the appropriate GS value.}\par
00359 \{\par
00360     {\cf19 return} (PPROCESSOR)__readgsqword(0); {\cf20 // Only works because we have a self pointer at offset 0 in the struct.}\par
00361 \}\par
00362 \par
00363 FORCEINLINE\par
00364 {\cf18 void}\par
00365 MeAcquireSchedulerLock({\cf18 void})\par
00366 \par
00367 \{\par
00368     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00369     {\cf20 // Acquire the spinlock. (FIXME MsAcquireSpinlockAtSynchLevel(&cpu->SchedulerLock)}\par
00370     {\cf19 while} (__sync_lock_test_and_set(&cpu->SchedulerLock.locked, 1)) \{\par
00371         __asm__ {\cf17 volatile}({\cf22 "pause"} ::: {\cf22 "memory"}); {\cf20 /* x86 pause \'97 CPU relax hint */}\par
00372     \}\par
00373     {\cf20 // Memory barrier to prevent instruction reordering}\par
00374     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00375     cpu->schedulerEnabled = {\cf17 false};\par
00376 \}\par
00377 \par
00378 FORCEINLINE\par
00379 {\cf18 void}\par
00380 MeReleaseSchedulerLock({\cf18 void})\par
00381 \par
00382 \{\par
00383     PPROCESSOR cpu = MeGetCurrentProcessor();\par
00384     cpu->schedulerEnabled = {\cf17 true};\par
00385     {\cf20 // Release the spinlock. (FIXME MsReleaseSpinlockFromSynchLevel(&cpu->SchedulerLock)}\par
00386     __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});\par
00387     __sync_lock_release(&cpu->SchedulerLock.locked);\par
00388 \}\par
00389 \par
00390 {\cf17 extern} uint32_t g_cpuCount;\par
00391 \par
00392 FORCEINLINE\par
00393 uint8_t\par
00394 MeGetActiveProcessorCount({\cf18 void})\par
00395 \par
00396 \{\par
00397     {\cf19 return} (uint8_t)g_cpuCount; {\cf20 // The reason we cast to uint8_t is because we would never have more than 255 Cpus in the system, not guranteed, though, :) }\par
00398 \}\par
00399 \par
00400 FORCEINLINE\par
00401 IRQL\par
00402 MeGetCurrentIrql({\cf18 void})\par
00403 \par
00404 {\cf20 /*++}\par
00405 {\cf20 }\par
00406 {\cf20     Routine description : Retrieves the IRQL of the current processor.}\par
00407 {\cf20 }\par
00408 {\cf20     Arguments:}\par
00409 {\cf20 }\par
00410 {\cf20         None.}\par
00411 {\cf20 }\par
00412 {\cf20     Return Values:}\par
00413 {\cf20 }\par
00414 {\cf20         Current IRQL at time of call.}\par
00415 {\cf20 }\par
00416 {\cf20 --*/}\par
00417 \par
00418 \{\par
00419 {\cf21 #ifdef DEBUG}\par
00420     IRQL returningIrql = (IRQL)__readgsqword(FIELD_OFFSET(PROCESSOR, currentIrql));\par
00421     {\cf19 if} (returningIrql > HIGH_LEVEL) MeBugCheck(INVALID_IRQL_SUPPLIED);\par
00422     {\cf19 return} returningIrql;\par
00423 {\cf21 #else}\par
00424     {\cf19 return} (IRQL)__readgsqword(FIELD_OFFSET(PROCESSOR, currentIrql));\par
00425 {\cf21 #endif}\par
00426 \}\par
00427 \par
00428 \par
00429 FORCEINLINE\par
00430 PITHREAD\par
00431 MeGetCurrentThread({\cf18 void})\par
00432 \par
00433 {\cf20 /*++}\par
00434 {\cf20 }\par
00435 {\cf20     Routine description : Retrieves the current running thread on the processor.}\par
00436 {\cf20 }\par
00437 {\cf20     Arguments:}\par
00438 {\cf20 }\par
00439 {\cf20         None.}\par
00440 {\cf20 }\par
00441 {\cf20     Return Values:}\par
00442 {\cf20 }\par
00443 {\cf20         Current thread running on time of call (this thread)}\par
00444 {\cf20 }\par
00445 {\cf20 --*/}\par
00446 \par
00447 \{\par
00448     {\cf19 return} (PITHREAD)__readgsqword(FIELD_OFFSET(PROCESSOR, currentThread));\par
00449 \}\par
00450 \par
00451 FORCEINLINE\par
00452 {\cf18 bool}\par
00453 MeIsExecutingDpc({\cf18 void})\par
00454 \par
00455 \{\par
00456     {\cf19 return} ({\cf18 bool})__readgsqword(FIELD_OFFSET(PROCESSOR, DpcRoutineActive));\par
00457 \}\par
00458 \par
00459 {\cf18 void}\par
00460 MeInitializeProcessor(\par
00461     IN PPROCESSOR CPU,\par
00462     IN {\cf18 bool} InitializeStandardRoutine,\par
00463     IN {\cf18 bool} AreYouAP\par
00464 );\par
00465 \par
00466 {\cf18 void}\par
00467 MeRaiseIrql(\par
00468     IN IRQL NewIrql,\par
00469     OUT PIRQL OldIrql\par
00470 );\par
00471 \par
00472 {\cf18 void} \par
00473 MeLowerIrql(\par
00474     IN IRQL NewIrql\par
00475 );\par
00476 \par
00477 {\cf18 void}\par
00478 _MeSetIrql(\par
00479     IN IRQL NewIrql\par
00480 );\par
00481 \par
00482 {\cf18 void}\par
00483 MeSetTargetProcessorDpc(\par
00484     IN PDPC Dpc,\par
00485     IN uint32_t CpuNumber\par
00486 );\par
00487 \par
00488 {\cf18 void}\par
00489 MeInitializeDpc(\par
00490     IN PDPC DpcAllocated,\par
00491     IN PDEFERRED_ROUTINE DeferredRoutine,\par
00492     IN {\cf18 void}* DeferredContext,\par
00493     IN DPC_PRIORITY DeferredPriority\par
00494 );\par
00495 \par
00496 {\cf18 bool}\par
00497 MeInsertQueueDpc(\par
00498     IN PDPC Dpc,\par
00499     IN {\cf18 void}* SystemArgument1,\par
00500     IN {\cf18 void}* SystemArgument2\par
00501 );\par
00502 \par
00503 {\cf18 bool}\par
00504 MeRemoveQueueDpc(\par
00505     IN PDPC Dpc\par
00506 );\par
00507 \par
00508 {\cf18 void}\par
00509 MeRetireDPCs(\par
00510     {\cf18 void}\par
00511 );\par
00512 \par
00513 {\cf18 void} CleanStacks(DPC* dpc, {\cf18 void}* thread, {\cf18 void}* allocatedDPC, {\cf18 void}* arg4);\par
00514 {\cf18 void} ReapOb(DPC* dpc, {\cf18 void}* DeferredContext, {\cf18 void}* SystemArgument1, {\cf18 void}* SystemArgument2);\par
00515 {\cf18 void} InitScheduler({\cf18 void});\par
00516 \par
00517 {\cf18 void}\par
00518 MeAttachProcess(\par
00519     IN PIPROCESS Process,\par
00520     OUT PAPC_STATE ApcState\par
00521 );\par
00522 \par
00523 {\cf18 void}\par
00524 MeDetachProcess(\par
00525     IN PAPC_STATE ApcState\par
00526 );\par
00527 \par
00528 NORETURN\par
00529 {\cf18 void}\par
00530 Schedule({\cf18 void});\par
00531 \par
00532 FORCEINLINE\par
00533 PRIVILEGE_MODE\par
00534 MeGetPreviousMode(\par
00535     {\cf18 void}\par
00536 )\par
00537 \par
00538 \{\par
00539     PITHREAD CurrentThread = MeGetCurrentThread();\par
00540     {\cf19 if} (CurrentThread) \{\par
00541         {\cf19 return} CurrentThread->PreviousMode;\par
00542     \}\par
00543     {\cf19 else} \{\par
00544         {\cf20 // No thread is active on the current processor (not even a kernel one), this is early init.}\par
00545         {\cf19 return} KernelMode;\par
00546     \}\par
00547 \}\par
00548 \par
00549 {\cf18 void}\par
00550 MeEnableInterrupts(\par
00551     IN {\cf18 bool} EnabledBefore\par
00552 );\par
00553 \par
00554 {\cf18 bool}\par
00555 MeDisableInterrupts(\par
00556     {\cf18 void}\par
00557 );\par
00558 \par
00559 {\cf18 bool}\par
00560 MeAreInterruptsEnabled(\par
00561     {\cf18 void}\par
00562 );\par
00563 \par
00564 {\cf20 // smp.c}\par
00565 PPROCESSOR MeGetProcessorBlock(uint8_t ProcessorNumber);\par
00566 \par
00567 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mg.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mg.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mg.h}
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "stdarg_myos.h"}\par
{\f2 #include "efi.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_RED}\~ 0xFFFF0000\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors definitions for easier access. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_GREEN}\~ 0xFF00FF00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_BLUE}\~ 0xFF0000FF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_WHITE}\~ 0xFFFFFFFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_BLACK}\~ 0xFF000000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_YELLOW}\~ 0xFFFFFF00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_CYAN}\~ 0xFF00FFFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_MAGENTA}\~ 0xFFFF00FF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_GRAY}\~ 0xFF808080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_DARK_GRAY}\~ 0xFF404040\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_LIGHT_GRAY}\~ 0xFFD3D3D3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_ORANGE}\~ 0xFFFFA500\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_BROWN}\~ 0xFFA52A2A\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_PURPLE}\~ 0xFF800080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_PINK}\~ 0xFFFFC0CB\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_LIME}\~ 0xFF32CD32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_NAVY}\~ 0xFF000080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_TEAL}\~ 0xFF008080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COLOR_OLIVE}\~ 0xFF808000\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b gop_printf} (uint32_t color, const char *fmt,...) {\b __attribute__}((format(printf\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void void {\b gop_clear_screen} ({\b GOP_PARAMS} *gop, uint32_t color)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ksnprintf} (char *buf, size_t bufsize, const char *fmt,...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kstrcmp} (const char *s1, const char *s2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b kstrncmp} (const char *s1, const char *s2, size_t length)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b kstrlen} (const char *str)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrcpy} (char *dst, const char *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrncpy} (char *dst, const char *src, size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrtok_r} (char *str, const char *delim, char **save_ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b kstrncat} (char *dest, const char *src, size_t max_len)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MgAcquireExclusiveGopOwnerShip} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MgReleaseExclusiveGopOwnerShip} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v COLOR_BLACK\:mg.h}
{\xe \v mg.h\:COLOR_BLACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_BLACK\~ 0xFF000000}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b mg.h}.}\par
}
{\xe \v COLOR_BLUE\:mg.h}
{\xe \v mg.h\:COLOR_BLUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_BLUE\~ 0xFF0000FF}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b mg.h}.}\par
}
{\xe \v COLOR_BROWN\:mg.h}
{\xe \v mg.h\:COLOR_BROWN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_BROWN\~ 0xFFA52A2A}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b mg.h}.}\par
}
{\xe \v COLOR_CYAN\:mg.h}
{\xe \v mg.h\:COLOR_CYAN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_CYAN\~ 0xFF00FFFF}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b mg.h}.}\par
}
{\xe \v COLOR_DARK_GRAY\:mg.h}
{\xe \v mg.h\:COLOR_DARK_GRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_DARK_GRAY\~ 0xFF404040}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b mg.h}.}\par
}
{\xe \v COLOR_GRAY\:mg.h}
{\xe \v mg.h\:COLOR_GRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_GRAY\~ 0xFF808080}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b mg.h}.}\par
}
{\xe \v COLOR_GREEN\:mg.h}
{\xe \v mg.h\:COLOR_GREEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_GREEN\~ 0xFF00FF00}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b mg.h}.}\par
}
{\xe \v COLOR_LIGHT_GRAY\:mg.h}
{\xe \v mg.h\:COLOR_LIGHT_GRAY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_LIGHT_GRAY\~ 0xFFD3D3D3}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b mg.h}.}\par
}
{\xe \v COLOR_LIME\:mg.h}
{\xe \v mg.h\:COLOR_LIME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_LIME\~ 0xFF32CD32}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b mg.h}.}\par
}
{\xe \v COLOR_MAGENTA\:mg.h}
{\xe \v mg.h\:COLOR_MAGENTA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_MAGENTA\~ 0xFFFF00FF}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b mg.h}.}\par
}
{\xe \v COLOR_NAVY\:mg.h}
{\xe \v mg.h\:COLOR_NAVY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_NAVY\~ 0xFF000080}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b mg.h}.}\par
}
{\xe \v COLOR_OLIVE\:mg.h}
{\xe \v mg.h\:COLOR_OLIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_OLIVE\~ 0xFF808000}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b mg.h}.}\par
}
{\xe \v COLOR_ORANGE\:mg.h}
{\xe \v mg.h\:COLOR_ORANGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_ORANGE\~ 0xFFFFA500}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b mg.h}.}\par
}
{\xe \v COLOR_PINK\:mg.h}
{\xe \v mg.h\:COLOR_PINK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_PINK\~ 0xFFFFC0CB}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b mg.h}.}\par
}
{\xe \v COLOR_PURPLE\:mg.h}
{\xe \v mg.h\:COLOR_PURPLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_PURPLE\~ 0xFF800080}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b mg.h}.}\par
}
{\xe \v COLOR_RED\:mg.h}
{\xe \v mg.h\:COLOR_RED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_RED\~ 0xFFFF0000}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Colors definitions for easier access. }}\par
{
Definition at line {\b 29} of file {\b mg.h}.}\par
}
{\xe \v COLOR_TEAL\:mg.h}
{\xe \v mg.h\:COLOR_TEAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_TEAL\~ 0xFF008080}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b mg.h}.}\par
}
{\xe \v COLOR_WHITE\:mg.h}
{\xe \v mg.h\:COLOR_WHITE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_WHITE\~ 0xFFFFFFFF}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b mg.h}.}\par
}
{\xe \v COLOR_YELLOW\:mg.h}
{\xe \v mg.h\:COLOR_YELLOW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COLOR_YELLOW\~ 0xFFFFFF00}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b mg.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v gop_clear_screen\:mg.h}
{\xe \v mg.h\:gop_clear_screen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void void gop_clear_screen ({\b GOP_PARAMS} * gop, uint32_t color)}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b gop.c}.}\par
}
{\xe \v gop_printf\:mg.h}
{\xe \v mg.h\:gop_printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gop_printf (uint32_t color, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ksnprintf\:mg.h}
{\xe \v mg.h\:ksnprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ksnprintf (char * buf, size_t bufsize, const char * fmt,  ...)}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 546} of file {\b gop.c}.}\par
}
{\xe \v kstrcmp\:mg.h}
{\xe \v mg.h\:kstrcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kstrcmp (const char * s1, const char * s2)}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 657} of file {\b gop.c}.}\par
}
{\xe \v kstrcpy\:mg.h}
{\xe \v mg.h\:kstrcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrcpy (char * dst, const char * src)}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b gop.c}.}\par
}
{\xe \v kstrlen\:mg.h}
{\xe \v mg.h\:kstrlen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t kstrlen (const char * str)}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 393} of file {\b gop.c}.}\par
}
{\xe \v kstrncat\:mg.h}
{\xe \v mg.h\:kstrncat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrncat (char * dest, const char * src, size_t max_len)}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Concatenates src onto dest, up to max_len total bytes in dest. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dest} \cell }{Destination buffer (must be mutable)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i src} \cell }{String to append\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i max_len} \cell }{Total size of the destination buffer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Pointer to dest\par
}}}{
Definition at line {\b 365} of file {\b gop.c}.}\par
}
{\xe \v kstrncmp\:mg.h}
{\xe \v mg.h\:kstrncmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int kstrncmp (const char * s1, const char * s2, size_t length)}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 666} of file {\b gop.c}.}\par
}
{\xe \v kstrncpy\:mg.h}
{\xe \v mg.h\:kstrncpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrncpy (char * dst, const char * src, size_t n)}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b gop.c}.}\par
}
{\xe \v kstrtok_r\:mg.h}
{\xe \v mg.h\:kstrtok_r}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * kstrtok_r (char * str, const char * delim, char ** save_ptr)}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 491} of file {\b gop.c}.}\par
}
{\xe \v MgAcquireExclusiveGopOwnerShip\:mg.h}
{\xe \v mg.h\:MgAcquireExclusiveGopOwnerShip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MgAcquireExclusiveGopOwnerShip (void )}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 794} of file {\b gop.c}.}\par
}
{\xe \v MgReleaseExclusiveGopOwnerShip\:mg.h}
{\xe \v mg.h\:MgReleaseExclusiveGopOwnerShip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MgReleaseExclusiveGopOwnerShip (void )}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 806} of file {\b gop.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mg.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mg.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mg.h}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_GRAPHICAL_H}\par
00002 {\cf21 #define X86_MATANEL_GRAPHICAL_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     mg.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for graphical interfaces. - Note that this only contains a very basic driver, advanced drivers should be loaded dynamically.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 \par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stdbool.h>}\par
00025 {\cf21 #include "stdarg_myos.h"}\par
00026 {\cf21 #include "efi.h"}\par
00027 \par
00029 {\cf21 #define COLOR_RED        0xFFFF0000}\par
00030 {\cf21 #define COLOR_GREEN      0xFF00FF00}\par
00031 {\cf21 #define COLOR_BLUE       0xFF0000FF}\par
00032 {\cf21 #define COLOR_WHITE      0xFFFFFFFF}\par
00033 {\cf21 #define COLOR_BLACK      0xFF000000}\par
00034 {\cf21 #define COLOR_YELLOW     0xFFFFFF00}\par
00035 {\cf21 #define COLOR_CYAN       0xFF00FFFF}\par
00036 {\cf21 #define COLOR_MAGENTA    0xFFFF00FF}\par
00037 {\cf21 #define COLOR_GRAY       0xFF808080}\par
00038 {\cf21 #define COLOR_DARK_GRAY  0xFF404040}\par
00039 {\cf21 #define COLOR_LIGHT_GRAY 0xFFD3D3D3}\par
00040 {\cf21 #define COLOR_ORANGE     0xFFFFA500}\par
00041 {\cf21 #define COLOR_BROWN      0xFFA52A2A}\par
00042 {\cf21 #define COLOR_PURPLE     0xFF800080}\par
00043 {\cf21 #define COLOR_PINK       0xFFFFC0CB}\par
00044 {\cf21 #define COLOR_LIME       0xFF32CD32}\par
00045 {\cf21 #define COLOR_NAVY       0xFF000080}\par
00046 {\cf21 #define COLOR_TEAL       0xFF008080}\par
00047 {\cf21 #define COLOR_OLIVE      0xFF808000}\par
00048 \par
00049 {\cf18 void} gop_printf(uint32_t color, {\cf17 const} {\cf18 char}* fmt, ...)\par
00050 __attribute__((format(printf, 2, 3)));\par
00051 {\cf18 void} gop_clear_screen(GOP_PARAMS* gop, uint32_t color);\par
00052 \par
00053 \par
00054 {\cf18 int} ksnprintf({\cf18 char}* buf, {\cf18 size_t} bufsize, const {\cf18 char}* fmt, ...);\par
00055 {\cf18 int} kstrcmp(const {\cf18 char}* s1, const {\cf18 char}* s2);\par
00056 {\cf18 int} kstrncmp(const {\cf18 char}* s1, const {\cf18 char}* s2, {\cf18 size_t} length);\par
00057 {\cf18 size_t} kstrlen(const {\cf18 char}* str);\par
00058 {\cf18 char}* kstrcpy({\cf18 char}* dst, const {\cf18 char}* src);\par
00059 {\cf20 // Gurantees null termination.}\par
00060 {\cf18 char}* kstrncpy({\cf18 char}* dst, const {\cf18 char}* src, {\cf18 size_t} n);\par
00061 {\cf18 char}* kstrtok_r({\cf18 char}* str, const {\cf18 char}* delim, {\cf18 char}** save_ptr);\par
00062 {\cf18 char}* kstrncat({\cf18 char}* dest, const {\cf18 char}* src, {\cf18 size_t} max_len);\par
00063 \par
00064 \par
00065 {\cf18 void} MgAcquireExclusiveGopOwnerShip({\cf18 void});\par
00066 {\cf18 void} MgReleaseExclusiveGopOwnerShip({\cf18 void});\par
00067 \par
00068 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mh.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mh.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mh.h}
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "core.h"}\par
{\f2 #include "annotations.h"}\par
{\f2 #include "macros.h"}\par
{\f2 #include <cpuid.h>}\par
{\f2 #include "mm.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IDT_PTR}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IDT_ENTRY_64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _RSDP_Descriptor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ACPI_SDT_HEADER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _XSDT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _GenericAddressStructure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _FADT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MADT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __attribute__}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SMP_BOOTINFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _DEBUG_REGISTERS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _PAGE_PARAMETERS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _IPI_PARAMS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IDT_ENTRIES}\~ 256\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IRQL_VECTOR_BASE}\~ 0x40\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TPR_PASSIVE}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TPR_APC}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TPR_DPC}\~ 8\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TPR_PROFILE}\~ 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TPR_IPI}\~ 11\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CALC_VECTOR}(pri)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VECTOR_DPC}\~ {\b CALC_VECTOR}({\b TPR_DPC})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VECTOR_APC}\~ {\b CALC_VECTOR}({\b TPR_APC})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VECTOR_IPI}\~ {\b CALC_VECTOR}({\b TPR_IPI})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_TIMER_VECTOR}\~ 0xEF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AP_TRAMP_PHYS}\~ 0x7000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AP_TRAMP_SIZE}\~ 0x1000UL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AP_TRAMP_APMAIN_OFFSET}\~ 0x1000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AP_TRAMP_PML4_OFFSET}\~ 0x2000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AP_TRAMP_CPUS_OFFSET}\~ 0x2500ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_CPUS}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LAPIC_ID}\~ 0x020\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SMP_MAGIC}\~ 0x4D4154414E454C00\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IST_SIZE}\~ (16*1024)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IST_ALIGNMENT}\~ 16\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AMD}\~ "AuthenticAMD"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AMD_OLD}\~ "AMDisbetter!"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_INTEL}\~ "GenuineIntel"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VIA}\~ "VIA VIA VIA "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_TRANSMETA}\~ "GenuineTMx86"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_TRANSMETA_OLD}\~ "TransmetaCPU"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_CYRIX}\~ "CyrixInstead"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_CENTAUR}\~ "CentaurHauls"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_NEXGEN}\~ "NexGenDriven"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_UMC}\~ "UMC UMC UMC "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_SIS}\~ "SiS SiS SiS "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_NSC}\~ "Geode by NSC"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_RISE}\~ "RiseRiseRise"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VORTEX}\~ "Vortex86 SoC"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AO486}\~ "MiSTer AO486"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_AO486_OLD}\~ "GenuineAO486"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_ZHAOXIN}\~ "  Shanghai  "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_HYGON}\~ "HygonGenuine"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_ELBRUS}\~ "E2K MACHINE "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_QEMU}\~ "TCGTCGTCGTCG"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_KVM}\~ " KVMKVMKVM  "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VMWARE}\~ "VMwareVMware"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_VIRTUALBOX}\~ "VBoxVBoxVBox"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_XEN}\~ "XenVMMXenVMM"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_HYPERV}\~ "Microsoft Hv"\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_PARALLELS}\~ " prl hyperv "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_PARALLELS_ALT}\~ " lrpepyh vr "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_BHYVE}\~ "bhyve bhyve "\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CPUID_VENDOR_QNX}\~ " QNXQVMBSQG "\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _CPU_EXCEPTIONS} {\b CPU_EXCEPTIONS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _INTERRUPT_LIST} {\b INTERRUPT_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _CPU_ACTION} {\b CPU_ACTION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IDT_PTR} {\b IDT_PTR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IDT_ENTRY_64} {\b IDT_ENTRY64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _SMP_BOOTINFO} {\b SMP_BOOTINFO}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b DebugCallback}) (void *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _DEBUG_REGISTERS} {\b DEBUG_REGISTERS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _PAGE_PARAMETERS} {\b PAGE_PARAMETERS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _IPI_PARAMS} {\b IPI_PARAMS}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _CPU_EXCEPTIONS} \{ {\b EXCEPTION_DIVIDE_BY_ZERO}
, {\b EXCEPTION_SINGLE_STEP}
, {\b EXCEPTION_NON_MASKABLE_INTERRUPT}
, {\b EXCEPTION_BREAKPOINT}
, {\b EXCEPTION_OVERFLOW}
, {\b EXCEPTION_BOUNDS_CHECK}
, {\b EXCEPTION_INVALID_OPCODE}
, {\b EXCEPTION_NO_COPROCESSOR}
, {\b EXCEPTION_DOUBLE_FAULT}
, {\b EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN}
, {\b EXCEPTION_INVALID_TSS}
, {\b EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT}
, {\b EXCEPTION_STACK_SEGMENT_OVERRUN}
, {\b EXCEPTION_GENERAL_PROTECTION_FAULT}
, {\b EXCEPTION_PAGE_FAULT}
, {\b EXCEPTION_RESERVED}
, {\b EXCEPTION_FLOATING_POINT_ERROR}
, {\b EXCEPTION_ALIGNMENT_CHECK}
, {\b EXCEPTION_SEVERE_MACHINE_CHECK}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _INTERRUPT_LIST} \{ {\b TIMER_INTERRUPT} = 32
, {\b KEYBOARD_INTERRUPT} = 33
, {\b ATA_INTERRUPT} = 46
, {\b LAPIC_INTERRUPT} = 0xEF
, {\b LAPIC_SIV_INTERRUPT} = 0xFF
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _CPU_ACTION} \{ {\b CPU_ACTION_STOP} = 0
, {\b CPU_ACTION_PRINT_ID} = 1
, {\b CPU_ACTION_PERFORM_TLB_SHOOTDOWN} = 2
, {\b CPU_ACTION_WRITE_DEBUG_REGS} = 3
, {\b CPU_ACTION_CLEAR_DEBUG_REGS} = 4
, {\b CPU_ACTION_DO_DEFERRED_ROUTINES} = 5
, {\b CPU_ACTION_FLUSH_CR3} = 6
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MADT_TYPES} \{ {\b MADT_LAPIC} = 0
, {\b MADT_IOAPIC} = 1
, {\b MADT_INTERUPT_SOURCE_OVERRIDE} = 2
, {\b MADT_NON_MASKABLE_INTERRUPT} = 4
, {\b MADT_X2APIC} = 9
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b CPUID_FEAT_ECX_SSE3} = 1 << 0
, {\b CPUID_FEAT_ECX_PCLMUL} = 1 << 1
, {\b CPUID_FEAT_ECX_DTES64} = 1 << 2
, {\b CPUID_FEAT_ECX_MONITOR} = 1 << 3
, {\b CPUID_FEAT_ECX_DS_CPL} = 1 << 4
, {\b CPUID_FEAT_ECX_VMX} = 1 << 5
, {\b CPUID_FEAT_ECX_SMX} = 1 << 6
, {\b CPUID_FEAT_ECX_EST} = 1 << 7
, {\b CPUID_FEAT_ECX_TM2} = 1 << 8
, {\b CPUID_FEAT_ECX_SSSE3} = 1 << 9
, {\b CPUID_FEAT_ECX_CID} = 1 << 10
, {\b CPUID_FEAT_ECX_SDBG} = 1 << 11
, {\b CPUID_FEAT_ECX_FMA} = 1 << 12
, {\b CPUID_FEAT_ECX_CX16} = 1 << 13
, {\b CPUID_FEAT_ECX_XTPR} = 1 << 14
, {\b CPUID_FEAT_ECX_PDCM} = 1 << 15
, {\b CPUID_FEAT_ECX_PCID} = 1 << 17
, {\b CPUID_FEAT_ECX_DCA} = 1 << 18
, {\b CPUID_FEAT_ECX_SSE4_1} = 1 << 19
, {\b CPUID_FEAT_ECX_SSE4_2} = 1 << 20
, {\b CPUID_FEAT_ECX_X2APIC} = 1 << 21
, {\b CPUID_FEAT_ECX_MOVBE} = 1 << 22
, {\b CPUID_FEAT_ECX_POPCNT} = 1 << 23
, {\b CPUID_FEAT_ECX_TSC} = 1 << 24
, {\b CPUID_FEAT_ECX_AES} = 1 << 25
, {\b CPUID_FEAT_ECX_XSAVE} = 1 << 26
, {\b CPUID_FEAT_ECX_OSXSAVE} = 1 << 27
, {\b CPUID_FEAT_ECX_AVX} = 1 << 28
, {\b CPUID_FEAT_ECX_F16C} = 1 << 29
, {\b CPUID_FEAT_ECX_RDRAND} = 1 << 30
, {\b CPUID_FEAT_ECX_HYPERVISOR} = 1 << 31
, {\b CPUID_FEAT_EDX_FPU} = 1 << 0
, {\b CPUID_FEAT_EDX_VME} = 1 << 1
, {\b CPUID_FEAT_EDX_DE} = 1 << 2
, {\b CPUID_FEAT_EDX_PSE} = 1 << 3
, {\b CPUID_FEAT_EDX_TSC} = 1 << 4
, {\b CPUID_FEAT_EDX_MSR} = 1 << 5
, {\b CPUID_FEAT_EDX_PAE} = 1 << 6
, {\b CPUID_FEAT_EDX_MCE} = 1 << 7
, {\b CPUID_FEAT_EDX_CX8} = 1 << 8
, {\b CPUID_FEAT_EDX_APIC} = 1 << 9
, {\b CPUID_FEAT_EDX_SEP} = 1 << 11
, {\b CPUID_FEAT_EDX_MTRR} = 1 << 12
, {\b CPUID_FEAT_EDX_PGE} = 1 << 13
, {\b CPUID_FEAT_EDX_MCA} = 1 << 14
, {\b CPUID_FEAT_EDX_CMOV} = 1 << 15
, {\b CPUID_FEAT_EDX_PAT} = 1 << 16
, {\b CPUID_FEAT_EDX_PSE36} = 1 << 17
, {\b CPUID_FEAT_EDX_PSN} = 1 << 18
, {\b CPUID_FEAT_EDX_CLFLUSH} = 1 << 19
, {\b CPUID_FEAT_EDX_DS} = 1 << 21
, {\b CPUID_FEAT_EDX_ACPI} = 1 << 22
, {\b CPUID_FEAT_EDX_MMX} = 1 << 23
, {\b CPUID_FEAT_EDX_FXSR} = 1 << 24
, {\b CPUID_FEAT_EDX_SSE} = 1 << 25
, {\b CPUID_FEAT_EDX_SSE2} = 1 << 26
, {\b CPUID_FEAT_EDX_SS} = 1 << 27
, {\b CPUID_FEAT_EDX_HTT} = 1 << 28
, {\b CPUID_FEAT_EDX_TM} = 1 << 29
, {\b CPUID_FEAT_EDX_IA64} = 1 << 30
, {\b CPUID_FEAT_EDX_PBE} = 1 << 31
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _RSDP_Descriptor} {\b __attribute__} ((packed)) RSDP_Descriptor\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b APMain} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
---------------\'97 FUNCTIONS ---------------\'97 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhInitializeSMP} (uint8_t *{\b apic_list}, uint32_t {\b cpu_count}, uint32_t {\b lapicAddress})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhSendActionToCpusAndWait} ({\b CPU_ACTION} action, {\b IPI_PARAMS} parameter)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_idt_gate} (int n, unsigned long int handler)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b install_idt} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_interrupts} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_init_cpu} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_enable} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapic_mmio_read} (uint32_t off)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_mmio_write} (uint32_t off, uint32_t val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_eoi} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_init_siv} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_send_ipi} (uint8_t apic_id, uint8_t vector, uint32_t {\b flags})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b init_lapic_timer} (uint32_t hz)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pit_sleep_ms} (uint32_t ms)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lapic_timer_calibrate} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkcpuid} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b checkApic} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b getCpuName} (char *name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhHandleInterrupt} ({\b IN} int vec_num, {\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiLapicInterrupt} (bool schedulerEnabled, {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiBreakpoint} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MiNonMaskableInterrupt} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiDivideByZero} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiDebugTrap} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NORETURN} void {\b MiDoubleFault} ({\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInterprocessorInterrupt} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiPageFault} ({\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInvalidTss} ({\b IN} {\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiOverflow} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiBoundsCheck} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInvalidOpcode} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiNoCoprocessor} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiCoprocessorSegmentOverrun} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiSegmentSelectorNotPresent} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiStackSegmentOverrun} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiGeneralProtectionFault} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiFloatingPointError} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiAlignmentCheck} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiMachineCheck} ({\b PTRAP_FRAME} trap)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhRequestSoftwareInterrupt} ({\b IN} {\b IRQL} RequestIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MhInitializeACPI} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MhParseLAPICs} (uint8_t *buffer, size_t maxCPUs, uint32_t *cpuCount, uint32_t *{\b lapicAddress})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MhRebootComputer} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b __attribute__}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b Signature} [8]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Checksum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OemId} [6]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Revision}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b RsdtAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b XsdtAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ExtendedChecksum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved} [3]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b OemTableId} [8]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b OemRevision}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b CreatorId}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b CreatorRevision}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ACPI_SDT_HEADER} {\b h}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Entries} []\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AddressSpace}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b BitWidth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b BitOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AccessSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b Address}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b FirmwareCtrl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Dsdt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PreferredPowerManagementProfile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b SCI_Interrupt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b SMI_CommandPort}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AcpiEnable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b AcpiDisable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b S4BIOS_REQ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PSTATE_Control}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1aEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1bEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1aControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM1bControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PM2ControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b PMTimerBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b GPE0Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b GPE1Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PM1EventLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PM1ControlLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PM2ControlLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b PMTimerLength}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b GPE0Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b GPE1Length}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b GPE1Base}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b CStateControl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b WorstC2Latency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b WorstC3Latency}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b FlushSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b FlushStride}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b DutyOffset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b DutyWidth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b DayAlarm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b MonthAlarm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Century}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b BootArchitectureFlags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved2}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b ResetReg}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b ResetValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b Reserved3} [3]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b X_FirmwareControl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b X_Dsdt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1aEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1bEventBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1aControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM1bControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PM2ControlBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_PMTimerBlock}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_GPE0Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GenericAddressStructure {\b X_GPE1Block}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapicAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GDTEntry64}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GDTPtr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TSS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b smp_cpu_count}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b smpInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allApsInitialized}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AP_TRAMP_APMAIN_OFFSET\:mh.h}
{\xe \v mh.h\:AP_TRAMP_APMAIN_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AP_TRAMP_APMAIN_OFFSET\~ 0x1000ULL}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 405} of file {\b mh.h}.}\par
}
{\xe \v AP_TRAMP_CPUS_OFFSET\:mh.h}
{\xe \v mh.h\:AP_TRAMP_CPUS_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AP_TRAMP_CPUS_OFFSET\~ 0x2500ULL}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 407} of file {\b mh.h}.}\par
}
{\xe \v AP_TRAMP_PHYS\:mh.h}
{\xe \v mh.h\:AP_TRAMP_PHYS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AP_TRAMP_PHYS\~ 0x7000ULL}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 403} of file {\b mh.h}.}\par
}
{\xe \v AP_TRAMP_PML4_OFFSET\:mh.h}
{\xe \v mh.h\:AP_TRAMP_PML4_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AP_TRAMP_PML4_OFFSET\~ 0x2000ULL}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 406} of file {\b mh.h}.}\par
}
{\xe \v AP_TRAMP_SIZE\:mh.h}
{\xe \v mh.h\:AP_TRAMP_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AP_TRAMP_SIZE\~ 0x1000UL}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 404} of file {\b mh.h}.}\par
}
{\xe \v CALC_VECTOR\:mh.h}
{\xe \v mh.h\:CALC_VECTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CALC_VECTOR( pri)}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (IRQL_VECTOR_BASE + (pri << 4))\par
}
{
Definition at line {\b 44} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_AMD\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_AMD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AMD\~ "AuthenticAMD"}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 414} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_AMD_OLD\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_AMD_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AMD_OLD\~ "AMDisbetter!"}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 415} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_AO486\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_AO486}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AO486\~ "MiSTer AO486"}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 428} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_AO486_OLD\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_AO486_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_AO486_OLD\~ "GenuineAO486"}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 429} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_BHYVE\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_BHYVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_BHYVE\~ "bhyve bhyve "}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 443} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_CENTAUR\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_CENTAUR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_CENTAUR\~ "CentaurHauls"}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 421} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_CYRIX\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_CYRIX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_CYRIX\~ "CyrixInstead"}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 420} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_ELBRUS\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_ELBRUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_ELBRUS\~ "E2K MACHINE "}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 432} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_HYGON\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_HYGON}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_HYGON\~ "HygonGenuine"}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_HYPERV\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_HYPERV}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_HYPERV\~ "Microsoft Hv"}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 440} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_INTEL\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_INTEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_INTEL\~ "GenuineIntel"}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_KVM\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_KVM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_KVM\~ " KVMKVMKVM  "}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 436} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_NEXGEN\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_NEXGEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_NEXGEN\~ "NexGenDriven"}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 422} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_NSC\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_NSC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_NSC\~ "Geode by NSC"}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 425} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_PARALLELS\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_PARALLELS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_PARALLELS\~ " prl hyperv "}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 441} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_PARALLELS_ALT\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_PARALLELS_ALT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_PARALLELS_ALT\~ " lrpepyh vr "}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 442} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_QEMU\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_QEMU}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_QEMU\~ "TCGTCGTCGTCG"}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 435} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_QNX\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_QNX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_QNX\~ " QNXQVMBSQG "}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 444} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_RISE\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_RISE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_RISE\~ "RiseRiseRise"}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 426} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_SIS\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_SIS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_SIS\~ "SiS SiS SiS "}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 424} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_TRANSMETA\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_TRANSMETA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_TRANSMETA\~ "GenuineTMx86"}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 418} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_TRANSMETA_OLD\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_TRANSMETA_OLD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_TRANSMETA_OLD\~ "TransmetaCPU"}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 419} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_UMC\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_UMC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_UMC\~ "UMC UMC UMC "}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 423} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_VIA\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_VIA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VIA\~ "VIA VIA VIA "}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 417} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_VIRTUALBOX\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_VIRTUALBOX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VIRTUALBOX\~ "VBoxVBoxVBox"}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 438} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_VMWARE\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_VMWARE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VMWARE\~ "VMwareVMware"}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 437} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_VORTEX\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_VORTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_VORTEX\~ "Vortex86 SoC"}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 427} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_XEN\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_XEN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_XEN\~ "XenVMMXenVMM"}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 439} of file {\b mh.h}.}\par
}
{\xe \v CPUID_VENDOR_ZHAOXIN\:mh.h}
{\xe \v mh.h\:CPUID_VENDOR_ZHAOXIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CPUID_VENDOR_ZHAOXIN\~ "  Shanghai  "}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 430} of file {\b mh.h}.}\par
}
{\xe \v IDT_ENTRIES\:mh.h}
{\xe \v mh.h\:IDT_ENTRIES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IDT_ENTRIES\~ 256}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b mh.h}.}\par
}
{\xe \v IRQL_VECTOR_BASE\:mh.h}
{\xe \v mh.h\:IRQL_VECTOR_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IRQL_VECTOR_BASE\~ 0x40}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b mh.h}.}\par
}
{\xe \v IST_ALIGNMENT\:mh.h}
{\xe \v mh.h\:IST_ALIGNMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IST_ALIGNMENT\~ 16}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 412} of file {\b mh.h}.}\par
}
{\xe \v IST_SIZE\:mh.h}
{\xe \v mh.h\:IST_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IST_SIZE\~ (16*1024)}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 411} of file {\b mh.h}.}\par
}
{\xe \v LAPIC_ID\:mh.h}
{\xe \v mh.h\:LAPIC_ID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_ID\~ 0x020}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 409} of file {\b mh.h}.}\par
}
{\xe \v LAPIC_TIMER_VECTOR\:mh.h}
{\xe \v mh.h\:LAPIC_TIMER_VECTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LAPIC_TIMER_VECTOR\~ 0xEF}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b mh.h}.}\par
}
{\xe \v MAX_CPUS\:mh.h}
{\xe \v mh.h\:MAX_CPUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_CPUS\~ 32}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 408} of file {\b mh.h}.}\par
}
{\xe \v SMP_MAGIC\:mh.h}
{\xe \v mh.h\:SMP_MAGIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SMP_MAGIC\~ 0x4D4154414E454C00}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 410} of file {\b mh.h}.}\par
}
{\xe \v TPR_APC\:mh.h}
{\xe \v mh.h\:TPR_APC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TPR_APC\~ 3}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b mh.h}.}\par
}
{\xe \v TPR_DPC\:mh.h}
{\xe \v mh.h\:TPR_DPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TPR_DPC\~ 8}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b mh.h}.}\par
}
{\xe \v TPR_IPI\:mh.h}
{\xe \v mh.h\:TPR_IPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TPR_IPI\~ 11}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b mh.h}.}\par
}
{\xe \v TPR_PASSIVE\:mh.h}
{\xe \v mh.h\:TPR_PASSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TPR_PASSIVE\~ 0}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b mh.h}.}\par
}
{\xe \v TPR_PROFILE\:mh.h}
{\xe \v mh.h\:TPR_PROFILE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TPR_PROFILE\~ 10}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b mh.h}.}\par
}
{\xe \v VECTOR_APC\:mh.h}
{\xe \v mh.h\:VECTOR_APC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VECTOR_APC\~ {\b CALC_VECTOR}({\b TPR_APC})}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 48} of file {\b mh.h}.}\par
}
{\xe \v VECTOR_DPC\:mh.h}
{\xe \v mh.h\:VECTOR_DPC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VECTOR_DPC\~ {\b CALC_VECTOR}({\b TPR_DPC})}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b mh.h}.}\par
}
{\xe \v VECTOR_IPI\:mh.h}
{\xe \v mh.h\:VECTOR_IPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VECTOR_IPI\~ {\b CALC_VECTOR}({\b TPR_IPI})}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CPU_ACTION\:mh.h}
{\xe \v mh.h\:CPU_ACTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _CPU_ACTION} {\b CPU_ACTION}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPU_EXCEPTIONS\:mh.h}
{\xe \v mh.h\:CPU_EXCEPTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _CPU_EXCEPTIONS} {\b CPU_EXCEPTIONS}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DEBUG_REGISTERS\:mh.h}
{\xe \v mh.h\:DEBUG_REGISTERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _DEBUG_REGISTERS} {\b DEBUG_REGISTERS}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v DebugCallback\:mh.h}
{\xe \v mh.h\:DebugCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* DebugCallback) (void *)}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b mh.h}.}\par
}
{\xe \v IDT_ENTRY64\:mh.h}
{\xe \v mh.h\:IDT_ENTRY64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IDT_ENTRY_64} {\b IDT_ENTRY64}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v IDT_PTR\:mh.h}
{\xe \v mh.h\:IDT_PTR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IDT_PTR} {\b IDT_PTR}}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v INTERRUPT_LIST\:mh.h}
{\xe \v mh.h\:INTERRUPT_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _INTERRUPT_LIST} {\b INTERRUPT_LIST}}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interrupt Definitions \par
}}
{\xe \v IPI_PARAMS\:mh.h}
{\xe \v mh.h\:IPI_PARAMS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _IPI_PARAMS} {\b IPI_PARAMS}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PAGE_PARAMETERS\:mh.h}
{\xe \v mh.h\:PAGE_PARAMETERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _PAGE_PARAMETERS} {\b PAGE_PARAMETERS}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SMP_BOOTINFO\:mh.h}
{\xe \v mh.h\:SMP_BOOTINFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _SMP_BOOTINFO} {\b SMP_BOOTINFO}}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CPUID_FEAT_ECX_SSE3\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_SSE3}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSE3{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_PCLMUL\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_PCLMUL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_PCLMUL{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_DTES64\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_DTES64}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_DTES64{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_MONITOR\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_MONITOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_MONITOR{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_DS_CPL\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_DS_CPL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_DS_CPL{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_VMX\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_VMX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_VMX{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SMX\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_SMX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SMX{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_EST\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_EST}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_EST{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_TM2\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_TM2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_TM2{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SSSE3\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_SSSE3}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSSE3{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_CID\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_CID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_CID{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SDBG\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_SDBG}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SDBG{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_FMA\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_FMA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_FMA{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_CX16\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_CX16}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_CX16{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_XTPR\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_XTPR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_XTPR{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_PDCM\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_PDCM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_PDCM{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_PCID\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_PCID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_PCID{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_DCA\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_DCA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_DCA{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SSE4_1\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_SSE4_1}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSE4_1{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_SSE4_2\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_SSE4_2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_SSE4_2{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_X2APIC\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_X2APIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_X2APIC{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_MOVBE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_MOVBE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_MOVBE{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_POPCNT\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_POPCNT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_POPCNT{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_TSC\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_TSC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_TSC{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_AES\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_AES}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_AES{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_XSAVE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_XSAVE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_XSAVE{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_OSXSAVE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_OSXSAVE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_OSXSAVE{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_AVX\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_AVX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_AVX{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_F16C\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_F16C}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_F16C{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_RDRAND\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_RDRAND}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_RDRAND{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_ECX_HYPERVISOR\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_ECX_HYPERVISOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_ECX_HYPERVISOR{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_FPU\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_FPU}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_FPU{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_VME\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_VME}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_VME{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_DE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_DE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_DE{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PSE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PSE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PSE{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_TSC\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_TSC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_TSC{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MSR\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_MSR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MSR{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PAE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PAE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PAE{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MCE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_MCE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MCE{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_CX8\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_CX8}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_CX8{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_APIC\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_APIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_APIC{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SEP\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_SEP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SEP{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MTRR\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_MTRR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MTRR{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PGE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PGE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PGE{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MCA\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_MCA}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MCA{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_CMOV\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_CMOV}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_CMOV{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PAT\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PAT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PAT{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PSE36\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PSE36}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PSE36{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PSN\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PSN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PSN{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_CLFLUSH\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_CLFLUSH}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_CLFLUSH{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_DS\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_DS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_DS{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_ACPI\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_ACPI}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_ACPI{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_MMX\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_MMX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_MMX{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_FXSR\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_FXSR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_FXSR{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SSE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_SSE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SSE{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SSE2\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_SSE2}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SSE2{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_SS\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_SS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_SS{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_HTT\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_HTT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_HTT{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_TM\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_TM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_TM{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_IA64\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_IA64}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_IA64{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
\cell }{\cell }{\row }
{\xe \v CPUID_FEAT_EDX_PBE\:mh.h}
{\xe \v mh.h\:CPUID_FEAT_EDX_PBE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPUID_FEAT_EDX_PBE{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 109} of file {\b mh.h}.}\par
}
{\xe \v _CPU_ACTION\:mh.h}
{\xe \v mh.h\:_CPU_ACTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _CPU_ACTION}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CPU_ACTION_STOP\:mh.h}
{\xe \v mh.h\:CPU_ACTION_STOP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_STOP{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
\cell }{\cell }{\row }
{\xe \v CPU_ACTION_PRINT_ID\:mh.h}
{\xe \v mh.h\:CPU_ACTION_PRINT_ID}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_PRINT_ID{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
\cell }{\cell }{\row }
{\xe \v CPU_ACTION_PERFORM_TLB_SHOOTDOWN\:mh.h}
{\xe \v mh.h\:CPU_ACTION_PERFORM_TLB_SHOOTDOWN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_PERFORM_TLB_SHOOTDOWN{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
\cell }{\cell }{\row }
{\xe \v CPU_ACTION_WRITE_DEBUG_REGS\:mh.h}
{\xe \v mh.h\:CPU_ACTION_WRITE_DEBUG_REGS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_WRITE_DEBUG_REGS{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
\cell }{\cell }{\row }
{\xe \v CPU_ACTION_CLEAR_DEBUG_REGS\:mh.h}
{\xe \v mh.h\:CPU_ACTION_CLEAR_DEBUG_REGS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_CLEAR_DEBUG_REGS{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
\cell }{\cell }{\row }
{\xe \v CPU_ACTION_DO_DEFERRED_ROUTINES\:mh.h}
{\xe \v mh.h\:CPU_ACTION_DO_DEFERRED_ROUTINES}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_DO_DEFERRED_ROUTINES{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
\cell }{\cell }{\row }
{\xe \v CPU_ACTION_FLUSH_CR3\:mh.h}
{\xe \v mh.h\:CPU_ACTION_FLUSH_CR3}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid CPU_ACTION_FLUSH_CR3{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 91} of file {\b mh.h}.}\par
}
{\xe \v _CPU_EXCEPTIONS\:mh.h}
{\xe \v mh.h\:_CPU_EXCEPTIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _CPU_EXCEPTIONS}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v EXCEPTION_DIVIDE_BY_ZERO\:mh.h}
{\xe \v mh.h\:EXCEPTION_DIVIDE_BY_ZERO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_DIVIDE_BY_ZERO{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_SINGLE_STEP\:mh.h}
{\xe \v mh.h\:EXCEPTION_SINGLE_STEP}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_SINGLE_STEP{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_NON_MASKABLE_INTERRUPT\:mh.h}
{\xe \v mh.h\:EXCEPTION_NON_MASKABLE_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_NON_MASKABLE_INTERRUPT{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_BREAKPOINT\:mh.h}
{\xe \v mh.h\:EXCEPTION_BREAKPOINT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_BREAKPOINT{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_OVERFLOW\:mh.h}
{\xe \v mh.h\:EXCEPTION_OVERFLOW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_OVERFLOW{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_BOUNDS_CHECK\:mh.h}
{\xe \v mh.h\:EXCEPTION_BOUNDS_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_BOUNDS_CHECK{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_INVALID_OPCODE\:mh.h}
{\xe \v mh.h\:EXCEPTION_INVALID_OPCODE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_INVALID_OPCODE{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_NO_COPROCESSOR\:mh.h}
{\xe \v mh.h\:EXCEPTION_NO_COPROCESSOR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_NO_COPROCESSOR{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_DOUBLE_FAULT\:mh.h}
{\xe \v mh.h\:EXCEPTION_DOUBLE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_DOUBLE_FAULT{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN\:mh.h}
{\xe \v mh.h\:EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_INVALID_TSS\:mh.h}
{\xe \v mh.h\:EXCEPTION_INVALID_TSS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_INVALID_TSS{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT\:mh.h}
{\xe \v mh.h\:EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_STACK_SEGMENT_OVERRUN\:mh.h}
{\xe \v mh.h\:EXCEPTION_STACK_SEGMENT_OVERRUN}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_STACK_SEGMENT_OVERRUN{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_GENERAL_PROTECTION_FAULT\:mh.h}
{\xe \v mh.h\:EXCEPTION_GENERAL_PROTECTION_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_GENERAL_PROTECTION_FAULT{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_PAGE_FAULT\:mh.h}
{\xe \v mh.h\:EXCEPTION_PAGE_FAULT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_PAGE_FAULT{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_RESERVED\:mh.h}
{\xe \v mh.h\:EXCEPTION_RESERVED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_RESERVED{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_FLOATING_POINT_ERROR\:mh.h}
{\xe \v mh.h\:EXCEPTION_FLOATING_POINT_ERROR}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_FLOATING_POINT_ERROR{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_ALIGNMENT_CHECK\:mh.h}
{\xe \v mh.h\:EXCEPTION_ALIGNMENT_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_ALIGNMENT_CHECK{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
\cell }{\cell }{\row }
{\xe \v EXCEPTION_SEVERE_MACHINE_CHECK\:mh.h}
{\xe \v mh.h\:EXCEPTION_SEVERE_MACHINE_CHECK}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid EXCEPTION_SEVERE_MACHINE_CHECK{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 60} of file {\b mh.h}.}\par
}
{\xe \v _INTERRUPT_LIST\:mh.h}
{\xe \v mh.h\:_INTERRUPT_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _INTERRUPT_LIST}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Interrupt Definitions \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v TIMER_INTERRUPT\:mh.h}
{\xe \v mh.h\:TIMER_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid TIMER_INTERRUPT{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
\cell }{\cell }{\row }
{\xe \v KEYBOARD_INTERRUPT\:mh.h}
{\xe \v mh.h\:KEYBOARD_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid KEYBOARD_INTERRUPT{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
\cell }{\cell }{\row }
{\xe \v ATA_INTERRUPT\:mh.h}
{\xe \v mh.h\:ATA_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ATA_INTERRUPT{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
\cell }{\cell }{\row }
{\xe \v LAPIC_INTERRUPT\:mh.h}
{\xe \v mh.h\:LAPIC_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_INTERRUPT{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
\cell }{\cell }{\row }
{\xe \v LAPIC_SIV_INTERRUPT\:mh.h}
{\xe \v mh.h\:LAPIC_SIV_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid LAPIC_SIV_INTERRUPT{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 83} of file {\b mh.h}.}\par
}
{\xe \v MADT_TYPES\:mh.h}
{\xe \v mh.h\:MADT_TYPES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MADT_TYPES}}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MADT_LAPIC\:mh.h}
{\xe \v mh.h\:MADT_LAPIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MADT_LAPIC{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
\cell }{\cell }{\row }
{\xe \v MADT_IOAPIC\:mh.h}
{\xe \v mh.h\:MADT_IOAPIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MADT_IOAPIC{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
\cell }{\cell }{\row }
{\xe \v MADT_INTERUPT_SOURCE_OVERRIDE\:mh.h}
{\xe \v mh.h\:MADT_INTERUPT_SOURCE_OVERRIDE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MADT_INTERUPT_SOURCE_OVERRIDE{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
\cell }{\cell }{\row }
{\xe \v MADT_NON_MASKABLE_INTERRUPT\:mh.h}
{\xe \v mh.h\:MADT_NON_MASKABLE_INTERRUPT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MADT_NON_MASKABLE_INTERRUPT{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
\cell }{\cell }{\row }
{\xe \v MADT_X2APIC\:mh.h}
{\xe \v mh.h\:MADT_X2APIC}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MADT_X2APIC{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 101} of file {\b mh.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:mh.h}
{\xe \v mh.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _RSDP_Descriptor} __attribute__ ((packed) )}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 52} of file {\b mh.h}.}\par
}
{\xe \v APMain\:mh.h}
{\xe \v mh.h\:APMain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void APMain (void )}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
---------------\'97 FUNCTIONS ---------------\'97 }}\par
{
Definition at line {\b 35} of file {\b ap_main.c}.}\par
}
{\xe \v checkApic\:mh.h}
{\xe \v mh.h\:checkApic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool checkApic (void )}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b mh.h}.}\par
}
{\xe \v checkcpuid\:mh.h}
{\xe \v mh.h\:checkcpuid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkcpuid (void ){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getCpuName\:mh.h}
{\xe \v mh.h\:getCpuName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void getCpuName (char * name)}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 495} of file {\b mh.h}.}\par
}
{\xe \v init_interrupts\:mh.h}
{\xe \v mh.h\:init_interrupts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_interrupts (void )}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 168} of file {\b isr.c}.}\par
}
{\xe \v init_lapic_timer\:mh.h}
{\xe \v mh.h\:init_lapic_timer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int init_lapic_timer (uint32_t hz)}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b apic.c}.}\par
}
{\xe \v install_idt\:mh.h}
{\xe \v mh.h\:install_idt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void install_idt (void )}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b idt.c}.}\par
}
{\xe \v lapic_enable\:mh.h}
{\xe \v mh.h\:lapic_enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_enable (void )}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b apic.c}.}\par
}
{\xe \v lapic_eoi\:mh.h}
{\xe \v mh.h\:lapic_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_eoi (void )}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b apic.c}.}\par
}
{\xe \v lapic_init_cpu\:mh.h}
{\xe \v mh.h\:lapic_init_cpu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_init_cpu (void )}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b apic.c}.}\par
}
{\xe \v lapic_init_siv\:mh.h}
{\xe \v mh.h\:lapic_init_siv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_init_siv (void )}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b apic.c}.}\par
}
{\xe \v lapic_mmio_read\:mh.h}
{\xe \v mh.h\:lapic_mmio_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapic_mmio_read (uint32_t off)}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b apic.c}.}\par
}
{\xe \v lapic_mmio_write\:mh.h}
{\xe \v mh.h\:lapic_mmio_write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_mmio_write (uint32_t off, uint32_t val)}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b apic.c}.}\par
}
{\xe \v lapic_send_ipi\:mh.h}
{\xe \v mh.h\:lapic_send_ipi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_send_ipi (uint8_t apic_id, uint8_t vector, uint32_t flags)}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b apic.c}.}\par
}
{\xe \v lapic_timer_calibrate\:mh.h}
{\xe \v mh.h\:lapic_timer_calibrate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lapic_timer_calibrate (void )}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b apic.c}.}\par
}
{\xe \v MhHandleInterrupt\:mh.h}
{\xe \v mh.h\:MhHandleInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhHandleInterrupt ({\b IN} int vec_num, {\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b isr.c}.}\par
}
{\xe \v MhInitializeACPI\:mh.h}
{\xe \v mh.h\:MhInitializeACPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MhInitializeACPI (void )}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b acpi.c}.}\par
}
{\xe \v MhInitializeSMP\:mh.h}
{\xe \v mh.h\:MhInitializeSMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhInitializeSMP (uint8_t * apic_list, uint32_t cpu_count, uint32_t lapicAddress)}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b smp.c}.}\par
}
{\xe \v MhParseLAPICs\:mh.h}
{\xe \v mh.h\:MhParseLAPICs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MhParseLAPICs (uint8_t * buffer, size_t maxCPUs, uint32_t * cpuCount, uint32_t * lapicAddress)}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b acpi.c}.}\par
}
{\xe \v MhRebootComputer\:mh.h}
{\xe \v mh.h\:MhRebootComputer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhRebootComputer (void )}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b acpi.c}.}\par
}
{\xe \v MhRequestSoftwareInterrupt\:mh.h}
{\xe \v mh.h\:MhRequestSoftwareInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhRequestSoftwareInterrupt ({\b IN} {\b IRQL} RequestIrql)}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b apic.c}.}\par
}
{\xe \v MhSendActionToCpusAndWait\:mh.h}
{\xe \v mh.h\:MhSendActionToCpusAndWait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MhSendActionToCpusAndWait ({\b CPU_ACTION} action, {\b IPI_PARAMS} parameter)}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b smp.c}.}\par
}
{\xe \v MiAlignmentCheck\:mh.h}
{\xe \v mh.h\:MiAlignmentCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiAlignmentCheck ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 468} of file {\b handlers.c}.}\par
}
{\xe \v MiBoundsCheck\:mh.h}
{\xe \v mh.h\:MiBoundsCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiBoundsCheck ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 420} of file {\b handlers.c}.}\par
}
{\xe \v MiBreakpoint\:mh.h}
{\xe \v mh.h\:MiBreakpoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiBreakpoint ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 392} of file {\b handlers.c}.}\par
}
{\xe \v MiCoprocessorSegmentOverrun\:mh.h}
{\xe \v mh.h\:MiCoprocessorSegmentOverrun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiCoprocessorSegmentOverrun ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 434} of file {\b handlers.c}.}\par
}
{\xe \v MiDebugTrap\:mh.h}
{\xe \v mh.h\:MiDebugTrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiDebugTrap ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 298} of file {\b handlers.c}.}\par
}
{\xe \v MiDivideByZero\:mh.h}
{\xe \v mh.h\:MiDivideByZero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiDivideByZero ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 258} of file {\b handlers.c}.}\par
}
{\xe \v MiDoubleFault\:mh.h}
{\xe \v mh.h\:MiDoubleFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MiDoubleFault ({\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b handlers.c}.}\par
}
{\xe \v MiFloatingPointError\:mh.h}
{\xe \v mh.h\:MiFloatingPointError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiFloatingPointError ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 462} of file {\b handlers.c}.}\par
}
{\xe \v MiGeneralProtectionFault\:mh.h}
{\xe \v mh.h\:MiGeneralProtectionFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiGeneralProtectionFault ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 457} of file {\b handlers.c}.}\par
}
{\xe \v MiInterprocessorInterrupt\:mh.h}
{\xe \v mh.h\:MiInterprocessorInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInterprocessorInterrupt (void )}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b handlers.c}.}\par
}
{\xe \v MiInvalidOpcode\:mh.h}
{\xe \v mh.h\:MiInvalidOpcode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInvalidOpcode ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 425} of file {\b handlers.c}.}\par
}
{\xe \v MiInvalidTss\:mh.h}
{\xe \v mh.h\:MiInvalidTss}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInvalidTss ({\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 439} of file {\b handlers.c}.}\par
}
{\xe \v MiLapicInterrupt\:mh.h}
{\xe \v mh.h\:MiLapicInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiLapicInterrupt (bool schedulerEnabled, {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b handlers.c}.}\par
}
{\xe \v MiMachineCheck\:mh.h}
{\xe \v mh.h\:MiMachineCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiMachineCheck ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 478} of file {\b handlers.c}.}\par
}
{\xe \v MiNoCoprocessor\:mh.h}
{\xe \v mh.h\:MiNoCoprocessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiNoCoprocessor ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 429} of file {\b handlers.c}.}\par
}
{\xe \v MiNonMaskableInterrupt\:mh.h}
{\xe \v mh.h\:MiNonMaskableInterrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NORETURN} void MiNonMaskableInterrupt ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 362} of file {\b handlers.c}.}\par
}
{\xe \v MiOverflow\:mh.h}
{\xe \v mh.h\:MiOverflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiOverflow ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 416} of file {\b handlers.c}.}\par
}
{\xe \v MiPageFault\:mh.h}
{\xe \v mh.h\:MiPageFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiPageFault ({\b IN} {\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b handlers.c}.}\par
}
{\xe \v MiSegmentSelectorNotPresent\:mh.h}
{\xe \v mh.h\:MiSegmentSelectorNotPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiSegmentSelectorNotPresent ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 445} of file {\b handlers.c}.}\par
}
{\xe \v MiStackSegmentOverrun\:mh.h}
{\xe \v mh.h\:MiStackSegmentOverrun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiStackSegmentOverrun ({\b PTRAP_FRAME} trap)}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 451} of file {\b handlers.c}.}\par
}
{\xe \v pit_sleep_ms\:mh.h}
{\xe \v mh.h\:pit_sleep_ms}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void pit_sleep_ms (uint32_t ms)}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b pit.c}.}\par
}
{\xe \v set_idt_gate\:mh.h}
{\xe \v mh.h\:set_idt_gate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void set_idt_gate (int n, unsigned long int handler)}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b idt.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v __attribute__\:mh.h}
{\xe \v mh.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct __attribute__}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b fat32.h}.}\par
}
{\xe \v AccessSize\:mh.h}
{\xe \v mh.h\:AccessSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AccessSize}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b mh.h}.}\par
}
{\xe \v AcpiDisable\:mh.h}
{\xe \v mh.h\:AcpiDisable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AcpiDisable}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b mh.h}.}\par
}
{\xe \v AcpiEnable\:mh.h}
{\xe \v mh.h\:AcpiEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AcpiEnable}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b mh.h}.}\par
}
{\xe \v Address\:mh.h}
{\xe \v mh.h\:Address}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Address}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b mh.h}.}\par
}
{\xe \v AddressSpace\:mh.h}
{\xe \v mh.h\:AddressSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t AddressSpace}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 0} of file {\b mh.h}.}\par
}
{\xe \v allApsInitialized\:mh.h}
{\xe \v mh.h\:allApsInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool allApsInitialized{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b kernel.c}.}\par
}
{\xe \v BitOffset\:mh.h}
{\xe \v mh.h\:BitOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BitOffset}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b mh.h}.}\par
}
{\xe \v BitWidth\:mh.h}
{\xe \v mh.h\:BitWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t BitWidth}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b mh.h}.}\par
}
{\xe \v BootArchitectureFlags\:mh.h}
{\xe \v mh.h\:BootArchitectureFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t BootArchitectureFlags}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b mh.h}.}\par
}
{\xe \v Century\:mh.h}
{\xe \v mh.h\:Century}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Century}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b mh.h}.}\par
}
{\xe \v Checksum\:mh.h}
{\xe \v mh.h\:Checksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Checksum}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b mh.h}.}\par
}
{\xe \v CreatorId\:mh.h}
{\xe \v mh.h\:CreatorId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t CreatorId}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b mh.h}.}\par
}
{\xe \v CreatorRevision\:mh.h}
{\xe \v mh.h\:CreatorRevision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t CreatorRevision}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b mh.h}.}\par
}
{\xe \v CStateControl\:mh.h}
{\xe \v mh.h\:CStateControl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t CStateControl}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b mh.h}.}\par
}
{\xe \v DayAlarm\:mh.h}
{\xe \v mh.h\:DayAlarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t DayAlarm}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b mh.h}.}\par
}
{\xe \v Dsdt\:mh.h}
{\xe \v mh.h\:Dsdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Dsdt}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b mh.h}.}\par
}
{\xe \v DutyOffset\:mh.h}
{\xe \v mh.h\:DutyOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t DutyOffset}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b mh.h}.}\par
}
{\xe \v DutyWidth\:mh.h}
{\xe \v mh.h\:DutyWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t DutyWidth}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b mh.h}.}\par
}
{\xe \v Entries\:mh.h}
{\xe \v mh.h\:Entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t Entries[]}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b mh.h}.}\par
}
{\xe \v ExtendedChecksum\:mh.h}
{\xe \v mh.h\:ExtendedChecksum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ExtendedChecksum}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b mh.h}.}\par
}
{\xe \v FirmwareCtrl\:mh.h}
{\xe \v mh.h\:FirmwareCtrl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t FirmwareCtrl}}
\par
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b mh.h}.}\par
}
{\xe \v Flags\:mh.h}
{\xe \v mh.h\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Flags}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b mh.h}.}\par
}
{\xe \v flags\:mh.h}
{\xe \v mh.h\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t flags}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b mh.h}.}\par
}
{\xe \v FlushSize\:mh.h}
{\xe \v mh.h\:FlushSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t FlushSize}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b mh.h}.}\par
}
{\xe \v FlushStride\:mh.h}
{\xe \v mh.h\:FlushStride}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t FlushStride}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b mh.h}.}\par
}
{\xe \v GDTEntry64\:mh.h}
{\xe \v mh.h\:GDTEntry64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GDTEntry64}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 366} of file {\b mh.h}.}\par
}
{\xe \v GDTPtr\:mh.h}
{\xe \v mh.h\:GDTPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GDTPtr}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 371} of file {\b mh.h}.}\par
}
{\xe \v GPE0Block\:mh.h}
{\xe \v mh.h\:GPE0Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GPE0Block}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b mh.h}.}\par
}
{\xe \v GPE0Length\:mh.h}
{\xe \v mh.h\:GPE0Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t GPE0Length}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b mh.h}.}\par
}
{\xe \v GPE1Base\:mh.h}
{\xe \v mh.h\:GPE1Base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t GPE1Base}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b mh.h}.}\par
}
{\xe \v GPE1Block\:mh.h}
{\xe \v mh.h\:GPE1Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t GPE1Block}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b mh.h}.}\par
}
{\xe \v GPE1Length\:mh.h}
{\xe \v mh.h\:GPE1Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t GPE1Length}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b mh.h}.}\par
}
{\xe \v h\:mh.h}
{\xe \v mh.h\:h}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _ACPI_SDT_HEADER} h}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 0} of file {\b mh.h}.}\par
}
{\xe \v lapicAddress\:mh.h}
{\xe \v mh.h\:lapicAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapicAddress}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b mh.h}.}\par
}
{\xe \v Length\:mh.h}
{\xe \v mh.h\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Length}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b mh.h}.}\par
}
{\xe \v MonthAlarm\:mh.h}
{\xe \v mh.h\:MonthAlarm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t MonthAlarm}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b mh.h}.}\par
}
{\xe \v OemId\:mh.h}
{\xe \v mh.h\:OemId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OemId}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b mh.h}.}\par
}
{\xe \v OemRevision\:mh.h}
{\xe \v mh.h\:OemRevision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t OemRevision}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b mh.h}.}\par
}
{\xe \v OemTableId\:mh.h}
{\xe \v mh.h\:OemTableId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char OemTableId[8]}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b mh.h}.}\par
}
{\xe \v PM1aControlBlock\:mh.h}
{\xe \v mh.h\:PM1aControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1aControlBlock}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b mh.h}.}\par
}
{\xe \v PM1aEventBlock\:mh.h}
{\xe \v mh.h\:PM1aEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1aEventBlock}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b mh.h}.}\par
}
{\xe \v PM1bControlBlock\:mh.h}
{\xe \v mh.h\:PM1bControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1bControlBlock}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b mh.h}.}\par
}
{\xe \v PM1bEventBlock\:mh.h}
{\xe \v mh.h\:PM1bEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM1bEventBlock}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b mh.h}.}\par
}
{\xe \v PM1ControlLength\:mh.h}
{\xe \v mh.h\:PM1ControlLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PM1ControlLength}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b mh.h}.}\par
}
{\xe \v PM1EventLength\:mh.h}
{\xe \v mh.h\:PM1EventLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PM1EventLength}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b mh.h}.}\par
}
{\xe \v PM2ControlBlock\:mh.h}
{\xe \v mh.h\:PM2ControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PM2ControlBlock}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b mh.h}.}\par
}
{\xe \v PM2ControlLength\:mh.h}
{\xe \v mh.h\:PM2ControlLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PM2ControlLength}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b mh.h}.}\par
}
{\xe \v PMTimerBlock\:mh.h}
{\xe \v mh.h\:PMTimerBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t PMTimerBlock}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b mh.h}.}\par
}
{\xe \v PMTimerLength\:mh.h}
{\xe \v mh.h\:PMTimerLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PMTimerLength}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mh.h}.}\par
}
{\xe \v PreferredPowerManagementProfile\:mh.h}
{\xe \v mh.h\:PreferredPowerManagementProfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PreferredPowerManagementProfile}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b mh.h}.}\par
}
{\xe \v PSTATE_Control\:mh.h}
{\xe \v mh.h\:PSTATE_Control}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t PSTATE_Control}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b mh.h}.}\par
}
{\xe \v Reserved\:mh.h}
{\xe \v mh.h\:Reserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b mh.h}.}\par
}
{\xe \v Reserved2\:mh.h}
{\xe \v mh.h\:Reserved2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved2}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b mh.h}.}\par
}
{\xe \v Reserved3\:mh.h}
{\xe \v mh.h\:Reserved3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Reserved3[3]}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b mh.h}.}\par
}
{\xe \v ResetReg\:mh.h}
{\xe \v mh.h\:ResetReg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure ResetReg}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b mh.h}.}\par
}
{\xe \v ResetValue\:mh.h}
{\xe \v mh.h\:ResetValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t ResetValue}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 49} of file {\b mh.h}.}\par
}
{\xe \v Revision\:mh.h}
{\xe \v mh.h\:Revision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t Revision}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b mh.h}.}\par
}
{\xe \v RsdtAddress\:mh.h}
{\xe \v mh.h\:RsdtAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t RsdtAddress}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b mh.h}.}\par
}
{\xe \v S4BIOS_REQ\:mh.h}
{\xe \v mh.h\:S4BIOS_REQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t S4BIOS_REQ}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b mh.h}.}\par
}
{\xe \v SCI_Interrupt\:mh.h}
{\xe \v mh.h\:SCI_Interrupt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t SCI_Interrupt}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b mh.h}.}\par
}
{\xe \v Signature\:mh.h}
{\xe \v mh.h\:Signature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char Signature}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 0} of file {\b mh.h}.}\par
}
{\xe \v SMI_CommandPort\:mh.h}
{\xe \v mh.h\:SMI_CommandPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t SMI_CommandPort}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b mh.h}.}\par
}
{\xe \v smp_cpu_count\:mh.h}
{\xe \v mh.h\:smp_cpu_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int smp_cpu_count{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b smp.c}.}\par
}
{\xe \v smpInitialized\:mh.h}
{\xe \v mh.h\:smpInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool smpInitialized{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b kernel.c}.}\par
}
{\xe \v TSS\:mh.h}
{\xe \v mh.h\:TSS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TSS}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 383} of file {\b mh.h}.}\par
}
{\xe \v WorstC2Latency\:mh.h}
{\xe \v mh.h\:WorstC2Latency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t WorstC2Latency}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b mh.h}.}\par
}
{\xe \v WorstC3Latency\:mh.h}
{\xe \v mh.h\:WorstC3Latency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t WorstC3Latency}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b mh.h}.}\par
}
{\xe \v X_Dsdt\:mh.h}
{\xe \v mh.h\:X_Dsdt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t X_Dsdt}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b mh.h}.}\par
}
{\xe \v X_FirmwareControl\:mh.h}
{\xe \v mh.h\:X_FirmwareControl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t X_FirmwareControl}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b mh.h}.}\par
}
{\xe \v X_GPE0Block\:mh.h}
{\xe \v mh.h\:X_GPE0Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_GPE0Block}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b mh.h}.}\par
}
{\xe \v X_GPE1Block\:mh.h}
{\xe \v mh.h\:X_GPE1Block}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_GPE1Block}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b mh.h}.}\par
}
{\xe \v X_PM1aControlBlock\:mh.h}
{\xe \v mh.h\:X_PM1aControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1aControlBlock}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b mh.h}.}\par
}
{\xe \v X_PM1aEventBlock\:mh.h}
{\xe \v mh.h\:X_PM1aEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1aEventBlock}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b mh.h}.}\par
}
{\xe \v X_PM1bControlBlock\:mh.h}
{\xe \v mh.h\:X_PM1bControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1bControlBlock}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b mh.h}.}\par
}
{\xe \v X_PM1bEventBlock\:mh.h}
{\xe \v mh.h\:X_PM1bEventBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM1bEventBlock}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b mh.h}.}\par
}
{\xe \v X_PM2ControlBlock\:mh.h}
{\xe \v mh.h\:X_PM2ControlBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PM2ControlBlock}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b mh.h}.}\par
}
{\xe \v X_PMTimerBlock\:mh.h}
{\xe \v mh.h\:X_PMTimerBlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericAddressStructure X_PMTimerBlock}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b mh.h}.}\par
}
{\xe \v XsdtAddress\:mh.h}
{\xe \v mh.h\:XsdtAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t XsdtAddress}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b mh.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mh.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mh.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mh.h}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_HAL_H}\par
00002 {\cf21 #define X86_MATANEL_HAL_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     mh.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for the hardware abstraction layer of MatanelOS.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf21 #include "core.h"}\par
00023 {\cf21 #include "annotations.h"}\par
00024 {\cf21 #include "macros.h"}\par
00025 {\cf21 #include <cpuid.h>}\par
00026 {\cf21 #define IDT_ENTRIES        256}\par
00027 \par
00028 {\cf21 #include "mm.h"}\par
00029 \par
00030 {\cf21 #define IRQL_VECTOR_BASE    0x40}\par
00031 \par
00032 {\cf20 // Priority Levels (0-15)}\par
00033 {\cf20 // With Base 0x40, the Max Priority allowed is 11 (0x40 + 11<<4 = 240).}\par
00034 {\cf20 // If we need 12, we must lower IRQL_VECTOR_BASE to 0x20.}\par
00035 {\cf20 // But we are good with 11 from now.}\par
00036 \par
00037 {\cf21 #define TPR_PASSIVE         0}\par
00038 {\cf21 #define TPR_APC             3}\par
00039 {\cf21 #define TPR_DPC             8   }{\cf20 // Vector: 0x40 + 0x80 = 0xC0 (192)}\par
00040 {\cf21 #define TPR_PROFILE         10}\par
00041 {\cf21 #define TPR_IPI             11 }\par
00042 \par
00043 {\cf20 // The Math Macros}\par
00044 {\cf21 #define CALC_VECTOR(pri)    (IRQL_VECTOR_BASE + (pri << 4))}\par
00045 \par
00046 {\cf20 // Calculated Vectors}\par
00047 {\cf21 #define VECTOR_DPC          CALC_VECTOR(TPR_DPC)}\par
00048 {\cf21 #define VECTOR_APC          CALC_VECTOR(TPR_APC)}\par
00049 {\cf21 #define VECTOR_IPI          CALC_VECTOR(TPR_IPI)}\par
00050 {\cf21 #define LAPIC_TIMER_VECTOR 0xEF}\par
00051 \par
00052 {\cf17 static} {\cf17 inline} {\cf18 unsigned} {\cf18 int} priority_to_vector(uint8_t pri) \{\par
00053     {\cf19 if} (pri > 15) pri = 15;\par
00054     {\cf19 return} CALC_VECTOR(pri);\par
00055 \}\par
00056 \par
00057 {\cf20 // ------------------ ENUMERATORS ------------------}\par
00058 \par
00059 {\cf20 //** Exception Definitions **/}\par
00060 {\cf17 typedef} {\cf17 enum} _CPU_EXCEPTIONS \{\par
00061     EXCEPTION_DIVIDE_BY_ZERO,\par
00062     EXCEPTION_SINGLE_STEP,\par
00063     EXCEPTION_NON_MASKABLE_INTERRUPT,\par
00064     EXCEPTION_BREAKPOINT,\par
00065     EXCEPTION_OVERFLOW,\par
00066     EXCEPTION_BOUNDS_CHECK,\par
00067     EXCEPTION_INVALID_OPCODE,\par
00068     EXCEPTION_NO_COPROCESSOR,\par
00069     EXCEPTION_DOUBLE_FAULT,\par
00070     EXCEPTION_COPROCESSOR_SEGMENT_OVERRUN,\par
00071     EXCEPTION_INVALID_TSS,\par
00072     EXCEPTION_SEGMENT_SELECTOR_NOTPRESENT,\par
00073     EXCEPTION_STACK_SEGMENT_OVERRUN,\par
00074     EXCEPTION_GENERAL_PROTECTION_FAULT,\par
00075     EXCEPTION_PAGE_FAULT,\par
00076     EXCEPTION_RESERVED,\par
00077     EXCEPTION_FLOATING_POINT_ERROR,\par
00078     EXCEPTION_ALIGNMENT_CHECK,\par
00079     EXCEPTION_SEVERE_MACHINE_CHECK,\par
00080 \} CPU_EXCEPTIONS;\par
00081 \par
00083 {\cf17 typedef} {\cf17 enum} _INTERRUPT_LIST \{\par
00084     TIMER_INTERRUPT = 32, {\cf20 // Unused, PIC.}\par
00085     KEYBOARD_INTERRUPT = 33, {\cf20 // Unused, PS/2 Keyboard}\par
00086     ATA_INTERRUPT = 46, {\cf20 // Might be used for driver, ATA.}\par
00087     LAPIC_INTERRUPT = 0xEF, {\cf20 // LAPIC Timer.}\par
00088     LAPIC_SIV_INTERRUPT = 0xFF, {\cf20 // LAPIC Spurious interrupt vector.}\par
00089 \} INTERRUPT_LIST;\par
00090 \par
00091 {\cf17 typedef} {\cf17 enum} _CPU_ACTION \{\par
00092     CPU_ACTION_STOP = 0,\par
00093     CPU_ACTION_PRINT_ID = 1,\par
00094     CPU_ACTION_PERFORM_TLB_SHOOTDOWN = 2,\par
00095     CPU_ACTION_WRITE_DEBUG_REGS = 3,\par
00096     CPU_ACTION_CLEAR_DEBUG_REGS = 4,\par
00097     CPU_ACTION_DO_DEFERRED_ROUTINES = 5,\par
00098     CPU_ACTION_FLUSH_CR3 = 6,\par
00099 \} CPU_ACTION;\par
00100 \par
00101 {\cf17 enum} MADT_TYPES \{\par
00102     MADT_LAPIC = 0,\par
00103     MADT_IOAPIC = 1,\par
00104     MADT_INTERUPT_SOURCE_OVERRIDE = 2,\par
00105     MADT_NON_MASKABLE_INTERRUPT = 4,\par
00106     MADT_X2APIC = 9\par
00107 \};\par
00108 \par
00109 {\cf17 enum} \{\par
00110     CPUID_FEAT_ECX_SSE3 = 1 << 0,\par
00111     CPUID_FEAT_ECX_PCLMUL = 1 << 1,\par
00112     CPUID_FEAT_ECX_DTES64 = 1 << 2,\par
00113     CPUID_FEAT_ECX_MONITOR = 1 << 3,\par
00114     CPUID_FEAT_ECX_DS_CPL = 1 << 4,\par
00115     CPUID_FEAT_ECX_VMX = 1 << 5,\par
00116     CPUID_FEAT_ECX_SMX = 1 << 6,\par
00117     CPUID_FEAT_ECX_EST = 1 << 7,\par
00118     CPUID_FEAT_ECX_TM2 = 1 << 8,\par
00119     CPUID_FEAT_ECX_SSSE3 = 1 << 9,\par
00120     CPUID_FEAT_ECX_CID = 1 << 10,\par
00121     CPUID_FEAT_ECX_SDBG = 1 << 11,\par
00122     CPUID_FEAT_ECX_FMA = 1 << 12,\par
00123     CPUID_FEAT_ECX_CX16 = 1 << 13,\par
00124     CPUID_FEAT_ECX_XTPR = 1 << 14,\par
00125     CPUID_FEAT_ECX_PDCM = 1 << 15,\par
00126     CPUID_FEAT_ECX_PCID = 1 << 17,\par
00127     CPUID_FEAT_ECX_DCA = 1 << 18,\par
00128     CPUID_FEAT_ECX_SSE4_1 = 1 << 19,\par
00129     CPUID_FEAT_ECX_SSE4_2 = 1 << 20,\par
00130     CPUID_FEAT_ECX_X2APIC = 1 << 21,\par
00131     CPUID_FEAT_ECX_MOVBE = 1 << 22,\par
00132     CPUID_FEAT_ECX_POPCNT = 1 << 23,\par
00133     CPUID_FEAT_ECX_TSC = 1 << 24,\par
00134     CPUID_FEAT_ECX_AES = 1 << 25,\par
00135     CPUID_FEAT_ECX_XSAVE = 1 << 26,\par
00136     CPUID_FEAT_ECX_OSXSAVE = 1 << 27,\par
00137     CPUID_FEAT_ECX_AVX = 1 << 28,\par
00138     CPUID_FEAT_ECX_F16C = 1 << 29,\par
00139     CPUID_FEAT_ECX_RDRAND = 1 << 30,\par
00140     CPUID_FEAT_ECX_HYPERVISOR = 1 << 31,\par
00141 \par
00142     CPUID_FEAT_EDX_FPU = 1 << 0,\par
00143     CPUID_FEAT_EDX_VME = 1 << 1,\par
00144     CPUID_FEAT_EDX_DE = 1 << 2,\par
00145     CPUID_FEAT_EDX_PSE = 1 << 3,\par
00146     CPUID_FEAT_EDX_TSC = 1 << 4,\par
00147     CPUID_FEAT_EDX_MSR = 1 << 5,\par
00148     CPUID_FEAT_EDX_PAE = 1 << 6,\par
00149     CPUID_FEAT_EDX_MCE = 1 << 7,\par
00150     CPUID_FEAT_EDX_CX8 = 1 << 8,\par
00151     CPUID_FEAT_EDX_APIC = 1 << 9,\par
00152     CPUID_FEAT_EDX_SEP = 1 << 11,\par
00153     CPUID_FEAT_EDX_MTRR = 1 << 12,\par
00154     CPUID_FEAT_EDX_PGE = 1 << 13,\par
00155     CPUID_FEAT_EDX_MCA = 1 << 14,\par
00156     CPUID_FEAT_EDX_CMOV = 1 << 15,\par
00157     CPUID_FEAT_EDX_PAT = 1 << 16,\par
00158     CPUID_FEAT_EDX_PSE36 = 1 << 17,\par
00159     CPUID_FEAT_EDX_PSN = 1 << 18,\par
00160     CPUID_FEAT_EDX_CLFLUSH = 1 << 19,\par
00161     CPUID_FEAT_EDX_DS = 1 << 21,\par
00162     CPUID_FEAT_EDX_ACPI = 1 << 22,\par
00163     CPUID_FEAT_EDX_MMX = 1 << 23,\par
00164     CPUID_FEAT_EDX_FXSR = 1 << 24,\par
00165     CPUID_FEAT_EDX_SSE = 1 << 25,\par
00166     CPUID_FEAT_EDX_SSE2 = 1 << 26,\par
00167     CPUID_FEAT_EDX_SS = 1 << 27,\par
00168     CPUID_FEAT_EDX_HTT = 1 << 28,\par
00169     CPUID_FEAT_EDX_TM = 1 << 29,\par
00170     CPUID_FEAT_EDX_IA64 = 1 << 30,\par
00171     CPUID_FEAT_EDX_PBE = 1 << 31\par
00172 \};\par
00173 \par
00174 {\cf20 // ------------------ STRUCTURES ------------------}\par
00175 \par
00176 {\cf21 #pragma pack(push, 1)}\par
00177 {\cf17 typedef} {\cf17 struct }_IDT_PTR \{\par
00178     uint16_t limit;\par
00179     uint64_t base;\par
00180 \} IDT_PTR;\par
00181 \par
00182 {\cf17 typedef} {\cf17 struct }_IDT_ENTRY_64 \{\par
00183     uint16_t offset_low;\par
00184     uint16_t selector;\par
00185     uint8_t  ist;\par
00186     uint8_t  type_attr;\par
00187     uint16_t offset_mid;\par
00188     uint32_t offset_high;\par
00189     uint32_t zero;\par
00190 \} IDT_ENTRY64;\par
00191 {\cf21 #pragma pack(pop)}\par
00192 \par
00193 {\cf17 typedef} {\cf17 struct }_RSDP_Descriptor \{\par
00194     {\cf18 char}     Signature[8];\par
00195     uint8_t  Checksum;\par
00196     {\cf18 char}     OemId[6];\par
00197     uint8_t  Revision;\par
00198     uint32_t RsdtAddress; {\cf20 // legacy 32bit.}\par
00199     {\cf20 // acpi 2.0 fields}\par
00200     uint32_t Length;\par
00201     uint64_t XsdtAddress; {\cf20 // The one we use.}\par
00202     uint8_t  ExtendedChecksum;\par
00203     uint8_t  Reserved[3];\par
00204 \} __attribute__((packed)) RSDP_Descriptor;\par
00205 \par
00206 {\cf17 typedef} {\cf17 struct }_ACPI_SDT_HEADER \{\par
00207     {\cf18 char}     Signature[4];\par
00208     uint32_t Length;\par
00209     uint8_t  Revision;\par
00210     uint8_t  Checksum;\par
00211     {\cf18 char}     OemId[6];\par
00212     {\cf18 char}     OemTableId[8];\par
00213     uint32_t OemRevision;\par
00214     uint32_t CreatorId;\par
00215     uint32_t CreatorRevision;\par
00216 \} __attribute__((packed)) ACPI_SDT_HEADER;\par
00217 \par
00218 {\cf17 typedef} {\cf17 struct }_XSDT \{\par
00219     {\cf17 struct }_ACPI_SDT_HEADER h;\par
00220     uint64_t Entries[]; {\cf20 // Array of 64-bit physical addresses to other tables}\par
00221 \} __attribute__((packed)) XSDT;\par
00222 \par
00223 {\cf17 typedef} {\cf17 struct }_GenericAddressStructure\par
00224 \{\par
00225     uint8_t AddressSpace;\par
00226     uint8_t BitWidth;\par
00227     uint8_t BitOffset;\par
00228     uint8_t AccessSize;\par
00229     uint64_t Address;\par
00230 \} __attribute__((packed)) GenericAddressStructure;\par
00231 \par
00232 {\cf17 typedef} {\cf17 struct }_FADT\par
00233 \{\par
00234     {\cf17 struct   }_ACPI_SDT_HEADER h;\par
00235     uint32_t FirmwareCtrl;\par
00236     uint32_t Dsdt;\par
00237 \par
00238     {\cf20 // field used in ACPI 1.0; no longer in use, for compatibility only}\par
00239     uint8_t  Reserved;\par
00240 \par
00241     uint8_t  PreferredPowerManagementProfile;\par
00242     uint16_t SCI_Interrupt;\par
00243     uint32_t SMI_CommandPort;\par
00244     uint8_t  AcpiEnable;\par
00245     uint8_t  AcpiDisable;\par
00246     uint8_t  S4BIOS_REQ;\par
00247     uint8_t  PSTATE_Control;\par
00248     uint32_t PM1aEventBlock;\par
00249     uint32_t PM1bEventBlock;\par
00250     uint32_t PM1aControlBlock;\par
00251     uint32_t PM1bControlBlock;\par
00252     uint32_t PM2ControlBlock;\par
00253     uint32_t PMTimerBlock;\par
00254     uint32_t GPE0Block;\par
00255     uint32_t GPE1Block;\par
00256     uint8_t  PM1EventLength;\par
00257     uint8_t  PM1ControlLength;\par
00258     uint8_t  PM2ControlLength;\par
00259     uint8_t  PMTimerLength;\par
00260     uint8_t  GPE0Length;\par
00261     uint8_t  GPE1Length;\par
00262     uint8_t  GPE1Base;\par
00263     uint8_t  CStateControl;\par
00264     uint16_t WorstC2Latency;\par
00265     uint16_t WorstC3Latency;\par
00266     uint16_t FlushSize;\par
00267     uint16_t FlushStride;\par
00268     uint8_t  DutyOffset;\par
00269     uint8_t  DutyWidth;\par
00270     uint8_t  DayAlarm;\par
00271     uint8_t  MonthAlarm;\par
00272     uint8_t  Century;\par
00273 \par
00274     {\cf20 // reserved in ACPI 1.0; used since ACPI 2.0+}\par
00275     uint16_t BootArchitectureFlags;\par
00276 \par
00277     uint8_t  Reserved2;\par
00278     uint32_t Flags;\par
00279 \par
00280     {\cf20 // 12 byte structure; see below for details}\par
00281     GenericAddressStructure ResetReg;\par
00282 \par
00283     uint8_t  ResetValue;\par
00284     uint8_t  Reserved3[3];\par
00285 \par
00286     {\cf20 // 64bit pointers - Available on ACPI 2.0+}\par
00287     uint64_t                X_FirmwareControl;\par
00288     uint64_t                X_Dsdt;\par
00289 \par
00290     GenericAddressStructure X_PM1aEventBlock;\par
00291     GenericAddressStructure X_PM1bEventBlock;\par
00292     GenericAddressStructure X_PM1aControlBlock;\par
00293     GenericAddressStructure X_PM1bControlBlock;\par
00294     GenericAddressStructure X_PM2ControlBlock;\par
00295     GenericAddressStructure X_PMTimerBlock;\par
00296     GenericAddressStructure X_GPE0Block;\par
00297     GenericAddressStructure X_GPE1Block;\par
00298 \} __attribute__((packed)) FADT;\par
00299 \par
00300 {\cf17 typedef} {\cf17 struct }_MADT \{\par
00301     {\cf17 struct }_ACPI_SDT_HEADER h;\par
00302     uint32_t lapicAddress;\par
00303     uint32_t flags;\par
00304 \} __attribute__((packed)) MADT;\par
00305 \par
00306 {\cf17 typedef} {\cf17 struct }\{\par
00307     uint8_t Type;          {\cf20 // 0}\par
00308     uint8_t Length;        {\cf20 // 8}\par
00309     uint8_t AcpiProcessorId;\par
00310     uint8_t ApicId;\par
00311     uint32_t Flags;        {\cf20 // Bit 0 = enabled, Bit 1 = online-capable}\par
00312 \} __attribute__((packed)) MADT_LOCAL_APIC;\par
00313 \par
00314 {\cf17 typedef} {\cf17 struct }\{\par
00315     uint8_t Type;           {\cf20 // 1}\par
00316     uint8_t Length;         {\cf20 // 12}\par
00317     uint8_t IoApicId;\par
00318     uint8_t Reserved;       {\cf20 // must be 0}\par
00319     uint32_t IoApicAddress; {\cf20 // physical address}\par
00320     uint32_t GlobalSystemInterruptBase;\par
00321 \} __attribute__((packed)) MADT_IO_APIC;\par
00322 \par
00323 {\cf17 typedef} {\cf17 struct }\{\par
00324     uint8_t Type;            {\cf20 // 2}\par
00325     uint8_t Length;          {\cf20 // 10}\par
00326     uint8_t Bus;             {\cf20 // 0 = ISA}\par
00327     uint8_t Source;          {\cf20 // IRQ source}\par
00328     uint32_t GlobalSystemInterrupt;\par
00329     uint16_t Flags;\par
00330 \} __attribute__((packed)) MADT_INTERRUPT_OVERRIDE;\par
00331 \par
00332 {\cf17 typedef} {\cf17 struct }\{\par
00333     uint8_t Type;     {\cf20 // 4}\par
00334     uint8_t Length;   {\cf20 // 6}\par
00335     uint8_t AcpiProcessorId; {\cf20 // 0xFF = all processors}\par
00336     uint16_t Flags;\par
00337     uint8_t Lint;     {\cf20 // LINTn pin (0 or 1)}\par
00338 \} __attribute__((packed)) MADT_NMI;\par
00339 \par
00340 {\cf17 typedef} {\cf17 struct }\{\par
00341     uint8_t Type;         {\cf20 // 9}\par
00342     uint8_t Length;       {\cf20 // 16}\par
00343     uint16_t Reserved;\par
00344     uint32_t X2ApicId;\par
00345     uint32_t Flags;       {\cf20 // same as local APIC flags}\par
00346     uint32_t AcpiProcessorUid;\par
00347 \} __attribute__((packed)) MADT_LOCAL_X2APIC;\par
00348 \par
00349 {\cf17 typedef} {\cf17 struct }_SMP_BOOTINFO \{\par
00350     uint64_t magic;\par
00351     uint64_t kernel_pml4_phys;  {\cf20 // from boot_info_local.Pml4Phys}\par
00352     uint64_t ap_entry_virt;     {\cf20 // kernel virtual address of ap_main()}\par
00353     uint32_t cpu_count;\par
00354     uint32_t lapic_base;\par
00355 \} SMP_BOOTINFO;\par
00356 \par
00357 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _GDTEntry64 \{\par
00358     uint16_t limit_low;\par
00359     uint16_t base_low;\par
00360     uint8_t  base_middle;\par
00361     uint8_t  access;\par
00362     uint8_t  granularity;\par
00363     uint8_t  base_high;\par
00364     uint32_t base_upper;\par
00365     uint32_t reserved;\par
00366 \} GDTEntry64;\par
00367 \par
00368 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _GDTPtr \{\par
00369     uint16_t limit;\par
00370     uint64_t base;\par
00371 \} GDTPtr;\par
00372 \par
00373 {\cf17 typedef} {\cf17 struct }__attribute__((packed)) _TSS \{\par
00374     uint32_t reserved0;\par
00375     uint64_t rsp0;\par
00376     uint64_t rsp1;\par
00377     uint64_t rsp2;\par
00378     uint64_t reserved1;\par
00379     uint64_t ist[7]; {\cf20 // This is the Interrupt Stack Table}\par
00380     uint32_t reserved2;\par
00381     uint16_t reserved3;\par
00382     uint16_t io_map_base;\par
00383 \} TSS;\par
00384 \par
00385 {\cf17 typedef} void (*DebugCallback)({\cf18 void}*);\par
00386 \par
00387 {\cf17 typedef} {\cf17 struct }_DEBUG_REGISTERS \{\par
00388     uint64_t dr7;\par
00389     uint64_t address;\par
00390     DebugCallback callback;\par
00391 \} DEBUG_REGISTERS;\par
00392 \par
00393 {\cf17 typedef} {\cf17 struct }_PAGE_PARAMETERS \{\par
00394     uint64_t addressToInvalidate;\par
00395 \} PAGE_PARAMETERS;\par
00396 \par
00397 {\cf17 typedef} {\cf17 struct }_IPI_PARAMS \{\par
00398     {\cf17 struct }_DEBUG_REGISTERS debugRegs;\par
00399     {\cf17 struct }_PAGE_PARAMETERS pageParams;\par
00400 \} IPI_PARAMS;\par
00401 \par
00402 {\cf20 // ------------------ MACROS ------------------}\par
00403 {\cf21 #define AP_TRAMP_PHYS 0x7000ULL}\par
00404 {\cf21 #define AP_TRAMP_SIZE 0x1000UL   }{\cf20 // single page}\par
00405 {\cf21 #define AP_TRAMP_APMAIN_OFFSET 0x1000ULL}\par
00406 {\cf21 #define AP_TRAMP_PML4_OFFSET 0x2000ULL}\par
00407 {\cf21 #define AP_TRAMP_CPUS_OFFSET 0x2500ULL}\par
00408 {\cf21 #define MAX_CPUS 32}\par
00409 {\cf21 #define LAPIC_ID 0x020}\par
00410 {\cf21 #define SMP_MAGIC 0x4D4154414E454C00 }{\cf20 // MATANEL\\0}\par
00411 {\cf21 #define IST_SIZE (16*1024) }{\cf20 // 16 KiB}\par
00412 {\cf21 #define IST_ALIGNMENT 16}\par
00413 {\cf20 // Vendor strings from CPUs.}\par
00414 {\cf21 #define CPUID_VENDOR_AMD           "AuthenticAMD"}\par
00415 {\cf21 #define CPUID_VENDOR_AMD_OLD       "AMDisbetter!" }{\cf20 // Early engineering samples of AMD K5 processor}\par
00416 {\cf21 #define CPUID_VENDOR_INTEL         "GenuineIntel"}\par
00417 {\cf21 #define CPUID_VENDOR_VIA           "VIA VIA VIA "}\par
00418 {\cf21 #define CPUID_VENDOR_TRANSMETA     "GenuineTMx86"}\par
00419 {\cf21 #define CPUID_VENDOR_TRANSMETA_OLD "TransmetaCPU"}\par
00420 {\cf21 #define CPUID_VENDOR_CYRIX         "CyrixInstead"}\par
00421 {\cf21 #define CPUID_VENDOR_CENTAUR       "CentaurHauls"}\par
00422 {\cf21 #define CPUID_VENDOR_NEXGEN        "NexGenDriven"}\par
00423 {\cf21 #define CPUID_VENDOR_UMC           "UMC UMC UMC "}\par
00424 {\cf21 #define CPUID_VENDOR_SIS           "SiS SiS SiS "}\par
00425 {\cf21 #define CPUID_VENDOR_NSC           "Geode by NSC"}\par
00426 {\cf21 #define CPUID_VENDOR_RISE          "RiseRiseRise"}\par
00427 {\cf21 #define CPUID_VENDOR_VORTEX        "Vortex86 SoC"}\par
00428 {\cf21 #define CPUID_VENDOR_AO486         "MiSTer AO486"}\par
00429 {\cf21 #define CPUID_VENDOR_AO486_OLD     "GenuineAO486"}\par
00430 {\cf21 #define CPUID_VENDOR_ZHAOXIN       "  Shanghai  "}\par
00431 {\cf21 #define CPUID_VENDOR_HYGON         "HygonGenuine"}\par
00432 {\cf21 #define CPUID_VENDOR_ELBRUS        "E2K MACHINE "}\par
00433 \par
00434 {\cf20 // Vendor strings from hypervisors.}\par
00435 {\cf21 #define CPUID_VENDOR_QEMU          "TCGTCGTCGTCG"}\par
00436 {\cf21 #define CPUID_VENDOR_KVM           " KVMKVMKVM  "}\par
00437 {\cf21 #define CPUID_VENDOR_VMWARE        "VMwareVMware"}\par
00438 {\cf21 #define CPUID_VENDOR_VIRTUALBOX    "VBoxVBoxVBox"}\par
00439 {\cf21 #define CPUID_VENDOR_XEN           "XenVMMXenVMM"}\par
00440 {\cf21 #define CPUID_VENDOR_HYPERV        "Microsoft Hv"}\par
00441 {\cf21 #define CPUID_VENDOR_PARALLELS     " prl hyperv "}\par
00442 {\cf21 #define CPUID_VENDOR_PARALLELS_ALT " lrpepyh vr " }{\cf20 // Sometimes Parallels incorrectly encodes "prl hyperv" as "lrpepyh vr" due to an endianness mismatch.}\par
00443 {\cf21 #define CPUID_VENDOR_BHYVE         "bhyve bhyve "}\par
00444 {\cf21 #define CPUID_VENDOR_QNX           " QNXQVMBSQG "}\par
00445 \par
00447 \par
00448 {\cf18 void} APMain({\cf18 void});\par
00449 {\cf18 void} MhInitializeSMP(uint8_t* apic_list, uint32_t cpu_count, uint32_t lapicAddress);\par
00450 {\cf18 void} MhSendActionToCpusAndWait(CPU_ACTION action, IPI_PARAMS parameter);\par
00451 \par
00452 {\cf17 extern} {\cf18 int} smp_cpu_count;\par
00453 {\cf17 extern} {\cf18 bool} smpInitialized;\par
00454 {\cf17 extern} {\cf18 bool} allApsInitialized;\par
00455 \par
00456 {\cf20 // Didn't get rename yet.}\par
00457 {\cf18 void} set_idt_gate({\cf18 int} n, {\cf18 unsigned} {\cf18 long} {\cf18 int} handler);\par
00458 {\cf18 void} install_idt({\cf18 void});\par
00459 {\cf18 void} init_interrupts({\cf18 void});\par
00460 \par
00461 {\cf18 void} lapic_init_cpu({\cf18 void});                    {\cf20 // call once on BSP early}\par
00462 {\cf18 void} lapic_enable({\cf18 void});\par
00463 uint32_t lapic_mmio_read(uint32_t off);\par
00464 {\cf18 void} lapic_mmio_write(uint32_t off, uint32_t val);\par
00465 {\cf18 void} lapic_eoi({\cf18 void});\par
00466 {\cf20 // lapic spurious interrupt vector, protects against faulty interrupts.}\par
00467 {\cf18 void} lapic_init_siv({\cf18 void});\par
00468 {\cf20 // send IPI to APIC id }\par
00469 {\cf20 // apic_id - APICId of the CPU.}\par
00470 {\cf20 // vector - IDT Vector number}\par
00471 {\cf20 // flags - specified cpu flags, 0 for none.}\par
00472 {\cf18 void} lapic_send_ipi(uint8_t apic_id, uint8_t vector, uint32_t flags);\par
00473 {\cf18 int} init_lapic_timer(uint32_t hz);           {\cf20 // calibrate + start periodic timer at `hz` (returns 0 on success)}\par
00474 {\cf18 void} pit_sleep_ms(uint32_t ms);\par
00475 {\cf18 void} lapic_timer_calibrate({\cf18 void});\par
00476 \par
00477 {\cf17 extern} {\cf18 bool} checkcpuid({\cf18 void});\par
00478 \par
00479 {\cf20 // Get CPU Model number}\par
00480 {\cf17 static} {\cf17 inline} {\cf18 int} getCpuModel({\cf18 void}) \{\par
00481     {\cf18 int} ebx, unused;\par
00482     __cpuid(0, unused, ebx, unused, unused);\par
00483     {\cf19 return} ebx;\par
00484 \}\par
00485 \par
00486 {\cf20 // Check for APIC Availability}\par
00487 FORCEINLINE\par
00488 {\cf18 bool} checkApic({\cf18 void}) \{\par
00489     {\cf18 unsigned} {\cf18 int} eax, ebx, ecx, edx;\par
00490     __cpuid(1, eax, ebx, ecx, edx);\par
00491     {\cf19 return} edx & (1 << 9); {\cf20 // bit 9 = APIC}\par
00492 \}\par
00493 \par
00494 FORCEINLINE \par
00495 {\cf18 void} getCpuName({\cf18 char}* name) \{\par
00496     {\cf18 unsigned} {\cf18 int} regs[4];\par
00497     {\cf18 char}* p = name;\par
00498 \par
00499     {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0; i < 3; i++) \{\par
00500         __cpuid(0x80000002 + i, regs[0], regs[1], regs[2], regs[3]);\par
00501         kmemcpy(p, regs, {\cf17 sizeof}(regs));\par
00502         p += {\cf17 sizeof}(regs);\par
00503     \}\par
00504     *p = {\cf23 '\\0'}; {\cf20 // Null-terminate}\par
00505 \}\par
00506 \par
00507 {\cf18 void} \par
00508 MhHandleInterrupt (\par
00509     IN    {\cf18 int} vec_num,\par
00510     IN    PTRAP_FRAME trap\par
00511 );\par
00512 \par
00513 {\cf18 void} MiLapicInterrupt(\par
00514     {\cf18 bool} schedulerEnabled,\par
00515     PTRAP_FRAME trap\par
00516 );\par
00517 \par
00518 {\cf18 void} MiBreakpoint(\par
00519     PTRAP_FRAME trap\par
00520 );\par
00521 \par
00522 NORETURN\par
00523 {\cf18 void}\par
00524 MiNonMaskableInterrupt(\par
00525     PTRAP_FRAME trap\par
00526 );\par
00527 \par
00528 {\cf18 void}\par
00529 MiDivideByZero(\par
00530     PTRAP_FRAME trap\par
00531 );\par
00532 \par
00533 {\cf18 void}\par
00534 MiDebugTrap(\par
00535     PTRAP_FRAME trap\par
00536 );\par
00537 \par
00538 NORETURN\par
00539 {\cf18 void}\par
00540 MiDoubleFault(\par
00541     IN  PTRAP_FRAME trap\par
00542 );\par
00543 \par
00544 {\cf18 void} \par
00545 MiInterprocessorInterrupt(\par
00546     {\cf18 void}\par
00547 );\par
00548 \par
00549 {\cf18 void}\par
00550 MiPageFault(\par
00551     IN  PTRAP_FRAME trap\par
00552 );\par
00553 \par
00554 {\cf18 void}\par
00555 MiInvalidTss(\par
00556     IN    PTRAP_FRAME trap\par
00557 );\par
00558 \par
00559 {\cf18 void} \par
00560 MiOverflow(\par
00561     PTRAP_FRAME trap\par
00562 );\par
00563 \par
00564 {\cf18 void} \par
00565 MiBoundsCheck(\par
00566     PTRAP_FRAME trap\par
00567 );\par
00568 \par
00569 {\cf18 void} \par
00570 MiInvalidOpcode(\par
00571     PTRAP_FRAME trap\par
00572 );\par
00573 \par
00574 {\cf18 void} \par
00575 MiNoCoprocessor(\par
00576     PTRAP_FRAME trap\par
00577 );\par
00578 \par
00579 {\cf18 void} \par
00580 MiCoprocessorSegmentOverrun(\par
00581     PTRAP_FRAME trap\par
00582 );\par
00583 \par
00584 {\cf18 void} \par
00585 MiSegmentSelectorNotPresent(\par
00586     PTRAP_FRAME trap\par
00587 );\par
00588 \par
00589 {\cf18 void} \par
00590 MiStackSegmentOverrun(\par
00591     PTRAP_FRAME trap\par
00592 );\par
00593 \par
00594 {\cf18 void} \par
00595 MiGeneralProtectionFault(\par
00596     PTRAP_FRAME trap\par
00597 );\par
00598 \par
00599 {\cf18 void} \par
00600 MiFloatingPointError(\par
00601     PTRAP_FRAME trap\par
00602 );\par
00603 \par
00604 {\cf18 void}\par
00605 MiAlignmentCheck(\par
00606     PTRAP_FRAME trap\par
00607 );\par
00608 \par
00609 {\cf18 void} \par
00610 MiMachineCheck(\par
00611     PTRAP_FRAME trap\par
00612 );\par
00613 \par
00614 {\cf18 void}\par
00615 MhRequestSoftwareInterrupt(\par
00616     IN IRQL RequestIrql\par
00617 );\par
00618 \par
00619 MTSTATUS MhInitializeACPI({\cf18 void});\par
00620 MTSTATUS MhParseLAPICs(uint8_t* buffer, {\cf18 size_t} maxCPUs, uint32_t* cpuCount, uint32_t* lapicAddress);\par
00621 \par
00622 {\cf18 void}\par
00623 MhRebootComputer(\par
00624     {\cf18 void}\par
00625 );\par
00626 \par
00627 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mm.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mm.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mm.h}
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "annotations.h"}\par
{\f2 #include "macros.h"}\par
{\f2 #include "../mtstatus.h"}\par
{\f2 #include "../intrinsics/intrin.h"}\par
{\f2 #include "../intrinsics/atomic.h"}\par
{\f2 #include "ms.h"}\par
{\f2 #include "core.h"}\par
{\f2 #include "efi.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MMPTE}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _PFN_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MM_PFN_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MM_PFN_DATABASE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MMVAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _POOL_HEADER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _POOL_DESCRIPTOR}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PML4_INDEX_BITS}\~ 9\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PML4_INDEX_SHIFT}\~ 39\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PML4_INDEX_MASK}\~ ((1ULL << {\b PML4_INDEX_BITS}) - 1ULL)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PML4_INDEX_FROM_VA}(VA)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PML4_INDEX_FROM_PHYS}(PHYS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VirtualPageSize}\~ 4096ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PhysicalFrameSize}\~ 4096ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b KernelVaStart}\~ 0xfffff80000000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PhysicalMemoryOffset}\~ 0xffff880000000000ULL\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RECURSIVE_INDEX}\~ 0x1FF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INDEX_TO_PPFN}(Index)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PHYSICAL_TO_PPFN}(PHYS)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PTE_TO_PHYSICAL}({\b PMMPTE})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_WRITE_PTE}(_PtePointer,  _Va,  _Pa,  _Flags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PPFN_TO_INDEX}(PPFN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PPFN_TO_PHYSICAL_ADDRESS}(PPFN)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VA_OFFSET}(_VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_IS_DEMAND_ZERO_PTE}(pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_SET_DEMAND_ZERO_PTE}(pte,  prot_flags,  nx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_UNSET_DEMAND_ZERO_PTE}(pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BYTES_TO_PAGES}(Bytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGES_TO_BYTES}(Pages)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_POOL_DESCRIPTORS}\~ 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _32KB_POOL}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _64KB_POOL}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _128KB_POOL}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _256KB_POOL}\~ 4\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _512KB_POOL}\~ 5\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _1024KB_POOL}\~ 6\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _2048KB_POOL}\~ 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b POOL_MIN_ALLOC}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_VA_END}\~ 0x00007FFFFFFFFFFF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b USER_VA_START}\~ 0x10000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b POOL_MAX_ALLOC}\~ 2048\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_NONPAGED_POOL_SIZE}\~ ((size_t)16ULL * 1024 * 1024 * 1024)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_PAGED_POOL_SIZE}\~ ((size_t)32ULL * 1024 * 1024 * 1024)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NONPAGED_POOL_VA_TOTAL_PAGES}\~ ({\b MI_NONPAGED_POOL_SIZE} / {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGED_POOL_VA_TOTAL_PAGES}\~ ({\b MI_PAGED_POOL_SIZE} / {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NONPAGED_POOL_VA_BITMAP_QWORDS}\~ (({\b NONPAGED_POOL_VA_TOTAL_PAGES} + 63) / 64)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGED_POOL_VA_BITMAP_QWORDS}\~ (({\b PAGED_POOL_VA_TOTAL_PAGES} + 63) / 64)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_NONPAGED_BITMAP_PAGES_NEEDED}\~ (({\b NONPAGED_POOL_VA_BITMAP_QWORDS} * sizeof(uint64_t) + {\b VirtualPageSize} - 1) / {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_PAGED_BITMAP_PAGES_NEEDED}\~ (({\b PAGED_POOL_VA_BITMAP_QWORDS} * sizeof(uint64_t) + {\b VirtualPageSize} - 1) / {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ALIGN_UP}(x,  align)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_NONPAGED_BITMAP_BASE}\~ {\b ALIGN_UP}({\b LK_KERNEL_END}, {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_NONPAGED_BITMAP_END}\~ ({\b MI_NONPAGED_BITMAP_BASE} + {\b MI_NONPAGED_BITMAP_PAGES_NEEDED} * {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_PAGED_BITMAP_BASE}\~ {\b ALIGN_UP}({\b MI_NONPAGED_BITMAP_END}, {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_PAGED_BITMAP_END}\~ ({\b MI_PAGED_BITMAP_BASE} + {\b MI_PAGED_BITMAP_PAGES_NEEDED} * {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_NONPAGED_POOL_BASE}\~ {\b ALIGN_UP}({\b MI_NONPAGED_BITMAP_END}, {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_NONPAGED_POOL_END}\~ ({\b MI_NONPAGED_POOL_BASE} + {\b MI_NONPAGED_POOL_SIZE})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_PAGED_POOL_BASE}\~ {\b ALIGN_UP}({\b MI_NONPAGED_POOL_END}, {\b VirtualPageSize})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_PAGED_POOL_END}\~ ({\b MI_PAGED_POOL_BASE} + {\b MI_PAGED_POOL_SIZE})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_IS_CANONICAL_ADDR}(va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PFN_TO_PHYS}(Pfn)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PHYS_TO_INDEX}(PhysicalAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PFN_ERROR}\~ {\b UINT64_T_MAX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PROT_KERNEL_READ}\~ 0x1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PROT_KERNEL_WRITE}\~ 0x2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_DEMAND_ZERO_BIT}\~ (1ULL << 16)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MM_POOL_CANARY}\~ 'BEKA'\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_STACK_SIZE}\~ 0x4000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_LARGE_STACK_SIZE}\~ 0xf000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MI_GUARD_PAGE_PROTECTION}\~ (1ULL << 17)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MmFullBarrier}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MmBarrier}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MmIsAddressValid}(VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PAGE_PAT}\~ (1ULL << 7)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint64_t {\b PAGE_INDEX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PFN_STATE} {\b PFN_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PFN_FLAGS} {\b PFN_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _VAD_FLAGS} {\b VAD_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PAGE_FLAGS} {\b PAGE_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _POOL_TYPE} {\b POOL_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FAULT_OPERATION} {\b FAULT_OPERATION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _FAULT_OPERATION} * {\b PFAULT_OPERATION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PRIVILEGE_MODE} {\b PRIVILEGE_MODE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PRIVILEGE_MODE} * {\b PPRIVILEGE_MODE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _MEMORY_CACHING_TYPE} {\b MEMORY_CACHING_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _SYSTEM_PHASE_ROUTINE} {\b SYSTEM_PHASE_ROUTINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MMPTE} {\b MMPTE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MMPTE} * {\b PMMPTE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _PFN_ENTRY} {\b PFN_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _PFN_ENTRY} * {\b PPFN_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MM_PFN_LIST} {\b MM_PFN_LIST}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MM_PFN_DATABASE} {\b MM_PFN_DATABASE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MMVAD} {\b MMVAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MMVAD} * {\b PMMVAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _POOL_HEADER} {\b POOL_HEADER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _POOL_HEADER} * {\b PPOOL_HEADER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _POOL_DESCRIPTOR} {\b POOL_DESCRIPTOR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _POOL_DESCRIPTOR} * {\b PPOOL_DESCRIPTOR}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PFN_STATE} \{ {\b PfnStateActive}
, {\b PfnStateStandby}
, {\b PfnStateModified}
, {\b PfnStateFree}
, {\b PfnStateZeroed}
, {\b PfnStateTransition}
, {\b PfnStateBad}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PFN_FLAGS} \{ {\b PFN_FLAG_NONE} = 0
, {\b PFN_FLAG_NONPAGED} = (1U << 0)
, {\b PFN_FLAG_COPY_ON_WRITE} = (1U << 1)
, {\b PFN_FLAG_MAPPED_FILE} = (1U << 2)
, {\b PFN_FLAG_LOCKED_FOR_IO} = (1U << 3)
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _VAD_FLAGS} \{ {\b VAD_FLAG_NONE} = 0
, {\b VAD_FLAG_READ} = (1U << 0)
, {\b VAD_FLAG_WRITE} = (1U << 1)
, {\b VAD_FLAG_EXECUTE} = (1U << 2)
, {\b VAD_FLAG_PRIVATE} = (1U << 3)
, {\b VAD_FLAG_MAPPED_FILE} = (1U << 4)
, {\b VAD_FLAG_COPY_ON_WRITE} = (1U << 5)
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PAGE_FLAGS} \{ {\b PAGE_PRESENT} = 1 << 0
, {\b PAGE_RW} = 1 << 1
, {\b PAGE_USER} = 1 << 2
, {\b PAGE_PWT} = 0x8
, {\b PAGE_PCD} = 0x10
, {\b PAGE_ACCESSED} = 0x20
, {\b PAGE_DIRTY} = 0x40
, {\b PAGE_PS} = 0x80
, {\b PAGE_GLOBAL} = 0x100
, {\b PAGE_NX} = (1ULL << 63)
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _POOL_TYPE} \{ {\b NonPagedPool} = 0
, {\b PagedPool} = 1
, {\b NonPagedPoolCacheAligned} = 2
, {\b PagedPoolCacheAligned} = 3
, {\b NonPagedPoolNx} = 4
, {\b PagedPoolNx} = 5
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _FAULT_OPERATION} \{ {\b FaultOpInvalid} = -1
, {\b ReadOperation} = 0
, {\b WriteOperation} = 2
, {\b ExecuteOperation} = 10
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PRIVILEGE_MODE} \{ {\b KernelMode} = 0
, {\b UserMode} = 1
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _MEMORY_CACHING_TYPE} \{ {\b MmNonCached} = 0
, {\b MmCached}
, {\b MmWriteCombined}
, {\b MmWriteThrough}
, {\b MmNonCachedUnordered}
, {\b MmUSWCCached}
, {\b MmHardwareCoherentCached}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _SYSTEM_PHASE_ROUTINE} \{ {\b SYSTEM_PHASE_INITIALIZE_ALL} = 1
, {\b SYSTEM_PHASE_INITIALIZE_PAT_ONLY} = 2
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t * {\b pml4_from_recursive} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b kmemset} (void *dest, int64_t val, uint64_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b kmemcpy} (void *dest, const void *src, size_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int {\b kmemcmp} (const void *s1, const void *s2, size_t n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiReloadTLBs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b MiCacheToFlags} ({\b MEMORY_CACHING_TYPE} type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b FAULT_OPERATION} {\b MiRetrieveOperationFromErrorCode} (uint64_t ErrorCode)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b MiRetrieveLastFaultyAddress} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MiAtomicExchangePte} ({\b PMMPTE} PtePtr, uint64_t NewPteValue)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiInvalidateTlbForVa} ({\b IN} void *VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b MiIsValidPfn} ({\b IN} {\b PAGE_INDEX} Pfn)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MiInitializePfnDatabase} ({\b IN} {\b PBOOT_INFO} BootInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGE_INDEX} {\b MiRequestPhysicalPage} ({\b IN} {\b PFN_STATE} ListType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiReleasePhysicalPage} ({\b IN} {\b PAGE_INDEX} PfnIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiUnlinkPageFromList} ({\b PPFN_ENTRY} pfn)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPml4ePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPdptePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPdePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMPTE} {\b MiGetPtePointer} ({\b IN} uintptr_t va)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b MiTranslatePteToVa} ({\b IN} {\b PMMPTE} pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGE_INDEX} {\b MiTranslatePteToPfn} ({\b IN} {\b PMMPTE} pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MiTranslateVirtualToPhysical} ({\b IN} void *VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiUnmapPte} ({\b IN} {\b PMMPTE} pte)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmIsAddressPresent} ({\b IN} uintptr_t VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MiMapPageInHyperspace} ({\b IN} uint64_t PfnIndex, {\b OUT} {\b PIRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiUnmapHyperSpaceMap} ({\b IN} {\b IRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MiInitializePoolSystem} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MmAllocatePoolWithTag} ({\b IN} enum {\b _POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes, {\b IN} uint32_t Tag)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MmFreePool} ({\b IN} void *buf)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MiCreateKernelStack} ({\b IN} bool LargeStack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiFreeKernelStack} ({\b IN} void *AllocatedStackTop, {\b IN} bool LargeStack)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmCreateProcessAddressSpace} ({\b OUT} void **DirectoryTable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmAllocateVirtualMemory} ({\b IN} {\b PEPROCESS} Process, {\b _In_Opt} {\b _Out_Opt} void **BaseAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b VAD_FLAGS} VadFlags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmFreeVirtualMemory} ({\b IN} {\b PEPROCESS} Process, {\b IN} void *BaseAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PMMVAD} {\b MiFindVad} ({\b IN} {\b PMMVAD} Root, {\b IN} uintptr_t VirtualAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiMoveUefiDataToHigherHalf} ({\b IN} {\b PBOOT_INFO} BootInfo)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmFindFreeAddressSpace} ({\b IN} {\b PEPROCESS} Process, {\b IN} size_t NumberOfBytes, {\b IN} uintptr_t SearchStart, {\b IN} uintptr_t SearchEnd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MiInitializePoolVaSpace} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MiAllocatePoolVa} ({\b IN} {\b POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MiFreePoolVaContiguous} ({\b IN} uintptr_t va, {\b IN} size_t NumberOfBytes, {\b IN} {\b POOL_TYPE} PoolType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MmAccessFault} ({\b IN} uint64_t FaultBits, {\b IN} uint64_t VirtualAddress, {\b IN} {\b PRIVILEGE_MODE} PreviousMode, {\b IN} {\b PTRAP_FRAME} TrapFrame)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmInvalidAccessAllowed} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MiCheckForContigiousMemory} ({\b IN} void *StartAddress, {\b IN} size_t NumberOfBytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MmAllocateContigiousMemory} ({\b IN} size_t NumberOfBytes, {\b IN} uint64_t HighestAcceptableAddress)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MmFreeContigiousMemory} ({\b IN} void *BaseAddress, {\b IN} size_t NumberOfBytes)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b MmMapIoSpace} ({\b IN} uintptr_t PhysicalAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b MEMORY_CACHING_TYPE} CacheType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmInitSystem} ({\b IN} uint8_t Phase, {\b IN} {\b PBOOT_INFO} BootInformation)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MM_PFN_DATABASE} {\b PfnDatabase}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MmPfnDatabaseInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PAGE_INDEX} {\b MmHighestPfn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmSystemRangeStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmHighestUserAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmUserProbeAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmNonPagedPoolStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmNonPagedPoolEnd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmPagedPoolStart}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uintptr_t {\b MmPagedPoolEnd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v _1024KB_POOL\:mm.h}
{\xe \v mm.h\:_1024KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _1024KB_POOL\~ 6}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b mm.h}.}\par
}
{\xe \v _128KB_POOL\:mm.h}
{\xe \v mm.h\:_128KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _128KB_POOL\~ 3}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b mm.h}.}\par
}
{\xe \v _2048KB_POOL\:mm.h}
{\xe \v mm.h\:_2048KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _2048KB_POOL\~ 7}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b mm.h}.}\par
}
{\xe \v _256KB_POOL\:mm.h}
{\xe \v mm.h\:_256KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _256KB_POOL\~ 4}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 155} of file {\b mm.h}.}\par
}
{\xe \v _32KB_POOL\:mm.h}
{\xe \v mm.h\:_32KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _32KB_POOL\~ 1}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b mm.h}.}\par
}
{\xe \v _512KB_POOL\:mm.h}
{\xe \v mm.h\:_512KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _512KB_POOL\~ 5}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b mm.h}.}\par
}
{\xe \v _64KB_POOL\:mm.h}
{\xe \v mm.h\:_64KB_POOL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _64KB_POOL\~ 2}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b mm.h}.}\par
}
{\xe \v ALIGN_UP\:mm.h}
{\xe \v mm.h\:ALIGN_UP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ALIGN_UP( x,  align)}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((uintptr_t)(x) + ((align)-1)) & ~((uintptr_t)((align)-1)))\par
}
{
Definition at line {\b 181} of file {\b mm.h}.}\par
}
{\xe \v BYTES_TO_PAGES\:mm.h}
{\xe \v mm.h\:BYTES_TO_PAGES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BYTES_TO_PAGES( Bytes)}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (((Bytes) + VirtualPageSize - 1) / VirtualPageSize)\par
}
{
Definition at line {\b 147} of file {\b mm.h}.}\par
}
{\xe \v INDEX_TO_PPFN\:mm.h}
{\xe \v mm.h\:INDEX_TO_PPFN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INDEX_TO_PPFN( Index)}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     (&(PfnDatabase.PfnEntries[(size_t)(Index)]))\par
}
{
Definition at line {\b 62} of file {\b mm.h}.}\par
}
{\xe \v KernelVaStart\:mm.h}
{\xe \v mm.h\:KernelVaStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define KernelVaStart\~ 0xfffff80000000000ULL}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b mm.h}.}\par
}
{\xe \v MAX_POOL_DESCRIPTORS\:mm.h}
{\xe \v mm.h\:MAX_POOL_DESCRIPTORS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_POOL_DESCRIPTORS\~ 7}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b mm.h}.}\par
}
{\xe \v MI_DEMAND_ZERO_BIT\:mm.h}
{\xe \v mm.h\:MI_DEMAND_ZERO_BIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_DEMAND_ZERO_BIT\~ (1ULL << 16)}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b mm.h}.}\par
}
{\xe \v MI_GUARD_PAGE_PROTECTION\:mm.h}
{\xe \v mm.h\:MI_GUARD_PAGE_PROTECTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_GUARD_PAGE_PROTECTION\~ (1ULL << 17)}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b mm.h}.}\par
}
{\xe \v MI_IS_CANONICAL_ADDR\:mm.h}
{\xe \v mm.h\:MI_IS_CANONICAL_ADDR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_IS_CANONICAL_ADDR( va)}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (\{ \\\par
    uint64_t _va = (uint64_t)(va); \\\par
    uint64_t _mask = ~((1ULL << 48) - 1); {\cf20 /* bits 63:48 */} \\\par
    ((_va & _mask) == 0 || (_va & _mask) == _mask); \\\par
\})\par
}
{
Definition at line {\b 198} of file {\b mm.h}.}\par
}
{\xe \v MI_LARGE_STACK_SIZE\:mm.h}
{\xe \v mm.h\:MI_LARGE_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_LARGE_STACK_SIZE\~ 0xf000}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b mm.h}.}\par
}
{\xe \v MI_NONPAGED_BITMAP_BASE\:mm.h}
{\xe \v mm.h\:MI_NONPAGED_BITMAP_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_NONPAGED_BITMAP_BASE\~ {\b ALIGN_UP}({\b LK_KERNEL_END}, {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b mm.h}.}\par
}
{\xe \v MI_NONPAGED_BITMAP_END\:mm.h}
{\xe \v mm.h\:MI_NONPAGED_BITMAP_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_NONPAGED_BITMAP_END\~ ({\b MI_NONPAGED_BITMAP_BASE} + {\b MI_NONPAGED_BITMAP_PAGES_NEEDED} * {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b mm.h}.}\par
}
{\xe \v MI_NONPAGED_BITMAP_PAGES_NEEDED\:mm.h}
{\xe \v mm.h\:MI_NONPAGED_BITMAP_PAGES_NEEDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_NONPAGED_BITMAP_PAGES_NEEDED\~ (({\b NONPAGED_POOL_VA_BITMAP_QWORDS} * sizeof(uint64_t) + {\b VirtualPageSize} - 1) / {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b mm.h}.}\par
}
{\xe \v MI_NONPAGED_POOL_BASE\:mm.h}
{\xe \v mm.h\:MI_NONPAGED_POOL_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_NONPAGED_POOL_BASE\~ {\b ALIGN_UP}({\b MI_NONPAGED_BITMAP_END}, {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b mm.h}.}\par
}
{\xe \v MI_NONPAGED_POOL_END\:mm.h}
{\xe \v mm.h\:MI_NONPAGED_POOL_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_NONPAGED_POOL_END\~ ({\b MI_NONPAGED_POOL_BASE} + {\b MI_NONPAGED_POOL_SIZE})}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 192} of file {\b mm.h}.}\par
}
{\xe \v MI_NONPAGED_POOL_SIZE\:mm.h}
{\xe \v mm.h\:MI_NONPAGED_POOL_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_NONPAGED_POOL_SIZE\~ ((size_t)16ULL * 1024 * 1024 * 1024)}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b mm.h}.}\par
}
{\xe \v MI_PAGED_BITMAP_BASE\:mm.h}
{\xe \v mm.h\:MI_PAGED_BITMAP_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_PAGED_BITMAP_BASE\~ {\b ALIGN_UP}({\b MI_NONPAGED_BITMAP_END}, {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 187} of file {\b mm.h}.}\par
}
{\xe \v MI_PAGED_BITMAP_END\:mm.h}
{\xe \v mm.h\:MI_PAGED_BITMAP_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_PAGED_BITMAP_END\~ ({\b MI_PAGED_BITMAP_BASE} + {\b MI_PAGED_BITMAP_PAGES_NEEDED} * {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b mm.h}.}\par
}
{\xe \v MI_PAGED_BITMAP_PAGES_NEEDED\:mm.h}
{\xe \v mm.h\:MI_PAGED_BITMAP_PAGES_NEEDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_PAGED_BITMAP_PAGES_NEEDED\~ (({\b PAGED_POOL_VA_BITMAP_QWORDS} * sizeof(uint64_t) + {\b VirtualPageSize} - 1) / {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 178} of file {\b mm.h}.}\par
}
{\xe \v MI_PAGED_POOL_BASE\:mm.h}
{\xe \v mm.h\:MI_PAGED_POOL_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_PAGED_POOL_BASE\~ {\b ALIGN_UP}({\b MI_NONPAGED_POOL_END}, {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b mm.h}.}\par
}
{\xe \v MI_PAGED_POOL_END\:mm.h}
{\xe \v mm.h\:MI_PAGED_POOL_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_PAGED_POOL_END\~ ({\b MI_PAGED_POOL_BASE} + {\b MI_PAGED_POOL_SIZE})}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b mm.h}.}\par
}
{\xe \v MI_PAGED_POOL_SIZE\:mm.h}
{\xe \v mm.h\:MI_PAGED_POOL_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_PAGED_POOL_SIZE\~ ((size_t)32ULL * 1024 * 1024 * 1024)}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b mm.h}.}\par
}
{\xe \v MI_STACK_SIZE\:mm.h}
{\xe \v mm.h\:MI_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_STACK_SIZE\~ 0x4000}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b mm.h}.}\par
}
{\xe \v MI_WRITE_PTE\:mm.h}
{\xe \v mm.h\:MI_WRITE_PTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MI_WRITE_PTE( _PtePointer,  _Va,  _Pa,  _Flags)}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 do} \{                                                                        \\\par
    MMPTE* _pte = (MMPTE*)(_PtePointer);                                    \\\par
    uint64_t _val = (((uintptr_t)(_Pa)) & ~0xFFFULL) | (uint64_t)(_Flags);  \\\par
    MiAtomicExchangePte(_pte, _val);                                        \\\par
    __asm__ {\cf17 volatile}({\cf22 ""} ::: {\cf22 "memory"});                                      \\\par
                                                                            \\\par
    {\cf20 /* Only set PFN->PTE link if PFN database is initialized */}             \\\par
    if (MmPfnDatabaseInitialized) \{                                         \\\par
        PPFN_ENTRY _pfn = PHYSICAL_TO_PPFN(_Pa);                            \\\par
        _pfn->Descriptor.Mapping.PteAddress = (PMMPTE)_pte;                 \\\par
        _pfn->State = PfnStateActive;                                       \\\par
        _pfn->Flags = PFN_FLAG_NONPAGED;                                    \\\par
    \}                                                                       \\\par
                                                                            \\\par
    invlpg(({\cf18 void}*)(uintptr_t)(_Va));                                        \\\par
                                                                            \\\par
    {\cf20 /* Send IPIs if SMP is initialized */}                                   \\\par
    if (smpInitialized && allApsInitialized) \{                              \\\par
        IPI_PARAMS _Params;                                                 \\\par
        _Params.pageParams.addressToInvalidate = (uint64_t)(_Va);          \\\par
        MhSendActionToCpusAndWait(CPU_ACTION_PERFORM_TLB_SHOOTDOWN, _Params);\\\par
    \}                                                                       \\\par
\} {\cf19 while} (0)\par
}
{
Definition at line {\b 90} of file {\b mm.h}.}\par
}
{\xe \v MM_IS_DEMAND_ZERO_PTE\:mm.h}
{\xe \v mm.h\:MM_IS_DEMAND_ZERO_PTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_IS_DEMAND_ZERO_PTE( pte)}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     (((pte).Soft.SoftwareFlags & MI_DEMAND_ZERO_BIT) != 0)\par
}
{
Definition at line {\b 120} of file {\b mm.h}.}\par
}
{\xe \v MM_POOL_CANARY\:mm.h}
{\xe \v mm.h\:MM_POOL_CANARY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_POOL_CANARY\~ 'BEKA'}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 216} of file {\b mm.h}.}\par
}
{\xe \v MM_SET_DEMAND_ZERO_PTE\:mm.h}
{\xe \v mm.h\:MM_SET_DEMAND_ZERO_PTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_SET_DEMAND_ZERO_PTE( pte,  prot_flags,  nx)}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        (pte).Value = 0; \\\par
        (pte).Soft.SoftwareFlags = (prot_flags) | MI_DEMAND_ZERO_BIT; \\\par
        (pte).Soft.NoExecute = (nx); \\\par
    \} {\cf19 while}(0)\par
}
{
Definition at line {\b 122} of file {\b mm.h}.}\par
}
{\xe \v MM_UNSET_DEMAND_ZERO_PTE\:mm.h}
{\xe \v mm.h\:MM_UNSET_DEMAND_ZERO_PTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MM_UNSET_DEMAND_ZERO_PTE( pte)}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf19 do} \{ \\\par
        (pte).Soft.SoftwareFlags &= ~MI_DEMAND_ZERO_BIT; \\\par
    \} {\cf19 while}(0)\par
}
{
Definition at line {\b 128} of file {\b mm.h}.}\par
}
{\xe \v MmBarrier\:mm.h}
{\xe \v mm.h\:MmBarrier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MmBarrier()}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __asm__ __volatile__({\cf22 "mfence"} ::: {\cf22 "memory"})\par
}
{
Definition at line {\b 229} of file {\b mm.h}.}\par
}
{\xe \v MmFullBarrier\:mm.h}
{\xe \v mm.h\:MmFullBarrier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MmFullBarrier()}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __sync_synchronize()\par
}
{
Definition at line {\b 226} of file {\b mm.h}.}\par
}
{\xe \v MmIsAddressValid\:mm.h}
{\xe \v mm.h\:MmIsAddressValid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MmIsAddressValid( VirtualAddress)}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid MmIsAddressPresent(VirtualAddress)\par
}
{
Definition at line {\b 234} of file {\b mm.h}.}\par
}
{\xe \v NONPAGED_POOL_VA_BITMAP_QWORDS\:mm.h}
{\xe \v mm.h\:NONPAGED_POOL_VA_BITMAP_QWORDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NONPAGED_POOL_VA_BITMAP_QWORDS\~ (({\b NONPAGED_POOL_VA_TOTAL_PAGES} + 63) / 64)}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b mm.h}.}\par
}
{\xe \v NONPAGED_POOL_VA_TOTAL_PAGES\:mm.h}
{\xe \v mm.h\:NONPAGED_POOL_VA_TOTAL_PAGES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NONPAGED_POOL_VA_TOTAL_PAGES\~ ({\b MI_NONPAGED_POOL_SIZE} / {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 169} of file {\b mm.h}.}\par
}
{\xe \v PAGE_PAT\:mm.h}
{\xe \v mm.h\:PAGE_PAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGE_PAT\~ (1ULL << 7)}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 301} of file {\b mm.h}.}\par
}
{\xe \v PAGED_POOL_VA_BITMAP_QWORDS\:mm.h}
{\xe \v mm.h\:PAGED_POOL_VA_BITMAP_QWORDS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGED_POOL_VA_BITMAP_QWORDS\~ (({\b PAGED_POOL_VA_TOTAL_PAGES} + 63) / 64)}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b mm.h}.}\par
}
{\xe \v PAGED_POOL_VA_TOTAL_PAGES\:mm.h}
{\xe \v mm.h\:PAGED_POOL_VA_TOTAL_PAGES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGED_POOL_VA_TOTAL_PAGES\~ ({\b MI_PAGED_POOL_SIZE} / {\b VirtualPageSize})}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b mm.h}.}\par
}
{\xe \v PAGES_TO_BYTES\:mm.h}
{\xe \v mm.h\:PAGES_TO_BYTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PAGES_TO_BYTES( Pages)}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((Pages) * VirtualPageSize)\par
}
{
Definition at line {\b 149} of file {\b mm.h}.}\par
}
{\xe \v PFN_ERROR\:mm.h}
{\xe \v mm.h\:PFN_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PFN_ERROR\~ {\b UINT64_T_MAX}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b mm.h}.}\par
}
{\xe \v PFN_TO_PHYS\:mm.h}
{\xe \v mm.h\:PFN_TO_PHYS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PFN_TO_PHYS( Pfn)}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(Pfn))\par
}
{
Definition at line {\b 205} of file {\b mm.h}.}\par
}
{\xe \v PHYS_TO_INDEX\:mm.h}
{\xe \v mm.h\:PHYS_TO_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PHYS_TO_INDEX( PhysicalAddress)}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid PPFN_TO_INDEX(PHYSICAL_TO_PPFN(PhysicalAddress))\par
}
{
Definition at line {\b 206} of file {\b mm.h}.}\par
}
{\xe \v PHYSICAL_TO_PPFN\:mm.h}
{\xe \v mm.h\:PHYSICAL_TO_PPFN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PHYSICAL_TO_PPFN( PHYS)}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     (&PfnDatabase.PfnEntries[(size_t)((PHYS) / (uint64_t)PhysicalFrameSize)])\par
}
{
Definition at line {\b 64} of file {\b mm.h}.}\par
}
{\xe \v PhysicalFrameSize\:mm.h}
{\xe \v mm.h\:PhysicalFrameSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PhysicalFrameSize\~ 4096ULL}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b mm.h}.}\par
}
{\xe \v PhysicalMemoryOffset\:mm.h}
{\xe \v mm.h\:PhysicalMemoryOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PhysicalMemoryOffset\~ 0xffff880000000000ULL}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b mm.h}.}\par
}
{\xe \v PML4_INDEX_BITS\:mm.h}
{\xe \v mm.h\:PML4_INDEX_BITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PML4_INDEX_BITS\~ 9}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b mm.h}.}\par
}
{\xe \v PML4_INDEX_FROM_PHYS\:mm.h}
{\xe \v mm.h\:PML4_INDEX_FROM_PHYS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PML4_INDEX_FROM_PHYS( PHYS)}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid PML4_INDEX_FROM_VA( (uintptr_t)(PHYS) + (uintptr_t)PhysicalMemoryOffset )\par
}
{
Definition at line {\b 46} of file {\b mm.h}.}\par
}
{\xe \v PML4_INDEX_FROM_VA\:mm.h}
{\xe \v mm.h\:PML4_INDEX_FROM_VA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PML4_INDEX_FROM_VA( VA)}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ( ( (uintptr_t)(VA) >> PML4_INDEX_SHIFT ) & PML4_INDEX_MASK )\par
}
{
Definition at line {\b 42} of file {\b mm.h}.}\par
}
{\xe \v PML4_INDEX_MASK\:mm.h}
{\xe \v mm.h\:PML4_INDEX_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PML4_INDEX_MASK\~ ((1ULL << {\b PML4_INDEX_BITS}) - 1ULL)}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b mm.h}.}\par
}
{\xe \v PML4_INDEX_SHIFT\:mm.h}
{\xe \v mm.h\:PML4_INDEX_SHIFT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PML4_INDEX_SHIFT\~ 39}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b mm.h}.}\par
}
{\xe \v POOL_MAX_ALLOC\:mm.h}
{\xe \v mm.h\:POOL_MAX_ALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define POOL_MAX_ALLOC\~ 2048}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b mm.h}.}\par
}
{\xe \v POOL_MIN_ALLOC\:mm.h}
{\xe \v mm.h\:POOL_MIN_ALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define POOL_MIN_ALLOC\~ 32}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 159} of file {\b mm.h}.}\par
}
{\xe \v PPFN_TO_INDEX\:mm.h}
{\xe \v mm.h\:PPFN_TO_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PPFN_TO_INDEX( PPFN)}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((size_t)((PPFN) - PfnDatabase.PfnEntries))\par
}
{
Definition at line {\b 116} of file {\b mm.h}.}\par
}
{\xe \v PPFN_TO_PHYSICAL_ADDRESS\:mm.h}
{\xe \v mm.h\:PPFN_TO_PHYSICAL_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PPFN_TO_PHYSICAL_ADDRESS( PPFN)}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ((uint64_t)((uint64_t)PPFN_TO_INDEX(PPFN) * (uint64_t)PhysicalFrameSize))\par
}
{
Definition at line {\b 117} of file {\b mm.h}.}\par
}
{\xe \v PROT_KERNEL_READ\:mm.h}
{\xe \v mm.h\:PROT_KERNEL_READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PROT_KERNEL_READ\~ 0x1}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 211} of file {\b mm.h}.}\par
}
{\xe \v PROT_KERNEL_WRITE\:mm.h}
{\xe \v mm.h\:PROT_KERNEL_WRITE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PROT_KERNEL_WRITE\~ 0x2}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b mm.h}.}\par
}
{\xe \v PTE_TO_PHYSICAL\:mm.h}
{\xe \v mm.h\:PTE_TO_PHYSICAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PTE_TO_PHYSICAL( {\b PMMPTE})}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((PMMPTE)->Value & ~0xFFFULL)\par
}
{
Definition at line {\b 66} of file {\b mm.h}.}\par
}
{\xe \v RECURSIVE_INDEX\:mm.h}
{\xe \v mm.h\:RECURSIVE_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RECURSIVE_INDEX\~ 0x1FF}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b mm.h}.}\par
}
{\xe \v USER_VA_END\:mm.h}
{\xe \v mm.h\:USER_VA_END}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_VA_END\~ 0x00007FFFFFFFFFFF}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b mm.h}.}\par
}
{\xe \v USER_VA_START\:mm.h}
{\xe \v mm.h\:USER_VA_START}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define USER_VA_START\~ 0x10000}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b mm.h}.}\par
}
{\xe \v VA_OFFSET\:mm.h}
{\xe \v mm.h\:VA_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VA_OFFSET( _VirtualAddress)}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((uintptr_t)(_VirtualAddress) & 0xFFF)\par
}
{
Definition at line {\b 119} of file {\b mm.h}.}\par
}
{\xe \v VirtualPageSize\:mm.h}
{\xe \v mm.h\:VirtualPageSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VirtualPageSize\~ 4096ULL}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v FAULT_OPERATION\:mm.h}
{\xe \v mm.h\:FAULT_OPERATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FAULT_OPERATION} {\b FAULT_OPERATION}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MEMORY_CACHING_TYPE\:mm.h}
{\xe \v mm.h\:MEMORY_CACHING_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _MEMORY_CACHING_TYPE} {\b MEMORY_CACHING_TYPE}}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MM_PFN_DATABASE\:mm.h}
{\xe \v mm.h\:MM_PFN_DATABASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MM_PFN_DATABASE} {\b MM_PFN_DATABASE}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MM_PFN_LIST\:mm.h}
{\xe \v mm.h\:MM_PFN_LIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MM_PFN_LIST} {\b MM_PFN_LIST}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MMPTE\:mm.h}
{\xe \v mm.h\:MMPTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MMPTE} {\b MMPTE}}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MMVAD\:mm.h}
{\xe \v mm.h\:MMVAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MMVAD} {\b MMVAD}}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PAGE_FLAGS\:mm.h}
{\xe \v mm.h\:PAGE_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PAGE_FLAGS} {\b PAGE_FLAGS}}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PAGE_INDEX\:mm.h}
{\xe \v mm.h\:PAGE_INDEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef uint64_t {\b PAGE_INDEX}}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b mm.h}.}\par
}
{\xe \v PFAULT_OPERATION\:mm.h}
{\xe \v mm.h\:PFAULT_OPERATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _FAULT_OPERATION} * {\b PFAULT_OPERATION}}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PFN_ENTRY\:mm.h}
{\xe \v mm.h\:PFN_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _PFN_ENTRY} {\b PFN_ENTRY}}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PFN_FLAGS\:mm.h}
{\xe \v mm.h\:PFN_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PFN_FLAGS} {\b PFN_FLAGS}}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PFN_STATE\:mm.h}
{\xe \v mm.h\:PFN_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PFN_STATE} {\b PFN_STATE}}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PMMPTE\:mm.h}
{\xe \v mm.h\:PMMPTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MMPTE} * {\b PMMPTE}}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PMMVAD\:mm.h}
{\xe \v mm.h\:PMMVAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MMVAD} * {\b PMMVAD}}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v POOL_DESCRIPTOR\:mm.h}
{\xe \v mm.h\:POOL_DESCRIPTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _POOL_DESCRIPTOR} {\b POOL_DESCRIPTOR}}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v POOL_HEADER\:mm.h}
{\xe \v mm.h\:POOL_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _POOL_HEADER} {\b POOL_HEADER}}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v POOL_TYPE\:mm.h}
{\xe \v mm.h\:POOL_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _POOL_TYPE} {\b POOL_TYPE}}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PPFN_ENTRY\:mm.h}
{\xe \v mm.h\:PPFN_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _PFN_ENTRY} * {\b PPFN_ENTRY}}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PPOOL_DESCRIPTOR\:mm.h}
{\xe \v mm.h\:PPOOL_DESCRIPTOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _POOL_DESCRIPTOR} * {\b PPOOL_DESCRIPTOR}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PPOOL_HEADER\:mm.h}
{\xe \v mm.h\:PPOOL_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _POOL_HEADER} * {\b PPOOL_HEADER}}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PPRIVILEGE_MODE\:mm.h}
{\xe \v mm.h\:PPRIVILEGE_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PRIVILEGE_MODE} * {\b PPRIVILEGE_MODE}}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PRIVILEGE_MODE\:mm.h}
{\xe \v mm.h\:PRIVILEGE_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PRIVILEGE_MODE} {\b PRIVILEGE_MODE}}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SYSTEM_PHASE_ROUTINE\:mm.h}
{\xe \v mm.h\:SYSTEM_PHASE_ROUTINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _SYSTEM_PHASE_ROUTINE} {\b SYSTEM_PHASE_ROUTINE}}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VAD_FLAGS\:mm.h}
{\xe \v mm.h\:VAD_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _VAD_FLAGS} {\b VAD_FLAGS}}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _FAULT_OPERATION\:mm.h}
{\xe \v mm.h\:_FAULT_OPERATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _FAULT_OPERATION}}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v FaultOpInvalid\:mm.h}
{\xe \v mm.h\:FaultOpInvalid}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid FaultOpInvalid{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
\cell }{\cell }{\row }
{\xe \v ReadOperation\:mm.h}
{\xe \v mm.h\:ReadOperation}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ReadOperation{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
\cell }{\cell }{\row }
{\xe \v WriteOperation\:mm.h}
{\xe \v mm.h\:WriteOperation}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid WriteOperation{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
\cell }{\cell }{\row }
{\xe \v ExecuteOperation\:mm.h}
{\xe \v mm.h\:ExecuteOperation}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid ExecuteOperation{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 325} of file {\b mm.h}.}\par
}
{\xe \v _MEMORY_CACHING_TYPE\:mm.h}
{\xe \v mm.h\:_MEMORY_CACHING_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _MEMORY_CACHING_TYPE}}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MmNonCached\:mm.h}
{\xe \v mm.h\:MmNonCached}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmNonCached{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
\cell }{\cell }{\row }
{\xe \v MmCached\:mm.h}
{\xe \v mm.h\:MmCached}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmCached{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
\cell }{\cell }{\row }
{\xe \v MmWriteCombined\:mm.h}
{\xe \v mm.h\:MmWriteCombined}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmWriteCombined{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
\cell }{\cell }{\row }
{\xe \v MmWriteThrough\:mm.h}
{\xe \v mm.h\:MmWriteThrough}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmWriteThrough{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
\cell }{\cell }{\row }
{\xe \v MmNonCachedUnordered\:mm.h}
{\xe \v mm.h\:MmNonCachedUnordered}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmNonCachedUnordered{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
\cell }{\cell }{\row }
{\xe \v MmUSWCCached\:mm.h}
{\xe \v mm.h\:MmUSWCCached}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmUSWCCached{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
\cell }{\cell }{\row }
{\xe \v MmHardwareCoherentCached\:mm.h}
{\xe \v mm.h\:MmHardwareCoherentCached}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid MmHardwareCoherentCached{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 337} of file {\b mm.h}.}\par
}
{\xe \v _PAGE_FLAGS\:mm.h}
{\xe \v mm.h\:_PAGE_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PAGE_FLAGS}}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PAGE_PRESENT\:mm.h}
{\xe \v mm.h\:PAGE_PRESENT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PRESENT{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
\cell }{\cell }{\row }
{\xe \v PAGE_RW\:mm.h}
{\xe \v mm.h\:PAGE_RW}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_RW{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
\cell }{\cell }{\row }
{\xe \v PAGE_USER\:mm.h}
{\xe \v mm.h\:PAGE_USER}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_USER{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
\cell }{\cell }{\row }
{\xe \v PAGE_PWT\:mm.h}
{\xe \v mm.h\:PAGE_PWT}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PWT{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
\cell }{\cell }{\row }
{\xe \v PAGE_PCD\:mm.h}
{\xe \v mm.h\:PAGE_PCD}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PCD{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
\cell }{\cell }{\row }
{\xe \v PAGE_ACCESSED\:mm.h}
{\xe \v mm.h\:PAGE_ACCESSED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_ACCESSED{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
\cell }{\cell }{\row }
{\xe \v PAGE_DIRTY\:mm.h}
{\xe \v mm.h\:PAGE_DIRTY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_DIRTY{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
\cell }{\cell }{\row }
{\xe \v PAGE_PS\:mm.h}
{\xe \v mm.h\:PAGE_PS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_PS{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
\cell }{\cell }{\row }
{\xe \v PAGE_GLOBAL\:mm.h}
{\xe \v mm.h\:PAGE_GLOBAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_GLOBAL{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
\cell }{\cell }{\row }
{\xe \v PAGE_NX\:mm.h}
{\xe \v mm.h\:PAGE_NX}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PAGE_NX{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 267} of file {\b mm.h}.}\par
}
{\xe \v _PFN_FLAGS\:mm.h}
{\xe \v mm.h\:_PFN_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PFN_FLAGS}}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PFN_FLAG_NONE\:mm.h}
{\xe \v mm.h\:PFN_FLAG_NONE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PFN_FLAG_NONE{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
\cell }{\cell }{\row }
{\xe \v PFN_FLAG_NONPAGED\:mm.h}
{\xe \v mm.h\:PFN_FLAG_NONPAGED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PFN_FLAG_NONPAGED{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
\cell }{\cell }{\row }
{\xe \v PFN_FLAG_COPY_ON_WRITE\:mm.h}
{\xe \v mm.h\:PFN_FLAG_COPY_ON_WRITE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PFN_FLAG_COPY_ON_WRITE{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
\cell }{\cell }{\row }
{\xe \v PFN_FLAG_MAPPED_FILE\:mm.h}
{\xe \v mm.h\:PFN_FLAG_MAPPED_FILE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PFN_FLAG_MAPPED_FILE{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
\cell }{\cell }{\row }
{\xe \v PFN_FLAG_LOCKED_FOR_IO\:mm.h}
{\xe \v mm.h\:PFN_FLAG_LOCKED_FOR_IO}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PFN_FLAG_LOCKED_FOR_IO{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 249} of file {\b mm.h}.}\par
}
{\xe \v _PFN_STATE\:mm.h}
{\xe \v mm.h\:_PFN_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PFN_STATE}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PfnStateActive\:mm.h}
{\xe \v mm.h\:PfnStateActive}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateActive{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
\cell }{\cell }{\row }
{\xe \v PfnStateStandby\:mm.h}
{\xe \v mm.h\:PfnStateStandby}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateStandby{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
\cell }{\cell }{\row }
{\xe \v PfnStateModified\:mm.h}
{\xe \v mm.h\:PfnStateModified}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateModified{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
\cell }{\cell }{\row }
{\xe \v PfnStateFree\:mm.h}
{\xe \v mm.h\:PfnStateFree}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateFree{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
\cell }{\cell }{\row }
{\xe \v PfnStateZeroed\:mm.h}
{\xe \v mm.h\:PfnStateZeroed}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateZeroed{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
\cell }{\cell }{\row }
{\xe \v PfnStateTransition\:mm.h}
{\xe \v mm.h\:PfnStateTransition}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateTransition{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
\cell }{\cell }{\row }
{\xe \v PfnStateBad\:mm.h}
{\xe \v mm.h\:PfnStateBad}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PfnStateBad{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 238} of file {\b mm.h}.}\par
}
{\xe \v _POOL_TYPE\:mm.h}
{\xe \v mm.h\:_POOL_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _POOL_TYPE}}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NonPagedPool\:mm.h}
{\xe \v mm.h\:NonPagedPool}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NonPagedPool{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
\cell }{\cell }{\row }
{\xe \v PagedPool\:mm.h}
{\xe \v mm.h\:PagedPool}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PagedPool{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
\cell }{\cell }{\row }
{\xe \v NonPagedPoolCacheAligned\:mm.h}
{\xe \v mm.h\:NonPagedPoolCacheAligned}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NonPagedPoolCacheAligned{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
\cell }{\cell }{\row }
{\xe \v PagedPoolCacheAligned\:mm.h}
{\xe \v mm.h\:PagedPoolCacheAligned}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PagedPoolCacheAligned{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
\cell }{\cell }{\row }
{\xe \v NonPagedPoolNx\:mm.h}
{\xe \v mm.h\:NonPagedPoolNx}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NonPagedPoolNx{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
\cell }{\cell }{\row }
{\xe \v PagedPoolNx\:mm.h}
{\xe \v mm.h\:PagedPoolNx}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PagedPoolNx{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 315} of file {\b mm.h}.}\par
}
{\xe \v _PRIVILEGE_MODE\:mm.h}
{\xe \v mm.h\:_PRIVILEGE_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PRIVILEGE_MODE}}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v KernelMode\:mm.h}
{\xe \v mm.h\:KernelMode}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid KernelMode{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
\cell }{\cell }{\row }
{\xe \v UserMode\:mm.h}
{\xe \v mm.h\:UserMode}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid UserMode{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 332} of file {\b mm.h}.}\par
}
{\xe \v _SYSTEM_PHASE_ROUTINE\:mm.h}
{\xe \v mm.h\:_SYSTEM_PHASE_ROUTINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _SYSTEM_PHASE_ROUTINE}}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v SYSTEM_PHASE_INITIALIZE_ALL\:mm.h}
{\xe \v mm.h\:SYSTEM_PHASE_INITIALIZE_ALL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SYSTEM_PHASE_INITIALIZE_ALL{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
\cell }{\cell }{\row }
{\xe \v SYSTEM_PHASE_INITIALIZE_PAT_ONLY\:mm.h}
{\xe \v mm.h\:SYSTEM_PHASE_INITIALIZE_PAT_ONLY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SYSTEM_PHASE_INITIALIZE_PAT_ONLY{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 374} of file {\b mm.h}.}\par
}
{\xe \v _VAD_FLAGS\:mm.h}
{\xe \v mm.h\:_VAD_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _VAD_FLAGS}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v VAD_FLAG_NONE\:mm.h}
{\xe \v mm.h\:VAD_FLAG_NONE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_NONE{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
\cell }{\cell }{\row }
{\xe \v VAD_FLAG_READ\:mm.h}
{\xe \v mm.h\:VAD_FLAG_READ}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_READ{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
\cell }{\cell }{\row }
{\xe \v VAD_FLAG_WRITE\:mm.h}
{\xe \v mm.h\:VAD_FLAG_WRITE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_WRITE{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
\cell }{\cell }{\row }
{\xe \v VAD_FLAG_EXECUTE\:mm.h}
{\xe \v mm.h\:VAD_FLAG_EXECUTE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_EXECUTE{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
\cell }{\cell }{\row }
{\xe \v VAD_FLAG_PRIVATE\:mm.h}
{\xe \v mm.h\:VAD_FLAG_PRIVATE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_PRIVATE{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
\cell }{\cell }{\row }
{\xe \v VAD_FLAG_MAPPED_FILE\:mm.h}
{\xe \v mm.h\:VAD_FLAG_MAPPED_FILE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_MAPPED_FILE{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
\cell }{\cell }{\row }
{\xe \v VAD_FLAG_COPY_ON_WRITE\:mm.h}
{\xe \v mm.h\:VAD_FLAG_COPY_ON_WRITE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid VAD_FLAG_COPY_ON_WRITE{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 257} of file {\b mm.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v kmemcmp\:mm.h}
{\xe \v mm.h\:kmemcmp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int kmemcmp (const void * s1, const void * s2, size_t n)}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 566} of file {\b mm.h}.}\par
}
{\xe \v kmemcpy\:mm.h}
{\xe \v mm.h\:kmemcpy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * kmemcpy (void * dest, const void * src, size_t len)}}
\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 554} of file {\b mm.h}.}\par
}
{\xe \v kmemset\:mm.h}
{\xe \v mm.h\:kmemset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * kmemset (void * dest, int64_t val, uint64_t len)}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 540} of file {\b mm.h}.}\par
}
{\xe \v MiAllocatePoolVa\:mm.h}
{\xe \v mm.h\:MiAllocatePoolVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MiAllocatePoolVa ({\b IN} {\b POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes)}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b va.c}.}\par
}
{\xe \v MiAtomicExchangePte\:mm.h}
{\xe \v mm.h\:MiAtomicExchangePte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MiAtomicExchangePte ({\b PMMPTE} PtePtr, uint64_t NewPteValue)}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 651} of file {\b mm.h}.}\par
}
{\xe \v MiCacheToFlags\:mm.h}
{\xe \v mm.h\:MiCacheToFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t MiCacheToFlags ({\b MEMORY_CACHING_TYPE} type)}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 587} of file {\b mm.h}.}\par
}
{\xe \v MiCheckForContigiousMemory\:mm.h}
{\xe \v mm.h\:MiCheckForContigiousMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MiCheckForContigiousMemory ({\b IN} void * StartAddress, {\b IN} size_t NumberOfBytes)}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mmio.c}.}\par
}
{\xe \v MiCreateKernelStack\:mm.h}
{\xe \v mm.h\:MiCreateKernelStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MiCreateKernelStack ({\b IN} bool LargeStack)}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mmproc.c}.}\par
}
{\xe \v MiFindVad\:mm.h}
{\xe \v mm.h\:MiFindVad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMVAD} MiFindVad ({\b IN} {\b PMMVAD} Root, {\b IN} uintptr_t VirtualAddress)}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 354} of file {\b vad.c}.}\par
}
{\xe \v MiFreeKernelStack\:mm.h}
{\xe \v mm.h\:MiFreeKernelStack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiFreeKernelStack ({\b IN} void * AllocatedStackTop, {\b IN} bool LargeStack)}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 148} of file {\b mmproc.c}.}\par
}
{\xe \v MiFreePoolVaContiguous\:mm.h}
{\xe \v mm.h\:MiFreePoolVaContiguous}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiFreePoolVaContiguous ({\b IN} uintptr_t va, {\b IN} size_t NumberOfBytes, {\b IN} {\b POOL_TYPE} PoolType)}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 367} of file {\b va.c}.}\par
}
{\xe \v MiGetPdePointer\:mm.h}
{\xe \v mm.h\:MiGetPdePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPdePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b map.c}.}\par
}
{\xe \v MiGetPdptePointer\:mm.h}
{\xe \v mm.h\:MiGetPdptePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPdptePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b map.c}.}\par
}
{\xe \v MiGetPml4ePointer\:mm.h}
{\xe \v mm.h\:MiGetPml4ePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPml4ePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b map.c}.}\par
}
{\xe \v MiGetPtePointer\:mm.h}
{\xe \v mm.h\:MiGetPtePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PMMPTE} MiGetPtePointer ({\b IN} uintptr_t va)}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b map.c}.}\par
}
{\xe \v MiInitializePfnDatabase\:mm.h}
{\xe \v mm.h\:MiInitializePfnDatabase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MiInitializePfnDatabase ({\b IN} {\b PBOOT_INFO} BootInfo)}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b pfn.c}.}\par
}
{\xe \v MiInitializePoolSystem\:mm.h}
{\xe \v mm.h\:MiInitializePoolSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MiInitializePoolSystem (void )}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b pool.c}.}\par
}
{\xe \v MiInitializePoolVaSpace\:mm.h}
{\xe \v mm.h\:MiInitializePoolVaSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MiInitializePoolVaSpace (void )}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b va.c}.}\par
}
{\xe \v MiInvalidateTlbForVa\:mm.h}
{\xe \v mm.h\:MiInvalidateTlbForVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiInvalidateTlbForVa ({\b IN} void * VirtualAddress)}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 273} of file {\b map.c}.}\par
}
{\xe \v MiIsValidPfn\:mm.h}
{\xe \v mm.h\:MiIsValidPfn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool MiIsValidPfn ({\b IN} {\b PAGE_INDEX} Pfn)}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 667} of file {\b mm.h}.}\par
}
{\xe \v MiMapPageInHyperspace\:mm.h}
{\xe \v mm.h\:MiMapPageInHyperspace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MiMapPageInHyperspace ({\b IN} uint64_t PfnIndex, {\b OUT} {\b PIRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b hypermap.c}.}\par
}
{\xe \v MiMoveUefiDataToHigherHalf\:mm.h}
{\xe \v mm.h\:MiMoveUefiDataToHigherHalf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiMoveUefiDataToHigherHalf ({\b IN} {\b PBOOT_INFO} BootInfo)}}
\par
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b mminit.c}.}\par
}
{\xe \v MiReleasePhysicalPage\:mm.h}
{\xe \v mm.h\:MiReleasePhysicalPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiReleasePhysicalPage ({\b IN} {\b PAGE_INDEX} PfnIndex)}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 421} of file {\b pfn.c}.}\par
}
{\xe \v MiReloadTLBs\:mm.h}
{\xe \v mm.h\:MiReloadTLBs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiReloadTLBs (void )}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 443} of file {\b map.c}.}\par
}
{\xe \v MiRequestPhysicalPage\:mm.h}
{\xe \v mm.h\:MiRequestPhysicalPage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGE_INDEX} MiRequestPhysicalPage ({\b IN} {\b PFN_STATE} ListType)}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 325} of file {\b pfn.c}.}\par
}
{\xe \v MiRetrieveLastFaultyAddress\:mm.h}
{\xe \v mm.h\:MiRetrieveLastFaultyAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t MiRetrieveLastFaultyAddress (void )}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 641} of file {\b mm.h}.}\par
}
{\xe \v MiRetrieveOperationFromErrorCode\:mm.h}
{\xe \v mm.h\:MiRetrieveOperationFromErrorCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b FAULT_OPERATION} MiRetrieveOperationFromErrorCode (uint64_t ErrorCode)}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 619} of file {\b mm.h}.}\par
}
{\xe \v MiTranslatePteToPfn\:mm.h}
{\xe \v mm.h\:MiTranslatePteToPfn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGE_INDEX} MiTranslatePteToPfn ({\b IN} {\b PMMPTE} pte)}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 310} of file {\b map.c}.}\par
}
{\xe \v MiTranslatePteToVa\:mm.h}
{\xe \v mm.h\:MiTranslatePteToVa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t MiTranslatePteToVa ({\b IN} {\b PMMPTE} pte)}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 337} of file {\b map.c}.}\par
}
{\xe \v MiTranslateVirtualToPhysical\:mm.h}
{\xe \v mm.h\:MiTranslateVirtualToPhysical}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MiTranslateVirtualToPhysical ({\b IN} void * VirtualAddress)}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 456} of file {\b map.c}.}\par
}
{\xe \v MiUnlinkPageFromList\:mm.h}
{\xe \v mm.h\:MiUnlinkPageFromList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiUnlinkPageFromList ({\b PPFN_ENTRY} pfn)}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 486} of file {\b pfn.c}.}\par
}
{\xe \v MiUnmapHyperSpaceMap\:mm.h}
{\xe \v mm.h\:MiUnmapHyperSpaceMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiUnmapHyperSpaceMap ({\b IN} {\b IRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b hypermap.c}.}\par
}
{\xe \v MiUnmapPte\:mm.h}
{\xe \v mm.h\:MiUnmapPte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MiUnmapPte ({\b IN} {\b PMMPTE} pte)}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 385} of file {\b map.c}.}\par
}
{\xe \v MmAccessFault\:mm.h}
{\xe \v mm.h\:MmAccessFault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmAccessFault ({\b IN} uint64_t FaultBits, {\b IN} uint64_t VirtualAddress, {\b IN} {\b PRIVILEGE_MODE} PreviousMode, {\b IN} {\b PTRAP_FRAME} TrapFrame)}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b fault.c}.}\par
}
{\xe \v MmAllocateContigiousMemory\:mm.h}
{\xe \v mm.h\:MmAllocateContigiousMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MmAllocateContigiousMemory ({\b IN} size_t NumberOfBytes, {\b IN} uint64_t HighestAcceptableAddress)}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b mmio.c}.}\par
}
{\xe \v MmAllocatePoolWithTag\:mm.h}
{\xe \v mm.h\:MmAllocatePoolWithTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MmAllocatePoolWithTag ({\b IN} enum {\b _POOL_TYPE} PoolType, {\b IN} size_t NumberOfBytes, {\b IN} uint32_t Tag)}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 427} of file {\b pool.c}.}\par
}
{\xe \v MmAllocateVirtualMemory\:mm.h}
{\xe \v mm.h\:MmAllocateVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmAllocateVirtualMemory ({\b IN} {\b PEPROCESS} Process, {\b _In_Opt} {\b _Out_Opt} void ** BaseAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b VAD_FLAGS} VadFlags)}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 723} of file {\b vad.c}.}\par
}
{\xe \v MmCreateProcessAddressSpace\:mm.h}
{\xe \v mm.h\:MmCreateProcessAddressSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmCreateProcessAddressSpace ({\b OUT} void ** DirectoryTable)}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b mmproc.c}.}\par
}
{\xe \v MmFindFreeAddressSpace\:mm.h}
{\xe \v mm.h\:MmFindFreeAddressSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmFindFreeAddressSpace ({\b IN} {\b PEPROCESS} Process, {\b IN} size_t NumberOfBytes, {\b IN} uintptr_t SearchStart, {\b IN} uintptr_t SearchEnd)}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 708} of file {\b vad.c}.}\par
}
{\xe \v MmFreeContigiousMemory\:mm.h}
{\xe \v mm.h\:MmFreeContigiousMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MmFreeContigiousMemory ({\b IN} void * BaseAddress, {\b IN} size_t NumberOfBytes)}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b mmio.c}.}\par
}
{\xe \v MmFreePool\:mm.h}
{\xe \v mm.h\:MmFreePool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MmFreePool ({\b IN} void * buf)}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 586} of file {\b pool.c}.}\par
}
{\xe \v MmFreeVirtualMemory\:mm.h}
{\xe \v mm.h\:MmFreeVirtualMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MmFreeVirtualMemory ({\b IN} {\b PEPROCESS} Process, {\b IN} void * BaseAddress)}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 817} of file {\b vad.c}.}\par
}
{\xe \v MmInitSystem\:mm.h}
{\xe \v mm.h\:MmInitSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmInitSystem ({\b IN} uint8_t Phase, {\b IN} {\b PBOOT_INFO} BootInformation)}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b mminit.c}.}\par
}
{\xe \v MmInvalidAccessAllowed\:mm.h}
{\xe \v mm.h\:MmInvalidAccessAllowed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmInvalidAccessAllowed (void )}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 292} of file {\b fault.c}.}\par
}
{\xe \v MmIsAddressPresent\:mm.h}
{\xe \v mm.h\:MmIsAddressPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmIsAddressPresent ({\b IN} uintptr_t VirtualAddress)}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 488} of file {\b map.c}.}\par
}
{\xe \v MmMapIoSpace\:mm.h}
{\xe \v mm.h\:MmMapIoSpace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * MmMapIoSpace ({\b IN} uintptr_t PhysicalAddress, {\b IN} size_t NumberOfBytes, {\b IN} {\b MEMORY_CACHING_TYPE} CacheType)}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 269} of file {\b mmio.c}.}\par
}
{\xe \v pml4_from_recursive\:mm.h}
{\xe \v mm.h\:pml4_from_recursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t * pml4_from_recursive (void )}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b map.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v MmHighestPfn\:mm.h}
{\xe \v mm.h\:MmHighestPfn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PAGE_INDEX} MmHighestPfn{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b pfn.c}.}\par
}
{\xe \v MmHighestUserAddress\:mm.h}
{\xe \v mm.h\:MmHighestUserAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmHighestUserAddress{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b process.c}.}\par
}
{\xe \v MmNonPagedPoolEnd\:mm.h}
{\xe \v mm.h\:MmNonPagedPoolEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmNonPagedPoolEnd{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b pool.c}.}\par
}
{\xe \v MmNonPagedPoolStart\:mm.h}
{\xe \v mm.h\:MmNonPagedPoolStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmNonPagedPoolStart{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b pool.c}.}\par
}
{\xe \v MmPagedPoolEnd\:mm.h}
{\xe \v mm.h\:MmPagedPoolEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmPagedPoolEnd{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b pool.c}.}\par
}
{\xe \v MmPagedPoolStart\:mm.h}
{\xe \v mm.h\:MmPagedPoolStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmPagedPoolStart{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b pool.c}.}\par
}
{\xe \v MmPfnDatabaseInitialized\:mm.h}
{\xe \v mm.h\:MmPfnDatabaseInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MmPfnDatabaseInitialized{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b pfn.c}.}\par
}
{\xe \v MmSystemRangeStart\:mm.h}
{\xe \v mm.h\:MmSystemRangeStart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmSystemRangeStart{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b process.c}.}\par
}
{\xe \v MmUserProbeAddress\:mm.h}
{\xe \v mm.h\:MmUserProbeAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uintptr_t MmUserProbeAddress{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b process.c}.}\par
}
{\xe \v PfnDatabase\:mm.h}
{\xe \v mm.h\:PfnDatabase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MM_PFN_DATABASE} PfnDatabase{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b pfn.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mm.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mm.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mm.h}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_MEMORY_H}\par
00002 {\cf21 #define X86_MATANEL_MEMORY_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     mm.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files required for memory management (virtual, physical, PFN, VAD, MMIO, init, etc.)}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf20 // Base Includes}\par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stdbool.h>}\par
00025 {\cf21 #include "annotations.h"}\par
00026 {\cf21 #include "macros.h"}\par
00027 {\cf21 #include "../mtstatus.h"}\par
00028 {\cf21 #include "../intrinsics/intrin.h"}\par
00029 {\cf21 #include "../intrinsics/atomic.h"}\par
00030 \par
00031 {\cf20 // Needed for linked list and spinlocks}\par
00032 {\cf21 #include "ms.h"}\par
00033 {\cf21 #include "core.h"}\par
00034 {\cf21 #include "efi.h"}\par
00035 \par
00036 {\cf20 // ------------------ HEADER SPECIFIC MACROS ------------------}\par
00037 \par
00038 {\cf21 #define PML4_INDEX_BITS   9}\par
00039 {\cf21 #define PML4_INDEX_SHIFT  39}\par
00040 {\cf21 #define PML4_INDEX_MASK   ((1ULL << PML4_INDEX_BITS) - 1ULL)}\par
00041 \par
00042 {\cf21 #define PML4_INDEX_FROM_VA(VA) ( ( (uintptr_t)(VA) >> PML4_INDEX_SHIFT ) & PML4_INDEX_MASK )}\par
00043 \par
00044 {\cf20 /* If PhysicalMemoryOffset is the kernel VA base that maps physical 0:}\par
00045 {\cf20    index in PML4 for physical address PHYS is the index of (PHYS + PhysicalMemoryOffset) */}\par
00046 {\cf21 #define PML4_INDEX_FROM_PHYS(PHYS) PML4_INDEX_FROM_VA( (uintptr_t)(PHYS) + (uintptr_t)PhysicalMemoryOffset )}\par
00047 \par
00048    {\cf20 /* safer typed helper */}\par
00049 {\cf17 static} {\cf17 inline} {\cf18 int} MiConvertVaToPml4Offset(uint64_t va) \{\par
00050     {\cf19 return} ({\cf18 int})((va >> PML4_INDEX_SHIFT) & PML4_INDEX_MASK);\par
00051 \}\par
00052 \par
00053 {\cf21 #define VirtualPageSize 4096ULL }{\cf20 // Same as each physical frame.}\par
00054 {\cf21 #define PhysicalFrameSize 4096ULL }{\cf20 // Each physical frame.}\par
00055 {\cf21 #define KernelVaStart 0xfffff80000000000ULL}\par
00056 {\cf21 #define PhysicalMemoryOffset 0xffff880000000000ULL }{\cf20 // Defines the offset in arithmetic for quick mapping}\par
00057 {\cf21 #define RECURSIVE_INDEX 0x1FF}\par
00058 \par
00059 {\cf21 #ifndef __INTELLISENSE__}\par
00060 {\cf21 #ifndef __OFFSET_GENERATOR__}\par
00061 {\cf20 /* Convert a PFN index to a PPFN_ENTRY pointer */}\par
00062 {\cf21 #define INDEX_TO_PPFN(Index) \\}\par
00063 {\cf21     (&(PfnDatabase.PfnEntries[(size_t)(Index)]))}\par
00064 {\cf21 #define PHYSICAL_TO_PPFN(PHYS) \\}\par
00065 {\cf21     (&PfnDatabase.PfnEntries[(size_t)((PHYS) / (uint64_t)PhysicalFrameSize)])}\par
00066 {\cf21 #define PTE_TO_PHYSICAL(PMMPTE) ((PMMPTE)->Value & ~0xFFFULL)}\par
00067 {\cf20 /* single-CPU build (no IPI shootdown code) */}\par
00068 {\cf21 #ifdef MT_UP}\par
00069 \par
00070 {\cf21 #define MI_WRITE_PTE(_PtePointer, _Va, _Pa, _Flags)                         \\}\par
00071 {\cf21 do \{                                                                        \\}\par
00072 {\cf21     MMPTE* _pte = (MMPTE*)(_PtePointer);                                    \\}\par
00073 {\cf21     uint64_t _val = (((uintptr_t)(_Pa)) & ~0xFFFULL) | (uint64_t)(_Flags);  \\}\par
00074 {\cf21     MiAtomicExchangePte(_pte, _val);                                        \\}\par
00075 {\cf21     __asm__ volatile("" ::: "memory");                                      \\}\par
00076 {\cf21                                                                             \\}\par
00077 {\cf21     }{\cf20 /* Only set PFN->PTE link if PFN database is initialized */}{\cf21              \\}\par
00078 {\cf21     if (MmPfnDatabaseInitialized) \{                                         \\}\par
00079 {\cf21         PPFN_ENTRY _pfn = PHYSICAL_TO_PPFN(_Pa);                            \\}\par
00080 {\cf21         _pfn->Descriptor.Mapping.PteAddress = (PMMPTE)_pte;                 \\}\par
00081 {\cf21         _pfn->State = PfnStateActive;                                       \\}\par
00082 {\cf21         _pfn->Flags = PFN_FLAG_NONPAGED;                                    \\}\par
00083 {\cf21     \}                                                                       \\}\par
00084 {\cf21                                                                             \\}\par
00085 {\cf21     invlpg((void*)(uintptr_t)(_Va));                                        \\}\par
00086 {\cf21 \} while (0)}\par
00087 \par
00088 {\cf21 #else }{\cf20 /* MP / SMP build: include TLB shootdown via IPI */}{\cf21 }\par
00089 \par
00090 {\cf21 #define MI_WRITE_PTE(_PtePointer, _Va, _Pa, _Flags)                         \\}\par
00091 {\cf21 do \{                                                                        \\}\par
00092 {\cf21     MMPTE* _pte = (MMPTE*)(_PtePointer);                                    \\}\par
00093 {\cf21     uint64_t _val = (((uintptr_t)(_Pa)) & ~0xFFFULL) | (uint64_t)(_Flags);  \\}\par
00094 {\cf21     MiAtomicExchangePte(_pte, _val);                                        \\}\par
00095 {\cf21     __asm__ volatile("" ::: "memory");                                      \\}\par
00096 {\cf21                                                                             \\}\par
00097 {\cf21     }{\cf20 /* Only set PFN->PTE link if PFN database is initialized */}{\cf21              \\}\par
00098 {\cf21     if (MmPfnDatabaseInitialized) \{                                         \\}\par
00099 {\cf21         PPFN_ENTRY _pfn = PHYSICAL_TO_PPFN(_Pa);                            \\}\par
00100 {\cf21         _pfn->Descriptor.Mapping.PteAddress = (PMMPTE)_pte;                 \\}\par
00101 {\cf21         _pfn->State = PfnStateActive;                                       \\}\par
00102 {\cf21         _pfn->Flags = PFN_FLAG_NONPAGED;                                    \\}\par
00103 {\cf21     \}                                                                       \\}\par
00104 {\cf21                                                                             \\}\par
00105 {\cf21     invlpg((void*)(uintptr_t)(_Va));                                        \\}\par
00106 {\cf21                                                                             \\}\par
00107 {\cf21     }{\cf20 /* Send IPIs if SMP is initialized */}{\cf21                                    \\}\par
00108 {\cf21     if (smpInitialized && allApsInitialized) \{                              \\}\par
00109 {\cf21         IPI_PARAMS _Params;                                                 \\}\par
00110 {\cf21         _Params.pageParams.addressToInvalidate = (uint64_t)(_Va);          \\}\par
00111 {\cf21         MhSendActionToCpusAndWait(CPU_ACTION_PERFORM_TLB_SHOOTDOWN, _Params);\\}\par
00112 {\cf21     \}                                                                       \\}\par
00113 {\cf21 \} while (0)}\par
00114 \par
00115 {\cf21 #endif}\par
00116 {\cf21 #define PPFN_TO_INDEX(PPFN) ((size_t)((PPFN) - PfnDatabase.PfnEntries))}\par
00117 {\cf21 #define PPFN_TO_PHYSICAL_ADDRESS(PPFN) \\}\par
00118 {\cf21     ((uint64_t)((uint64_t)PPFN_TO_INDEX(PPFN) * (uint64_t)PhysicalFrameSize))}\par
00119 {\cf21 #define VA_OFFSET(_VirtualAddress) ((uintptr_t)(_VirtualAddress) & 0xFFF)}\par
00120 {\cf21 #define MM_IS_DEMAND_ZERO_PTE(pte) \\}\par
00121 {\cf21     (((pte).Soft.SoftwareFlags & MI_DEMAND_ZERO_BIT) != 0)}\par
00122 {\cf21 #define MM_SET_DEMAND_ZERO_PTE(pte, prot_flags, nx)  \\}\par
00123 {\cf21     do \{ \\}\par
00124 {\cf21         (pte).Value = 0; \\}\par
00125 {\cf21         (pte).Soft.SoftwareFlags = (prot_flags) | MI_DEMAND_ZERO_BIT; \\}\par
00126 {\cf21         (pte).Soft.NoExecute = (nx); \\}\par
00127 {\cf21     \} while(0)}\par
00128 {\cf21 #define MM_UNSET_DEMAND_ZERO_PTE(pte) \\}\par
00129 {\cf21     do \{ \\}\par
00130 {\cf21         (pte).Soft.SoftwareFlags &= ~MI_DEMAND_ZERO_BIT; \\}\par
00131 {\cf21     \} while(0)}\par
00132 {\cf21 #endif}\par
00133 {\cf21 #else}\par
00134 {\cf21 #define PTE_TO_PHYSICAL(PMMPTE) (0)}\par
00135 {\cf21 #define MI_WRITE_PTE(_PtePointer, _Va, _Pa, _Flags) ((void)0)}\par
00136 {\cf21 #define PPFN_TO_INDEX(PPFN) (0)}\par
00137 {\cf21 #define PPFN_TO_PHYSICAL_ADDRESS(PPFN) (0)}\par
00138 {\cf21 #define INDEX_TO_PPFN(Index) (NULL)}\par
00139 {\cf21 #define PHYSICAL_TO_PPFN(PHYS) (NULL)}\par
00140 {\cf21 #define VA_OFFSET(_VirtualAddress) (uintptr_t)(NULL)}\par
00141 {\cf21 #define MM_IS_DEMAND_ZERO_PTE(pte) (NULL)}\par
00142 {\cf21 #define MM_SET_DEMAND_ZERO_PTE(pte, prot_flags, nx) ((void)0)}\par
00143 {\cf21 #define MM_UNSET_DEMAND_ZERO_PTE(pte) (NULL)}\par
00144 {\cf21 #endif}\par
00145 \par
00146 {\cf20 // Convert bytes to pages (rounding up)}\par
00147 {\cf21 #define BYTES_TO_PAGES(Bytes) (((Bytes) + VirtualPageSize - 1) / VirtualPageSize)}\par
00148 {\cf20 // Convert pages to bytes}\par
00149 {\cf21 #define PAGES_TO_BYTES(Pages) ((Pages) * VirtualPageSize)}\par
00150 \par
00151 {\cf21 #define MAX_POOL_DESCRIPTORS 7 }{\cf20 // Allows for: 32, 64, 128, 256, 512, 1024, 2048 Bytes Per pool}\par
00152 {\cf21 #define _32KB_POOL 1}\par
00153 {\cf21 #define _64KB_POOL 2}\par
00154 {\cf21 #define _128KB_POOL 3}\par
00155 {\cf21 #define _256KB_POOL 4}\par
00156 {\cf21 #define _512KB_POOL 5}\par
00157 {\cf21 #define _1024KB_POOL 6}\par
00158 {\cf21 #define _2048KB_POOL 7}\par
00159 {\cf21 #define POOL_MIN_ALLOC 32}\par
00160 {\cf21 #define USER_VA_END 0x00007FFFFFFFFFFF}\par
00161 {\cf21 #define USER_VA_START 0x10000}\par
00162 {\cf20 // You are allowed to request bytes above max allocation, the global pool would be used.}\par
00163 {\cf21 #define POOL_MAX_ALLOC 2048}\par
00164 {\cf20 // Pool sizes}\par
00165 {\cf21 #define MI_NONPAGED_POOL_SIZE ((size_t)16ULL * 1024 * 1024 * 1024)  }{\cf20 // 16 GiB}\par
00166 {\cf21 #define MI_PAGED_POOL_SIZE ((size_t)32ULL * 1024 * 1024 * 1024)     }{\cf20 // 32 GiB}\par
00167 \par
00168 {\cf20 // Total pages in each pool}\par
00169 {\cf21 #define NONPAGED_POOL_VA_TOTAL_PAGES (MI_NONPAGED_POOL_SIZE / VirtualPageSize)}\par
00170 {\cf21 #define PAGED_POOL_VA_TOTAL_PAGES (MI_PAGED_POOL_SIZE / VirtualPageSize)}\par
00171 \par
00172 {\cf20 // Bitmap QWORDs}\par
00173 {\cf21 #define NONPAGED_POOL_VA_BITMAP_QWORDS ((NONPAGED_POOL_VA_TOTAL_PAGES + 63) / 64)}\par
00174 {\cf21 #define PAGED_POOL_VA_BITMAP_QWORDS ((PAGED_POOL_VA_TOTAL_PAGES + 63) / 64)}\par
00175 \par
00176 {\cf20 // Number of pages needed for each bitmap (page-aligned)}\par
00177 {\cf21 #define MI_NONPAGED_BITMAP_PAGES_NEEDED ((NONPAGED_POOL_VA_BITMAP_QWORDS * sizeof(uint64_t) + VirtualPageSize - 1) / VirtualPageSize)}\par
00178 {\cf21 #define MI_PAGED_BITMAP_PAGES_NEEDED ((PAGED_POOL_VA_BITMAP_QWORDS * sizeof(uint64_t) + VirtualPageSize - 1) / VirtualPageSize)}\par
00179 \par
00180 {\cf20 // Alignment helper}\par
00181 {\cf21 #define ALIGN_UP(x, align) (((uintptr_t)(x) + ((align)-1)) & ~((uintptr_t)((align)-1)))}\par
00182 \par
00183 {\cf20 // Bitmap memory allocations (physical pages)}\par
00184 {\cf21 #define MI_NONPAGED_BITMAP_BASE  ALIGN_UP(LK_KERNEL_END, VirtualPageSize)}\par
00185 {\cf21 #define MI_NONPAGED_BITMAP_END   (MI_NONPAGED_BITMAP_BASE + MI_NONPAGED_BITMAP_PAGES_NEEDED * VirtualPageSize)}\par
00186 \par
00187 {\cf21 #define MI_PAGED_BITMAP_BASE ALIGN_UP(MI_NONPAGED_BITMAP_END, VirtualPageSize)}\par
00188 {\cf21 #define MI_PAGED_BITMAP_END (MI_PAGED_BITMAP_BASE + MI_PAGED_BITMAP_PAGES_NEEDED * VirtualPageSize)}\par
00189 \par
00190 {\cf20 // Pool virtual address ranges (page-aligned)}\par
00191 {\cf21 #define MI_NONPAGED_POOL_BASE    ALIGN_UP(MI_NONPAGED_BITMAP_END, VirtualPageSize)}\par
00192 {\cf21 #define MI_NONPAGED_POOL_END     (MI_NONPAGED_POOL_BASE + MI_NONPAGED_POOL_SIZE)}\par
00193 \par
00194 {\cf21 #define MI_PAGED_POOL_BASE ALIGN_UP(MI_NONPAGED_POOL_END, VirtualPageSize)}\par
00195 {\cf21 #define MI_PAGED_POOL_END (MI_PAGED_POOL_BASE + MI_PAGED_POOL_SIZE)}\par
00196 \par
00197 {\cf20 // Address Manipulation And Checks}\par
00198 {\cf21 #define MI_IS_CANONICAL_ADDR(va) \\}\par
00199 {\cf21 (\{ \\}\par
00200 {\cf21     uint64_t _va = (uint64_t)(va); \\}\par
00201 {\cf21     uint64_t _mask = ~((1ULL << 48) - 1); }{\cf20 /* bits 63:48 */}{\cf21  \\}\par
00202 {\cf21     ((_va & _mask) == 0 || (_va & _mask) == _mask); \\}\par
00203 {\cf21 \})}\par
00204 \par
00205 {\cf21 #define PFN_TO_PHYS(Pfn) PPFN_TO_PHYSICAL_ADDRESS(INDEX_TO_PPFN(Pfn))}\par
00206 {\cf21 #define PHYS_TO_INDEX(PhysicalAddress) PPFN_TO_INDEX(PHYSICAL_TO_PPFN(PhysicalAddress))}\par
00207 \par
00208 {\cf21 #define PFN_ERROR UINT64_T_MAX}\par
00209 \par
00210 {\cf20 // Lazy allocations macros}\par
00211 {\cf21 #define PROT_KERNEL_READ  0x1}\par
00212 {\cf21 #define PROT_KERNEL_WRITE 0x2}\par
00213 {\cf21 #define MI_DEMAND_ZERO_BIT   (1ULL << 16)}\par
00214 \par
00215 {\cf20 // Tags}\par
00216 {\cf21 #define MM_POOL_CANARY 'BEKA'}\par
00217 \par
00218 {\cf20 // Stack sizes & protections.}\par
00219 {\cf21 #define MI_STACK_SIZE 0x4000 }{\cf20 // 16KiB}\par
00220 {\cf21 #define MI_LARGE_STACK_SIZE 0xf000 }{\cf20 // 60 KiB}\par
00221 {\cf21 #define MI_GUARD_PAGE_PROTECTION (1ULL << 17)}\par
00222 \par
00223 {\cf20 // Barriers}\par
00224 \par
00225 {\cf20 // Prevents CPU Reordering as well as the MmBarrier functionality.}\par
00226 {\cf21 #define MmFullBarrier() __sync_synchronize()}\par
00227 \par
00228 {\cf20 // Ensure ordedring of memory operations (memory should be visible before continuing)}\par
00229 {\cf21 #define MmBarrier() __asm__ __volatile__("mfence" ::: "memory")}\par
00230 \par
00231 {\cf20 // ------------------ TYPE DEFINES ------------------}\par
00232 {\cf17 typedef} uint64_t PAGE_INDEX;\par
00233 \par
00234 {\cf21 #define MmIsAddressValid(VirtualAddress) MmIsAddressPresent(VirtualAddress)}\par
00235 \par
00236 {\cf20 // ------------------ ENUMERATORS ------------------}\par
00237 \par
00238 {\cf17 typedef} {\cf17 enum} _PFN_STATE \{\par
00239     PfnStateActive,         {\cf20 // Actively mapped in a process (RefCount > 0)}\par
00240     PfnStateStandby,        {\cf20 // Clean, in RAM, not mapped (RefCount == 0)}\par
00241     PfnStateModified,       {\cf20 // Dirty, in RAM, not mapped (RefCount == 0)}\par
00242     PfnStateFree,           {\cf20 // Contents are garbage (RefCount == 0)}\par
00243     PfnStateZeroed,         {\cf20 // Contents are all zeros (RefCount == 0)}\par
00244     PfnStateTransition,     {\cf20 // Locked for I/O (e.g being paged in/out)}\par
00245     PfnStateBad             {\cf20 // Unusable (hardware error)}\par
00246 \} PFN_STATE;\par
00247 \par
00248 {\cf20 // Page FLAGS (attributes that can be combined)}\par
00249 {\cf17 typedef} {\cf17 enum} _PFN_FLAGS \{\par
00250     PFN_FLAG_NONE = 0,\par
00251     PFN_FLAG_NONPAGED = (1U << 0),    {\cf20 // This PFN holds a nonpaged virtual address (not backed by a file), BIT 3 must NOT be set if this bit is active.}\par
00252     PFN_FLAG_COPY_ON_WRITE = (1U << 1), {\cf20 // This is a COW page}\par
00253     PFN_FLAG_MAPPED_FILE = (1U << 2), {\cf20 // Backed by a file (not swap)}\par
00254     PFN_FLAG_LOCKED_FOR_IO = (1U << 3)  {\cf20 // Page is pinned for DMA, etc.}\par
00255 \} PFN_FLAGS;\par
00256 \par
00257 {\cf17 typedef} {\cf17 enum} _VAD_FLAGS \{\par
00258     VAD_FLAG_NONE = 0,\par
00259     VAD_FLAG_READ = (1U << 0),\par
00260     VAD_FLAG_WRITE = (1U << 1),\par
00261     VAD_FLAG_EXECUTE = (1U << 2),\par
00262     VAD_FLAG_PRIVATE = (1U << 3),     {\cf20 // Private (backed by swap file, like pagefile.mtsys)}\par
00263     VAD_FLAG_MAPPED_FILE = (1U << 4), {\cf20 // Backed by a file (lets say data.mtdll)}\par
00264     VAD_FLAG_COPY_ON_WRITE = (1U << 5)\par
00265 \} VAD_FLAGS;\par
00266 \par
00267 {\cf17 typedef} {\cf17 enum} _PAGE_FLAGS \{\par
00268     PAGE_PRESENT = 1 << 0,  {\cf20 // Bit 0}\par
00269     {\cf20 // 0 = page not present (access causes page fault)}\par
00270     {\cf20 // 1 = page is present, MMU translates virtual addresses}\par
00271 \par
00272     PAGE_RW = 1 << 1,  {\cf20 // Bit 1}\par
00273     {\cf20 // 0 = read-only}\par
00274     {\cf20 // 1 = read/write}\par
00275 \par
00276     PAGE_USER = 1 << 2,  {\cf20 // Bit 2}\par
00277     {\cf20 // 0 = supervisor (kernel) only}\par
00278     {\cf20 // 1 = user-mode access allowed}\par
00279 \par
00280     PAGE_PWT = 0x8,     {\cf20 // Bit 3}\par
00281     {\cf20 // Page Write-Through}\par
00282     {\cf20 // 0 = write-back caching}\par
00283     {\cf20 // 1 = write-through caching}\par
00284 \par
00285     PAGE_PCD = 0x10,    {\cf20 // Bit 4}\par
00286     {\cf20 // Page Cache Disable}\par
00287     {\cf20 // 0 = cacheable}\par
00288     {\cf20 // 1 = cache disabled}\par
00289 \par
00290     PAGE_ACCESSED = 0x20,    {\cf20 // Bit 5}\par
00291     {\cf20 // Set by CPU when page is read or written}\par
00292 \par
00293     PAGE_DIRTY = 0x40,    {\cf20 // Bit 6}\par
00294     {\cf20 // Set by CPU when page is written to}\par
00295 \par
00296     PAGE_PS = 0x80,    {\cf20 // Bit 7}\par
00297     {\cf20 // Page Size}\par
00298     {\cf20 // 0 = normal 4KB page}\par
00299     {\cf20 // 1 = large page (4MB in PDE, 2MB in PTE for PAE/long mode)}\par
00300 \par
00301 {\cf21 #define PAGE_PAT  (1ULL << 7)}\par
00302     {\cf20 // PAGE_PAT, Look at MEMORY_CACHING_TYPE enum.}\par
00303 \par
00304     PAGE_GLOBAL = 0x100,   {\cf20 // Bit 8}\par
00305     {\cf20 // Global page}\par
00306     {\cf20 // Not flushed from TLB on CR3 reload}\par
00307 \par
00308     PAGE_NX = (1ULL << 63) {\cf20 // Bit 63}\par
00309     {\cf20 // No-Execute region}\par
00310     {\cf20 // Execution cannot happen in this page.}\par
00311 \} PAGE_FLAGS;\par
00312 \par
00313 {\cf20 // NonPagedPools - Allocations occur at max DISPATCH_LEVEL (inclusive). (e.g assert(IRQL == DISPATCH/PASSIVE/APC_LEVEL)}\par
00314 {\cf20 // PagedPools - Allocations occur at max DISPATCH_LEVEL (exclusive) (e.g assert(IRQL == PASSIVE/APC_LEVEL)}\par
00315 {\cf17 typedef} {\cf17 enum} _POOL_TYPE \{\par
00316     NonPagedPool = 0,                 {\cf20 // Non-pageable kernel pool (instant map, available at all IRQLs)}\par
00317     PagedPool = 1,                    {\cf20 // Pageable pool (can only be used when IRQL < DISPATCH_LEVEL).}\par
00318     NonPagedPoolCacheAligned = 2,     {\cf20 // Non-paged, cache-aligned (UNIMPLEMENTED)}\par
00319     PagedPoolCacheAligned = 3,        {\cf20 // Paged, cache-aligned (UNIMPLEMENTED)}\par
00320     NonPagedPoolNx = 4,               {\cf20 // Non-paged, non-executable (NX) (UNIMPLEMENTED)}\par
00321     PagedPoolNx = 5,                  {\cf20 // Paged, non-executable (UNIMPLEMENTED)}\par
00322     {\cf20 // No MustSucceeds, these are a bad concept, handle errors gracefully.}\par
00323 \} POOL_TYPE;\par
00324 \par
00325 {\cf17 typedef} {\cf17 enum} _FAULT_OPERATION \{\par
00326     FaultOpInvalid = -1,\par
00327     ReadOperation = 0,\par
00328     WriteOperation = 2,\par
00329     ExecuteOperation = 10,\par
00330 \} FAULT_OPERATION, *PFAULT_OPERATION;\par
00331 \par
00332 {\cf17 typedef} {\cf17 enum} _PRIVILEGE_MODE \{\par
00333     KernelMode = 0,\par
00334     UserMode = 1\par
00335 \} PRIVILEGE_MODE, * PPRIVILEGE_MODE;\par
00336 \par
00337 {\cf17 typedef} {\cf17 enum} _MEMORY_CACHING_TYPE \{\par
00338 \par
00339     MmNonCached = 0,           {\cf20 // UC  (Uncacheable)}\par
00340     {\cf20 // CPU never caches reads/writes.}\par
00341     {\cf20 // Every access goes directly to RAM or device.}\par
00342     {\cf20 // Most MMIO devices require this.}\par
00343 \par
00344     MmCached,                  {\cf20 // WB  (Write-Back) (default)}\par
00345     {\cf20 // Normal DRAM caching behavior.}\par
00346     {\cf20 // Reads/writes go through CPU caches; writes may be delayed.}\par
00347     {\cf20 // Fastest and default for regular memory.}\par
00348 \par
00349     MmWriteCombined,           {\cf20 // WC  (Write-Combining)}\par
00350     {\cf20 // Writes are buffered and combined, NOT cached.}\par
00351     {\cf20 // Ideal for framebuffers / GPUs.}\par
00352     {\cf20 // Fast sequential writes; CPU collects them and bursts to memory.}\par
00353 \par
00354     MmWriteThrough,            {\cf20 // WT  (Write-Through)}\par
00355     {\cf20 // Reads are cached, but writes go straight to memory.}\par
00356     {\cf20 // Ensures memory is always coherent but slower for writes.}\par
00357     {\cf20 // Rarely used today.}\par
00358 \par
00359     MmNonCachedUnordered,      {\cf20 // UC- (Uncacheable Minus)}\par
00360     {\cf20 // Similar to UC but allows some reordering and speculative reads.}\par
00361     {\cf20 // Safe for some device memory but not all.}\par
00362     {\cf20 // Used mostly by OSes for special mappings.}\par
00363 \par
00364     MmUSWCCached,              {\cf20 // USWC (Uncached Speculative Write Combining)}\par
00365     {\cf20 // Read = UC-, Write = WC.}\par
00366     {\cf20 // Used for some high-end GPU/PCIe devices.}\par
00367     {\cf20 // Allows speculative reads + write-combined writes.}\par
00368 \par
00369     MmHardwareCoherentCached,  {\cf20 // WB or WT depending on device}\par
00370     {\cf20 // For coherent DMA-capable devices.}\par
00371     {\cf20 // Typically WB unless device explicitly requires WT.}\par
00372 \} MEMORY_CACHING_TYPE;\par
00373 \par
00374 {\cf17 typedef} {\cf17 enum} _SYSTEM_PHASE_ROUTINE \{\par
00375     SYSTEM_PHASE_INITIALIZE_ALL = 1,\par
00376     SYSTEM_PHASE_INITIALIZE_PAT_ONLY = 2,\par
00377 \} SYSTEM_PHASE_ROUTINE;\par
00378 \par
00379 {\cf20 // ------------------ STRUCTURES ------------------}\par
00380 \par
00381 {\cf17 typedef} {\cf17 struct }_MMPTE\par
00382 \{\par
00383     {\cf17 union}\par
00384     \{\par
00385         uint64_t Value; {\cf20 // Raw 64-bit PTE value}\par
00386 \par
00387         {\cf20 //}\par
00388         {\cf20 // Hardware format when the page is present in memory}\par
00389         {\cf20 //}\par
00390         {\cf17 struct}\par
00391         \{\par
00392             uint64_t Present : 1;         {\cf20 // 1 = Present}\par
00393             uint64_t Write : 1;           {\cf20 // Writable}\par
00394             uint64_t User : 1;            {\cf20 // User-accessible}\par
00395             uint64_t WriteThrough : 1;    {\cf20 // Write-through cache}\par
00396             uint64_t CacheDisable : 1;    {\cf20 // Disable caching}\par
00397             uint64_t Accessed : 1;        {\cf20 // Set by CPU when accessed}\par
00398             uint64_t Dirty : 1;           {\cf20 // Set by CPU when written}\par
00399             uint64_t LargePage : 1;       {\cf20 // Large page flag (2MB/1GB) (valid only in PDE)}\par
00400             uint64_t Global : 1;          {\cf20 // Global TLB entry}\par
00401             uint64_t CopyOnWrite : 1;     {\cf20 // Software: copy-on-write}\par
00402             uint64_t Prototype : 1;       {\cf20 // Software: prototype PTE (section)}\par
00403             uint64_t Reserved0 : 1;       {\cf20 // Unused or software-available}\par
00404             uint64_t PageFrameNumber : 40;{\cf20 // Physical page frame number}\par
00405             uint64_t Reserved1 : 11;      {\cf20 // Reserved by hardware}\par
00406             uint64_t NoExecute : 1;       {\cf20 // NX bit}\par
00407         \} Hard;\par
00408 \par
00409         {\cf20 //}\par
00410         {\cf20 // Software format when not present}\par
00411         {\cf20 // (Paged out / transition / pagefile / prototype)}\par
00412         {\cf20 //}\par
00413         {\cf17 struct}\par
00414         \{\par
00415             uint64_t Present : 1;            {\cf20 // 0 = Not present}\par
00416             uint64_t Write : 1;              {\cf20 // Meaning depends on context}\par
00417             uint64_t Transition : 1;         {\cf20 // 1 = Page is in transition (has PFN) (used for StandBy List)}\par
00418             uint64_t Prototype : 1;          {\cf20 // 1 = Prototype PTE (mapped section)}\par
00419             uint64_t PageFile : 1;           {\cf20 // 1 = Paged to disk (pagefile)}\par
00420             uint64_t Reserved : 7;           {\cf20 // i'm sorry, h.c}\par
00421             uint64_t PageFrameNumber : 32;   {\cf20 // Pagefile offset or PFN (if transition)}\par
00422             uint64_t SoftwareFlags : 20;     {\cf20 // e.g. protection mask, pool type}\par
00423             uint64_t NoExecute : 1;          {\cf20 // NX still meaningful in software}\par
00424         \} Soft;\par
00425     \};\par
00426 \} MMPTE, * PMMPTE;\par
00427 \par
00428 {\cf17 typedef} {\cf17 struct }_PFN_ENTRY \{\par
00429     {\cf17 volatile} uint32_t RefCount;     {\cf20 // Atomic Reference Count}\par
00430     uint8_t State;                  {\cf20 // PFN_STATE of this Page.}\par
00431     uint8_t Flags;                  {\cf20 // Bitfield of PFN_FLAGS}\par
00432     {\cf20 // The Descriptor of the PFN (contains mapping data, the doubly linked list, and file offset, all that depend on the State)}\par
00433     {\cf17 union }\{\par
00434         {\cf20 // State: PfnStateFree, PfnStateZeroed, }\par
00435         {\cf20 // PfnStateStandby, PfnStateModified (Used when - INACTIVE)}\par
00436         {\cf17 struct }_DOUBLY_LINKED_LIST ListEntry;\par
00437 \par
00438         {\cf20 // State: PfnStateActive (this is the reverse mapping information) (Used when - ACTIVE, IN USE)}\par
00439         {\cf17 struct }\{\par
00440             {\cf17 struct }_MMVAD* Vad;  {\cf20 // Pointer to VAD in memory. (might not always be in use)}\par
00441             PMMPTE PteAddress; {\cf20 // Pointer to PTE in memory. (is always valid when in use)}\par
00442         \} Mapping;\par
00443 \par
00444         {\cf20 // State: PfnStateStandby or PfnStateModified (for file backed pages) (Used when - SEMI-ACTIVE, PAGED TO DISK, NOT IN CURRENT USE)}\par
00445         uint64_t FileOffset; {\cf20 // Offset of 4KiB pages in pagefile.mtsys}\par
00446 \par
00447     \} Descriptor;\par
00448 \} PFN_ENTRY, *PPFN_ENTRY;\par
00449 \par
00450 {\cf17 typedef} {\cf17 struct }_MM_PFN_LIST \{\par
00451     {\cf17 struct }_DOUBLY_LINKED_LIST ListEntry;       {\cf20 // List Head}\par
00452     {\cf17 volatile} uint64_t Count;                    {\cf20 // Number of pages in this list.}\par
00453     SPINLOCK PfnListLock;                       {\cf20 // Spinlock for each PFN List to ensure atomicity.}\par
00454 \} MM_PFN_LIST;\par
00455 \par
00456 {\cf17 typedef} {\cf17 struct }_MM_PFN_DATABASE \{\par
00457     PPFN_ENTRY PfnEntries;  {\cf20 // Pointer to base of the PFN_ENTRY array.}\par
00458     {\cf18 size_t} TotalPageCount;  {\cf20 // Total count of pages in the PFN database.}\par
00459     SPINLOCK PfnDatabaseLock; {\cf20 // Global spinlock for adding/popping memory.}\par
00460 \par
00461     {\cf20 // Page lists}\par
00462     MM_PFN_LIST FreePageList;   {\cf20 // Pages with garbage data.}\par
00463     MM_PFN_LIST ZeroedPageList; {\cf20 // Pages pre-filled with zeros for optimization purposes.}\par
00464     MM_PFN_LIST StandbyPageList; {\cf20 // Clean pages, candidates for reuse. (used for loading processes fast)}\par
00465     MM_PFN_LIST ModifiedPageList; {\cf20 // Dirty pages, must be written to disk for backing.}\par
00466     MM_PFN_LIST BadPageList;    {\cf20 // List of bad memory pages}\par
00467 \par
00468     {\cf20 // Statistics}\par
00469     {\cf17 volatile} {\cf18 size_t} AvailablePages; {\cf20 // Free + Zeroed + Standby}\par
00470     {\cf17 volatile} {\cf18 size_t} TotalReserved;  {\cf20 // Kernel, drivers, etc.}\par
00471 \} MM_PFN_DATABASE;\par
00472 \par
00473 {\cf17 typedef} {\cf17 struct }_MMVAD \{\par
00474     uintptr_t StartVa; {\cf20 // Starting Virtual Address.}\par
00475     uintptr_t EndVa;   {\cf20 // Ending Virtual Address.}\par
00476     VAD_FLAGS Flags;   {\cf20 // VAD_FLAGS Bitfield}\par
00477     \par
00478     {\cf20 // VAD Are per process, stored in an AVL.}\par
00479     {\cf17 struct }_MMVAD* LeftChild;\par
00480     {\cf17 struct }_MMVAD* RightChild;\par
00481     {\cf17 struct }_MMVAD* Parent;\par
00482 \par
00483     {\cf20 // Height of the node in the tree.}\par
00484     {\cf18 int} Height;\par
00485 \par
00486     {\cf20 // If VAD_FLAG_MAPPED_FILE bit is set.}\par
00487     {\cf17 struct }_FILE_OBJECT* File;  {\cf20 // Pointer to file object.}\par
00488     uint64_t FileOffset;    {\cf20 // Offset into the file this region starts in.}\par
00489 \par
00490     {\cf20 // Pointer to owner process.}\par
00491     {\cf17 struct }_EPROCESS* OwningProcess;\par
00492 \} MMVAD, *PMMVAD;\par
00493 \par
00494 {\cf17 typedef} {\cf17 struct }_POOL_HEADER\par
00495 \{\par
00496     uint32_t PoolCanary; {\cf20 // Must always be equal to - 'BEKA'}\par
00497     {\cf17 union}\par
00498     \{\par
00499         {\cf20 // When the block is FREE, it's part of a list.}\par
00500         SINGLE_LINKED_LIST FreeListEntry;\par
00501 \par
00502         {\cf20 // When the block is ALLOCATED, we store actual metadata info.}\par
00503         {\cf17 struct}\par
00504         \{\par
00505             uint16_t BlockSize;  {\cf20 // Size of this block}\par
00506             uint16_t PoolIndex;  {\cf20 // Index of the slab it came from}\par
00507         \};\par
00508     \} Metadata;\par
00509     uint32_t PoolTag; {\cf20 // Tag of pool. (default - 'ADIR')}\par
00510 \} POOL_HEADER, * PPOOL_HEADER;\par
00511 \par
00512 {\cf17 typedef} {\cf17 struct }_POOL_DESCRIPTOR \{\par
00513     SINGLE_LINKED_LIST FreeListHead;    {\cf20 // Head of the free list}\par
00514     {\cf18 size_t} BlockSize;                   {\cf20 // The size of the block + header (so if this is a 32 byte slab, it would be (32 + sizeof(POOL_HEADER))}\par
00515     {\cf17 volatile} uint64_t FreeCount;        {\cf20 // Number of blocks on the free list}\par
00516     {\cf17 volatile} uint64_t TotalBlocks;      {\cf20 // Total blocks ever allocated (statistics)}\par
00517     SPINLOCK PoolLock;                  {\cf20 // Spinlock for this specific pool descriptor.}\par
00518 \} POOL_DESCRIPTOR, *PPOOL_DESCRIPTOR;\par
00519 \par
00520 {\cf20 // ------------------ FUNCTIONS ------------------}\par
00521 \par
00522 {\cf17 extern} MM_PFN_DATABASE PfnDatabase; {\cf20 // Database defined in 'pfn.c'}\par
00523 {\cf20 // Global Declarations for signals & constants.}\par
00524 {\cf17 extern} {\cf18 bool} MmPfnDatabaseInitialized;\par
00525 {\cf17 extern} PAGE_INDEX MmHighestPfn;\par
00526 {\cf17 extern} uintptr_t MmSystemRangeStart;\par
00527 {\cf17 extern} uintptr_t MmHighestUserAddress;\par
00528 {\cf17 extern} uintptr_t MmUserProbeAddress;\par
00529 {\cf17 extern} uintptr_t MmNonPagedPoolStart;\par
00530 {\cf17 extern} uintptr_t MmNonPagedPoolEnd;\par
00531 {\cf17 extern} uintptr_t MmPagedPoolStart;\par
00532 {\cf17 extern} uintptr_t MmPagedPoolEnd;\par
00533 \par
00534 {\cf20 // general functions}\par
00535 uint64_t* pml4_from_recursive({\cf18 void});\par
00536 \par
00537 {\cf20 // Memory Set.}\par
00538 FORCEINLINE\par
00539 {\cf18 void}* \par
00540 kmemset (\par
00541     {\cf18 void}* dest, int64_t val, uint64_t len\par
00542 ) \par
00543 \{\par
00544     uint8_t* ptr = dest;\par
00545     {\cf19 for} ({\cf18 size_t} i = 0; i < (size_t)len; i++) \{\par
00546         ptr[i] = (uint8_t)val;\par
00547     \}\par
00548     {\cf19 return} dest;\par
00549 \}\par
00550 \par
00551 {\cf20 // Memory copy  }\par
00552 FORCEINLINE\par
00553 {\cf18 void}* \par
00554 kmemcpy(\par
00555     {\cf18 void}* dest, {\cf17 const} {\cf18 void}* src, {\cf18 size_t} len\par
00556 ) \par
00557 \{\par
00558     uint8_t* d = (uint8_t*)dest;\par
00559     {\cf17 const} uint8_t* s = ({\cf17 const} uint8_t*)src;\par
00560     {\cf19 for} ({\cf18 size_t} i = 0; i < len; i++) d[i] = s[i];\par
00561     {\cf19 return} dest;\par
00562 \}\par
00563 \par
00564 FORCEINLINE\par
00565 {\cf18 int} \par
00566 kmemcmp(\par
00567     {\cf17 const} {\cf18 void}* s1, {\cf17 const} {\cf18 void}* s2, {\cf18 size_t} n\par
00568 ) \par
00569 \{\par
00570     {\cf17 const} uint8_t* p1 = ({\cf17 const} uint8_t*)s1;\par
00571     {\cf17 const} uint8_t* p2 = ({\cf17 const} uint8_t*)s2;\par
00572 \par
00573     {\cf19 for} ({\cf18 size_t} i = 0; i < n; i++) \{\par
00574         {\cf19 if} (p1[i] != p2[i])\par
00575             {\cf19 return} ({\cf18 int})(p1[i] - p2[i]);\par
00576     \}\par
00577     {\cf19 return} 0;\par
00578 \}\par
00579 \par
00580 {\cf18 void}\par
00581 MiReloadTLBs(\par
00582     {\cf18 void}\par
00583 );\par
00584 \par
00585 FORCEINLINE\par
00586 uint64_t \par
00587 MiCacheToFlags(MEMORY_CACHING_TYPE type)\par
00588 \{\par
00589     {\cf19 switch} (type)\par
00590     \{\par
00591     {\cf19 case} MmCached:                 {\cf20 // WB}\par
00592         {\cf19 return} 0;\par
00593 \par
00594     {\cf19 case} MmWriteThrough:           {\cf20 // WT}\par
00595         {\cf19 return} PAGE_PWT;\par
00596 \par
00597     {\cf19 case} MmNonCached:              {\cf20 // UC}\par
00598         {\cf19 return} PAGE_PCD | PAGE_PWT;\par
00599 \par
00600     {\cf19 case} MmWriteCombined:          {\cf20 // WC}\par
00601         {\cf19 return} PAGE_PAT;           {\cf20 // (Index 5)}\par
00602 \par
00603     {\cf19 case} MmNonCachedUnordered:     {\cf20 // UC-}\par
00604         {\cf19 return} PAGE_PAT | PAGE_PCD; {\cf20 // (Index 6)}\par
00605 \par
00606     {\cf19 case} MmUSWCCached:             {\cf20 // USWC (UC- reads + WC writes)}\par
00607         {\cf19 return} PAGE_PAT | PAGE_PWT; {\cf20 // (Index 7 = UC, but write behavior is WC)}\par
00608 \par
00609     {\cf19 case} MmHardwareCoherentCached: {\cf20 // Usually WB; fallback WT if required}\par
00610         {\cf19 return} 0;\par
00611 \par
00612     {\cf19 default}:\par
00613         {\cf19 return} 0;\par
00614     \}\par
00615 \}\par
00616 \par
00617 FORCEINLINE\par
00618 FAULT_OPERATION\par
00619 MiRetrieveOperationFromErrorCode(\par
00620     uint64_t ErrorCode\par
00621 )\par
00622 \par
00623 \{\par
00624     FAULT_OPERATION operation;\par
00625 \par
00626     {\cf19 if} (ErrorCode & (1 << 4)) \{\par
00627         operation = ExecuteOperation; {\cf20 // Execute (NX Fault) (NX Bit set, and CPU attempted execution on an instruction with it present.)}\par
00628     \}\par
00629     {\cf19 else} {\cf19 if} (ErrorCode & (1 << 1)) \{\par
00630         operation = WriteOperation; {\cf20 // Write fault (read only page \\ not present)}\par
00631     \}\par
00632     {\cf19 else} \{\par
00633         operation = ReadOperation; {\cf20 // Read Fault (not present?)}\par
00634     \}\par
00635     \par
00636     {\cf19 return} operation;\par
00637 \}\par
00638 \par
00639 FORCEINLINE\par
00640 uint64_t\par
00641 MiRetrieveLastFaultyAddress(\par
00642     {\cf18 void}\par
00643 )\par
00644 \par
00645 \{\par
00646     {\cf19 return} __read_cr2();\par
00647 \}\par
00648 \par
00649 FORCEINLINE\par
00650 {\cf18 void}\par
00651 MiAtomicExchangePte(\par
00652     PMMPTE PtePtr,\par
00653     uint64_t NewPteValue\par
00654 )\par
00655 \par
00656 \{\par
00657     InterlockedExchangeU64(({\cf17 volatile} uint64_t*)PtePtr, NewPteValue);\par
00658 \}\par
00659 \par
00660 {\cf18 void}\par
00661 MiInvalidateTlbForVa(\par
00662     IN {\cf18 void}* VirtualAddress\par
00663 );\par
00664 \par
00665 FORCEINLINE\par
00666 {\cf18 bool}\par
00667 MiIsValidPfn(\par
00668     IN PAGE_INDEX Pfn\par
00669 )\par
00670 \par
00671 \{\par
00672     {\cf19 return} Pfn <= MmHighestPfn;\par
00673 \}\par
00674 \par
00675 {\cf20 // module: pfn.c}\par
00676 \par
00677 MTSTATUS\par
00678 MiInitializePfnDatabase(\par
00679     IN  PBOOT_INFO BootInfo\par
00680 );\par
00681 \par
00682 PAGE_INDEX\par
00683 MiRequestPhysicalPage(\par
00684     IN  PFN_STATE ListType\par
00685 );\par
00686 \par
00687 {\cf18 void}\par
00688 MiReleasePhysicalPage(\par
00689     IN  PAGE_INDEX PfnIndex\par
00690 );\par
00691 \par
00692 {\cf18 void}\par
00693 MiUnlinkPageFromList(\par
00694     PPFN_ENTRY pfn\par
00695 );\par
00696 \par
00697 {\cf20 // module: map.c}\par
00698 \par
00699 PMMPTE\par
00700 MiGetPml4ePointer(\par
00701     IN  uintptr_t va\par
00702 );\par
00703 \par
00704 PMMPTE\par
00705 MiGetPdptePointer(\par
00706     IN  uintptr_t va\par
00707 );\par
00708 \par
00709 PMMPTE\par
00710 MiGetPdePointer(\par
00711     IN  uintptr_t va\par
00712 );\par
00713 \par
00714 PMMPTE\par
00715 MiGetPtePointer(\par
00716     IN  uintptr_t va\par
00717 );\par
00718 \par
00719 uint64_t\par
00720 MiTranslatePteToVa(\par
00721     IN PMMPTE pte\par
00722 );\par
00723 \par
00724 PAGE_INDEX\par
00725 MiTranslatePteToPfn(\par
00726     IN  PMMPTE pte\par
00727 );\par
00728 \par
00729 uintptr_t\par
00730 MiTranslateVirtualToPhysical(\par
00731     IN {\cf18 void}* VirtualAddress\par
00732 );\par
00733 \par
00734 {\cf18 void}\par
00735 MiUnmapPte(\par
00736     IN  PMMPTE pte\par
00737 );\par
00738 \par
00739 {\cf18 bool}\par
00740 MmIsAddressPresent(\par
00741     IN  uintptr_t VirtualAddress\par
00742 );\par
00743 \par
00744 {\cf20 // module: hypermap.c}\par
00745 \par
00746 {\cf18 void}*\par
00747 MiMapPageInHyperspace(\par
00748     IN  uint64_t PfnIndex,\par
00749     OUT  PIRQL OldIrql\par
00750 );\par
00751 \par
00752 {\cf18 void}\par
00753 MiUnmapHyperSpaceMap(\par
00754     IN  IRQL OldIrql\par
00755 );\par
00756 \par
00757 {\cf20 // module: pool.c}\par
00758 \par
00759 MTSTATUS\par
00760 MiInitializePoolSystem(\par
00761     {\cf18 void}\par
00762 );\par
00763 \par
00764 {\cf20 // Only NonPagedPool and PagedPool are implemented out of the POOL_TYPE enumerator.}\par
00765 {\cf18 void}*\par
00766 MmAllocatePoolWithTag(\par
00767     IN {\cf17 enum} _POOL_TYPE PoolType,\par
00768     IN  {\cf18 size_t} NumberOfBytes,\par
00769     IN  uint32_t Tag\par
00770 );\par
00771 \par
00772 {\cf18 void}\par
00773 MmFreePool(\par
00774     IN  {\cf18 void}* buf\par
00775 );\par
00776 \par
00777 {\cf20 // module: mmproc.c}\par
00778 \par
00779 {\cf18 void}*\par
00780 MiCreateKernelStack(\par
00781     IN  {\cf18 bool} LargeStack\par
00782 );\par
00783 \par
00784 {\cf18 void}\par
00785 MiFreeKernelStack(\par
00786     IN {\cf18 void}* AllocatedStackTop,\par
00787     IN {\cf18 bool} LargeStack\par
00788 );\par
00789 \par
00790 MTSTATUS\par
00791 MmCreateProcessAddressSpace(\par
00792     OUT {\cf18 void}** DirectoryTable\par
00793 );\par
00794 \par
00795 {\cf20 // module: vad.c}\par
00796 \par
00797 MTSTATUS\par
00798 MmAllocateVirtualMemory(\par
00799     IN PEPROCESS Process,\par
00800     _In_Opt _Out_Opt {\cf18 void}** BaseAddress,\par
00801     IN {\cf18 size_t} NumberOfBytes,\par
00802     IN VAD_FLAGS VadFlags\par
00803 );\par
00804 \par
00805 MTSTATUS\par
00806 {\cf20 // TODO Free with explicit size, split vad if needed.}\par
00807 MmFreeVirtualMemory(\par
00808     IN PEPROCESS Process,\par
00809     IN {\cf18 void}* BaseAddress\par
00810 );\par
00811 \par
00812 PMMVAD\par
00813 MiFindVad(\par
00814     IN  PMMVAD Root,\par
00815     IN  uintptr_t VirtualAddress\par
00816 );\par
00817 \par
00818 {\cf18 void}\par
00819 MiMoveUefiDataToHigherHalf(\par
00820     IN PBOOT_INFO BootInfo\par
00821 );\par
00822 \par
00823 uintptr_t\par
00824 MmFindFreeAddressSpace(\par
00825     IN  PEPROCESS Process,\par
00826     IN  {\cf18 size_t} NumberOfBytes,\par
00827     IN  uintptr_t SearchStart,\par
00828     IN  uintptr_t SearchEnd    {\cf20 // exclusive}\par
00829 );\par
00830 \par
00831 {\cf20 // module: va.c}\par
00832 \par
00833 {\cf18 bool}\par
00834 MiInitializePoolVaSpace(\par
00835     {\cf18 void}\par
00836 );\par
00837 \par
00838 uintptr_t\par
00839 MiAllocatePoolVa(\par
00840     IN  POOL_TYPE PoolType,\par
00841     IN  {\cf18 size_t} NumberOfBytes\par
00842 );\par
00843 \par
00844 {\cf18 void}\par
00845 MiFreePoolVaContiguous(\par
00846     IN  uintptr_t va,\par
00847     IN  {\cf18 size_t} NumberOfBytes,\par
00848     IN  POOL_TYPE PoolType\par
00849 );\par
00850 \par
00851 {\cf20 // module: fault.c}\par
00852 \par
00853 MTSTATUS\par
00854 MmAccessFault(\par
00855     IN  uint64_t FaultBits,\par
00856     IN  uint64_t VirtualAddress,\par
00857     IN  PRIVILEGE_MODE PreviousMode,\par
00858     IN  PTRAP_FRAME TrapFrame\par
00859 );\par
00860 \par
00861 {\cf18 bool}\par
00862 MmInvalidAccessAllowed(\par
00863     {\cf18 void}\par
00864 );\par
00865 \par
00866 {\cf20 // module: mmio.c}\par
00867 \par
00868 {\cf18 bool}\par
00869 MiCheckForContigiousMemory(\par
00870     IN {\cf18 void}* StartAddress,\par
00871     IN {\cf18 size_t} NumberOfBytes\par
00872 );\par
00873 \par
00874 {\cf18 void}*\par
00875 MmAllocateContigiousMemory(\par
00876     IN  {\cf18 size_t} NumberOfBytes,\par
00877     IN  uint64_t HighestAcceptableAddress\par
00878 );\par
00879 \par
00880 {\cf18 void}\par
00881 MmFreeContigiousMemory(\par
00882     IN  {\cf18 void}* BaseAddress,\par
00883     IN  {\cf18 size_t} NumberOfBytes\par
00884 );\par
00885 \par
00886 {\cf18 void}*\par
00887 MmMapIoSpace(\par
00888     IN uintptr_t PhysicalAddress,\par
00889     IN {\cf18 size_t} NumberOfBytes,\par
00890     IN MEMORY_CACHING_TYPE CacheType\par
00891 );\par
00892 \par
00893 {\cf20 // module: mminit.c}\par
00894 \par
00895 {\cf18 bool}\par
00896 MmInitSystem(\par
00897     IN uint8_t Phase,\par
00898     IN PBOOT_INFO BootInformation\par
00899 );\par
00900 \par
00901 {\cf20 // module: oom.c}\par
00902 \par
00903 {\cf20 // TODO OOM KILLER, TO USE WHEN 0 PHYSICAL MEMORY IS AVAILABLE, AND PAGING TO DISK EVEN FAILED.}\par
00904 \par
00905 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ms.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ms.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ms.h}
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "../mtstatus.h"}\par
{\f2 #include "annotations.h"}\par
{\f2 #include "core.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _SPINLOCK}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _RUNDOWN_REF}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _Queue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EVENT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _MUTEX}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _SPINLOCK} {\b SPINLOCK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _SPINLOCK} * {\b PSPINLOCK}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _RUNDOWN_REF} {\b RUNDOWN_REF}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _RUNDOWN_REF} * {\b PRUNDOWN_REF}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _Queue} {\b Queue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _EVENT_TYPE} {\b EVENT_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EVENT} {\b EVENT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EVENT} * {\b PEVENT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MUTEX} {\b MUTEX}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _MUTEX} * {\b PMUTEX}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _EVENT_TYPE} \{ {\b NotificationEvent}
, {\b SynchronizationEvent}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsAcquireSpinlock} ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b PIRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsReleaseSpinlock} ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b IRQL} OldIrql)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsInitializeMutexObject} ({\b IN} {\b PMUTEX} mut)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsAcquireMutexObject} ({\b IN} {\b PMUTEX} mut)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsReleaseMutexObject} ({\b IN} {\b PMUTEX} mut)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MsAcquireRundownProtection} ({\b IN} {\b PRUNDOWN_REF} rundown)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsReleaseRundownProtection} ({\b IN} {\b PRUNDOWN_REF} rundown)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsWaitForRundownProtectionRelease} ({\b IN} {\b PRUNDOWN_REF} rundown)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsSetEvent} ({\b IN} {\b PEVENT} event)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b MsWaitForEvent} ({\b IN} {\b PEVENT} event)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsAcquireSpinlockAtDpcLevel} ({\b IN} {\b PSPINLOCK} Lock)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsReleaseSpinlockFromDpcLevel} ({\b IN} {\b PSPINLOCK} Lock)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b InitializeListHead} ({\b PDOUBLY_LINKED_LIST} Head)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b InsertTailList} ({\b PDOUBLY_LINKED_LIST} Head, {\b PDOUBLY_LINKED_LIST} Entry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b InsertHeadList} ({\b PDOUBLY_LINKED_LIST} Head, {\b PDOUBLY_LINKED_LIST} Entry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PDOUBLY_LINKED_LIST} {\b RemoveHeadList} ({\b PDOUBLY_LINKED_LIST} Head)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b RemoveEntryList} ({\b PDOUBLY_LINKED_LIST} Entry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b InterlockedPushEntry} ({\b PSINGLE_LINKED_LIST} *ListHeadPtr, {\b PSINGLE_LINKED_LIST} Entry)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PSINGLE_LINKED_LIST} {\b InterlockedPopEntry} ({\b PSINGLE_LINKED_LIST} *ListHeadPtr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v EVENT\:ms.h}
{\xe \v ms.h\:EVENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EVENT} {\b EVENT}}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EVENT} - kernel event object{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Embedded {\b SPINLOCK} and {\b Queue} for waiting threads. \par}
}}
{\xe \v EVENT_TYPE\:ms.h}
{\xe \v ms.h\:EVENT_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _EVENT_TYPE} {\b EVENT_TYPE}}}
\par
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EVENT_TYPE} - controls wake behavior \par
}}
{\xe \v MUTEX\:ms.h}
{\xe \v ms.h\:MUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MUTEX} {\b MUTEX}}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MUTEX} - Mutual exclusion.\par
Used to sleep instead of busy waiting, used in non critical paths (e.g {\b IRQL} < DISPATCH_LEVEL) \par
}}
{\xe \v PEVENT\:ms.h}
{\xe \v ms.h\:PEVENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EVENT} * {\b PEVENT}}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PMUTEX\:ms.h}
{\xe \v ms.h\:PMUTEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _MUTEX} * {\b PMUTEX}}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PRUNDOWN_REF\:ms.h}
{\xe \v ms.h\:PRUNDOWN_REF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _RUNDOWN_REF} * {\b PRUNDOWN_REF}}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PSPINLOCK\:ms.h}
{\xe \v ms.h\:PSPINLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _SPINLOCK} * {\b PSPINLOCK}}}
\par
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Queue\:ms.h}
{\xe \v ms.h\:Queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _Queue} {\b Queue}}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RUNDOWN_REF\:ms.h}
{\xe \v ms.h\:RUNDOWN_REF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _RUNDOWN_REF} {\b RUNDOWN_REF}}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rundown Reference Protection.\par
Used to protect current acquisition of destruction, for example, acquiring a rundown protection on a PROCESS or a Thread to assert they will not be destroyed during modification. \par
}}
{\xe \v SPINLOCK\:ms.h}
{\xe \v ms.h\:SPINLOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _SPINLOCK} {\b SPINLOCK}}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b SPINLOCK} - a tiny embedded spinlock representation.\par
Implementation note: keep this embedded (not a pointer) inside structures. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _EVENT_TYPE\:ms.h}
{\xe \v ms.h\:_EVENT_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _EVENT_TYPE}}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b EVENT_TYPE} - controls wake behavior \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v NotificationEvent\:ms.h}
{\xe \v ms.h\:NotificationEvent}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid NotificationEvent{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
\cell }{\cell }{\row }
{\xe \v SynchronizationEvent\:ms.h}
{\xe \v ms.h\:SynchronizationEvent}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid SynchronizationEvent{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 60} of file {\b ms.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACHZ}
{\bkmkend AAAAAAACHZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v InitializeListHead\:ms.h}
{\xe \v ms.h\:InitializeListHead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void InitializeListHead ({\b PDOUBLY_LINKED_LIST} Head)}}
\par
{\bkmkstart AAAAAAACIA}
{\bkmkend AAAAAAACIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b ms.h}.}\par
}
{\xe \v InsertHeadList\:ms.h}
{\xe \v ms.h\:InsertHeadList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void InsertHeadList ({\b PDOUBLY_LINKED_LIST} Head, {\b PDOUBLY_LINKED_LIST} Entry)}}
\par
{\bkmkstart AAAAAAACIB}
{\bkmkend AAAAAAACIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b ms.h}.}\par
}
{\xe \v InsertTailList\:ms.h}
{\xe \v ms.h\:InsertTailList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void InsertTailList ({\b PDOUBLY_LINKED_LIST} Head, {\b PDOUBLY_LINKED_LIST} Entry)}}
\par
{\bkmkstart AAAAAAACIC}
{\bkmkend AAAAAAACIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b ms.h}.}\par
}
{\xe \v InterlockedPopEntry\:ms.h}
{\xe \v ms.h\:InterlockedPopEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PSINGLE_LINKED_LIST} InterlockedPopEntry ({\b PSINGLE_LINKED_LIST} * ListHeadPtr)}}
\par
{\bkmkstart AAAAAAACID}
{\bkmkend AAAAAAACID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 291} of file {\b ms.h}.}\par
}
{\xe \v InterlockedPushEntry\:ms.h}
{\xe \v ms.h\:InterlockedPushEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void InterlockedPushEntry ({\b PSINGLE_LINKED_LIST} * ListHeadPtr, {\b PSINGLE_LINKED_LIST} Entry)}}
\par
{\bkmkstart AAAAAAACIE}
{\bkmkend AAAAAAACIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 266} of file {\b ms.h}.}\par
}
{\xe \v MsAcquireMutexObject\:ms.h}
{\xe \v ms.h\:MsAcquireMutexObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsAcquireMutexObject ({\b IN} {\b PMUTEX} mut)}}
\par
{\bkmkstart AAAAAAACIF}
{\bkmkend AAAAAAACIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b mutex.c}.}\par
}
{\xe \v MsAcquireRundownProtection\:ms.h}
{\xe \v ms.h\:MsAcquireRundownProtection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MsAcquireRundownProtection ({\b IN} {\b PRUNDOWN_REF} rundown)}}
\par
{\bkmkstart AAAAAAACIG}
{\bkmkend AAAAAAACIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b rundown.c}.}\par
}
{\xe \v MsAcquireSpinlock\:ms.h}
{\xe \v ms.h\:MsAcquireSpinlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsAcquireSpinlock ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b PIRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAACIH}
{\bkmkend AAAAAAACIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b spinlock.c}.}\par
}
{\xe \v MsAcquireSpinlockAtDpcLevel\:ms.h}
{\xe \v ms.h\:MsAcquireSpinlockAtDpcLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsAcquireSpinlockAtDpcLevel ({\b IN} {\b PSPINLOCK} Lock)}}
\par
{\bkmkstart AAAAAAACII}
{\bkmkend AAAAAAACII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b spinlock.c}.}\par
}
{\xe \v MsInitializeMutexObject\:ms.h}
{\xe \v ms.h\:MsInitializeMutexObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsInitializeMutexObject ({\b IN} {\b PMUTEX} mut)}}
\par
{\bkmkstart AAAAAAACIJ}
{\bkmkend AAAAAAACIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#else #undef MsAcquireSpinlock #undef MsReleaseSpinlock\par
#define {\b MsAcquireSpinlock()} // NO-OP #define {\b MsReleaseSpinlock()} // NO-OP #endif \par
}{
Definition at line {\b 13} of file {\b mutex.c}.}\par
}
{\xe \v MsReleaseMutexObject\:ms.h}
{\xe \v ms.h\:MsReleaseMutexObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsReleaseMutexObject ({\b IN} {\b PMUTEX} mut)}}
\par
{\bkmkstart AAAAAAACIK}
{\bkmkend AAAAAAACIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b mutex.c}.}\par
}
{\xe \v MsReleaseRundownProtection\:ms.h}
{\xe \v ms.h\:MsReleaseRundownProtection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsReleaseRundownProtection ({\b IN} {\b PRUNDOWN_REF} rundown)}}
\par
{\bkmkstart AAAAAAACIL}
{\bkmkend AAAAAAACIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b rundown.c}.}\par
}
{\xe \v MsReleaseSpinlock\:ms.h}
{\xe \v ms.h\:MsReleaseSpinlock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsReleaseSpinlock ({\b IN} {\b PSPINLOCK} lock, {\b IN} {\b IRQL} OldIrql)}}
\par
{\bkmkstart AAAAAAACIM}
{\bkmkend AAAAAAACIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b spinlock.c}.}\par
}
{\xe \v MsReleaseSpinlockFromDpcLevel\:ms.h}
{\xe \v ms.h\:MsReleaseSpinlockFromDpcLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsReleaseSpinlockFromDpcLevel ({\b IN} {\b PSPINLOCK} Lock)}}
\par
{\bkmkstart AAAAAAACIN}
{\bkmkend AAAAAAACIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b spinlock.c}.}\par
}
{\xe \v MsSetEvent\:ms.h}
{\xe \v ms.h\:MsSetEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsSetEvent ({\b IN} {\b PEVENT} event)}}
\par
{\bkmkstart AAAAAAACIO}
{\bkmkend AAAAAAACIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b events.c}.}\par
}
{\xe \v MsWaitForEvent\:ms.h}
{\xe \v ms.h\:MsWaitForEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} MsWaitForEvent ({\b IN} {\b PEVENT} event)}}
\par
{\bkmkstart AAAAAAACIP}
{\bkmkend AAAAAAACIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b events.c}.}\par
}
{\xe \v MsWaitForRundownProtectionRelease\:ms.h}
{\xe \v ms.h\:MsWaitForRundownProtectionRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsWaitForRundownProtectionRelease ({\b IN} {\b PRUNDOWN_REF} rundown)}}
\par
{\bkmkstart AAAAAAACIQ}
{\bkmkend AAAAAAACIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 63} of file {\b rundown.c}.}\par
}
{\xe \v RemoveEntryList\:ms.h}
{\xe \v ms.h\:RemoveEntryList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void RemoveEntryList ({\b PDOUBLY_LINKED_LIST} Entry)}}
\par
{\bkmkstart AAAAAAACIR}
{\bkmkend AAAAAAACIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 240} of file {\b ms.h}.}\par
}
{\xe \v RemoveHeadList\:ms.h}
{\xe \v ms.h\:RemoveHeadList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PDOUBLY_LINKED_LIST} RemoveHeadList ({\b PDOUBLY_LINKED_LIST} Head)}}
\par
{\bkmkstart AAAAAAACIS}
{\bkmkend AAAAAAACIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b ms.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ms.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ms.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ms.h}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_SYNCHRONIZATION_H}\par
00002 {\cf21 #define X86_MATANEL_SYNCHRONIZATION_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     ms.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files & prototypes required for synchronization in a threaded - multiprocessing system.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf21 #include <stddef.h>}\par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stdbool.h>}\par
00025 {\cf21 #include "../mtstatus.h"}\par
00026 {\cf21 #include "annotations.h"}\par
00027 {\cf21 #include "core.h"}\par
00028 \par
00029 {\cf20 // ------------------ STRUCTURES ------------------}\par
00030 \par
00036 {\cf17 typedef} {\cf17 struct }_SPINLOCK \{\par
00037     {\cf17 volatile} uint32_t locked; {\cf20 /* 0 = unlocked, 1 = locked */}\par
00038 \} SPINLOCK, *PSPINLOCK;\par
00039 \par
00046 \par
00047 {\cf17 typedef} {\cf17 struct }_RUNDOWN_REF \{\par
00048     uint64_t Count; {\cf20 // Reference count, bit 0-62 is used for reference counting, bit 63 is used to signify the object is being terminated. (teardown flag)}\par
00049 \} RUNDOWN_REF, *PRUNDOWN_REF;\par
00050  \par
00051 {\cf17 typedef} {\cf17 struct }_Queue \{\par
00052     PETHREAD head;\par
00053     PETHREAD tail;\par
00054     {\cf17 struct }_SPINLOCK lock; {\cf20 /* embedded spinlock (do not change from embedded) */}\par
00055 \} Queue;\par
00056 \par
00060 {\cf17 typedef} {\cf17 enum} _EVENT_TYPE \{\par
00061     NotificationEvent,   {\cf20 /* wake all waiting threads */}\par
00062     SynchronizationEvent {\cf20 /* wake one thread at a time */}\par
00063 \} EVENT_TYPE;\par
00064 \par
00069 {\cf17 typedef} {\cf17 struct }_EVENT \{\par
00070     {\cf17 enum} _EVENT_TYPE type;              {\cf20 /* Notification vs Synchronization */}\par
00071     {\cf17 volatile} {\cf18 bool} signaled;             {\cf20 /* current state */}\par
00072     {\cf17 struct }_SPINLOCK lock;                {\cf20 /* protects signaled + waitingQueue */}\par
00073     {\cf17 struct }_Queue waitingQueue;           {\cf20 /* threads waiting on this event */}\par
00074 \} EVENT, *PEVENT;\par
00075 \par
00082 {\cf17 typedef} {\cf17 struct }_MUTEX \{\par
00083     uint32_t ownerTid;  {\cf20 /* owning thread id (0 if none) */}\par
00084     {\cf17 struct }_EVENT SynchEvent;   {\cf20 /* event used for waking waiters */}\par
00085     {\cf18 bool} locked;        {\cf20 /* fast-check boolean (protected by lock) */}\par
00086     {\cf17 struct }_SPINLOCK lock;      {\cf20 /* protects ownerTid/locked and wait list */}\par
00087     {\cf17 struct }_ETHREAD* ownerThread; {\cf20 /* pointer to current thread that holds the mutex */}\par
00088 \} MUTEX, *PMUTEX;\par
00089 \par
00090 {\cf20 // ------------------ FUNCTIONS ------------------}\par
00091 \par
00092 {\cf20 //#ifndef MT_UP}\par
00093 {\cf18 void}\par
00094 MsAcquireSpinlock(\par
00095     IN    PSPINLOCK lock,\par
00096     IN    PIRQL OldIrql\par
00097 );\par
00098 \par
00099 {\cf18 void}\par
00100 MsReleaseSpinlock(\par
00101     IN    PSPINLOCK lock,\par
00102     IN    IRQL OldIrql\par
00103 );\par
00113 \par
00114 MTSTATUS\par
00115 MsInitializeMutexObject(\par
00116     IN  PMUTEX mut\par
00117 );\par
00118 \par
00119 MTSTATUS\par
00120 MsAcquireMutexObject(\par
00121     IN  PMUTEX mut\par
00122 );\par
00123 \par
00124 MTSTATUS\par
00125 MsReleaseMutexObject(\par
00126     IN  PMUTEX mut\par
00127 );\par
00128 \par
00129 {\cf18 bool}\par
00130 MsAcquireRundownProtection(\par
00131     IN    PRUNDOWN_REF rundown\par
00132 );\par
00133 \par
00134 {\cf18 void}\par
00135 MsReleaseRundownProtection(\par
00136     IN    PRUNDOWN_REF rundown\par
00137 );\par
00138 \par
00139 {\cf18 void} \par
00140 MsWaitForRundownProtectionRelease(\par
00141     IN  PRUNDOWN_REF rundown\par
00142 );\par
00143 \par
00144 MTSTATUS\par
00145 MsSetEvent(\par
00146     IN PEVENT event\par
00147 );\par
00148 \par
00149 MTSTATUS \par
00150 MsWaitForEvent(\par
00151     IN  PEVENT event\par
00152 );\par
00153 \par
00154 {\cf18 void}\par
00155 MsAcquireSpinlockAtDpcLevel(\par
00156     IN PSPINLOCK Lock\par
00157 );\par
00158 \par
00159 {\cf18 void}\par
00160 MsReleaseSpinlockFromDpcLevel(\par
00161     IN PSPINLOCK Lock\par
00162 );\par
00163 \par
00164 FORCEINLINE\par
00165 {\cf18 void}\par
00166 InitializeListHead(\par
00167     PDOUBLY_LINKED_LIST Head\par
00168 )\par
00169 \par
00170 \{\par
00171     Head->Flink = Head;\par
00172     Head->Blink = Head;\par
00173 \}\par
00174 \par
00175 {\cf20 // ->>>> CRASHES IN THESE FUNCTIONS USUALLY BECAUSE INITIALIZELISTHEAD WASNT USED ON THE DOUBLY LINKED LIST !!!!!!!}\par
00176 \par
00177 FORCEINLINE\par
00178 {\cf18 void}\par
00179 InsertTailList(\par
00180     PDOUBLY_LINKED_LIST Head,\par
00181     PDOUBLY_LINKED_LIST Entry\par
00182 )\par
00183 \par
00184 \{\par
00185     PDOUBLY_LINKED_LIST Blink;\par
00186     {\cf20 // The last element is the one before Head (circular list style)}\par
00187     Blink = Head->Blink;\par
00188     Entry->Flink = Head;  {\cf20 // New entry points forward to Head}\par
00189     Entry->Blink = Blink; {\cf20 // New entry points back to old last node}\par
00190     Blink->Flink = Entry; {\cf20 // Old last node points forward to new entry}\par
00191     Head->Blink = Entry;  {\cf20 // Head points back to new entry}\par
00192 \}\par
00193 \par
00194 FORCEINLINE\par
00195 {\cf18 void}\par
00196 InsertHeadList(\par
00197     PDOUBLY_LINKED_LIST Head,\par
00198     PDOUBLY_LINKED_LIST Entry\par
00199 )\par
00200 \{\par
00201     PDOUBLY_LINKED_LIST First;\par
00202 \par
00203     {\cf20 // The first element is the one after Head (circular list)}\par
00204     First = Head->Flink;\par
00205 \par
00206     Entry->Flink = First; {\cf20 // Entry -> next = old first}\par
00207     Entry->Blink = Head;  {\cf20 // Entry -> prev = head}\par
00208 \par
00209     First->Blink = Entry; {\cf20 // old first -> prev = entry}\par
00210     Head->Flink = Entry;  {\cf20 // head -> next = entry}\par
00211 \}\par
00212 \par
00213 FORCEINLINE\par
00214 PDOUBLY_LINKED_LIST\par
00215 RemoveHeadList(\par
00216     PDOUBLY_LINKED_LIST Head\par
00217 )\par
00218 \par
00219 \{\par
00220     PDOUBLY_LINKED_LIST Entry;\par
00221     PDOUBLY_LINKED_LIST Flink;\par
00222 \par
00223     Entry = Head->Flink;\par
00224     {\cf19 if} (Entry == Head) \{\par
00225         {\cf20 // List is empty}\par
00226         {\cf19 return} NULL;\par
00227     \}\par
00228 \par
00229     Flink = Entry->Flink;\par
00230     Head->Flink = Flink;\par
00231     Flink->Blink = Head;\par
00232 \par
00233     {\cf20 // Clear links}\par
00234     Entry->Flink = Entry->Blink = NULL;\par
00235     {\cf19 return} Entry;\par
00236 \}\par
00237 \par
00238 FORCEINLINE\par
00239 {\cf18 void}\par
00240 RemoveEntryList(\par
00241     PDOUBLY_LINKED_LIST Entry\par
00242 )\par
00243 \{\par
00244     PDOUBLY_LINKED_LIST Flink;\par
00245     PDOUBLY_LINKED_LIST Blink;\par
00246 \par
00247     Flink = Entry->Flink;\par
00248     Blink = Entry->Blink;\par
00249 \par
00250     {\cf20 /* Normal (minimal) unlink \'97 identical to Windows' RemoveEntryList */}\par
00251     Blink->Flink = Flink;\par
00252     Flink->Blink = Blink;\par
00253 \par
00254     {\cf20 // Sanitize the removed entry so it doesn't look valid}\par
00255     Entry->Flink = NULL;\par
00256     Entry->Blink = NULL;\par
00257 \}\par
00258 \par
00259 \par
00260 {\cf20 /* Interlocked push: atomically push Entry onto *ListHeadPtr.}\par
00261 {\cf20    ListHeadPtr is PSINGLE_LINKED_LIST* (address of the head pointer). }\par
00262 {\cf20    Usage: InterlockedPushEntry(&Descriptor->FreeListHead.Next, &Header->Metadata.FreeListEntry);}\par
00263 {\cf20    */}\par
00264 FORCEINLINE \par
00265 {\cf18 void}\par
00266 InterlockedPushEntry(\par
00267     PSINGLE_LINKED_LIST* ListHeadPtr, {\cf20 /* &head_ptr */}\par
00268     PSINGLE_LINKED_LIST Entry         {\cf20 /* entry->Next must be valid memory */}\par
00269 )\par
00270 \{\par
00271     PSINGLE_LINKED_LIST oldHead;\par
00272     {\cf19 do} \{\par
00273         oldHead = __atomic_load_n(ListHeadPtr, __ATOMIC_RELAXED);\par
00274         Entry->Next = oldHead;\par
00275         {\cf20 /* try to replace head with Entry */}\par
00276     \} {\cf19 while} (!__atomic_compare_exchange_n(\par
00277         ListHeadPtr,           {\cf20 /* target */}\par
00278         &oldHead,              {\cf20 /* expected (updated on failure) */}\par
00279         Entry,                 {\cf20 /* desired */}\par
00280         {\cf20 /*weak*/} {\cf17 false},\par
00281         __ATOMIC_RELEASE,      {\cf20 /* success: release so prior stores are visible */}\par
00282         __ATOMIC_RELAXED));    {\cf20 /* failure: relaxed */}\par
00283 \}\par
00284 \par
00285 {\cf20 /* Interlocked pop: atomically pop and return the old head (or NULL).}\par
00286 {\cf20    Returns the popped entry pointer. }\par
00287 {\cf20    Usage: InterlockedPopEntry(&Descriptor->FreeListHead.Next);}\par
00288 {\cf20    */}\par
00289 FORCEINLINE\par
00290 PSINGLE_LINKED_LIST\par
00291 InterlockedPopEntry(\par
00292     PSINGLE_LINKED_LIST* ListHeadPtr\par
00293 )\par
00294 \{\par
00295     PSINGLE_LINKED_LIST oldHead;\par
00296     PSINGLE_LINKED_LIST next;\par
00297 \par
00298     {\cf19 do} \{\par
00299         oldHead = __atomic_load_n(ListHeadPtr, __ATOMIC_ACQUIRE);\par
00300         {\cf19 if} (oldHead == NULL)\par
00301             {\cf19 return} NULL;\par
00302         next = oldHead->Next;\par
00303         {\cf20 /* try to set head to next */}\par
00304     \} {\cf19 while} (!__atomic_compare_exchange_n(\par
00305         ListHeadPtr,\par
00306         &oldHead,\par
00307         next,\par
00308         {\cf20 /*weak*/} {\cf17 false},\par
00309         __ATOMIC_ACQ_REL,      {\cf20 /* success: acquire+release to pair with push */}\par
00310         __ATOMIC_RELAXED));   {\cf20 /* failure ordering */}\par
00311     {\cf19 return} oldHead;\par
00312 \}\par
00313 \par
00314 {\cf21 #endif }{\cf20 // X86_MATANEL_SYNCHRONIZATION_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mtos.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mtos.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mtos.h}
{\bkmkstart AAAAAAACIT}
{\bkmkend AAAAAAACIT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "me.h"}\par
{\f2 #include "ms.h"}\par
{\f2 #include "mh.h"}\par
{\f2 #include "mg.h"}\par
{\f2 #include "mm.h"}\par
{\f2 #include "md.h"}\par
{\f2 #include "ps.h"}\par
{\f2 #include "ob.h"}\par
{\f2 #include "rtl.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mtos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mtos.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/mtos.h}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_OPERATING_SYSTEM_FULL_HEADER}\par
00002 {\cf21 #define X86_MATANEL_OPERATING_SYSTEM_FULL_HEADER}\par
00003 \par
00004 {\cf20 // MTOS.H - Includes all essential headers for full kernel operation.}\par
00005 \par
00006 {\cf21 #include "me.h"}\par
00007 {\cf21 #include "ms.h"}\par
00008 {\cf21 #include "mh.h"}\par
00009 {\cf21 #include "mg.h"}\par
00010 {\cf21 #include "mm.h"}\par
00011 {\cf21 #include "md.h"}\par
00012 {\cf21 #include "ps.h"}\par
00013 {\cf21 #include "ob.h"}\par
00014 {\cf21 #include "rtl.h"}\par
00015 \par
00016 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ob.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ob.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ob.h}
{\bkmkstart AAAAAAACIU}
{\bkmkend AAAAAAACIU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "core.h"}\par
{\f2 #include "me.h"}\par
{\f2 #include "ht.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _OBJECT_TYPE_INITIALIZER}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _OBJECT_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _OBJECT_HEADER}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OBJECT_TO_OBJECT_HEADER}(o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b OBJECT_HEADER_TO_OBJECT}({\b h})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b OB_DELETE_METHOD}) (void *Object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b OB_CLOSE_METHOD}) (void *Object, void *Process, uint64_t Handle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b OB_DUMP_METHOD}) (void *Object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _OBJECT_TYPE_INITIALIZER} {\b OBJECT_TYPE_INITIALIZER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _OBJECT_TYPE_INITIALIZER} * {\b POBJECT_TYPE_INITIALIZER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _OBJECT_TYPE} {\b OBJECT_TYPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _OBJECT_TYPE} * {\b POBJECT_TYPE}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _OBJECT_HEADER} {\b __attribute__} ((aligned(16))) OBJECT_HEADER\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ObInitialize} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateObjectType} ({\b IN} char *TypeName, {\b IN} {\b POBJECT_TYPE_INITIALIZER} ObjectTypeInitializer, {\b OUT} {\b POBJECT_TYPE} *ObjectType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateObject} ({\b IN} {\b POBJECT_TYPE} ObjectType, {\b IN} uint32_t ObjectSize, {\b OUT} void **ObjectCreated)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateHandleForObject} ({\b IN} void *Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObCreateHandleForObjectEx} ({\b IN} void *Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle, {\b IN} {\b PHANDLE_TABLE} ObjectTable)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ObReferenceObject} ({\b IN} void *Object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObReferenceObjectByPointer} ({\b IN} void *Object, {\b IN} {\b POBJECT_TYPE} DesiredType)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b ObReferenceObjectByHandle} ({\b IN} {\b HANDLE} Handle, {\b IN} uint32_t DesiredAccess, {\b IN} {\b POBJECT_TYPE} DesiredType, {\b OUT} void **Object, {\b _Out_Opt} {\b PHANDLE_TABLE_ENTRY} HandleInformation)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ObDereferenceObject} ({\b IN} void *Object)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b PointerCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
union \{\par

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ uint64_t {\b HandleCount}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\~ volatile void * {\b NextToFree}\par
}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\}; \par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POBJECT_TYPE} {\b Type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b Flags}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _OBJECT_HEADER} * {\b POBJECT_HEADER}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACIV}
{\bkmkend AAAAAAACIV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v OBJECT_HEADER_TO_OBJECT\:ob.h}
{\xe \v ob.h\:OBJECT_HEADER_TO_OBJECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OBJECT_HEADER_TO_OBJECT( {\b h})}}
\par
{\bkmkstart AAAAAAACIW}
{\bkmkend AAAAAAACIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     (({\cf18 void}*)(({\cf18 char}*)(h) + {\cf17 sizeof}(OBJECT_HEADER)))\par
}
{
Definition at line {\b 71} of file {\b ob.h}.}\par
}
{\xe \v OBJECT_TO_OBJECT_HEADER\:ob.h}
{\xe \v ob.h\:OBJECT_TO_OBJECT_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define OBJECT_TO_OBJECT_HEADER( o)}}
\par
{\bkmkstart AAAAAAACIX}
{\bkmkend AAAAAAACIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     ((POBJECT_HEADER)(({\cf18 char}*)(o) - {\cf17 sizeof}(OBJECT_HEADER)))\par
}
{
Definition at line {\b 68} of file {\b ob.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACIY}
{\bkmkend AAAAAAACIY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v OB_CLOSE_METHOD\:ob.h}
{\xe \v ob.h\:OB_CLOSE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* OB_CLOSE_METHOD) (void *Object, void *Process, uint64_t Handle)}}
\par
{\bkmkstart AAAAAAACIZ}
{\bkmkend AAAAAAACIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ob.h}.}\par
}
{\xe \v OB_DELETE_METHOD\:ob.h}
{\xe \v ob.h\:OB_DELETE_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* OB_DELETE_METHOD) (void *Object)}}
\par
{\bkmkstart AAAAAAACJA}
{\bkmkend AAAAAAACJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b ob.h}.}\par
}
{\xe \v OB_DUMP_METHOD\:ob.h}
{\xe \v ob.h\:OB_DUMP_METHOD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* OB_DUMP_METHOD) (void *Object)}}
\par
{\bkmkstart AAAAAAACJB}
{\bkmkend AAAAAAACJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b ob.h}.}\par
}
{\xe \v OBJECT_TYPE\:ob.h}
{\xe \v ob.h\:OBJECT_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _OBJECT_TYPE} {\b OBJECT_TYPE}}}
\par
{\bkmkstart AAAAAAACJC}
{\bkmkend AAAAAAACJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v OBJECT_TYPE_INITIALIZER\:ob.h}
{\xe \v ob.h\:OBJECT_TYPE_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _OBJECT_TYPE_INITIALIZER} {\b OBJECT_TYPE_INITIALIZER}}}
\par
{\bkmkstart AAAAAAACJD}
{\bkmkend AAAAAAACJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v POBJECT_TYPE\:ob.h}
{\xe \v ob.h\:POBJECT_TYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _OBJECT_TYPE} * {\b POBJECT_TYPE}}}
\par
{\bkmkstart AAAAAAACJE}
{\bkmkend AAAAAAACJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v POBJECT_TYPE_INITIALIZER\:ob.h}
{\xe \v ob.h\:POBJECT_TYPE_INITIALIZER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _OBJECT_TYPE_INITIALIZER} * {\b POBJECT_TYPE_INITIALIZER}}}
\par
{\bkmkstart AAAAAAACJF}
{\bkmkend AAAAAAACJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACJG}
{\bkmkend AAAAAAACJG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:ob.h}
{\xe \v ob.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _OBJECT_HEADER} __attribute__ ((aligned(16)) )}}
\par
{\bkmkstart AAAAAAACJH}
{\bkmkend AAAAAAACJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ObCreateHandleForObject\:ob.h}
{\xe \v ob.h\:ObCreateHandleForObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateHandleForObject ({\b IN} void * Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle)}}
\par
{\bkmkstart AAAAAAACJI}
{\bkmkend AAAAAAACJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 318} of file {\b ob.c}.}\par
}
{\xe \v ObCreateHandleForObjectEx\:ob.h}
{\xe \v ob.h\:ObCreateHandleForObjectEx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateHandleForObjectEx ({\b IN} void * Object, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b OUT} {\b PHANDLE} ReturnedHandle, {\b IN} {\b PHANDLE_TABLE} ObjectTable)}}
\par
{\bkmkstart AAAAAAACJJ}
{\bkmkend AAAAAAACJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 363} of file {\b ob.c}.}\par
}
{\xe \v ObCreateObject\:ob.h}
{\xe \v ob.h\:ObCreateObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateObject ({\b IN} {\b POBJECT_TYPE} ObjectType, {\b IN} uint32_t ObjectSize, {\b OUT} void ** ObjectCreated)}}
\par
{\bkmkstart AAAAAAACJK}
{\bkmkend AAAAAAACJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b ob.c}.}\par
}
{\xe \v ObCreateObjectType\:ob.h}
{\xe \v ob.h\:ObCreateObjectType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObCreateObjectType ({\b IN} char * TypeName, {\b IN} {\b POBJECT_TYPE_INITIALIZER} ObjectTypeInitializer, {\b OUT} {\b POBJECT_TYPE} * ObjectType)}}
\par
{\bkmkstart AAAAAAACJL}
{\bkmkend AAAAAAACJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b ob.c}.}\par
}
{\xe \v ObDereferenceObject\:ob.h}
{\xe \v ob.h\:ObDereferenceObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObDereferenceObject ({\b IN} void * Object)}}
\par
{\bkmkstart AAAAAAACJM}
{\bkmkend AAAAAAACJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 446} of file {\b ob.c}.}\par
}
{\xe \v ObInitialize\:ob.h}
{\xe \v ob.h\:ObInitialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ObInitialize (void )}}
\par
{\bkmkstart AAAAAAACJN}
{\bkmkend AAAAAAACJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b ob.c}.}\par
}
{\xe \v ObReferenceObject\:ob.h}
{\xe \v ob.h\:ObReferenceObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ObReferenceObject ({\b IN} void * Object)}}
\par
{\bkmkstart AAAAAAACJO}
{\bkmkend AAAAAAACJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b ob.c}.}\par
}
{\xe \v ObReferenceObjectByHandle\:ob.h}
{\xe \v ob.h\:ObReferenceObjectByHandle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObReferenceObjectByHandle ({\b IN} {\b HANDLE} Handle, {\b IN} uint32_t DesiredAccess, {\b IN} {\b POBJECT_TYPE} DesiredType, {\b OUT} void ** Object, {\b _Out_Opt} {\b PHANDLE_TABLE_ENTRY} HandleInformation)}}
\par
{\bkmkstart AAAAAAACJP}
{\bkmkend AAAAAAACJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 247} of file {\b ob.c}.}\par
}
{\xe \v ObReferenceObjectByPointer\:ob.h}
{\xe \v ob.h\:ObReferenceObjectByPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} ObReferenceObjectByPointer ({\b IN} void * Object, {\b IN} {\b POBJECT_TYPE} DesiredType)}}
\par
{\bkmkstart AAAAAAACJQ}
{\bkmkend AAAAAAACJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b ob.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACJR}
{\bkmkend AAAAAAACJR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
union  \{ ... \} }}
\par
{\bkmkstart AAAAAAACJS}
{\bkmkend AAAAAAACJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Flags\:ob.h}
{\xe \v ob.h\:Flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t Flags}}
\par
{\bkmkstart AAAAAAACJT}
{\bkmkend AAAAAAACJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b ob.h}.}\par
}
{\xe \v HandleCount\:ob.h}
{\xe \v ob.h\:HandleCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t HandleCount}}
\par
{\bkmkstart AAAAAAACJU}
{\bkmkend AAAAAAACJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b ob.h}.}\par
}
{\xe \v NextToFree\:ob.h}
{\xe \v ob.h\:NextToFree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
volatile void* NextToFree}}
\par
{\bkmkstart AAAAAAACJV}
{\bkmkend AAAAAAACJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b ob.h}.}\par
}
{\xe \v POBJECT_HEADER\:ob.h}
{\xe \v ob.h\:POBJECT_HEADER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b _OBJECT_HEADER} * POBJECT_HEADER}}
\par
{\bkmkstart AAAAAAACJW}
{\bkmkend AAAAAAACJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b ob.h}.}\par
}
{\xe \v PointerCount\:ob.h}
{\xe \v ob.h\:PointerCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t PointerCount}}
\par
{\bkmkstart AAAAAAACJX}
{\bkmkend AAAAAAACJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 0} of file {\b ob.h}.}\par
}
{\xe \v Type\:ob.h}
{\xe \v ob.h\:Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POBJECT_TYPE} Type}}
\par
{\bkmkstart AAAAAAACJY}
{\bkmkend AAAAAAACJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b ob.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ob.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ob.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ob.h}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*++}\par
00002 {\cf20 }\par
00003 {\cf20 Module Name:}\par
00004 {\cf20 }\par
00005 {\cf20     ob.h}\par
00006 {\cf20 }\par
00007 {\cf20 Purpose:}\par
00008 {\cf20 }\par
00009 {\cf20     This module contains the header files & prototypes required for the Object Manager implementation of MatanelOS.}\par
00010 {\cf20 }\par
00011 {\cf20 Author:}\par
00012 {\cf20 }\par
00013 {\cf20     slep (Matanel) 2025.}\par
00014 {\cf20 }\par
00015 {\cf20 Revision History:}\par
00016 {\cf20 }\par
00017 {\cf20 --*/}\par
00018 \par
00019 {\cf21 #ifndef X86_MATANEL_OB_H}\par
00020 {\cf21 #define X86_MATANEL_OB_H}\par
00021 \par
00022 {\cf21 #include "core.h"}\par
00023 {\cf21 #include "me.h"}\par
00024 {\cf21 #include "ht.h"}\par
00025 \par
00026 {\cf20 // --------------- STRUCTURES ---------------}\par
00027 \par
00028 {\cf20 // Forward declare the object header}\par
00029 {\cf17 struct }_OBJECT_HEADER;\par
00030 \par
00031 {\cf20 // Function pointer types for object callbacks}\par
00032 {\cf17 typedef} void (*OB_DELETE_METHOD)({\cf18 void}* Object);\par
00033 {\cf17 typedef} void (*OB_CLOSE_METHOD)({\cf18 void}* Object, {\cf18 void}* Process, uint64_t Handle);\par
00034 {\cf17 typedef} void (*OB_DUMP_METHOD)({\cf18 void}* Object);\par
00035 \par
00036 {\cf20 // Defines how a specific type of object behaves.}\par
00037 {\cf20 // This struct mimics standard Windows OBJECT_TYPE_INITIALIZER}\par
00038 {\cf17 typedef} {\cf17 struct }_OBJECT_TYPE_INITIALIZER \{\par
00039     POOL_TYPE PoolType;          {\cf20 // NonPagedPool vs PagedPool}\par
00040     {\cf20 // Standard Callbacks}\par
00041     uint32_t ValidAccessRights;\par
00042     OB_DUMP_METHOD DumpProcedure;\par
00043     OB_DELETE_METHOD DeleteProcedure;\par
00044     OB_CLOSE_METHOD CloseProcedure; {\cf20 // Maybe will be used.}\par
00045 \} OBJECT_TYPE_INITIALIZER, * POBJECT_TYPE_INITIALIZER;\par
00046 \par
00047 {\cf17 typedef} {\cf17 struct }_OBJECT_TYPE \{\par
00048     DOUBLY_LINKED_LIST TypeList;     {\cf20 // Global list of all types}\par
00049     {\cf18 char} Name[32];                   {\cf20 // "Process", "Thread", "Mutant"}\par
00050     uint32_t TotalNumberOfObjects;   {\cf20 // Statistics}\par
00051     uint32_t TotalNumberOfHandles;   {\cf20 // Statistics}\par
00052     OBJECT_TYPE_INITIALIZER TypeInfo; {\cf20 // Routine (init & del & dbg) information for this object}\par
00053 \} OBJECT_TYPE, * POBJECT_TYPE;\par
00054 \par
00055 {\cf20 // Object header (it is aligned to 16 bytes, to avoid bugs)}\par
00056 {\cf17 typedef} {\cf17 struct }_OBJECT_HEADER \{\par
00057     uint64_t PointerCount; {\cf20 // Number of kernel pointers referencing this object.}\par
00058     {\cf17 union }\{\par
00059         uint64_t HandleCount;  {\cf20 // Number of user handles open (future)}\par
00060         {\cf17 volatile} {\cf18 void}* NextToFree; {\cf20 // If object is deferred for deletion, NextToFree is used instead of HandleCount.}\par
00061     \};\par
00062     POBJECT_TYPE Type;  {\cf20 // Pointer to type definition.}\par
00063     uint32_t Flags;\par
00064 \} __attribute__((aligned(16))) OBJECT_HEADER, *POBJECT_HEADER;\par
00065 _Static_assert(sizeof(OBJECT_HEADER) % 16 == 0, {\cf22 "OBJECT_HEADER must be 16-byte aligned"});\par
00066 \par
00067 {\cf20 // Macros for arithemetic}\par
00068 {\cf21 #define OBJECT_TO_OBJECT_HEADER(o) \\}\par
00069 {\cf21     ((POBJECT_HEADER)((char*)(o) - sizeof(OBJECT_HEADER)))}\par
00070 \par
00071 {\cf21 #define OBJECT_HEADER_TO_OBJECT(h) \\}\par
00072 {\cf21     ((void*)((char*)(h) + sizeof(OBJECT_HEADER)))}\par
00073 \par
00074 {\cf20 // --------------- FUNCTIONS ---------------}\par
00075 \par
00076 {\cf17 typedef} uint32_t ACCESS_MASK;\par
00077 \par
00078 {\cf18 void} ObInitialize({\cf18 void});\par
00079 \par
00080 MTSTATUS ObCreateObjectType(\par
00081     IN {\cf18 char}* TypeName,\par
00082     IN POBJECT_TYPE_INITIALIZER ObjectTypeInitializer,\par
00083     OUT POBJECT_TYPE* ObjectType\par
00084 );\par
00085 \par
00086 MTSTATUS\par
00087 ObCreateObject(\par
00088     IN POBJECT_TYPE ObjectType,\par
00089     IN uint32_t ObjectSize,\par
00090     OUT {\cf18 void}** ObjectCreated\par
00091     {\cf20 //_In_Opt char* Name - When files arrive, i'll uncomment this.}\par
00092 );\par
00093 \par
00094 MTSTATUS\par
00095 ObCreateHandleForObject(\par
00096     IN {\cf18 void}* Object,\par
00097     IN ACCESS_MASK DesiredAccess,\par
00098     OUT PHANDLE ReturnedHandle\par
00099 );\par
00100 \par
00101 MTSTATUS\par
00102 ObCreateHandleForObjectEx(\par
00103     IN {\cf18 void}* Object,\par
00104     IN ACCESS_MASK DesiredAccess,\par
00105     OUT PHANDLE ReturnedHandle,\par
00106     IN PHANDLE_TABLE ObjectTable\par
00107 );\par
00108 \par
00109 {\cf18 bool}\par
00110 ObReferenceObject(\par
00111     IN  {\cf18 void}* Object\par
00112 );\par
00113 \par
00114 MTSTATUS\par
00115 ObReferenceObjectByPointer(\par
00116     IN  {\cf18 void}* Object,\par
00117     IN  POBJECT_TYPE DesiredType\par
00118 );\par
00119 \par
00120 MTSTATUS\par
00121 ObReferenceObjectByHandle(\par
00122     IN HANDLE Handle,\par
00123     IN uint32_t DesiredAccess,\par
00124     IN POBJECT_TYPE DesiredType,\par
00125     OUT {\cf18 void}** Object,\par
00126     _Out_Opt PHANDLE_TABLE_ENTRY HandleInformation\par
00127 );\par
00128 \par
00129 {\cf18 void} ObDereferenceObject(\par
00130     IN  {\cf18 void}* Object\par
00131 );\par
00132 \par
00133 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ps.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ps.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ps.h}
{\bkmkstart AAAAAAACJZ}
{\bkmkend AAAAAAACJZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include "me.h"}\par
{\f2 #include "ht.h"}\par
{\f2 #include "ob.h"}\par
{\f2 #include "core.h"}\par
{\f2 #include "exception.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _EPROCESS}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _ETHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b _STACK_REAPER_ENTRY}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_TERMINATE}\~ 0x0001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_SUSPEND_RESUME}\~ 0x0002\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_SET_CONTEXT}\~ 0x0004\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_GET_CONTEXT}\~ 0x0008\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_QUERY_INFO}\~ 0x0010\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_SET_INFO}\~ 0x0020\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_ALL_ACCESS}\~ 0x003F\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_TERMINATE}\~ 0x0001\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_CREATE_THREAD}\~ 0x0002\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_VM_OPERATION}\~ 0x0004\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_VM_READ}\~ 0x0008\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_VM_WRITE}\~ 0x0010\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_DUP_HANDLE}\~ 0x0020\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_SET_INFO}\~ 0x0040\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_QUERY_INFO}\~ 0x0080\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_SUSPEND_RESUME}\~ 0x0100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_CREATE_PROCESS}\~ 0x0200\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_ALL_ACCESS}\~ 0x01FF\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PROCESS_STACK_SIZE}\~ (32*1024)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PROCESS_STACK_ALIGNMENT}\~ 16\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _THREAD_STATE} {\b THREAD_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _THREAD_STATE} * {\b PTHREAD_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PROCESS_STATE} {\b PROCESS_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PROCESS_STATE} * {\b PPROCESS_STATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b _PS_PHASE_ROUTINE} {\b PS_PHASE_ROUTINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EPROCESS} {\b EPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _EPROCESS} * {\b PEPROCESS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _ETHREAD} {\b ETHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _ETHREAD} * {\b PETHREAD}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _STACK_REAPER_ENTRY} {\b STACK_REAPER_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef struct {\b _STACK_REAPER_ENTRY} * {\b PSTACK_REAPER_ENTRY}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b THREAD_PARAMETER}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(* {\b ThreadEntry}) ({\b THREAD_PARAMETER})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _THREAD_STATE} \{ {\b THREAD_RUNNING}
, {\b THREAD_READY}
, {\b THREAD_BLOCKED}
, {\b THREAD_TERMINATING}
, {\b THREAD_TERMINATED}
, {\b THREAD_ZOMBIE}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PROCESS_STATE} \{ {\b PROCESS_RUNNING} = 0
, {\b PROCESS_READY}
, {\b PROCESS_WAITING}
, {\b PROCESS_TERMINATING}
, {\b PROCESS_TERMINATED}
, {\b PROCESS_SUSPENDED}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _PS_PHASE_ROUTINE} \{ {\b PS_PHASE_INITIALIZE_SYSTEM} = 0
, {\b PS_PHASE_INITIALIZE_WORKER_THREADS}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsCreateProcess} ({\b IN} const char *ExecutablePath, {\b OUT} {\b PHANDLE} ProcessHandle, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b _In_Opt} {\b HANDLE} ParentProcess)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsCreateThread} ({\b HANDLE} ProcessHandle, {\b PHANDLE} ThreadHandle, {\b ThreadEntry} EntryPoint, {\b THREAD_PARAMETER} ThreadParameter, {\b TimeSliceTicks} TimeSlice)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MsYieldExecution} ({\b PTRAP_FRAME} threadRegisters)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsCreateSystemThread} ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b TimeSliceTicks} TIMESLICE)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MTSTATUS} {\b PsInitializeSystem} ({\b IN} enum {\b _PS_PHASE_ROUTINE} Phase)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsDeferKernelStackDeletion} (void *StackBase, bool IsLarge)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsTerminateProcess} ({\b IN} {\b PEPROCESS} Process)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsTerminateThread} ({\b IN} {\b PETHREAD} Thread, {\b IN} {\b MTSTATUS} ExitStatus)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsDeleteThread} ({\b IN} void *Object)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b PsGetCurrentThread} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsInitializeWorkerThreads} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsInitializeCidTable} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PEPROCESS} {\b PsGetCurrentProcess} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b PsTerminateCurrentThread} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b PsTerminateCurrentProcess} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PETHREAD} {\b PsGetEThreadFromIThread} ({\b IN} {\b PITHREAD} IThread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PEPROCESS} {\b PsGetEProcessFromIProcess} ({\b IN} {\b PIPROCESS} IProcess)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b PsIsKernelThread} ({\b IN} {\b PETHREAD} Thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b PsAllocateProcessId} ({\b IN} {\b PEPROCESS} Process)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HANDLE} {\b PsAllocateThreadId} ({\b IN} {\b PETHREAD} Thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PEPROCESS} {\b PsLookupProcessByProcessId} ({\b IN} {\b HANDLE} ProcessId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PETHREAD} {\b PsLookupThreadByThreadId} ({\b IN} {\b HANDLE} ThreadId)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PsFreeCid} ({\b IN} {\b HANDLE} Cid)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MeEnqueueThreadWithLock} ({\b Queue} *queue, {\b PETHREAD} thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PETHREAD} {\b MeDequeueThreadWithLock} ({\b Queue} *q)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b MeEnqueueThread} ({\b Queue} *queue, {\b PETHREAD} thread)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} {\b PETHREAD} {\b MeDequeueThread} ({\b Queue} *q)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPROCESS} {\b PsInitialSystemProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POBJECT_TYPE} {\b PsProcessType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b POBJECT_TYPE} {\b PsThreadType}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACKA}
{\bkmkend AAAAAAACKA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MT_PROCESS_ALL_ACCESS\:ps.h}
{\xe \v ps.h\:MT_PROCESS_ALL_ACCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_ALL_ACCESS\~ 0x01FF}}
\par
{\bkmkstart AAAAAAACKB}
{\bkmkend AAAAAAACKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_CREATE_PROCESS\:ps.h}
{\xe \v ps.h\:MT_PROCESS_CREATE_PROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_CREATE_PROCESS\~ 0x0200}}
\par
{\bkmkstart AAAAAAACKC}
{\bkmkend AAAAAAACKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_CREATE_THREAD\:ps.h}
{\xe \v ps.h\:MT_PROCESS_CREATE_THREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_CREATE_THREAD\~ 0x0002}}
\par
{\bkmkstart AAAAAAACKD}
{\bkmkend AAAAAAACKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_DUP_HANDLE\:ps.h}
{\xe \v ps.h\:MT_PROCESS_DUP_HANDLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_DUP_HANDLE\~ 0x0020}}
\par
{\bkmkstart AAAAAAACKE}
{\bkmkend AAAAAAACKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_QUERY_INFO\:ps.h}
{\xe \v ps.h\:MT_PROCESS_QUERY_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_QUERY_INFO\~ 0x0080}}
\par
{\bkmkstart AAAAAAACKF}
{\bkmkend AAAAAAACKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_SET_INFO\:ps.h}
{\xe \v ps.h\:MT_PROCESS_SET_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_SET_INFO\~ 0x0040}}
\par
{\bkmkstart AAAAAAACKG}
{\bkmkend AAAAAAACKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 84} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_SUSPEND_RESUME\:ps.h}
{\xe \v ps.h\:MT_PROCESS_SUSPEND_RESUME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_SUSPEND_RESUME\~ 0x0100}}
\par
{\bkmkstart AAAAAAACKH}
{\bkmkend AAAAAAACKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_TERMINATE\:ps.h}
{\xe \v ps.h\:MT_PROCESS_TERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_TERMINATE\~ 0x0001}}
\par
{\bkmkstart AAAAAAACKI}
{\bkmkend AAAAAAACKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_VM_OPERATION\:ps.h}
{\xe \v ps.h\:MT_PROCESS_VM_OPERATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_VM_OPERATION\~ 0x0004}}
\par
{\bkmkstart AAAAAAACKJ}
{\bkmkend AAAAAAACKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_VM_READ\:ps.h}
{\xe \v ps.h\:MT_PROCESS_VM_READ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_VM_READ\~ 0x0008}}
\par
{\bkmkstart AAAAAAACKK}
{\bkmkend AAAAAAACKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b ps.h}.}\par
}
{\xe \v MT_PROCESS_VM_WRITE\:ps.h}
{\xe \v ps.h\:MT_PROCESS_VM_WRITE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_VM_WRITE\~ 0x0010}}
\par
{\bkmkstart AAAAAAACKL}
{\bkmkend AAAAAAACKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_ALL_ACCESS\:ps.h}
{\xe \v ps.h\:MT_THREAD_ALL_ACCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_ALL_ACCESS\~ 0x003F}}
\par
{\bkmkstart AAAAAAACKM}
{\bkmkend AAAAAAACKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_GET_CONTEXT\:ps.h}
{\xe \v ps.h\:MT_THREAD_GET_CONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_GET_CONTEXT\~ 0x0008}}
\par
{\bkmkstart AAAAAAACKN}
{\bkmkend AAAAAAACKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_QUERY_INFO\:ps.h}
{\xe \v ps.h\:MT_THREAD_QUERY_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_QUERY_INFO\~ 0x0010}}
\par
{\bkmkstart AAAAAAACKO}
{\bkmkend AAAAAAACKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_SET_CONTEXT\:ps.h}
{\xe \v ps.h\:MT_THREAD_SET_CONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_SET_CONTEXT\~ 0x0004}}
\par
{\bkmkstart AAAAAAACKP}
{\bkmkend AAAAAAACKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_SET_INFO\:ps.h}
{\xe \v ps.h\:MT_THREAD_SET_INFO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_SET_INFO\~ 0x0020}}
\par
{\bkmkstart AAAAAAACKQ}
{\bkmkend AAAAAAACKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_SUSPEND_RESUME\:ps.h}
{\xe \v ps.h\:MT_THREAD_SUSPEND_RESUME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_SUSPEND_RESUME\~ 0x0002}}
\par
{\bkmkstart AAAAAAACKR}
{\bkmkend AAAAAAACKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b ps.h}.}\par
}
{\xe \v MT_THREAD_TERMINATE\:ps.h}
{\xe \v ps.h\:MT_THREAD_TERMINATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_TERMINATE\~ 0x0001}}
\par
{\bkmkstart AAAAAAACKS}
{\bkmkend AAAAAAACKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b ps.h}.}\par
}
{\xe \v PROCESS_STACK_ALIGNMENT\:ps.h}
{\xe \v ps.h\:PROCESS_STACK_ALIGNMENT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PROCESS_STACK_ALIGNMENT\~ 16}}
\par
{\bkmkstart AAAAAAACKT}
{\bkmkend AAAAAAACKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b ps.h}.}\par
}
{\xe \v PROCESS_STACK_SIZE\:ps.h}
{\xe \v ps.h\:PROCESS_STACK_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PROCESS_STACK_SIZE\~ (32*1024)}}
\par
{\bkmkstart AAAAAAACKU}
{\bkmkend AAAAAAACKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACKV}
{\bkmkend AAAAAAACKV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v EPROCESS\:ps.h}
{\xe \v ps.h\:EPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EPROCESS} {\b EPROCESS}}}
\par
{\bkmkstart AAAAAAACKW}
{\bkmkend AAAAAAACKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ETHREAD\:ps.h}
{\xe \v ps.h\:ETHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _ETHREAD} {\b ETHREAD}}}
\par
{\bkmkstart AAAAAAACKX}
{\bkmkend AAAAAAACKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PEPROCESS\:ps.h}
{\xe \v ps.h\:PEPROCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _EPROCESS} * {\b PEPROCESS}}}
\par
{\bkmkstart AAAAAAACKY}
{\bkmkend AAAAAAACKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PETHREAD\:ps.h}
{\xe \v ps.h\:PETHREAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _ETHREAD} * {\b PETHREAD}}}
\par
{\bkmkstart AAAAAAACKZ}
{\bkmkend AAAAAAACKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PPROCESS_STATE\:ps.h}
{\xe \v ps.h\:PPROCESS_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PROCESS_STATE} * {\b PPROCESS_STATE}}}
\par
{\bkmkstart AAAAAAACLA}
{\bkmkend AAAAAAACLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PROCESS_STATE\:ps.h}
{\xe \v ps.h\:PROCESS_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PROCESS_STATE} {\b PROCESS_STATE}}}
\par
{\bkmkstart AAAAAAACLB}
{\bkmkend AAAAAAACLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PS_PHASE_ROUTINE\:ps.h}
{\xe \v ps.h\:PS_PHASE_ROUTINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _PS_PHASE_ROUTINE} {\b PS_PHASE_ROUTINE}}}
\par
{\bkmkstart AAAAAAACLC}
{\bkmkend AAAAAAACLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PSTACK_REAPER_ENTRY\:ps.h}
{\xe \v ps.h\:PSTACK_REAPER_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _STACK_REAPER_ENTRY} * {\b PSTACK_REAPER_ENTRY}}}
\par
{\bkmkstart AAAAAAACLD}
{\bkmkend AAAAAAACLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PTHREAD_STATE\:ps.h}
{\xe \v ps.h\:PTHREAD_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _THREAD_STATE} * {\b PTHREAD_STATE}}}
\par
{\bkmkstart AAAAAAACLE}
{\bkmkend AAAAAAACLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v STACK_REAPER_ENTRY\:ps.h}
{\xe \v ps.h\:STACK_REAPER_ENTRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef struct {\b _STACK_REAPER_ENTRY} {\b STACK_REAPER_ENTRY}}}
\par
{\bkmkstart AAAAAAACLF}
{\bkmkend AAAAAAACLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v THREAD_PARAMETER\:ps.h}
{\xe \v ps.h\:THREAD_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* {\b THREAD_PARAMETER}}}
\par
{\bkmkstart AAAAAAACLG}
{\bkmkend AAAAAAACLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b ps.h}.}\par
}
{\xe \v THREAD_STATE\:ps.h}
{\xe \v ps.h\:THREAD_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b _THREAD_STATE} {\b THREAD_STATE}}}
\par
{\bkmkstart AAAAAAACLH}
{\bkmkend AAAAAAACLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ThreadEntry\:ps.h}
{\xe \v ps.h\:ThreadEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(* ThreadEntry) ({\b THREAD_PARAMETER})}}
\par
{\bkmkstart AAAAAAACLI}
{\bkmkend AAAAAAACLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACLJ}
{\bkmkend AAAAAAACLJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v _PROCESS_STATE\:ps.h}
{\xe \v ps.h\:_PROCESS_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PROCESS_STATE}}}
\par
{\bkmkstart AAAAAAACLK}
{\bkmkend AAAAAAACLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PROCESS_RUNNING\:ps.h}
{\xe \v ps.h\:PROCESS_RUNNING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROCESS_RUNNING{\bkmkstart AAAAAAACLL}
{\bkmkend AAAAAAACLL}
\cell }{\cell }{\row }
{\xe \v PROCESS_READY\:ps.h}
{\xe \v ps.h\:PROCESS_READY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROCESS_READY{\bkmkstart AAAAAAACLM}
{\bkmkend AAAAAAACLM}
\cell }{\cell }{\row }
{\xe \v PROCESS_WAITING\:ps.h}
{\xe \v ps.h\:PROCESS_WAITING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROCESS_WAITING{\bkmkstart AAAAAAACLN}
{\bkmkend AAAAAAACLN}
\cell }{\cell }{\row }
{\xe \v PROCESS_TERMINATING\:ps.h}
{\xe \v ps.h\:PROCESS_TERMINATING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROCESS_TERMINATING{\bkmkstart AAAAAAACLO}
{\bkmkend AAAAAAACLO}
\cell }{\cell }{\row }
{\xe \v PROCESS_TERMINATED\:ps.h}
{\xe \v ps.h\:PROCESS_TERMINATED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROCESS_TERMINATED{\bkmkstart AAAAAAACLP}
{\bkmkend AAAAAAACLP}
\cell }{\cell }{\row }
{\xe \v PROCESS_SUSPENDED\:ps.h}
{\xe \v ps.h\:PROCESS_SUSPENDED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PROCESS_SUSPENDED{\bkmkstart AAAAAAACLQ}
{\bkmkend AAAAAAACLQ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 46} of file {\b ps.h}.}\par
}
{\xe \v _PS_PHASE_ROUTINE\:ps.h}
{\xe \v ps.h\:_PS_PHASE_ROUTINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _PS_PHASE_ROUTINE}}}
\par
{\bkmkstart AAAAAAACLR}
{\bkmkend AAAAAAACLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PS_PHASE_INITIALIZE_SYSTEM\:ps.h}
{\xe \v ps.h\:PS_PHASE_INITIALIZE_SYSTEM}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PS_PHASE_INITIALIZE_SYSTEM{\bkmkstart AAAAAAACLS}
{\bkmkend AAAAAAACLS}
\cell }{\cell }{\row }
{\xe \v PS_PHASE_INITIALIZE_WORKER_THREADS\:ps.h}
{\xe \v ps.h\:PS_PHASE_INITIALIZE_WORKER_THREADS}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid PS_PHASE_INITIALIZE_WORKER_THREADS{\bkmkstart AAAAAAACLT}
{\bkmkend AAAAAAACLT}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 55} of file {\b ps.h}.}\par
}
{\xe \v _THREAD_STATE\:ps.h}
{\xe \v ps.h\:_THREAD_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b _THREAD_STATE}}}
\par
{\bkmkstart AAAAAAACLU}
{\bkmkend AAAAAAACLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v THREAD_RUNNING\:ps.h}
{\xe \v ps.h\:THREAD_RUNNING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_RUNNING{\bkmkstart AAAAAAACLV}
{\bkmkend AAAAAAACLV}
\cell }{\cell }{\row }
{\xe \v THREAD_READY\:ps.h}
{\xe \v ps.h\:THREAD_READY}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_READY{\bkmkstart AAAAAAACLW}
{\bkmkend AAAAAAACLW}
\cell }{\cell }{\row }
{\xe \v THREAD_BLOCKED\:ps.h}
{\xe \v ps.h\:THREAD_BLOCKED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_BLOCKED{\bkmkstart AAAAAAACLX}
{\bkmkend AAAAAAACLX}
\cell }{\cell }{\row }
{\xe \v THREAD_TERMINATING\:ps.h}
{\xe \v ps.h\:THREAD_TERMINATING}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_TERMINATING{\bkmkstart AAAAAAACLY}
{\bkmkend AAAAAAACLY}
\cell }{\cell }{\row }
{\xe \v THREAD_TERMINATED\:ps.h}
{\xe \v ps.h\:THREAD_TERMINATED}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_TERMINATED{\bkmkstart AAAAAAACLZ}
{\bkmkend AAAAAAACLZ}
\cell }{\cell }{\row }
{\xe \v THREAD_ZOMBIE\:ps.h}
{\xe \v ps.h\:THREAD_ZOMBIE}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid THREAD_ZOMBIE{\bkmkstart AAAAAAACMA}
{\bkmkend AAAAAAACMA}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 37} of file {\b ps.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACMB}
{\bkmkend AAAAAAACMB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v MeDequeueThread\:ps.h}
{\xe \v ps.h\:MeDequeueThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PETHREAD} MeDequeueThread ({\b Queue} * q)}}
\par
{\bkmkstart AAAAAAACMC}
{\bkmkend AAAAAAACMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 394} of file {\b ps.h}.}\par
}
{\xe \v MeDequeueThreadWithLock\:ps.h}
{\xe \v ps.h\:MeDequeueThreadWithLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PETHREAD} MeDequeueThreadWithLock ({\b Queue} * q)}}
\par
{\bkmkstart AAAAAAACMD}
{\bkmkend AAAAAAACMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 336} of file {\b ps.h}.}\par
}
{\xe \v MeEnqueueThread\:ps.h}
{\xe \v ps.h\:MeEnqueueThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MeEnqueueThread ({\b Queue} * queue, {\b PETHREAD} thread)}}
\par
{\bkmkstart AAAAAAACME}
{\bkmkend AAAAAAACME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 371} of file {\b ps.h}.}\par
}
{\xe \v MeEnqueueThreadWithLock\:ps.h}
{\xe \v ps.h\:MeEnqueueThreadWithLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void MeEnqueueThreadWithLock ({\b Queue} * queue, {\b PETHREAD} thread)}}
\par
{\bkmkstart AAAAAAACMF}
{\bkmkend AAAAAAACMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 306} of file {\b ps.h}.}\par
}
{\xe \v MsYieldExecution\:ps.h}
{\xe \v ps.h\:MsYieldExecution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MsYieldExecution ({\b PTRAP_FRAME} threadRegisters){\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACMG}
{\bkmkend AAAAAAACMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PsAllocateProcessId\:ps.h}
{\xe \v ps.h\:PsAllocateProcessId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} PsAllocateProcessId ({\b IN} {\b PEPROCESS} Process)}}
\par
{\bkmkstart AAAAAAACMH}
{\bkmkend AAAAAAACMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b cid.c}.}\par
}
{\xe \v PsAllocateThreadId\:ps.h}
{\xe \v ps.h\:PsAllocateThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HANDLE} PsAllocateThreadId ({\b IN} {\b PETHREAD} Thread)}}
\par
{\bkmkstart AAAAAAACMI}
{\bkmkend AAAAAAACMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b cid.c}.}\par
}
{\xe \v PsCreateProcess\:ps.h}
{\xe \v ps.h\:PsCreateProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsCreateProcess ({\b IN} const char * ExecutablePath, {\b OUT} {\b PHANDLE} ProcessHandle, {\b IN} {\b ACCESS_MASK} DesiredAccess, {\b _In_Opt} {\b HANDLE} ParentProcess)}}
\par
{\bkmkstart AAAAAAACMJ}
{\bkmkend AAAAAAACMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b process.c}.}\par
}
{\xe \v PsCreateSystemThread\:ps.h}
{\xe \v ps.h\:PsCreateSystemThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsCreateSystemThread ({\b ThreadEntry} entry, {\b THREAD_PARAMETER} parameter, {\b TimeSliceTicks} TIMESLICE)}}
\par
{\bkmkstart AAAAAAACMK}
{\bkmkend AAAAAAACMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b thread.c}.}\par
}
{\xe \v PsCreateThread\:ps.h}
{\xe \v ps.h\:PsCreateThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsCreateThread ({\b HANDLE} ProcessHandle, {\b PHANDLE} ThreadHandle, {\b ThreadEntry} EntryPoint, {\b THREAD_PARAMETER} ThreadParameter, {\b TimeSliceTicks} TimeSlice)}}
\par
{\bkmkstart AAAAAAACML}
{\bkmkend AAAAAAACML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b thread.c}.}\par
}
{\xe \v PsDeferKernelStackDeletion\:ps.h}
{\xe \v ps.h\:PsDeferKernelStackDeletion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsDeferKernelStackDeletion (void * StackBase, bool IsLarge)}}
\par
{\bkmkstart AAAAAAACMM}
{\bkmkend AAAAAAACMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b pswork.c}.}\par
}
{\xe \v PsDeleteThread\:ps.h}
{\xe \v ps.h\:PsDeleteThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsDeleteThread ({\b IN} void * Object)}}
\par
{\bkmkstart AAAAAAACMN}
{\bkmkend AAAAAAACMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b thread.c}.}\par
}
{\xe \v PsFreeCid\:ps.h}
{\xe \v ps.h\:PsFreeCid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsFreeCid ({\b IN} {\b HANDLE} Cid)}}
\par
{\bkmkstart AAAAAAACMO}
{\bkmkend AAAAAAACMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 163} of file {\b cid.c}.}\par
}
{\xe \v PsGetCurrentProcess\:ps.h}
{\xe \v ps.h\:PsGetCurrentProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PEPROCESS} PsGetCurrentProcess (void )}}
\par
{\bkmkstart AAAAAAACMP}
{\bkmkend AAAAAAACMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b ps.h}.}\par
}
{\xe \v PsGetCurrentThread\:ps.h}
{\xe \v ps.h\:PsGetCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} PsGetCurrentThread (void )}}
\par
{\bkmkstart AAAAAAACMQ}
{\bkmkend AAAAAAACMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b thread.c}.}\par
}
{\xe \v PsGetEProcessFromIProcess\:ps.h}
{\xe \v ps.h\:PsGetEProcessFromIProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PEPROCESS} PsGetEProcessFromIProcess ({\b IN} {\b PIPROCESS} IProcess)}}
\par
{\bkmkstart AAAAAAACMR}
{\bkmkend AAAAAAACMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 249} of file {\b ps.h}.}\par
}
{\xe \v PsGetEThreadFromIThread\:ps.h}
{\xe \v ps.h\:PsGetEThreadFromIThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} {\b PETHREAD} PsGetEThreadFromIThread ({\b IN} {\b PITHREAD} IThread)}}
\par
{\bkmkstart AAAAAAACMS}
{\bkmkend AAAAAAACMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b ps.h}.}\par
}
{\xe \v PsInitializeCidTable\:ps.h}
{\xe \v ps.h\:PsInitializeCidTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsInitializeCidTable (void )}}
\par
{\bkmkstart AAAAAAACMT}
{\bkmkend AAAAAAACMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b cid.c}.}\par
}
{\xe \v PsInitializeSystem\:ps.h}
{\xe \v ps.h\:PsInitializeSystem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MTSTATUS} PsInitializeSystem ({\b IN} enum {\b _PS_PHASE_ROUTINE} Phase)}}
\par
{\bkmkstart AAAAAAACMU}
{\bkmkend AAAAAAACMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 97} of file {\b psmgr.c}.}\par
}
{\xe \v PsInitializeWorkerThreads\:ps.h}
{\xe \v ps.h\:PsInitializeWorkerThreads}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsInitializeWorkerThreads (void )}}
\par
{\bkmkstart AAAAAAACMV}
{\bkmkend AAAAAAACMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b pswork.c}.}\par
}
{\xe \v PsIsKernelThread\:ps.h}
{\xe \v ps.h\:PsIsKernelThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool PsIsKernelThread ({\b IN} {\b PETHREAD} Thread)}}
\par
{\bkmkstart AAAAAAACMW}
{\bkmkend AAAAAAACMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 259} of file {\b ps.h}.}\par
}
{\xe \v PsLookupProcessByProcessId\:ps.h}
{\xe \v ps.h\:PsLookupProcessByProcessId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PEPROCESS} PsLookupProcessByProcessId ({\b IN} {\b HANDLE} ProcessId)}}
\par
{\bkmkstart AAAAAAACMX}
{\bkmkend AAAAAAACMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b cid.c}.}\par
}
{\xe \v PsLookupThreadByThreadId\:ps.h}
{\xe \v ps.h\:PsLookupThreadByThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PETHREAD} PsLookupThreadByThreadId ({\b IN} {\b HANDLE} ThreadId)}}
\par
{\bkmkstart AAAAAAACMY}
{\bkmkend AAAAAAACMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b cid.c}.}\par
}
{\xe \v PsTerminateCurrentProcess\:ps.h}
{\xe \v ps.h\:PsTerminateCurrentProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void PsTerminateCurrentProcess (void )}}
\par
{\bkmkstart AAAAAAACMZ}
{\bkmkend AAAAAAACMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b ps.h}.}\par
}
{\xe \v PsTerminateCurrentThread\:ps.h}
{\xe \v ps.h\:PsTerminateCurrentThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void PsTerminateCurrentThread (void )}}
\par
{\bkmkstart AAAAAAACNA}
{\bkmkend AAAAAAACNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 227} of file {\b ps.h}.}\par
}
{\xe \v PsTerminateProcess\:ps.h}
{\xe \v ps.h\:PsTerminateProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsTerminateProcess ({\b IN} {\b PEPROCESS} Process)}}
\par
{\bkmkstart AAAAAAACNB}
{\bkmkend AAAAAAACNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 231} of file {\b process.c}.}\par
}
{\xe \v PsTerminateThread\:ps.h}
{\xe \v ps.h\:PsTerminateThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PsTerminateThread ({\b IN} {\b PETHREAD} Thread, {\b IN} {\b MTSTATUS} ExitStatus)}}
\par
{\bkmkstart AAAAAAACNC}
{\bkmkend AAAAAAACNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 196} of file {\b thread.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACND}
{\bkmkend AAAAAAACND}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PsInitialSystemProcess\:ps.h}
{\xe \v ps.h\:PsInitialSystemProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPROCESS} PsInitialSystemProcess{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACNE}
{\bkmkend AAAAAAACNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Stack Overflow check only checks for minor overflows, that don't completely smash the stack, yet do change the canaries (since it only checks in function epilogue) Complete stack smashes are guarded with the guard page in MiCreateKernelStack. \par
}{
Definition at line {\b 162} of file {\b kernel.c}.}\par
}
{\xe \v PsProcessType\:ps.h}
{\xe \v ps.h\:PsProcessType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POBJECT_TYPE} PsProcessType{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACNF}
{\bkmkend AAAAAAACNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b psmgr.c}.}\par
}
{\xe \v PsThreadType\:ps.h}
{\xe \v ps.h\:PsThreadType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b POBJECT_TYPE} PsThreadType{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACNG}
{\bkmkend AAAAAAACNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b psmgr.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ps.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ps.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/ps.h}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_PROCESS_H}\par
00002 {\cf21 #define X86_MATANEL_PROCESS_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     mp.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains the header files required for process and thread management.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf20 // Base includes}\par
00023 {\cf21 #include <stdint.h>}\par
00024 {\cf21 #include <stddef.h>}\par
00025 \par
00026 {\cf20 // Other file includes}\par
00027 {\cf21 #include "me.h"}\par
00028 {\cf21 #include "ht.h"}\par
00029 {\cf21 #include "ob.h"}\par
00030 {\cf21 #include "core.h"}\par
00031 \par
00032 {\cf20 // Exception Includes}\par
00033 {\cf21 #include "exception.h"}\par
00034 \par
00035 {\cf20 // ------------------ ENUMERATORS ------------------}\par
00036 \par
00037 {\cf17 typedef} {\cf17 enum} _THREAD_STATE \{\par
00038     THREAD_RUNNING,\par
00039     THREAD_READY,\par
00040     THREAD_BLOCKED,\par
00041     THREAD_TERMINATING,\par
00042     THREAD_TERMINATED,\par
00043     THREAD_ZOMBIE\par
00044 \} THREAD_STATE, *PTHREAD_STATE;\par
00045 \par
00046 {\cf17 typedef} {\cf17 enum} _PROCESS_STATE \{\par
00047     PROCESS_RUNNING = 0, {\cf20 // A thread in the process is currently running}\par
00048     PROCESS_READY,  {\cf20 // The process is ready to run. (essentially its threads)}\par
00049     PROCESS_WAITING,  {\cf20 // Waiting on a mutual exclusion or just sleeping.}\par
00050     PROCESS_TERMINATING,   {\cf20 // The process is ongoing termination in the kernel.}\par
00051     PROCESS_TERMINATED,  {\cf20 // Process is terminated, but core parts of its structure has been kept.}\par
00052     PROCESS_SUSPENDED {\cf20 // The process has been suspended by the kernel, either by choice or forcefully.}\par
00053 \} PROCESS_STATE, *PPROCESS_STATE;\par
00054 \par
00055 {\cf17 typedef} {\cf17 enum} _PS_PHASE_ROUTINE \{\par
00056     PS_PHASE_INITIALIZE_SYSTEM = 0,\par
00057     PS_PHASE_INITIALIZE_WORKER_THREADS, \par
00058 \} PS_PHASE_ROUTINE;\par
00059 \par
00060 {\cf20 // ------------------ STRUCTURES ------------------}\par
00061 \par
00062 {\cf20 //}\par
00063 {\cf20 // Thread Access Rights}\par
00064 {\cf20 //}\par
00065 {\cf21 #define MT_THREAD_TERMINATE          0x0001    }{\cf20 // Terminate the thread}\par
00066 {\cf21 #define MT_THREAD_SUSPEND_RESUME     0x0002    }{\cf20 // Suspend or resume thread execution}\par
00067 {\cf21 #define MT_THREAD_SET_CONTEXT        0x0004    }{\cf20 // Modify thread CPU context (registers, RIP/RSP)}\par
00068 {\cf21 #define MT_THREAD_GET_CONTEXT        0x0008    }{\cf20 // Read thread CPU context}\par
00069 {\cf21 #define MT_THREAD_QUERY_INFO         0x0010    }{\cf20 // Query thread info (state, priority, etc.)}\par
00070 {\cf21 #define MT_THREAD_SET_INFO           0x0020    }{\cf20 // Modify thread info (priority, name, affinity)}\par
00071 \par
00072 {\cf21 #define MT_THREAD_ALL_ACCESS         0x003F    }{\cf20 // Request all valid thread access rights}\par
00073 \par
00074 \par
00075 {\cf20 //}\par
00076 {\cf20 // Process Access Rights}\par
00077 {\cf20 //}\par
00078 {\cf21 #define MT_PROCESS_TERMINATE          0x0001  }{\cf20 // Kill the process}\par
00079 {\cf21 #define MT_PROCESS_CREATE_THREAD      0x0002  }{\cf20 // Create a new thread inside process}\par
00080 {\cf21 #define MT_PROCESS_VM_OPERATION       0x0004  }{\cf20 // Allocate/Protect/Free process memory}\par
00081 {\cf21 #define MT_PROCESS_VM_READ            0x0008  }{\cf20 // Read from process memory}\par
00082 {\cf21 #define MT_PROCESS_VM_WRITE           0x0010  }{\cf20 // Write to process memory}\par
00083 {\cf21 #define MT_PROCESS_DUP_HANDLE         0x0020  }{\cf20 // Duplicate a handle into this process}\par
00084 {\cf21 #define MT_PROCESS_SET_INFO           0x0040  }{\cf20 // Modify process properties/metadata}\par
00085 {\cf21 #define MT_PROCESS_QUERY_INFO         0x0080  }{\cf20 // Query process details (PID, exit code, etc.)}\par
00086 {\cf21 #define MT_PROCESS_SUSPEND_RESUME     0x0100  }{\cf20 // Suspend / Resume process}\par
00087 {\cf21 #define MT_PROCESS_CREATE_PROCESS     0x0200  }{\cf20 // Create a new process.}\par
00088 \par
00089 {\cf21 #define MT_PROCESS_ALL_ACCESS         0x01FF  }{\cf20 // Everything above}\par
00090 \par
00091 {\cf17 typedef} {\cf17 struct }_EPROCESS \{\par
00092     {\cf17 struct }_IPROCESS InternalProcess; {\cf20 // Internal process structure. (KPROCESS Equivalent-ish)}\par
00093     {\cf18 char} ImageName[24]; {\cf20 // Process image name - e.g "mtoskrnl.mtexe"}\par
00094     HANDLE PID; {\cf20 // Process Identifier, unique identifier to the process.}\par
00095     HANDLE ParentProcess; {\cf20 // Parent Process Handle}\par
00096     uint32_t priority; {\cf20 // TODO}\par
00097     uint64_t CreationTime; {\cf20 // Timestamp of creation, seconds from 1970 January 1st. (may change)}\par
00098     {\cf20 // SID TODO. - User info as well, when users.}\par
00099 \par
00100     {\cf20 // TODO PEB}\par
00101     {\cf18 void}* FileBuffer; {\cf20 // TODO RemoveMe for sections.}\par
00102     uint64_t ImageBase; {\cf20 // Base Pointer of loaded process memory.}\par
00103 \par
00104     {\cf20 // Synchorinzation for internal functions.}\par
00105     {\cf17 struct }_RUNDOWN_REF ProcessRundown; {\cf20 // A process rundown that is used to safely synchronize the teardown or deletion of a process, ensuring no threads are still accessing it.}\par
00106 \par
00107     {\cf20 // Thread infos}\par
00108     {\cf17 struct }_ETHREAD* MainThread; {\cf20 // Pointer to the main thread created for the process.}\par
00109     DOUBLY_LINKED_LIST AllThreads; {\cf20 // A linked list of pointers to the current threads of the process. (inserted with each new creation)}\par
00110     uint32_t NumThreads; {\cf20 // Unsigned 32 bit integer representing the amount of threads the process has.}\par
00111     uint64_t NextStackTop; {\cf20 // A 64 bit value representing the next stack top for a newly created thread}\par
00112 \par
00113     {\cf20 // Handle Table}\par
00114     PHANDLE_TABLE ObjectTable;\par
00115 \par
00116     {\cf20 // VAD}\par
00117     {\cf17 struct }_MMVAD* VadRoot; {\cf20 // The Root of the VAD for the process. (used to find free virtual addresses spaces in the process, and information about them)}\par
00118     SPINLOCK VadLock; {\cf20 // The spinlock to ensure VAD atomicity.}\par
00119 \} EPROCESS, *PEPROCESS;\par
00120 \par
00121 {\cf17 typedef} {\cf17 struct }_ETHREAD \{\par
00122     {\cf17 struct }_ITHREAD InternalThread; {\cf20 // Internal thread structure. (KTHREAD Equivalent-ish)}\par
00123     {\cf20 // TODO TEB}\par
00124     {\cf17 struct }_EXCEPTION_REGISTRATION_RECORD ExceptionRegistration;\par
00125     HANDLE TID;           {\cf20 /* thread id */}\par
00126     {\cf17 struct }_EVENT* CurrentEvent; {\cf20 /* ptr to current EVENT if any. */}\par
00127     {\cf17 struct }_EPROCESS* ParentProcess; {\cf20 /* pointer to the parent process of the thread */}\par
00128     {\cf17 struct }_DOUBLY_LINKED_LIST ThreadListEntry; {\cf20 // Forward and backward links to queue threads in.}\par
00129     {\cf17 struct }_RUNDOWN_REF ThreadRundown; {\cf20 // A thread rundown that is used to safely synchronize the teardown or deletion of a thread, ensuring no other threads are still accessing it.}\par
00130     MTSTATUS ExitStatus; {\cf20 // The status the thread exited in.}\par
00131     {\cf20 /* TODO: priority, affinity, wait list, etc. */}\par
00132 \} ETHREAD, *PETHREAD;\par
00133 \par
00134 {\cf17 typedef} {\cf17 struct }_STACK_REAPER_ENTRY \{\par
00135     {\cf17 struct }_STACK_REAPER_ENTRY* Next;\par
00136     {\cf18 void}* StackBase;\par
00137     {\cf18 bool} IsLarge;\par
00138 \} STACK_REAPER_ENTRY, * PSTACK_REAPER_ENTRY;\par
00139 \par
00140 {\cf20 // ------------------ MACROS ------------------}\par
00141 {\cf21 #define PROCESS_STACK_SIZE (32*1024) }{\cf20 // 32 KiB}\par
00142 {\cf21 #define PROCESS_STACK_ALIGNMENT 16 }{\cf20 // Alignment of 16 Bytes.}\par
00143 \par
00144 {\cf20 // ------------------ TYPE DEFINES ------------------}\par
00145 \par
00146 {\cf17 typedef} {\cf18 void}* THREAD_PARAMETER;\par
00147 {\cf17 typedef} void (*ThreadEntry)(THREAD_PARAMETER);\par
00148 \par
00149 {\cf20 // ------------------ FUNCTIONS ------------------}\par
00150 \par
00151 {\cf17 extern} EPROCESS PsInitialSystemProcess;\par
00152 {\cf17 extern} POBJECT_TYPE PsProcessType;\par
00153 {\cf17 extern} POBJECT_TYPE PsThreadType;\par
00154 \par
00155 MTSTATUS\par
00156 PsCreateProcess(\par
00157     IN {\cf17 const} {\cf18 char}* ExecutablePath,\par
00158     OUT PHANDLE ProcessHandle,\par
00159     IN ACCESS_MASK DesiredAccess,\par
00160     _In_Opt HANDLE ParentProcess\par
00161 );\par
00162 \par
00163 MTSTATUS\par
00164 PsCreateThread(\par
00165     HANDLE ProcessHandle,\par
00166     PHANDLE ThreadHandle,\par
00167     ThreadEntry EntryPoint,\par
00168     THREAD_PARAMETER ThreadParameter,\par
00169     TimeSliceTicks TimeSlice\par
00170 );\par
00171 \par
00172 {\cf17 extern} {\cf18 void} MsYieldExecution(PTRAP_FRAME threadRegisters);\par
00173 MTSTATUS PsCreateSystemThread(ThreadEntry entry, THREAD_PARAMETER parameter, TimeSliceTicks TIMESLICE);\par
00174 \par
00175 MTSTATUS\par
00176 PsInitializeSystem(\par
00177     IN {\cf17 enum} _PS_PHASE_ROUTINE Phase\par
00178 );\par
00179 \par
00180 {\cf18 void} PsDeferKernelStackDeletion({\cf18 void}* StackBase, {\cf18 bool} IsLarge);\par
00181 \par
00182 {\cf18 void}\par
00183 PsTerminateProcess(\par
00184     IN PEPROCESS Process\par
00185 );\par
00186 \par
00187 {\cf18 void}\par
00188 PsTerminateThread(\par
00189     IN PETHREAD Thread,\par
00190     IN MTSTATUS ExitStatus\par
00191 );\par
00192 \par
00193 {\cf18 void}\par
00194 PsDeleteThread(\par
00195     IN {\cf18 void}* Object\par
00196 );\par
00197 \par
00198 PETHREAD\par
00199 PsGetCurrentThread(\par
00200     {\cf18 void}\par
00201 );\par
00202 \par
00203 {\cf18 void} PsInitializeWorkerThreads({\cf18 void});\par
00204 \par
00205 {\cf18 void}\par
00206 PsInitializeCidTable(\par
00207     {\cf18 void}\par
00208 );\par
00209 \par
00210 FORCEINLINE\par
00211 PEPROCESS\par
00212 PsGetCurrentProcess(\par
00213     {\cf18 void}\par
00214 )\par
00215 \par
00216 {\cf20 // Will return the current process the thread is attached to (could be its parent thread, could be another in an APC)}\par
00217 \par
00218 \{\par
00219     {\cf19 if} (MeGetCurrentThread()) \{\par
00220         {\cf19 return} MeGetCurrentThread()->ApcState.SavedApcProcess;\par
00221     \}\par
00222     {\cf19 else} {\cf19 return} NULL;\par
00223 \}\par
00224 \par
00225 FORCEINLINE\par
00226 {\cf18 void}\par
00227 PsTerminateCurrentThread({\cf18 void}) \{\par
00228     {\cf19 return} PsTerminateThread(PsGetCurrentThread(), MT_SUCCESS);\par
00229 \}\par
00230 \par
00231 FORCEINLINE\par
00232 {\cf18 void}\par
00233 PsTerminateCurrentProcess({\cf18 void}) \{\par
00234     {\cf19 return} PsTerminateProcess(PsGetCurrentProcess());\par
00235 \}\par
00236 \par
00237 FORCEINLINE\par
00238 PETHREAD\par
00239 PsGetEThreadFromIThread(\par
00240     IN PITHREAD IThread\par
00241 )\par
00242 \par
00243 \{\par
00244     {\cf19 return} CONTAINING_RECORD(IThread, ETHREAD, InternalThread);\par
00245 \}\par
00246 \par
00247 FORCEINLINE\par
00248 PEPROCESS\par
00249 PsGetEProcessFromIProcess(\par
00250     IN PIPROCESS IProcess\par
00251 )\par
00252 \par
00253 \{\par
00254     {\cf19 return} CONTAINING_RECORD(IProcess, EPROCESS, InternalProcess);\par
00255 \}\par
00256 \par
00257 FORCEINLINE\par
00258 {\cf18 bool}\par
00259 PsIsKernelThread(\par
00260     IN PETHREAD Thread\par
00261 )\par
00262 \par
00263 \{\par
00264     {\cf20 // safety guard, can't believe i had to put it.}\par
00265     {\cf19 if} (Thread == NULL) {\cf19 return} {\cf17 true};\par
00266     {\cf19 return} (Thread->ParentProcess == &PsInitialSystemProcess);\par
00267 \}\par
00268 \par
00269 HANDLE\par
00270 PsAllocateProcessId(\par
00271     IN  PEPROCESS Process\par
00272 );\par
00273 \par
00274 HANDLE\par
00275 PsAllocateThreadId(\par
00276     IN  PETHREAD Thread\par
00277 );\par
00278 \par
00279 PEPROCESS\par
00280 PsLookupProcessByProcessId(\par
00281     IN HANDLE ProcessId\par
00282 );\par
00283 \par
00284 PETHREAD\par
00285 PsLookupThreadByThreadId(\par
00286     IN HANDLE ThreadId\par
00287 );\par
00288 \par
00289 {\cf18 void}\par
00290 PsFreeCid(\par
00291     IN HANDLE Cid\par
00292 );\par
00293 \par
00294 \par
00295 \par
00296 \par
00297 \par
00298 \par
00299 \par
00300 {\cf20 // End Of Ps API.}\par
00301 \par
00302 {\cf20 // Executive Functions - Are in PS.H}\par
00303 {\cf20 // Enqueues a thread into the queue with spinlock protection.}\par
00304 FORCEINLINE\par
00305 {\cf18 void}\par
00306 MeEnqueueThreadWithLock(\par
00307     Queue* queue, PETHREAD thread)\par
00308 \{\par
00309     IRQL flags;\par
00310     MsAcquireSpinlock(&queue->lock, &flags);\par
00311 \par
00312     {\cf20 // Initialize the new node's links}\par
00313     thread->ThreadListEntry.Flink = NULL;\par
00314 \par
00315     {\cf19 if} (queue->tail) \{\par
00316         {\cf20 // Link new node to current tail}\par
00317         thread->ThreadListEntry.Blink = &queue->tail->ThreadListEntry;\par
00318         {\cf20 // Link current tail to new node}\par
00319         queue->tail->ThreadListEntry.Flink = &thread->ThreadListEntry;\par
00320     \}\par
00321     {\cf19 else} \{\par
00322         {\cf20 // List was empty}\par
00323         thread->ThreadListEntry.Blink = NULL;\par
00324         queue->head = thread;\par
00325     \}\par
00326 \par
00327     {\cf20 // Update tail to be the new thread}\par
00328     queue->tail = thread;\par
00329 \par
00330     MsReleaseSpinlock(&queue->lock, flags);\par
00331 \}\par
00332 \par
00333 {\cf20 // Dequeues the head thread from the queue with spinlock protection.}\par
00334 FORCEINLINE\par
00335 PETHREAD\par
00336 MeDequeueThreadWithLock(Queue* q)\par
00337 \{\par
00338     IRQL flags;\par
00339     MsAcquireSpinlock(&q->lock, &flags);\par
00340 \par
00341     {\cf19 if} (!q->head) \{\par
00342         MsReleaseSpinlock(&q->lock, flags);\par
00343         {\cf19 return} NULL;\par
00344     \}\par
00345 \par
00346     PETHREAD t = q->head;\par
00347 \par
00348     {\cf20 // Check if there is a next item}\par
00349     {\cf19 if} (t->ThreadListEntry.Flink) \{\par
00350         {\cf20 // Get the ETHREAD from the generic list entry}\par
00351         q->head = CONTAINING_RECORD(t->ThreadListEntry.Flink, ETHREAD, ThreadListEntry);\par
00352         {\cf20 // The new head has no previous item}\par
00353         q->head->ThreadListEntry.Blink = NULL;\par
00354     \}\par
00355     {\cf19 else} \{\par
00356         {\cf20 // Queue is now empty}\par
00357         q->head = NULL;\par
00358         q->tail = NULL;\par
00359     \}\par
00360 \par
00361     {\cf20 // Isolate the removed thread}\par
00362     t->ThreadListEntry.Flink = NULL;\par
00363     t->ThreadListEntry.Blink = NULL;\par
00364 \par
00365     MsReleaseSpinlock(&q->lock, flags);\par
00366     {\cf19 return} t;\par
00367 \}\par
00368 \par
00369 {\cf20 // Enqueues the thread given to the queue (No Lock).}\par
00370 FORCEINLINE\par
00371 {\cf18 void} MeEnqueueThread(Queue* queue, PETHREAD thread)\par
00372 \{\par
00373     {\cf20 // Initialize the new node's links}\par
00374     thread->ThreadListEntry.Flink = NULL;\par
00375 \par
00376     {\cf19 if} (queue->tail) \{\par
00377         {\cf20 // Link new node to current tail}\par
00378         thread->ThreadListEntry.Blink = &queue->tail->ThreadListEntry;\par
00379         {\cf20 // Link current tail to new node}\par
00380         queue->tail->ThreadListEntry.Flink = &thread->ThreadListEntry;\par
00381     \}\par
00382     {\cf19 else} \{\par
00383         {\cf20 // List was empty}\par
00384         thread->ThreadListEntry.Blink = NULL;\par
00385         queue->head = thread;\par
00386     \}\par
00387 \par
00388     {\cf20 // Update tail to be the new thread}\par
00389     queue->tail = thread;\par
00390 \}\par
00391 \par
00392 {\cf20 // Dequeues the head thread from the queue (No Lock).}\par
00393 FORCEINLINE\par
00394 PETHREAD MeDequeueThread(Queue* q)\par
00395 \{\par
00396     {\cf19 if} (!q->head) \{\par
00397         {\cf19 return} NULL;\par
00398     \}\par
00399 \par
00400     PETHREAD t = q->head;\par
00401 \par
00402     {\cf20 // Check if there is a next item}\par
00403     {\cf19 if} (t->ThreadListEntry.Flink) \{\par
00404         {\cf20 // Get the ETHREAD from the generic list entry}\par
00405         q->head = CONTAINING_RECORD(t->ThreadListEntry.Flink, ETHREAD, ThreadListEntry);\par
00406         {\cf20 // The new head has no previous item}\par
00407         q->head->ThreadListEntry.Blink = NULL;\par
00408     \}\par
00409     {\cf19 else} \{\par
00410         {\cf20 // Queue is now empty}\par
00411         q->head = NULL;\par
00412         q->tail = NULL;\par
00413     \}\par
00414 \par
00415     {\cf20 // Isolate the removed thread}\par
00416     t->ThreadListEntry.Flink = NULL;\par
00417     t->ThreadListEntry.Blink = NULL;\par
00418 \par
00419     {\cf19 return} t;\par
00420 \}\par
00421 \par
00422 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/rtl.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/rtl.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/rtl.h}
{\bkmkstart AAAAAAACNH}
{\bkmkend AAAAAAACNH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "macros.h"}\par
{\f2 #include "annotations.h"}\par
{\f2 #include "../mtstatus.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b RtlZeroMemory} ({\b IN} void *Destination, {\b IN} size_t {\b Length})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACNI}
{\bkmkend AAAAAAACNI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v RtlZeroMemory\:rtl.h}
{\xe \v rtl.h\:RtlZeroMemory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void RtlZeroMemory ({\b IN} void * Destination, {\b IN} size_t Length)}}
\par
{\bkmkstart AAAAAAACNJ}
{\bkmkend AAAAAAACNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b rtl.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rtl.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/rtl.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/rtl.h}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef X86_MATANEL_RUNTIME_LIBRARIES_H}\par
00002 {\cf21 #define X86_MATANEL_RUNTIME_LIBRARIES_H}\par
00003 \par
00004 {\cf20 /*++}\par
00005 {\cf20 }\par
00006 {\cf20 Module Name:}\par
00007 {\cf20 }\par
00008 {\cf20     rtl.h}\par
00009 {\cf20 }\par
00010 {\cf20 Purpose:}\par
00011 {\cf20 }\par
00012 {\cf20     This module contains declarations for the runtime library (RTL), which provide core support routines used by other kernel components.}\par
00013 {\cf20 }\par
00014 {\cf20 Author:}\par
00015 {\cf20 }\par
00016 {\cf20     slep (Matanel) 2025.}\par
00017 {\cf20 }\par
00018 {\cf20 Revision History:}\par
00019 {\cf20 }\par
00020 {\cf20 --*/}\par
00021 \par
00022 {\cf21 #include <stdint.h>}\par
00023 {\cf21 #include <stddef.h>}\par
00024 {\cf21 #include <stdbool.h>}\par
00025 {\cf21 #include "macros.h"}\par
00026 {\cf21 #include "annotations.h"}\par
00027 {\cf21 #include "../mtstatus.h"}\par
00028 \par
00029 FORCEINLINE\par
00030 {\cf18 void}\par
00031 RtlZeroMemory(\par
00032     IN  {\cf18 void}* Destination,\par
00033     IN  {\cf18 size_t} Length\par
00034 )\par
00035 {\cf20 /*++}\par
00036 {\cf20 }\par
00037 {\cf20 Routine Description:}\par
00038 {\cf20 }\par
00039 {\cf20     Fills a block of memory with zeros.}\par
00040 {\cf20 }\par
00041 {\cf20 Arguments:}\par
00042 {\cf20 }\par
00043 {\cf20     Destination - Pointer to the memory block to zero.}\par
00044 {\cf20     Length      - Number of bytes to zero.}\par
00045 {\cf20 }\par
00046 {\cf20 Return Value:}\par
00047 {\cf20 }\par
00048 {\cf20     None.}\par
00049 {\cf20 }\par
00050 {\cf20 --*/}\par
00051 \{\par
00052     {\cf18 unsigned} {\cf18 char}* ptr = ({\cf18 unsigned} {\cf18 char}*)Destination;\par
00053     {\cf19 while} (Length--)\par
00054         *ptr++ = 0;\par
00055 \}\par
00056 \par
00057 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/stdarg_myos.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/stdarg_myos.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/stdarg_myos.h}
{\bkmkstart AAAAAAACNK}
{\bkmkend AAAAAAACNK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b va_start}(ap,  last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b va_arg}(ap,  type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b va_end}(ap)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef __builtin_va_list {\b va_list}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACNL}
{\bkmkend AAAAAAACNL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v va_arg\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_arg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define va_arg( ap,  type)}}
\par
{\bkmkstart AAAAAAACNM}
{\bkmkend AAAAAAACNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_va_arg(ap, type)\par
}
{
Definition at line {\b 12} of file {\b stdarg_myos.h}.}\par
}
{\xe \v va_end\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define va_end( ap)}}
\par
{\bkmkstart AAAAAAACNN}
{\bkmkend AAAAAAACNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_va_end(ap)\par
}
{
Definition at line {\b 13} of file {\b stdarg_myos.h}.}\par
}
{\xe \v va_start\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define va_start( ap,  last)}}
\par
{\bkmkstart AAAAAAACNO}
{\bkmkend AAAAAAACNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid __builtin_va_start(ap, last)\par
}
{
Definition at line {\b 11} of file {\b stdarg_myos.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACNP}
{\bkmkend AAAAAAACNP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v va_list\:stdarg_myos.h}
{\xe \v stdarg_myos.h\:va_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef __builtin_va_list {\b va_list}}}
\par
{\bkmkstart AAAAAAACNQ}
{\bkmkend AAAAAAACNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b stdarg_myos.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
stdarg_myos.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/stdarg_myos.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/includes/stdarg_myos.h}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Variadic functions compiler helpers.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef __STDARG_H}\par
00007 {\cf21 #define __STDARG_H}\par
00008 {\cf21 #ifndef _MSC_VER}\par
00009 {\cf17 typedef} __builtin_va_list va_list;\par
00010 \par
00011 {\cf21 #define va_start(ap, last) __builtin_va_start(ap, last)}\par
00012 {\cf21 #define va_arg(ap, type)   __builtin_va_arg(ap, type)}\par
00013 {\cf21 #define va_end(ap)         __builtin_va_end(ap)}\par
00014 {\cf21 #else}\par
00015 {\cf21 #define va_arg(ap, type) ((type)0)}\par
00016 {\cf21 #endif}\par
00017 \par
00018 {\cf21 #endif}\par
00019 {\cf21 #pragma once}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/atomic.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/atomic.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/atomic.h}
{\bkmkstart AAAAAAACNR}
{\bkmkend AAAAAAACNR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdatomic.h>}\par
{\f2 #include "../includes/annotations.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ATOMIC_ORDER}\~ __ATOMIC_SEQ_CST\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int8_t {\b InterlockedExchange8} (volatile int8_t *target, int8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int16_t {\b InterlockedExchange16} (volatile int16_t *target, int16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedExchange32} (volatile int32_t *target, int32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedExchange64} (volatile int64_t *target, int64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b InterlockedExchangeU8} (volatile uint8_t *target, uint8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint16_t {\b InterlockedExchangeU16} (volatile uint16_t *target, uint16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedExchangeU32} (volatile uint32_t *target, uint32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedExchangeU64} (volatile uint64_t *target, uint64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b InterlockedExchangePtr} (volatile void *volatile *target, void *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int8_t {\b InterlockedCompareExchange8} (volatile int8_t *target, int8_t value, int8_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int16_t {\b InterlockedCompareExchange16} (volatile int16_t *target, int16_t value, int16_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedCompareExchange32} (volatile int32_t *target, int32_t value, int32_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedCompareExchange64} (volatile int64_t *target, int64_t value, int64_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b InterlockedCompareExchangeU8} (volatile uint8_t *target, uint8_t value, uint8_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint16_t {\b InterlockedCompareExchangeU16} (volatile uint16_t *target, uint16_t value, uint16_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedCompareExchangeU32} (volatile uint32_t *target, uint32_t value, uint32_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedCompareExchangeU64} (volatile uint64_t *target, uint64_t value, uint64_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b InterlockedCompareExchangePtr} (volatile void *volatile *target, void *value, void *comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int8_t {\b InterlockedAdd8} (volatile int8_t *target, int8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int16_t {\b InterlockedAdd16} (volatile int16_t *target, int16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedAdd32} (volatile int32_t *target, int32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedAdd64} (volatile int64_t *target, int64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b InterlockedAddU8} (volatile uint8_t *target, uint8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint16_t {\b InterlockedAddU16} (volatile uint16_t *target, uint16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedAddU32} (volatile uint32_t *target, uint32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedAddU64} (volatile uint64_t *target, uint64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedIncrement32} (volatile int32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedDecrement32} (volatile int32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedIncrementU32} (volatile uint32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedDecrementU32} (volatile uint32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedIncrement64} (volatile int64_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedIncrementU64} (volatile uint64_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedDecrement64} (volatile int64_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedDecrementU64} (volatile uint64_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int8_t {\b InterlockedAnd8} (volatile int8_t *target, int8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int16_t {\b InterlockedAnd16} (volatile int16_t *target, int16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedAnd32} (volatile int32_t *target, int32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedAnd64} (volatile int64_t *target, int64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b InterlockedAndU8} (volatile uint8_t *target, uint8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint16_t {\b InterlockedAndU16} (volatile uint16_t *target, uint16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedAndU32} (volatile uint32_t *target, uint32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedAndU64} (volatile uint64_t *target, uint64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int8_t {\b InterlockedOr8} (volatile int8_t *target, int8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int16_t {\b InterlockedOr16} (volatile int16_t *target, int16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedOr32} (volatile int32_t *target, int32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedOr64} (volatile int64_t *target, int64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b InterlockedOrU8} (volatile uint8_t *target, uint8_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint16_t {\b InterlockedOrU16} (volatile uint16_t *target, uint16_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedOrU32} (volatile uint32_t *target, uint32_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedOrU64} (volatile uint64_t *target, uint64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uintptr_t {\b InterlockedExchangeUintptr} (volatile uintptr_t *target, uintptr_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uintptr_t {\b InterlockedCompareExchangeUintptr} (volatile uintptr_t *target, uintptr_t value, uintptr_t comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uintptr_t {\b InterlockedFetchAndUintptr} (volatile uintptr_t *target, uintptr_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uintptr_t {\b InterlockedFetchOrUintptr} (volatile uintptr_t *target, uintptr_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b InterlockedExchangeBool} (volatile bool *target, bool value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b InterlockedExchangePointer} (volatile void *volatile *target, void *value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b InterlockedCompareExchangePointer} (volatile void *volatile *target, void *value, void *comparand)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void * {\b InterlockedFetchPointer} (volatile void *volatile *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedSetMaskU32} (volatile uint32_t *target, uint32_t mask)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedClearMaskU32} (volatile uint32_t *target, uint32_t mask)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b AtomicLoad32} (volatile int32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b AtomicStore32} (volatile int32_t *target, int32_t v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b AtomicLoadU32} (volatile uint32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b AtomicStoreU32} (volatile uint32_t *target, uint32_t v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int8_t {\b InterlockedFetch8} (volatile int8_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int16_t {\b InterlockedFetch16} (volatile int16_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int32_t {\b InterlockedFetch32} (volatile int32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} int64_t {\b InterlockedFetch64} (volatile int64_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint8_t {\b InterlockedFetchU8} (volatile uint8_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint16_t {\b InterlockedFetchU16} (volatile uint16_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint32_t {\b InterlockedFetchU32} (volatile uint32_t *target)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b InterlockedFetchU64} (volatile uint64_t *target)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACNS}
{\bkmkend AAAAAAACNS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ATOMIC_ORDER\:atomic.h}
{\xe \v atomic.h\:ATOMIC_ORDER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ATOMIC_ORDER\~ __ATOMIC_SEQ_CST}}
\par
{\bkmkstart AAAAAAACNT}
{\bkmkend AAAAAAACNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b atomic.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACNU}
{\bkmkend AAAAAAACNU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v AtomicLoad32\:atomic.h}
{\xe \v atomic.h\:AtomicLoad32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t AtomicLoad32 (volatile int32_t * target)}}
\par
{\bkmkstart AAAAAAACNV}
{\bkmkend AAAAAAACNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 191} of file {\b atomic.h}.}\par
}
{\xe \v AtomicLoadU32\:atomic.h}
{\xe \v atomic.h\:AtomicLoadU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t AtomicLoadU32 (volatile uint32_t * target)}}
\par
{\bkmkstart AAAAAAACNW}
{\bkmkend AAAAAAACNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 197} of file {\b atomic.h}.}\par
}
{\xe \v AtomicStore32\:atomic.h}
{\xe \v atomic.h\:AtomicStore32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void AtomicStore32 (volatile int32_t * target, int32_t v)}}
\par
{\bkmkstart AAAAAAACNX}
{\bkmkend AAAAAAACNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b atomic.h}.}\par
}
{\xe \v AtomicStoreU32\:atomic.h}
{\xe \v atomic.h\:AtomicStoreU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void AtomicStoreU32 (volatile uint32_t * target, uint32_t v)}}
\par
{\bkmkstart AAAAAAACNY}
{\bkmkend AAAAAAACNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAdd16\:atomic.h}
{\xe \v atomic.h\:InterlockedAdd16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int16_t InterlockedAdd16 (volatile int16_t * target, int16_t value)}}
\par
{\bkmkstart AAAAAAACNZ}
{\bkmkend AAAAAAACNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAdd32\:atomic.h}
{\xe \v atomic.h\:InterlockedAdd32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedAdd32 (volatile int32_t * target, int32_t value)}}
\par
{\bkmkstart AAAAAAACOA}
{\bkmkend AAAAAAACOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 104} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAdd64\:atomic.h}
{\xe \v atomic.h\:InterlockedAdd64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedAdd64 (volatile int64_t * target, int64_t value)}}
\par
{\bkmkstart AAAAAAACOB}
{\bkmkend AAAAAAACOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAdd8\:atomic.h}
{\xe \v atomic.h\:InterlockedAdd8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int8_t InterlockedAdd8 (volatile int8_t * target, int8_t value)}}
\par
{\bkmkstart AAAAAAACOC}
{\bkmkend AAAAAAACOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAddU16\:atomic.h}
{\xe \v atomic.h\:InterlockedAddU16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint16_t InterlockedAddU16 (volatile uint16_t * target, uint16_t value)}}
\par
{\bkmkstart AAAAAAACOD}
{\bkmkend AAAAAAACOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAddU32\:atomic.h}
{\xe \v atomic.h\:InterlockedAddU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedAddU32 (volatile uint32_t * target, uint32_t value)}}
\par
{\bkmkstart AAAAAAACOE}
{\bkmkend AAAAAAACOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAddU64\:atomic.h}
{\xe \v atomic.h\:InterlockedAddU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedAddU64 (volatile uint64_t * target, uint64_t value)}}
\par
{\bkmkstart AAAAAAACOF}
{\bkmkend AAAAAAACOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAddU8\:atomic.h}
{\xe \v atomic.h\:InterlockedAddU8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t InterlockedAddU8 (volatile uint8_t * target, uint8_t value)}}
\par
{\bkmkstart AAAAAAACOG}
{\bkmkend AAAAAAACOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 107} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAnd16\:atomic.h}
{\xe \v atomic.h\:InterlockedAnd16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int16_t InterlockedAnd16 (volatile int16_t * target, int16_t value)}}
\par
{\bkmkstart AAAAAAACOH}
{\bkmkend AAAAAAACOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAnd32\:atomic.h}
{\xe \v atomic.h\:InterlockedAnd32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedAnd32 (volatile int32_t * target, int32_t value)}}
\par
{\bkmkstart AAAAAAACOI}
{\bkmkend AAAAAAACOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 128} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAnd64\:atomic.h}
{\xe \v atomic.h\:InterlockedAnd64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedAnd64 (volatile int64_t * target, int64_t value)}}
\par
{\bkmkstart AAAAAAACOJ}
{\bkmkend AAAAAAACOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAnd8\:atomic.h}
{\xe \v atomic.h\:InterlockedAnd8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int8_t InterlockedAnd8 (volatile int8_t * target, int8_t value)}}
\par
{\bkmkstart AAAAAAACOK}
{\bkmkend AAAAAAACOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAndU16\:atomic.h}
{\xe \v atomic.h\:InterlockedAndU16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint16_t InterlockedAndU16 (volatile uint16_t * target, uint16_t value)}}
\par
{\bkmkstart AAAAAAACOL}
{\bkmkend AAAAAAACOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 132} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAndU32\:atomic.h}
{\xe \v atomic.h\:InterlockedAndU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedAndU32 (volatile uint32_t * target, uint32_t value)}}
\par
{\bkmkstart AAAAAAACOM}
{\bkmkend AAAAAAACOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAndU64\:atomic.h}
{\xe \v atomic.h\:InterlockedAndU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedAndU64 (volatile uint64_t * target, uint64_t value)}}
\par
{\bkmkstart AAAAAAACON}
{\bkmkend AAAAAAACON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 134} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedAndU8\:atomic.h}
{\xe \v atomic.h\:InterlockedAndU8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t InterlockedAndU8 (volatile uint8_t * target, uint8_t value)}}
\par
{\bkmkstart AAAAAAACOO}
{\bkmkend AAAAAAACOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedClearMaskU32\:atomic.h}
{\xe \v atomic.h\:InterlockedClearMaskU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedClearMaskU32 (volatile uint32_t * target, uint32_t mask)}}
\par
{\bkmkstart AAAAAAACOP}
{\bkmkend AAAAAAACOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchange16\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchange16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int16_t InterlockedCompareExchange16 (volatile int16_t * target, int16_t value, int16_t comparand)}}
\par
{\bkmkstart AAAAAAACOQ}
{\bkmkend AAAAAAACOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchange32\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchange32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedCompareExchange32 (volatile int32_t * target, int32_t value, int32_t comparand)}}
\par
{\bkmkstart AAAAAAACOR}
{\bkmkend AAAAAAACOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchange64\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchange64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedCompareExchange64 (volatile int64_t * target, int64_t value, int64_t comparand)}}
\par
{\bkmkstart AAAAAAACOS}
{\bkmkend AAAAAAACOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchange8\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchange8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int8_t InterlockedCompareExchange8 (volatile int8_t * target, int8_t value, int8_t comparand)}}
\par
{\bkmkstart AAAAAAACOT}
{\bkmkend AAAAAAACOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangePointer\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * InterlockedCompareExchangePointer (volatile void *volatile * target, void * value, void * comparand)}}
\par
{\bkmkstart AAAAAAACOU}
{\bkmkend AAAAAAACOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 171} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangePtr\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangePtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * InterlockedCompareExchangePtr (volatile void *volatile * target, void * value, void * comparand)}}
\par
{\bkmkstart AAAAAAACOV}
{\bkmkend AAAAAAACOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangeU16\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangeU16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint16_t InterlockedCompareExchangeU16 (volatile uint16_t * target, uint16_t value, uint16_t comparand)}}
\par
{\bkmkstart AAAAAAACOW}
{\bkmkend AAAAAAACOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangeU32\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangeU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedCompareExchangeU32 (volatile uint32_t * target, uint32_t value, uint32_t comparand)}}
\par
{\bkmkstart AAAAAAACOX}
{\bkmkend AAAAAAACOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangeU64\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangeU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedCompareExchangeU64 (volatile uint64_t * target, uint64_t value, uint64_t comparand)}}
\par
{\bkmkstart AAAAAAACOY}
{\bkmkend AAAAAAACOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangeU8\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangeU8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t InterlockedCompareExchangeU8 (volatile uint8_t * target, uint8_t value, uint8_t comparand)}}
\par
{\bkmkstart AAAAAAACOZ}
{\bkmkend AAAAAAACOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedCompareExchangeUintptr\:atomic.h}
{\xe \v atomic.h\:InterlockedCompareExchangeUintptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uintptr_t InterlockedCompareExchangeUintptr (volatile uintptr_t * target, uintptr_t value, uintptr_t comparand)}}
\par
{\bkmkstart AAAAAAACPA}
{\bkmkend AAAAAAACPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 152} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedDecrement32\:atomic.h}
{\xe \v atomic.h\:InterlockedDecrement32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedDecrement32 (volatile int32_t * target)}}
\par
{\bkmkstart AAAAAAACPB}
{\bkmkend AAAAAAACPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 114} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedDecrement64\:atomic.h}
{\xe \v atomic.h\:InterlockedDecrement64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedDecrement64 (volatile int64_t * target)}}
\par
{\bkmkstart AAAAAAACPC}
{\bkmkend AAAAAAACPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedDecrementU32\:atomic.h}
{\xe \v atomic.h\:InterlockedDecrementU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedDecrementU32 (volatile uint32_t * target)}}
\par
{\bkmkstart AAAAAAACPD}
{\bkmkend AAAAAAACPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedDecrementU64\:atomic.h}
{\xe \v atomic.h\:InterlockedDecrementU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedDecrementU64 (volatile uint64_t * target)}}
\par
{\bkmkstart AAAAAAACPE}
{\bkmkend AAAAAAACPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchange16\:atomic.h}
{\xe \v atomic.h\:InterlockedExchange16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int16_t InterlockedExchange16 (volatile int16_t * target, int16_t value)}}
\par
{\bkmkstart AAAAAAACPF}
{\bkmkend AAAAAAACPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchange32\:atomic.h}
{\xe \v atomic.h\:InterlockedExchange32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedExchange32 (volatile int32_t * target, int32_t value)}}
\par
{\bkmkstart AAAAAAACPG}
{\bkmkend AAAAAAACPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchange64\:atomic.h}
{\xe \v atomic.h\:InterlockedExchange64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedExchange64 (volatile int64_t * target, int64_t value)}}
\par
{\bkmkstart AAAAAAACPH}
{\bkmkend AAAAAAACPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchange8\:atomic.h}
{\xe \v atomic.h\:InterlockedExchange8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int8_t InterlockedExchange8 (volatile int8_t * target, int8_t value)}}
\par
{\bkmkstart AAAAAAACPI}
{\bkmkend AAAAAAACPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangeBool\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangeBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool InterlockedExchangeBool (volatile bool * target, bool value)}}
\par
{\bkmkstart AAAAAAACPJ}
{\bkmkend AAAAAAACPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangePointer\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangePointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * InterlockedExchangePointer (volatile void *volatile * target, void * value)}}
\par
{\bkmkstart AAAAAAACPK}
{\bkmkend AAAAAAACPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangePtr\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangePtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * InterlockedExchangePtr (volatile void *volatile * target, void * value)}}
\par
{\bkmkstart AAAAAAACPL}
{\bkmkend AAAAAAACPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangeU16\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangeU16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint16_t InterlockedExchangeU16 (volatile uint16_t * target, uint16_t value)}}
\par
{\bkmkstart AAAAAAACPM}
{\bkmkend AAAAAAACPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangeU32\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangeU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedExchangeU32 (volatile uint32_t * target, uint32_t value)}}
\par
{\bkmkstart AAAAAAACPN}
{\bkmkend AAAAAAACPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangeU64\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangeU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedExchangeU64 (volatile uint64_t * target, uint64_t value)}}
\par
{\bkmkstart AAAAAAACPO}
{\bkmkend AAAAAAACPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangeU8\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangeU8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t InterlockedExchangeU8 (volatile uint8_t * target, uint8_t value)}}
\par
{\bkmkstart AAAAAAACPP}
{\bkmkend AAAAAAACPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedExchangeUintptr\:atomic.h}
{\xe \v atomic.h\:InterlockedExchangeUintptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uintptr_t InterlockedExchangeUintptr (volatile uintptr_t * target, uintptr_t value)}}
\par
{\bkmkstart AAAAAAACPQ}
{\bkmkend AAAAAAACPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetch16\:atomic.h}
{\xe \v atomic.h\:InterlockedFetch16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int16_t InterlockedFetch16 (volatile int16_t * target)}}
\par
{\bkmkstart AAAAAAACPR}
{\bkmkend AAAAAAACPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetch32\:atomic.h}
{\xe \v atomic.h\:InterlockedFetch32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedFetch32 (volatile int32_t * target)}}
\par
{\bkmkstart AAAAAAACPS}
{\bkmkend AAAAAAACPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 207} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetch64\:atomic.h}
{\xe \v atomic.h\:InterlockedFetch64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedFetch64 (volatile int64_t * target)}}
\par
{\bkmkstart AAAAAAACPT}
{\bkmkend AAAAAAACPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 208} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetch8\:atomic.h}
{\xe \v atomic.h\:InterlockedFetch8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int8_t InterlockedFetch8 (volatile int8_t * target)}}
\par
{\bkmkstart AAAAAAACPU}
{\bkmkend AAAAAAACPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchAndUintptr\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchAndUintptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uintptr_t InterlockedFetchAndUintptr (volatile uintptr_t * target, uintptr_t value)}}
\par
{\bkmkstart AAAAAAACPV}
{\bkmkend AAAAAAACPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 157} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchOrUintptr\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchOrUintptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uintptr_t InterlockedFetchOrUintptr (volatile uintptr_t * target, uintptr_t value)}}
\par
{\bkmkstart AAAAAAACPW}
{\bkmkend AAAAAAACPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchPointer\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void * InterlockedFetchPointer (volatile void *volatile * target)}}
\par
{\bkmkstart AAAAAAACPX}
{\bkmkend AAAAAAACPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchU16\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchU16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint16_t InterlockedFetchU16 (volatile uint16_t * target)}}
\par
{\bkmkstart AAAAAAACPY}
{\bkmkend AAAAAAACPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 211} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchU32\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedFetchU32 (volatile uint32_t * target)}}
\par
{\bkmkstart AAAAAAACPZ}
{\bkmkend AAAAAAACPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchU64\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedFetchU64 (volatile uint64_t * target)}}
\par
{\bkmkstart AAAAAAACQA}
{\bkmkend AAAAAAACQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedFetchU8\:atomic.h}
{\xe \v atomic.h\:InterlockedFetchU8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t InterlockedFetchU8 (volatile uint8_t * target)}}
\par
{\bkmkstart AAAAAAACQB}
{\bkmkend AAAAAAACQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedIncrement32\:atomic.h}
{\xe \v atomic.h\:InterlockedIncrement32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedIncrement32 (volatile int32_t * target)}}
\par
{\bkmkstart AAAAAAACQC}
{\bkmkend AAAAAAACQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 113} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedIncrement64\:atomic.h}
{\xe \v atomic.h\:InterlockedIncrement64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedIncrement64 (volatile int64_t * target)}}
\par
{\bkmkstart AAAAAAACQD}
{\bkmkend AAAAAAACQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedIncrementU32\:atomic.h}
{\xe \v atomic.h\:InterlockedIncrementU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedIncrementU32 (volatile uint32_t * target)}}
\par
{\bkmkstart AAAAAAACQE}
{\bkmkend AAAAAAACQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedIncrementU64\:atomic.h}
{\xe \v atomic.h\:InterlockedIncrementU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedIncrementU64 (volatile uint64_t * target)}}
\par
{\bkmkstart AAAAAAACQF}
{\bkmkend AAAAAAACQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 119} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOr16\:atomic.h}
{\xe \v atomic.h\:InterlockedOr16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int16_t InterlockedOr16 (volatile int16_t * target, int16_t value)}}
\par
{\bkmkstart AAAAAAACQG}
{\bkmkend AAAAAAACQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 137} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOr32\:atomic.h}
{\xe \v atomic.h\:InterlockedOr32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int32_t InterlockedOr32 (volatile int32_t * target, int32_t value)}}
\par
{\bkmkstart AAAAAAACQH}
{\bkmkend AAAAAAACQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 138} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOr64\:atomic.h}
{\xe \v atomic.h\:InterlockedOr64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int64_t InterlockedOr64 (volatile int64_t * target, int64_t value)}}
\par
{\bkmkstart AAAAAAACQI}
{\bkmkend AAAAAAACQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 139} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOr8\:atomic.h}
{\xe \v atomic.h\:InterlockedOr8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} int8_t InterlockedOr8 (volatile int8_t * target, int8_t value)}}
\par
{\bkmkstart AAAAAAACQJ}
{\bkmkend AAAAAAACQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOrU16\:atomic.h}
{\xe \v atomic.h\:InterlockedOrU16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint16_t InterlockedOrU16 (volatile uint16_t * target, uint16_t value)}}
\par
{\bkmkstart AAAAAAACQK}
{\bkmkend AAAAAAACQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 142} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOrU32\:atomic.h}
{\xe \v atomic.h\:InterlockedOrU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedOrU32 (volatile uint32_t * target, uint32_t value)}}
\par
{\bkmkstart AAAAAAACQL}
{\bkmkend AAAAAAACQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOrU64\:atomic.h}
{\xe \v atomic.h\:InterlockedOrU64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t InterlockedOrU64 (volatile uint64_t * target, uint64_t value)}}
\par
{\bkmkstart AAAAAAACQM}
{\bkmkend AAAAAAACQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedOrU8\:atomic.h}
{\xe \v atomic.h\:InterlockedOrU8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint8_t InterlockedOrU8 (volatile uint8_t * target, uint8_t value)}}
\par
{\bkmkstart AAAAAAACQN}
{\bkmkend AAAAAAACQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b atomic.h}.}\par
}
{\xe \v InterlockedSetMaskU32\:atomic.h}
{\xe \v atomic.h\:InterlockedSetMaskU32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint32_t InterlockedSetMaskU32 (volatile uint32_t * target, uint32_t mask)}}
\par
{\bkmkstart AAAAAAACQO}
{\bkmkend AAAAAAACQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b atomic.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
atomic.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/atomic.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/atomic.h}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /* atomic.h}\par
00002 {\cf20  * Fully featured interlocked/atomic helpers for MatanelOS kernel.}\par
00003 {\cf20  *}\par
00004 {\cf20  * - Uses GCC/Clang __atomic builtins (x86_64).}\par
00005 {\cf20  * - Default memory ordering: sequentially consistent (__ATOMIC_SEQ_CST).}\par
00006 {\cf20  * - Naming follows Windows-style "Interlocked" but includes unsigned variants.}\par
00007 {\cf20  *}\par
00008 {\cf20  * Semantics summary:}\par
00009 {\cf20  *  - Exchange functions return the previous value.}\par
00010 {\cf20  *  - CompareExchange returns the initial value that was at target (Windows style).}\par
00011 {\cf20  *  - Add/Increment/Decrement return the **new** value (matching InterlockedAdd semantics).}\par
00012 {\cf20  *  - And/Or return the **previous** value (matching Windows InterlockedAnd/Or).}\par
00013 {\cf20  *}\par
00014 {\cf20  * Note: The CPU treats bit patterns the same for signed/unsigned. Use unsigned forms}\par
00015 {\cf20  * for bitmasks/flags to avoid sign confusion in caller code.}\par
00016 {\cf20  */}\par
00017 \par
00018 {\cf21 #ifndef X86_ATOMIC_H}\par
00019 {\cf21 #define X86_ATOMIC_H}\par
00020 \par
00021 {\cf21 #include <stdint.h>}\par
00022 {\cf21 #include <stddef.h>}\par
00023 {\cf21 #include <stdbool.h>}\par
00024 {\cf21 #include <stdatomic.h>}\par
00025 {\cf21 #include "../includes/annotations.h"}\par
00026 \par
00027 {\cf21 #ifdef __cplusplus}\par
00028 {\cf17 extern} {\cf22 "C"} \{\par
00029 {\cf21 #endif}\par
00030 \par
00031 {\cf21 #define ATOMIC_ORDER __ATOMIC_SEQ_CST}\par
00032 \par
00033    {\cf20 /* Exchange (returns previous value) */}\par
00034     FORCEINLINE int8_t  InterlockedExchange8({\cf17 volatile} int8_t* target, int8_t  value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00035     FORCEINLINE int16_t InterlockedExchange16({\cf17 volatile} int16_t* target, int16_t value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00036     FORCEINLINE int32_t InterlockedExchange32({\cf17 volatile} int32_t* target, int32_t value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00037     FORCEINLINE int64_t InterlockedExchange64({\cf17 volatile} int64_t* target, int64_t value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00038 \par
00039     FORCEINLINE uint8_t  InterlockedExchangeU8({\cf17 volatile} uint8_t* target, uint8_t  value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00040     FORCEINLINE uint16_t InterlockedExchangeU16({\cf17 volatile} uint16_t* target, uint16_t value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00041     FORCEINLINE uint32_t InterlockedExchangeU32({\cf17 volatile} uint32_t* target, uint32_t value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00042     FORCEINLINE uint64_t InterlockedExchangeU64({\cf17 volatile} uint64_t* target, uint64_t value) \{ {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER); \}\par
00043 \par
00044     {\cf20 /* Pointer exchange */}\par
00045     FORCEINLINE {\cf18 void}* InterlockedExchangePtr({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target, {\cf18 void}* value) \{\par
00046         {\cf19 return} __atomic_exchange_n(({\cf18 void}* {\cf17 volatile}*)target, value, ATOMIC_ORDER);\par
00047     \}\par
00048 \par
00049     {\cf20 /* CompareExchange (returns initial value that was at target) */}\par
00050     FORCEINLINE int8_t  InterlockedCompareExchange8({\cf17 volatile} int8_t* target, int8_t  value, int8_t  comparand) \{\par
00051         int8_t expected = comparand;\par
00052         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00053         {\cf19 return} expected;\par
00054     \}\par
00055     FORCEINLINE int16_t InterlockedCompareExchange16({\cf17 volatile} int16_t* target, int16_t value, int16_t comparand) \{\par
00056         int16_t expected = comparand;\par
00057         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00058         {\cf19 return} expected;\par
00059     \}\par
00060     FORCEINLINE int32_t InterlockedCompareExchange32({\cf17 volatile} int32_t* target, int32_t value, int32_t comparand) \{\par
00061         int32_t expected = comparand;\par
00062         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00063         {\cf19 return} expected;\par
00064     \}\par
00065     FORCEINLINE int64_t InterlockedCompareExchange64({\cf17 volatile} int64_t* target, int64_t value, int64_t comparand) \{\par
00066         int64_t expected = comparand;\par
00067         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00068         {\cf19 return} expected;\par
00069     \}\par
00070 \par
00071     FORCEINLINE uint8_t  InterlockedCompareExchangeU8({\cf17 volatile} uint8_t* target, uint8_t  value, uint8_t  comparand) \{\par
00072         uint8_t expected = comparand;\par
00073         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00074         {\cf19 return} expected;\par
00075     \}\par
00076     FORCEINLINE uint16_t InterlockedCompareExchangeU16({\cf17 volatile} uint16_t* target, uint16_t value, uint16_t comparand) \{\par
00077         uint16_t expected = comparand;\par
00078         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00079         {\cf19 return} expected;\par
00080     \}\par
00081     FORCEINLINE uint32_t InterlockedCompareExchangeU32({\cf17 volatile} uint32_t* target, uint32_t value, uint32_t comparand) \{\par
00082         uint32_t expected = comparand;\par
00083         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00084         {\cf19 return} expected;\par
00085     \}\par
00086     FORCEINLINE uint64_t InterlockedCompareExchangeU64({\cf17 volatile} uint64_t* target, uint64_t value, uint64_t comparand) \{\par
00087         uint64_t expected = comparand;\par
00088         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00089         {\cf19 return} expected;\par
00090     \}\par
00091 \par
00092     {\cf20 /* Pointer CompareExchange */}\par
00093     FORCEINLINE {\cf18 void}* InterlockedCompareExchangePtr({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target, {\cf18 void}* value, {\cf18 void}* comparand) \{\par
00094         {\cf18 void}* expected = comparand;\par
00095         __atomic_compare_exchange_n(({\cf18 void}* {\cf17 volatile}*)target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00096         {\cf19 return} expected;\par
00097     \}\par
00098 \par
00099     {\cf20 /* -------------------------------}\par
00100 {\cf20        Add / Inc / Dec  (return NEW value)}\par
00101 {\cf20        ------------------------------- */}\par
00102     FORCEINLINE int8_t  InterlockedAdd8({\cf17 volatile} int8_t* target, int8_t  value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00103     FORCEINLINE int16_t InterlockedAdd16({\cf17 volatile} int16_t* target, int16_t value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00104     FORCEINLINE int32_t InterlockedAdd32({\cf17 volatile} int32_t* target, int32_t value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00105     FORCEINLINE int64_t InterlockedAdd64({\cf17 volatile} int64_t* target, int64_t value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00106 \par
00107     FORCEINLINE uint8_t  InterlockedAddU8({\cf17 volatile} uint8_t* target, uint8_t  value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00108     FORCEINLINE uint16_t InterlockedAddU16({\cf17 volatile} uint16_t* target, uint16_t value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00109     FORCEINLINE uint32_t InterlockedAddU32({\cf17 volatile} uint32_t* target, uint32_t value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00110     FORCEINLINE uint64_t InterlockedAddU64({\cf17 volatile} uint64_t* target, uint64_t value) \{ {\cf19 return} __atomic_add_fetch(target, value, ATOMIC_ORDER); \}\par
00111 \par
00112     {\cf20 /* Increment / Decrement convenience (return NEW value) */}\par
00113     FORCEINLINE int32_t InterlockedIncrement32({\cf17 volatile} int32_t* target) \{ {\cf19 return} InterlockedAdd32(target, 1); \}\par
00114     FORCEINLINE int32_t InterlockedDecrement32({\cf17 volatile} int32_t* target) \{ {\cf19 return} InterlockedAdd32(target, -1); \}\par
00115     FORCEINLINE uint32_t InterlockedIncrementU32({\cf17 volatile} uint32_t* target) \{ {\cf19 return} InterlockedAddU32(target, 1); \}\par
00116     FORCEINLINE uint32_t InterlockedDecrementU32({\cf17 volatile} uint32_t* target) \{ {\cf19 return} InterlockedAddU32(target, (uint32_t)-1); \}\par
00117 \par
00118     FORCEINLINE int64_t InterlockedIncrement64({\cf17 volatile} int64_t* target) \{ {\cf19 return} InterlockedAdd64(target, 1); \}\par
00119     FORCEINLINE uint64_t InterlockedIncrementU64({\cf17 volatile} uint64_t* target) \{ {\cf19 return} InterlockedAddU64(target, 1); \}\par
00120 \par
00121     FORCEINLINE int64_t InterlockedDecrement64({\cf17 volatile} int64_t* target) \{ {\cf19 return} InterlockedAdd64(target, -1); \}\par
00122     FORCEINLINE uint64_t InterlockedDecrementU64({\cf17 volatile} uint64_t* target) \{ {\cf19 return} InterlockedAddU64(target, (uint64_t)-1); \}\par
00123     {\cf20 /* -------------------------------}\par
00124 {\cf20        Bitwise AND / OR (return PREVIOUS value)}\par
00125 {\cf20        ------------------------------- */}\par
00126     FORCEINLINE int8_t  InterlockedAnd8({\cf17 volatile} int8_t* target, int8_t  value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00127     FORCEINLINE int16_t InterlockedAnd16({\cf17 volatile} int16_t* target, int16_t value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00128     FORCEINLINE int32_t InterlockedAnd32({\cf17 volatile} int32_t* target, int32_t value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00129     FORCEINLINE int64_t InterlockedAnd64({\cf17 volatile} int64_t* target, int64_t value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00130 \par
00131     FORCEINLINE uint8_t  InterlockedAndU8({\cf17 volatile} uint8_t* target, uint8_t  value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00132     FORCEINLINE uint16_t InterlockedAndU16({\cf17 volatile} uint16_t* target, uint16_t value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00133     FORCEINLINE uint32_t InterlockedAndU32({\cf17 volatile} uint32_t* target, uint32_t value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00134     FORCEINLINE uint64_t InterlockedAndU64({\cf17 volatile} uint64_t* target, uint64_t value) \{ {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER); \}\par
00135 \par
00136     FORCEINLINE int8_t  InterlockedOr8({\cf17 volatile} int8_t* target, int8_t  value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00137     FORCEINLINE int16_t InterlockedOr16({\cf17 volatile} int16_t* target, int16_t value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00138     FORCEINLINE int32_t InterlockedOr32({\cf17 volatile} int32_t* target, int32_t value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00139     FORCEINLINE int64_t InterlockedOr64({\cf17 volatile} int64_t* target, int64_t value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00140 \par
00141     FORCEINLINE uint8_t  InterlockedOrU8({\cf17 volatile} uint8_t* target, uint8_t  value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00142     FORCEINLINE uint16_t InterlockedOrU16({\cf17 volatile} uint16_t* target, uint16_t value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00143     FORCEINLINE uint32_t InterlockedOrU32({\cf17 volatile} uint32_t* target, uint32_t value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00144     FORCEINLINE uint64_t InterlockedOrU64({\cf17 volatile} uint64_t* target, uint64_t value) \{ {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER); \}\par
00145 \par
00146     {\cf20 /* -------------------------------}\par
00147 {\cf20        Pointer / uintptr helpers}\par
00148 {\cf20        ------------------------------- */}\par
00149     FORCEINLINE uintptr_t InterlockedExchangeUintptr({\cf17 volatile} uintptr_t* target, uintptr_t value) \{\par
00150         {\cf19 return} __atomic_exchange_n(target, value, ATOMIC_ORDER);\par
00151     \}\par
00152     FORCEINLINE uintptr_t InterlockedCompareExchangeUintptr({\cf17 volatile} uintptr_t* target, uintptr_t value, uintptr_t comparand) \{\par
00153         uintptr_t expected = comparand;\par
00154         __atomic_compare_exchange_n(target, &expected, value, 0, ATOMIC_ORDER, ATOMIC_ORDER);\par
00155         {\cf19 return} expected;\par
00156     \}\par
00157     FORCEINLINE uintptr_t InterlockedFetchAndUintptr({\cf17 volatile} uintptr_t* target, uintptr_t value) \{\par
00158         {\cf19 return} __atomic_fetch_and(target, value, ATOMIC_ORDER);\par
00159     \}\par
00160     FORCEINLINE uintptr_t InterlockedFetchOrUintptr({\cf17 volatile} uintptr_t* target, uintptr_t value) \{\par
00161         {\cf19 return} __atomic_fetch_or(target, value, ATOMIC_ORDER);\par
00162     \}\par
00163 \par
00164     {\cf20 // Boolean}\par
00165     FORCEINLINE {\cf18 bool} InterlockedExchangeBool({\cf17 volatile} {\cf18 bool}* target, {\cf18 bool} value) \{\par
00166         {\cf19 return} __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);\par
00167     \}\par
00168 \par
00169     {\cf20 /* Pointer convenience wrappers */}\par
00170     FORCEINLINE {\cf18 void}* InterlockedExchangePointer({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target, {\cf18 void}* value) \{ {\cf19 return} InterlockedExchangePtr(target, value); \}\par
00171     FORCEINLINE {\cf18 void}* InterlockedCompareExchangePointer({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target, {\cf18 void}* value, {\cf18 void}* comparand) \{ {\cf19 return} InterlockedCompareExchangePtr(target, value, comparand); \}\par
00172     FORCEINLINE {\cf18 void}* InterlockedFetchPointer({\cf17 volatile} {\cf18 void}* {\cf17 volatile}* target) \{ {\cf19 return} InterlockedCompareExchangePtr(target, NULL, NULL); \}\par
00173 \par
00174     {\cf20 /* -------------------------------}\par
00175 {\cf20        Utility: test-and-set style helpers}\par
00176 {\cf20        ------------------------------- */}\par
00177 \par
00178        {\cf20 /* Atomically set bits in a uint32_t mask and return previous mask */}\par
00179     FORCEINLINE uint32_t InterlockedSetMaskU32({\cf17 volatile} uint32_t* target, uint32_t mask) \{\par
00180         {\cf19 return} __atomic_fetch_or(target, mask, ATOMIC_ORDER);\par
00181     \}\par
00182 \par
00183     {\cf20 /* Atomically clear bits and return previous mask */}\par
00184     FORCEINLINE uint32_t InterlockedClearMaskU32({\cf17 volatile} uint32_t* target, uint32_t mask) \{\par
00185         {\cf19 return} __atomic_fetch_and(target, ~mask, ATOMIC_ORDER);\par
00186     \}\par
00187 \par
00188     {\cf20 /* -------------------------------}\par
00189 {\cf20        Load / Store (atomic loads/stores with specified ordering)}\par
00190 {\cf20        ------------------------------- */}\par
00191     FORCEINLINE int32_t AtomicLoad32({\cf17 volatile} int32_t* target) \{\par
00192         {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER);\par
00193     \}\par
00194     FORCEINLINE {\cf18 void} AtomicStore32({\cf17 volatile} int32_t* target, int32_t v) \{\par
00195         __atomic_store_n(target, v, ATOMIC_ORDER);\par
00196     \}\par
00197     FORCEINLINE uint32_t AtomicLoadU32({\cf17 volatile} uint32_t* target) \{\par
00198         {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER);\par
00199     \}\par
00200     FORCEINLINE {\cf18 void} AtomicStoreU32({\cf17 volatile} uint32_t* target, uint32_t v) \{\par
00201         __atomic_store_n(target, v, ATOMIC_ORDER);\par
00202     \}\par
00203 \par
00204 \par
00205     FORCEINLINE int8_t  InterlockedFetch8({\cf17 volatile} int8_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00206     FORCEINLINE int16_t InterlockedFetch16({\cf17 volatile} int16_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00207     FORCEINLINE int32_t InterlockedFetch32({\cf17 volatile} int32_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00208     FORCEINLINE int64_t InterlockedFetch64({\cf17 volatile} int64_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00209 \par
00210     FORCEINLINE uint8_t  InterlockedFetchU8({\cf17 volatile} uint8_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00211     FORCEINLINE uint16_t InterlockedFetchU16({\cf17 volatile} uint16_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00212     FORCEINLINE uint32_t InterlockedFetchU32({\cf17 volatile} uint32_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00213     FORCEINLINE uint64_t InterlockedFetchU64({\cf17 volatile} uint64_t* target) \{ {\cf19 return} __atomic_load_n(target, ATOMIC_ORDER); \}\par
00214     {\cf20 /* -------------------------------}\par
00215 {\cf20        Notes:}\par
00216 {\cf20        - Types may be signed or unsigned; operations are bit-pattern operations.}\par
00217 {\cf20        - On x86_64 the builtins will generate LOCK-prefixed instructions where necessary.}\par
00218 {\cf20        - For 8/16-bit atomics be careful about alignment; prefer natural alignment for the type.}\par
00219 {\cf20        ------------------------------- */}\par
00220 \par
00221 {\cf21 #ifdef __cplusplus}\par
00222 \}\par
00223 {\cf21 #endif}\par
00224 \par
00225 {\cf21 #endif }{\cf20 /* MATANEL_ATOMIC_H */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/intrin.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/intrin.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/intrin.h}
{\bkmkstart AAAAAAACQP}
{\bkmkend AAAAAAACQP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdbool.h>}\par
{\f2 #include "../includes/annotations.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC1_COMMAND_MASTER}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC1_DATA}\~ 0x21\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC2_COMMAND_SLAVE}\~ 0xA0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC2_DATA}\~ 0xA1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PIC_EOI}\~ 0x20\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IA32_KERNEL_GS_BASE}\~ 0xC0000102\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IA32_GS_BASE}\~ 0xC0000101 /* used both in kernel mode and user mode */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IA32_FS_BASE}\~ 0xC0000100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNREFERENCED_PARAMETER}(x)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __cli} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __sti} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __hlt} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned long int {\b __read_cr0} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_cr0} (unsigned long int val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned long {\b __read_cr2} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_cr2} (unsigned long val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __read_cr3} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_cr3} (uint64_t val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned long {\b __read_cr4} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_cr4} (unsigned long val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned long {\b __read_cr8} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_cr8} (unsigned long val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __read_dr} (int reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_dr} (int reg, uint64_t val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __lidt} (void *idt_ptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned long int {\b __read_rflags} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __write_rflags} (unsigned long int rflags)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned short {\b __inword} (unsigned short port)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __outword} (unsigned short port, unsigned short val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} unsigned char {\b __inbyte} (unsigned short port)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __outbyte} (unsigned short port, unsigned char val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b send_eoi} (unsigned char irq)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b invlpg} (void *m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __readmsr} (uint32_t msr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __writemsr} (uint32_t msr, uint64_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __read_rbp} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __read_rsp} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __read_rip} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __pause} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __readgsqword} (uint64_t offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __readfsqword} (uint64_t offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} void {\b __swapgs} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} bool {\b __rdrand64} (uint64_t *out)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FORCEINLINE} uint64_t {\b __rdtsc} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACQQ}
{\bkmkend AAAAAAACQQ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v IA32_FS_BASE\:intrin.h}
{\xe \v intrin.h\:IA32_FS_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IA32_FS_BASE\~ 0xC0000100}}
\par
{\bkmkstart AAAAAAACQR}
{\bkmkend AAAAAAACQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b intrin.h}.}\par
}
{\xe \v IA32_GS_BASE\:intrin.h}
{\xe \v intrin.h\:IA32_GS_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IA32_GS_BASE\~ 0xC0000101 /* used both in kernel mode and user mode */}}
\par
{\bkmkstart AAAAAAACQS}
{\bkmkend AAAAAAACQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b intrin.h}.}\par
}
{\xe \v IA32_KERNEL_GS_BASE\:intrin.h}
{\xe \v intrin.h\:IA32_KERNEL_GS_BASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IA32_KERNEL_GS_BASE\~ 0xC0000102}}
\par
{\bkmkstart AAAAAAACQT}
{\bkmkend AAAAAAACQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b intrin.h}.}\par
}
{\xe \v PIC1_COMMAND_MASTER\:intrin.h}
{\xe \v intrin.h\:PIC1_COMMAND_MASTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC1_COMMAND_MASTER\~ 0x20}}
\par
{\bkmkstart AAAAAAACQU}
{\bkmkend AAAAAAACQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b intrin.h}.}\par
}
{\xe \v PIC1_DATA\:intrin.h}
{\xe \v intrin.h\:PIC1_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC1_DATA\~ 0x21}}
\par
{\bkmkstart AAAAAAACQV}
{\bkmkend AAAAAAACQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b intrin.h}.}\par
}
{\xe \v PIC2_COMMAND_SLAVE\:intrin.h}
{\xe \v intrin.h\:PIC2_COMMAND_SLAVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC2_COMMAND_SLAVE\~ 0xA0}}
\par
{\bkmkstart AAAAAAACQW}
{\bkmkend AAAAAAACQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b intrin.h}.}\par
}
{\xe \v PIC2_DATA\:intrin.h}
{\xe \v intrin.h\:PIC2_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC2_DATA\~ 0xA1}}
\par
{\bkmkstart AAAAAAACQX}
{\bkmkend AAAAAAACQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b intrin.h}.}\par
}
{\xe \v PIC_EOI\:intrin.h}
{\xe \v intrin.h\:PIC_EOI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PIC_EOI\~ 0x20}}
\par
{\bkmkstart AAAAAAACQY}
{\bkmkend AAAAAAACQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b intrin.h}.}\par
}
{\xe \v UNREFERENCED_PARAMETER\:intrin.h}
{\xe \v intrin.h\:UNREFERENCED_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNREFERENCED_PARAMETER( x)}}
\par
{\bkmkstart AAAAAAACQZ}
{\bkmkend AAAAAAACQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (void)(x)\par
}
{
Definition at line {\b 24} of file {\b intrin.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACRA}
{\bkmkend AAAAAAACRA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __cli\:intrin.h}
{\xe \v intrin.h\:__cli}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __cli (void )}}
\par
{\bkmkstart AAAAAAACRB}
{\bkmkend AAAAAAACRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b intrin.h}.}\par
}
{\xe \v __hlt\:intrin.h}
{\xe \v intrin.h\:__hlt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __hlt (void )}}
\par
{\bkmkstart AAAAAAACRC}
{\bkmkend AAAAAAACRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b intrin.h}.}\par
}
{\xe \v __inbyte\:intrin.h}
{\xe \v intrin.h\:__inbyte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned char __inbyte (unsigned short port)}}
\par
{\bkmkstart AAAAAAACRD}
{\bkmkend AAAAAAACRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 172} of file {\b intrin.h}.}\par
}
{\xe \v __inword\:intrin.h}
{\xe \v intrin.h\:__inword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned short __inword (unsigned short port)}}
\par
{\bkmkstart AAAAAAACRE}
{\bkmkend AAAAAAACRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b intrin.h}.}\par
}
{\xe \v __lidt\:intrin.h}
{\xe \v intrin.h\:__lidt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __lidt (void * idt_ptr)}}
\par
{\bkmkstart AAAAAAACRF}
{\bkmkend AAAAAAACRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b intrin.h}.}\par
}
{\xe \v __outbyte\:intrin.h}
{\xe \v intrin.h\:__outbyte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __outbyte (unsigned short port, unsigned char val)}}
\par
{\bkmkstart AAAAAAACRG}
{\bkmkend AAAAAAACRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b intrin.h}.}\par
}
{\xe \v __outword\:intrin.h}
{\xe \v intrin.h\:__outword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __outword (unsigned short port, unsigned short val)}}
\par
{\bkmkstart AAAAAAACRH}
{\bkmkend AAAAAAACRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 167} of file {\b intrin.h}.}\par
}
{\xe \v __pause\:intrin.h}
{\xe \v intrin.h\:__pause}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __pause (void )}}
\par
{\bkmkstart AAAAAAACRI}
{\bkmkend AAAAAAACRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 224} of file {\b intrin.h}.}\par
}
{\xe \v __rdrand64\:intrin.h}
{\xe \v intrin.h\:__rdrand64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} bool __rdrand64 (uint64_t * out)}}
\par
{\bkmkstart AAAAAAACRJ}
{\bkmkend AAAAAAACRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 254} of file {\b intrin.h}.}\par
}
{\xe \v __rdtsc\:intrin.h}
{\xe \v intrin.h\:__rdtsc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __rdtsc (void )}}
\par
{\bkmkstart AAAAAAACRK}
{\bkmkend AAAAAAACRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 263} of file {\b intrin.h}.}\par
}
{\xe \v __read_cr0\:intrin.h}
{\xe \v intrin.h\:__read_cr0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned long int __read_cr0 (void )}}
\par
{\bkmkstart AAAAAAACRL}
{\bkmkend AAAAAAACRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b intrin.h}.}\par
}
{\xe \v __read_cr2\:intrin.h}
{\xe \v intrin.h\:__read_cr2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned long __read_cr2 (void )}}
\par
{\bkmkstart AAAAAAACRM}
{\bkmkend AAAAAAACRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b intrin.h}.}\par
}
{\xe \v __read_cr3\:intrin.h}
{\xe \v intrin.h\:__read_cr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __read_cr3 (void )}}
\par
{\bkmkstart AAAAAAACRN}
{\bkmkend AAAAAAACRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b intrin.h}.}\par
}
{\xe \v __read_cr4\:intrin.h}
{\xe \v intrin.h\:__read_cr4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned long __read_cr4 (void )}}
\par
{\bkmkstart AAAAAAACRO}
{\bkmkend AAAAAAACRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b intrin.h}.}\par
}
{\xe \v __read_cr8\:intrin.h}
{\xe \v intrin.h\:__read_cr8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned long __read_cr8 (void )}}
\par
{\bkmkstart AAAAAAACRP}
{\bkmkend AAAAAAACRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b intrin.h}.}\par
}
{\xe \v __read_dr\:intrin.h}
{\xe \v intrin.h\:__read_dr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __read_dr (int reg)}}
\par
{\bkmkstart AAAAAAACRQ}
{\bkmkend AAAAAAACRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b intrin.h}.}\par
}
{\xe \v __read_rbp\:intrin.h}
{\xe \v intrin.h\:__read_rbp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __read_rbp (void )}}
\par
{\bkmkstart AAAAAAACRR}
{\bkmkend AAAAAAACRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 206} of file {\b intrin.h}.}\par
}
{\xe \v __read_rflags\:intrin.h}
{\xe \v intrin.h\:__read_rflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} unsigned long int __read_rflags (void )}}
\par
{\bkmkstart AAAAAAACRS}
{\bkmkend AAAAAAACRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 140} of file {\b intrin.h}.}\par
}
{\xe \v __read_rip\:intrin.h}
{\xe \v intrin.h\:__read_rip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __read_rip (void )}}
\par
{\bkmkstart AAAAAAACRT}
{\bkmkend AAAAAAACRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 218} of file {\b intrin.h}.}\par
}
{\xe \v __read_rsp\:intrin.h}
{\xe \v intrin.h\:__read_rsp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __read_rsp (void )}}
\par
{\bkmkstart AAAAAAACRU}
{\bkmkend AAAAAAACRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 212} of file {\b intrin.h}.}\par
}
{\xe \v __readfsqword\:intrin.h}
{\xe \v intrin.h\:__readfsqword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __readfsqword (uint64_t offset)}}
\par
{\bkmkstart AAAAAAACRV}
{\bkmkend AAAAAAACRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 239} of file {\b intrin.h}.}\par
}
{\xe \v __readgsqword\:intrin.h}
{\xe \v intrin.h\:__readgsqword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __readgsqword (uint64_t offset)}}
\par
{\bkmkstart AAAAAAACRW}
{\bkmkend AAAAAAACRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 228} of file {\b intrin.h}.}\par
}
{\xe \v __readmsr\:intrin.h}
{\xe \v intrin.h\:__readmsr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} uint64_t __readmsr (uint32_t msr)}}
\par
{\bkmkstart AAAAAAACRX}
{\bkmkend AAAAAAACRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b intrin.h}.}\par
}
{\xe \v __sti\:intrin.h}
{\xe \v intrin.h\:__sti}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __sti (void )}}
\par
{\bkmkstart AAAAAAACRY}
{\bkmkend AAAAAAACRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b intrin.h}.}\par
}
{\xe \v __swapgs\:intrin.h}
{\xe \v intrin.h\:__swapgs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __swapgs (void )}}
\par
{\bkmkstart AAAAAAACRZ}
{\bkmkend AAAAAAACRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 250} of file {\b intrin.h}.}\par
}
{\xe \v __write_cr0\:intrin.h}
{\xe \v intrin.h\:__write_cr0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_cr0 (unsigned long int val)}}
\par
{\bkmkstart AAAAAAACSA}
{\bkmkend AAAAAAACSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 62} of file {\b intrin.h}.}\par
}
{\xe \v __write_cr2\:intrin.h}
{\xe \v intrin.h\:__write_cr2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_cr2 (unsigned long val)}}
\par
{\bkmkstart AAAAAAACSB}
{\bkmkend AAAAAAACSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b intrin.h}.}\par
}
{\xe \v __write_cr3\:intrin.h}
{\xe \v intrin.h\:__write_cr3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_cr3 (uint64_t val)}}
\par
{\bkmkstart AAAAAAACSC}
{\bkmkend AAAAAAACSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 83} of file {\b intrin.h}.}\par
}
{\xe \v __write_cr4\:intrin.h}
{\xe \v intrin.h\:__write_cr4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_cr4 (unsigned long val)}}
\par
{\bkmkstart AAAAAAACSD}
{\bkmkend AAAAAAACSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b intrin.h}.}\par
}
{\xe \v __write_cr8\:intrin.h}
{\xe \v intrin.h\:__write_cr8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_cr8 (unsigned long val)}}
\par
{\bkmkstart AAAAAAACSE}
{\bkmkend AAAAAAACSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b intrin.h}.}\par
}
{\xe \v __write_dr\:intrin.h}
{\xe \v intrin.h\:__write_dr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_dr (int reg, uint64_t val)}}
\par
{\bkmkstart AAAAAAACSF}
{\bkmkend AAAAAAACSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 124} of file {\b intrin.h}.}\par
}
{\xe \v __write_rflags\:intrin.h}
{\xe \v intrin.h\:__write_rflags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __write_rflags (unsigned long int rflags)}}
\par
{\bkmkstart AAAAAAACSG}
{\bkmkend AAAAAAACSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b intrin.h}.}\par
}
{\xe \v __writemsr\:intrin.h}
{\xe \v intrin.h\:__writemsr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void __writemsr (uint32_t msr, uint64_t value)}}
\par
{\bkmkstart AAAAAAACSH}
{\bkmkend AAAAAAACSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b intrin.h}.}\par
}
{\xe \v invlpg\:intrin.h}
{\xe \v intrin.h\:invlpg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void invlpg (void * m)}}
\par
{\bkmkstart AAAAAAACSI}
{\bkmkend AAAAAAACSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b intrin.h}.}\par
}
{\xe \v send_eoi\:intrin.h}
{\xe \v intrin.h\:send_eoi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b FORCEINLINE} void send_eoi (unsigned char irq)}}
\par
{\bkmkstart AAAAAAACSJ}
{\bkmkend AAAAAAACSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 183} of file {\b intrin.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
intrin.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/intrin.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/intrinsics/intrin.h}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Intrinsics for easy assembly use.}\par
00005 {\cf20  */}\par
00006 {\cf21 #ifndef X86_INTRINSICS_H}\par
00007 {\cf21 #define X86_INTRINSICS_H}\par
00008 \par
00009  {\cf20 // PIC Ports}\par
00010 {\cf21 #define PIC1_COMMAND_MASTER 0x20}\par
00011 {\cf21 #define PIC1_DATA           0x21}\par
00012 {\cf21 #define PIC2_COMMAND_SLAVE  0xA0}\par
00013 {\cf21 #define PIC2_DATA           0xA1}\par
00014 \par
00015 {\cf20 // End of Interrupt command code}\par
00016 {\cf21 #define PIC_EOI 0x20}\par
00017 \par
00018 {\cf20 // MSRs}\par
00019 {\cf21 #define IA32_KERNEL_GS_BASE 0xC0000102}\par
00020 {\cf21 #define IA32_GS_BASE 0xC0000101 }{\cf20 /* used both in kernel mode and user mode */}{\cf21 }\par
00021 {\cf21 #define IA32_FS_BASE 0xC0000100}\par
00022 \par
00023 {\cf21 #ifndef UNREFERENCED_PARAMETER}\par
00024 {\cf21 #define UNREFERENCED_PARAMETER(x) (void)(x)}\par
00025 {\cf21 #endif}\par
00026 \par
00027 {\cf21 #ifdef _MSC_VER}\par
00028 {\cf21 #ifndef __asm__}\par
00029 {\cf21 #define __asm__ __asm}\par
00030 {\cf21 #endif}\par
00031 {\cf21 #endif}\par
00032 \par
00033 {\cf21 #include <stdbool.h>}\par
00034 {\cf21 #include "../includes/annotations.h"}\par
00035 \par
00036 {\cf20 // Disable interrupts (cli)}\par
00037 FORCEINLINE\par
00038 {\cf18 void} __cli({\cf18 void}) \{\par
00039     __asm__ {\cf17 volatile} ({\cf22 "cli"});\par
00040 \}\par
00041 \par
00042 {\cf20 // Enable interrupts (sti)}\par
00043 FORCEINLINE\par
00044 {\cf18 void} __sti({\cf18 void}) \{\par
00045     __asm__ {\cf17 volatile} ({\cf22 "sti"});\par
00046 \}\par
00047 \par
00048 {\cf20 // Halt CPU until next interrupt (hlt)}\par
00049 FORCEINLINE\par
00050 {\cf18 void} __hlt({\cf18 void}) \{\par
00051     __asm__ {\cf17 volatile} ({\cf22 "hlt"});\par
00052 \}\par
00053 \par
00054 {\cf20 // Read CR0 register}\par
00055 FORCEINLINE {\cf18 unsigned} {\cf18 long} {\cf18 int} __read_cr0({\cf18 void}) \{\par
00056     {\cf18 unsigned} {\cf18 long} {\cf18 int} val;\par
00057     __asm__ {\cf17 volatile} ({\cf22 "mov %%cr0, %0"} : {\cf22 "=r"}(val));\par
00058     {\cf19 return} val;\par
00059 \}\par
00060 \par
00061 {\cf20 // Write CR0 register}\par
00062 FORCEINLINE {\cf18 void} __write_cr0({\cf18 unsigned} {\cf18 long} {\cf18 int} val) \{\par
00063     __asm__ {\cf17 volatile} ({\cf22 "mov %0, %%cr0"} :: {\cf22 "r"}(val));\par
00064 \}\par
00065 \par
00066 {\cf20 // CR2 (Page fault linear address)}\par
00067 FORCEINLINE {\cf18 unsigned} {\cf18 long} __read_cr2({\cf18 void}) \{\par
00068     {\cf18 unsigned} {\cf18 long} val;\par
00069     __asm__ {\cf17 volatile}({\cf22 "mov %%cr2, %0"} : {\cf22 "=r"}(val));\par
00070     {\cf19 return} val;\par
00071 \}\par
00072 \par
00073 FORCEINLINE {\cf18 void} __write_cr2({\cf18 unsigned} {\cf18 long} val) \{\par
00074     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr2"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00075 \}\par
00076 \par
00077 {\cf20 // CR3 (Page table base address)}\par
00078 FORCEINLINE uint64_t __read_cr3({\cf18 void}) \{\par
00079     uint64_t val;\par
00080     __asm__ {\cf17 volatile}({\cf22 "mov %%cr3, %0"} : {\cf22 "=r"}(val));\par
00081     {\cf19 return} val;\par
00082 \}\par
00083 FORCEINLINE {\cf18 void} __write_cr3(uint64_t val) \{\par
00084     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr3"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00085 \}\par
00086 \par
00087 {\cf20 // CR4 (Feature control)}\par
00088 FORCEINLINE {\cf18 unsigned} {\cf18 long} __read_cr4({\cf18 void}) \{\par
00089     {\cf18 unsigned} {\cf18 long} val;\par
00090     __asm__ {\cf17 volatile}({\cf22 "mov %%cr4, %0"} : {\cf22 "=r"}(val));\par
00091     {\cf19 return} val;\par
00092 \}\par
00093 FORCEINLINE {\cf18 void} __write_cr4({\cf18 unsigned} {\cf18 long} val) \{\par
00094     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr4"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00095 \}\par
00096 \par
00097 {\cf20 // CR8 (Task Priority Register, x86-64 only)}\par
00098 FORCEINLINE {\cf18 unsigned} {\cf18 long} __read_cr8({\cf18 void}) \{\par
00099     {\cf18 unsigned} {\cf18 long} val;\par
00100     __asm__ {\cf17 volatile}({\cf22 "mov %%cr8, %0"} : {\cf22 "=r"}(val));\par
00101     {\cf19 return} val;\par
00102 \}\par
00103 FORCEINLINE {\cf18 void} __write_cr8({\cf18 unsigned} {\cf18 long} val) \{\par
00104     __asm__ {\cf17 volatile}({\cf22 "mov %0, %%cr8"} :: {\cf22 "r"}(val) : {\cf22 "memory"});\par
00105 \}\par
00106 \par
00107 \par
00108 {\cf20 // Read DRx register (dr0-dr7) (Usage __read_dr(3) = will return dr3.}\par
00109 FORCEINLINE uint64_t __read_dr({\cf18 int} reg) \{\par
00110     {\cf18 unsigned} {\cf18 long} val = 0;\par
00111     {\cf19 switch} (reg) \{\par
00112         {\cf19 case} 0: __asm__ {\cf17 volatile}({\cf22 "mov %%dr0, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00113         {\cf19 case} 1: __asm__ {\cf17 volatile}({\cf22 "mov %%dr1, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00114         {\cf19 case} 2: __asm__ {\cf17 volatile}({\cf22 "mov %%dr2, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00115         {\cf19 case} 3: __asm__ {\cf17 volatile}({\cf22 "mov %%dr3, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00116         {\cf19 case} 6: __asm__ {\cf17 volatile}({\cf22 "mov %%dr6, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00117         {\cf19 case} 7: __asm__ {\cf17 volatile}({\cf22 "mov %%dr7, %0"} : {\cf22 "=r"}(val)); {\cf19 break};\par
00118         {\cf19 default}: {\cf19 break};\par
00119     \}\par
00120     {\cf19 return} val;\par
00121 \}\par
00122 \par
00123 {\cf20 // Write DRx register (dr0-dr7) (Usage __write_dr(3, 0x5000) = will write 0x5000 to dr3.}\par
00124 FORCEINLINE {\cf18 void} __write_dr({\cf18 int} reg, uint64_t val) \{\par
00125     {\cf19 switch} (reg) \{\par
00126         {\cf19 case} 0: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr0"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00127         {\cf19 case} 1: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr1"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00128         {\cf19 case} 2: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr2"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00129         {\cf19 case} 3: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr3"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00130         {\cf19 case} 6: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr6"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00131         {\cf19 case} 7: __asm__ {\cf17 volatile}({\cf22 "mov %0, %%dr7"} :: {\cf22 "r"}(val)); {\cf19 break};\par
00132         {\cf19 default}: {\cf19 break};\par
00133     \}\par
00134 \}\par
00135 FORCEINLINE {\cf18 void} __lidt({\cf18 void}* idt_ptr) \{\par
00136     __asm__ {\cf17 volatile} ({\cf22 "lidt (%0)"} :: {\cf22 "r"}(idt_ptr));\par
00137 \}\par
00138 \par
00139 {\cf20 // Read RFLAGS register}\par
00140 FORCEINLINE {\cf18 unsigned} {\cf18 long} {\cf18 int} __read_rflags({\cf18 void}) \{\par
00141     {\cf18 unsigned} {\cf18 long} {\cf18 int} rflags;\par
00142     __asm__ {\cf17 volatile} (\par
00143         {\cf22 "pushfl\\n\\t"}\par
00144         {\cf22 "pop %0"}\par
00145         : {\cf22 "=r"}(rflags)\par
00146         );\par
00147     {\cf19 return} rflags;\par
00148 \}\par
00149 \par
00150 {\cf20 // Write RFLAGS register}\par
00151 FORCEINLINE {\cf18 void} __write_rflags({\cf18 unsigned} {\cf18 long} {\cf18 int} rflags) \{\par
00152     __asm__ {\cf17 volatile} (\par
00153         {\cf22 "push %0\\n\\t"}\par
00154         {\cf22 "popfl"}\par
00155         :: {\cf22 "r"}(rflags)\par
00156         );\par
00157 \}\par
00158 \par
00159 {\cf20 // Read port (inw)}\par
00160 FORCEINLINE {\cf18 unsigned} {\cf18 short} __inword({\cf18 unsigned} {\cf18 short} port) \{\par
00161     {\cf18 unsigned} {\cf18 short} ret;\par
00162     __asm__ {\cf17 volatile} ({\cf22 "inw %1, %0"} : {\cf22 "=a"}(ret) : {\cf22 "Nd"}(port));\par
00163     {\cf19 return} ret;\par
00164 \}\par
00165 \par
00166 {\cf20 // Write port (outw)}\par
00167 FORCEINLINE {\cf18 void} __outword({\cf18 unsigned} {\cf18 short} port, {\cf18 unsigned} {\cf18 short} val) \{\par
00168     __asm__ {\cf17 volatile} ({\cf22 "outw %0, %1"} : : {\cf22 "a"}(val), {\cf22 "Nd"}(port));\par
00169 \}\par
00170 \par
00171 {\cf20 // Read port (inb)}\par
00172 FORCEINLINE {\cf18 unsigned} {\cf18 char} __inbyte({\cf18 unsigned} {\cf18 short} port) \{\par
00173     {\cf18 unsigned} {\cf18 char} ret;\par
00174     __asm__ {\cf17 volatile} ({\cf22 "inb %1, %0"} : {\cf22 "=a"}(ret) : {\cf22 "Nd"}(port));\par
00175     {\cf19 return} ret;\par
00176 \}\par
00177 \par
00178 {\cf20 // Write port (outb)}\par
00179 FORCEINLINE {\cf18 void} __outbyte({\cf18 unsigned} {\cf18 short} port, {\cf18 unsigned} {\cf18 char} val) \{\par
00180     __asm__ {\cf17 volatile} ({\cf22 "outb %0, %1"} :: {\cf22 "a"}(val), {\cf22 "Nd"}(port));\par
00181 \}\par
00182 \par
00183 FORCEINLINE {\cf18 void} send_eoi({\cf18 unsigned} {\cf18 char} irq) \{\par
00184     {\cf19 if} (irq >= 8) \{\par
00185         __outbyte(PIC2_COMMAND_SLAVE, PIC_EOI);  {\cf20 // Slave PIC}\par
00186     \}\par
00187     __outbyte(PIC1_COMMAND_MASTER, PIC_EOI);      {\cf20 // Master PIC}\par
00188 \}\par
00189 \par
00190 FORCEINLINE {\cf18 void} invlpg({\cf18 void}* m) \{\par
00191     __asm__ {\cf17 volatile}({\cf22 "invlpg (%0)"} : : {\cf22 "b"}(m) : {\cf22 "memory"});\par
00192 \}\par
00193 \par
00194 FORCEINLINE uint64_t __readmsr(uint32_t msr) \{\par
00195     uint32_t lo, hi;\par
00196     __asm__ {\cf17 volatile} ({\cf22 "rdmsr"} : {\cf22 "=a"}(lo), {\cf22 "=d"}(hi) : {\cf22 "c"}(msr));\par
00197     {\cf19 return} ((uint64_t)hi << 32) | lo;\par
00198 \}\par
00199 \par
00200 FORCEINLINE {\cf18 void} __writemsr(uint32_t msr, uint64_t value) \{\par
00201     uint32_t lo = value & 0xFFFFFFFF;\par
00202     uint32_t hi = value >> 32;\par
00203     __asm__ {\cf17 volatile} ({\cf22 "wrmsr"} : : {\cf22 "c"}(msr), {\cf22 "a"}(lo), {\cf22 "d"}(hi));\par
00204 \}\par
00205 \par
00206 FORCEINLINE uint64_t __read_rbp({\cf18 void}) \{\par
00207     uint64_t val;\par
00208     __asm__ {\cf17 volatile} ({\cf22 "mov %%rbp, %0"} : {\cf22 "=r"}(val));\par
00209     {\cf19 return} val;\par
00210 \}\par
00211 \par
00212 FORCEINLINE uint64_t __read_rsp({\cf18 void}) \{\par
00213     uint64_t val;\par
00214     __asm__ {\cf17 volatile} ({\cf22 "mov %%rsp, %0"} : {\cf22 "=r"}(val));\par
00215     {\cf19 return} val;\par
00216 \}\par
00217 \par
00218 FORCEINLINE uint64_t __read_rip({\cf18 void}) \{\par
00219     uint64_t rip;\par
00220     __asm__ {\cf17 volatile} ({\cf22 "leaq (%%rip), %0"} : {\cf22 "=r"}(rip));\par
00221     {\cf19 return} rip;\par
00222 \}\par
00223 \par
00224 FORCEINLINE {\cf18 void} __pause({\cf18 void}) \{\par
00225     __asm__ {\cf17 volatile}({\cf22 "pause"} ::: {\cf22 "memory"});\par
00226 \}\par
00227 \par
00228 FORCEINLINE uint64_t __readgsqword(uint64_t offset) \{\par
00229     uint64_t value;\par
00230     __asm__ {\cf17 volatile} (\par
00231         {\cf22 "movq %%gs:(%1), %0"}\par
00232         : {\cf22 "=r"}(value)\par
00233         : {\cf22 "r"}(offset)\par
00234         : {\cf22 "memory"}\par
00235         );\par
00236     {\cf19 return} value;\par
00237 \}\par
00238 \par
00239 FORCEINLINE uint64_t __readfsqword(uint64_t offset) \{\par
00240     uint64_t value;\par
00241     __asm__ {\cf17 volatile} (\par
00242         {\cf22 "movq %%fs:(%1), %0"}\par
00243         : {\cf22 "=r"}(value)\par
00244         : {\cf22 "r"}(offset)\par
00245         : {\cf22 "memory"}\par
00246         );\par
00247     {\cf19 return} value;\par
00248 \}\par
00249 \par
00250 FORCEINLINE {\cf18 void} __swapgs({\cf18 void}) \{\par
00251     __asm__ {\cf17 volatile} ({\cf22 "swapgs"} ::: {\cf22 "memory"});\par
00252 \}\par
00253 \par
00254 FORCEINLINE {\cf18 bool} __rdrand64(uint64_t* out) \{\par
00255     {\cf18 unsigned} {\cf18 char} ok;\par
00256     uint64_t val;\par
00257     __asm__ {\cf17 volatile}({\cf22 "rdrand %0; setc %1"}\par
00258         : {\cf22 "=r"}(val), {\cf22 "=qm"}(ok));\par
00259     *out = val;\par
00260     {\cf19 return} ok; {\cf20 // 1=success, 0=failure}\par
00261 \}\par
00262 \par
00263 FORCEINLINE uint64_t __rdtsc({\cf18 void}) \{\par
00264     uint32_t lo, hi;\par
00265     __asm__ {\cf17 volatile} ({\cf22 "rdtsc"} : {\cf22 "=a"}(lo), {\cf22 "=d"}(hi));\par
00266     {\cf19 return} ((uint64_t)hi << 32) | lo;\par
00267 \}\par
00268 \par
00269 {\cf21 #endif }{\cf20 // X86_INTRINSICS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\bkmkstart AAAAAAACSK}
{\bkmkend AAAAAAACSK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "kernel.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_AHCI_CONTROLLERS}\~ 32\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_MEMORY_MAP_SIZE}\~ 0x8000\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ISRAEL_UTC_OFFSET}\~ 3\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_memory_map} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_gop} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_boot_info} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_idle_checks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((noreturn))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBugChecking} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allApsInitialized} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PROCESSOR} {\b cpu0}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GOP_PARAMS} {\b gop_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b BOOT_INFO} {\b boot_info_local}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint64_t {\b ahci_bases_local} [{\b MAX_AHCI_CONTROLLERS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b apic_list} [{\b MAX_CPUS}]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b cpu_count} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b lapicAddress}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b smpInitialized}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPROCESS} {\b PsInitialSystemProcess}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b bss_start}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b bss_end}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACSL}
{\bkmkend AAAAAAACSL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ISRAEL_UTC_OFFSET\:kernel.c}
{\xe \v kernel.c\:ISRAEL_UTC_OFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ISRAEL_UTC_OFFSET\~ 3}}
\par
{\bkmkstart AAAAAAACSM}
{\bkmkend AAAAAAACSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v MAX_AHCI_CONTROLLERS\:kernel.c}
{\xe \v kernel.c\:MAX_AHCI_CONTROLLERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_AHCI_CONTROLLERS\~ 32}}
\par
{\bkmkstart AAAAAAACSN}
{\bkmkend AAAAAAACSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b kernel.c}.}\par
}
{\xe \v MAX_MEMORY_MAP_SIZE\:kernel.c}
{\xe \v kernel.c\:MAX_MEMORY_MAP_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_MEMORY_MAP_SIZE\~ 0x8000}}
\par
{\bkmkstart AAAAAAACSO}
{\bkmkend AAAAAAACSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ended \par
}{
Definition at line {\b 41} of file {\b kernel.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACSP}
{\bkmkend AAAAAAACSP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:kernel.c}
{\xe \v kernel.c\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((noreturn) )}}
\par
{\bkmkstart AAAAAAACSQ}
{\bkmkend AAAAAAACSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remember that paging is on when this is called, as UEFI turned it on. \par
}{
Definition at line {\b 180} of file {\b kernel.c}.}\par
}
{\xe \v copy_gop\:kernel.c}
{\xe \v kernel.c\:copy_gop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_gop ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACSR}
{\bkmkend AAAAAAACSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b kernel.c}.}\par
}
{\xe \v copy_memory_map\:kernel.c}
{\xe \v kernel.c\:copy_memory_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_memory_map ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACSS}
{\bkmkend AAAAAAACSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b kernel.c}.}\par
}
{\xe \v init_boot_info\:kernel.c}
{\xe \v kernel.c\:init_boot_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_boot_info ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACST}
{\bkmkend AAAAAAACST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b kernel.c}.}\par
}
{\xe \v kernel_idle_checks\:kernel.c}
{\xe \v kernel.c\:kernel_idle_checks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_idle_checks (void )}}
\par
{\bkmkstart AAAAAAACSU}
{\bkmkend AAAAAAACSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b kernel.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACSV}
{\bkmkend AAAAAAACSV}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ahci_bases_local\:kernel.c}
{\xe \v kernel.c\:ahci_bases_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint64_t ahci_bases_local[{\b MAX_AHCI_CONTROLLERS}]}}
\par
{\bkmkstart AAAAAAACSW}
{\bkmkend AAAAAAACSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b kernel.c}.}\par
}
{\xe \v allApsInitialized\:kernel.c}
{\xe \v kernel.c\:allApsInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool allApsInitialized = false}}
\par
{\bkmkstart AAAAAAACSX}
{\bkmkend AAAAAAACSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b kernel.c}.}\par
}
{\xe \v apic_list\:kernel.c}
{\xe \v kernel.c\:apic_list}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t apic_list[{\b MAX_CPUS}]}}
\par
{\bkmkstart AAAAAAACSY}
{\bkmkend AAAAAAACSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 143} of file {\b kernel.c}.}\par
}
{\xe \v boot_info_local\:kernel.c}
{\xe \v kernel.c\:boot_info_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b BOOT_INFO} boot_info_local}}
\par
{\bkmkstart AAAAAAACSZ}
{\bkmkend AAAAAAACSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b kernel.c}.}\par
}
{\xe \v bss_end\:kernel.c}
{\xe \v kernel.c\:bss_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bss_end{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACTA}
{\bkmkend AAAAAAACTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bss_start\:kernel.c}
{\xe \v kernel.c\:bss_start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t bss_start{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACTB}
{\bkmkend AAAAAAACTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cpu0\:kernel.c}
{\xe \v kernel.c\:cpu0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PROCESSOR} cpu0}}
\par
{\bkmkstart AAAAAAACTC}
{\bkmkend AAAAAAACTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b kernel.c}.}\par
}
{\xe \v cpu_count\:kernel.c}
{\xe \v kernel.c\:cpu_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t cpu_count = 0}}
\par
{\bkmkstart AAAAAAACTD}
{\bkmkend AAAAAAACTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b kernel.c}.}\par
}
{\xe \v gop_local\:kernel.c}
{\xe \v kernel.c\:gop_local}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GOP_PARAMS} gop_local}}
\par
{\bkmkstart AAAAAAACTE}
{\bkmkend AAAAAAACTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b kernel.c}.}\par
}
{\xe \v isBugChecking\:kernel.c}
{\xe \v kernel.c\:isBugChecking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBugChecking = false}}
\par
{\bkmkstart AAAAAAACTF}
{\bkmkend AAAAAAACTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global variables initialization \par
}{
Definition at line {\b 19} of file {\b kernel.c}.}\par
}
{\xe \v lapicAddress\:kernel.c}
{\xe \v kernel.c\:lapicAddress}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t lapicAddress}}
\par
{\bkmkstart AAAAAAACTG}
{\bkmkend AAAAAAACTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 145} of file {\b kernel.c}.}\par
}
{\xe \v PsInitialSystemProcess\:kernel.c}
{\xe \v kernel.c\:PsInitialSystemProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPROCESS} PsInitialSystemProcess}}
\par
{\bkmkstart AAAAAAACTH}
{\bkmkend AAAAAAACTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Stack Overflow check only checks for minor overflows, that don't completely smash the stack, yet do change the canaries (since it only checks in function epilogue) Complete stack smashes are guarded with the guard page in MiCreateKernelStack. \par
}{
Definition at line {\b 162} of file {\b kernel.c}.}\par
}
{\xe \v smpInitialized\:kernel.c}
{\xe \v kernel.c\:smpInitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool smpInitialized}}
\par
{\bkmkstart AAAAAAACTI}
{\bkmkend AAAAAAACTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
kernel.c\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.c}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      Core Kernel Entry Point for MatanelOS.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #include "kernel.h"}\par
00008 {\cf21 #ifndef _MSC_VER}\par
00009 {\cf17 _Static_assert}({\cf17 sizeof}({\cf18 void}*) == 8, {\cf22 "This Kernel is 64 bit only! The 32bit version is deprecated."});\par
00010 {\cf21 #endif}\par
00011 \par
00015 \par
00016 {\cf20 /*}\par
00017 {\cf20 Kernel Specific}\par
00018 {\cf20 */}\par
00019 {\cf18 bool} isBugChecking = {\cf17 false};\par
00020 {\cf18 bool} allApsInitialized = {\cf17 false};\par
00021 PROCESSOR cpu0; {\cf20 // In UP Mode - Will be the place the CPU struct lives permanently, however in SMP mode, the struct transfers to cpus[my_lapic_id] after initializing SMP.}\par
00022 \par
00023 {\cf20 /*}\par
00024 {\cf20 Boot Parameters}\par
00025 {\cf20 */}\par
00026 GOP_PARAMS gop_local;\par
00027 BOOT_INFO boot_info_local;\par
00028 \par
00029 {\cf20 /*}\par
00030 {\cf20 AHCI Specifications}\par
00031 {\cf20 */}\par
00032 {\cf21 #define MAX_AHCI_CONTROLLERS 32}\par
00033 uint64_t ahci_bases_local[MAX_AHCI_CONTROLLERS];\par
00034 \par
00035 \par
00039 \par
00040 \par
00041 {\cf21 #define MAX_MEMORY_MAP_SIZE 0x8000  }{\cf20 // 32 KB, enough for ~512 descriptors (this shouldn't be used, since we init the PFN db with the ptr from original UEFI, but eh, whatevs)}\par
00042 \par
00043 {\cf17 static} EFI_MEMORY_DESCRIPTOR memory_map_copy[MAX_MEMORY_MAP_SIZE / {\cf17 sizeof}(EFI_MEMORY_DESCRIPTOR)];\par
00044 \par
00045 {\cf18 void} copy_memory_map(BOOT_INFO* boot_info) \{\par
00046     {\cf19 if} (!boot_info || !boot_info->MemoryMap) {\cf19 return};\par
00047     {\cf19 if} (boot_info->MapSize > MAX_MEMORY_MAP_SIZE) \{\par
00048         {\cf20 // handle error, memory map too big}\par
00049         MeBugCheck(MEMORY_MAP_SIZE_OVERRUN);\par
00050     \}\par
00051 \par
00052     {\cf20 // Copy the entire memory map into the static buffer}\par
00053     kmemcpy(memory_map_copy, boot_info->MemoryMap, boot_info->MapSize);\par
00054 \par
00055     boot_info_local.MemoryMap = memory_map_copy;\par
00056     boot_info_local.MapSize = boot_info->MapSize;\par
00057     boot_info_local.DescriptorSize = boot_info->DescriptorSize;\par
00058     boot_info_local.DescriptorVersion = boot_info->DescriptorVersion;\par
00059 \}\par
00060 \par
00061 {\cf18 void} copy_gop(BOOT_INFO* boot_info) \{\par
00062     {\cf19 if} (!boot_info || !boot_info->Gop.FrameBufferBase) {\cf19 return};\par
00063 \par
00064     {\cf20 // Copy the GOP data to a local global variable}\par
00065     gop_local = (boot_info->Gop);\par
00066 \par
00067     {\cf20 // Update all relevant pointers to point to the local copy}\par
00068     boot_info_local.Gop = gop_local;\par
00069 \}\par
00070 \par
00071 \par
00072 {\cf18 void} init_boot_info(BOOT_INFO* boot_info) \{\par
00073     {\cf19 if} (!boot_info) {\cf19 return};\par
00074 \par
00075     copy_memory_map(boot_info);\par
00076     copy_gop(boot_info);\par
00077     {\cf19 if} (boot_info->AhciCount > MAX_AHCI_CONTROLLERS) \{\par
00078         MeBugCheck(BAD_AHCI_COUNT);\par
00079     \}\par
00080     {\cf19 for} (uint32_t i = 0; i < boot_info->AhciCount; i++) \{\par
00081         ahci_bases_local[i] = boot_info->AhciBarBases[i];\par
00082     \}\par
00083     {\cf20 // Copy the local array into local boot info.}\par
00084     kmemcpy(boot_info_local.AhciBarBases, ahci_bases_local, {\cf17 sizeof}(ahci_bases_local));\par
00085     boot_info_local.AhciCount = boot_info->AhciCount;\par
00086     boot_info_local.KernelStackTop = boot_info->KernelStackTop;\par
00087     boot_info_local.Pml4Phys = boot_info->Pml4Phys;\par
00088     boot_info_local.AcpiRsdpPhys = boot_info->AcpiRsdpPhys;\par
00089 \}\par
00090 \par
00091 {\cf17 static} {\cf17 inline} {\cf18 bool} interrupts_enabled({\cf18 void}) \{\par
00092     {\cf18 unsigned} {\cf18 long} flags;\par
00093     __asm__ __volatile__({\cf22 "pushfq; popq %0"}\par
00094         : {\cf22 "=r"}(flags)\par
00095         :\par
00096         : {\cf22 "memory"}, {\cf22 "cc"});\par
00097     {\cf19 return} (flags & (1UL << 9)) != 0; {\cf20 // IF is bit 9}\par
00098 \}\par
00099 \par
00100 {\cf18 void} kernel_idle_checks({\cf18 void}) \{\par
00101     gop_printf(0xFF000FF0, {\cf22 "Reached the scheduler!\\n"});\par
00102     {\cf20 // Reaching the idle thread with interrupts off means something did not have the RFLAGS IF Bit set.}\par
00103     {\cf19 if} (!interrupts_enabled()) \{\par
00104         gop_printf(COLOR_RED, {\cf22 "**Interrupts aren't enabled..\\n Stack Trace:\\n"});\par
00105         FREEZE();\par
00106     \}\par
00107     {\cf19 while} (1) \{\par
00108         {\cf19 if} (MeGetCurrentProcessor()->ZombieThread) \{\par
00109             {\cf20 // Delete the last thread.}\par
00110             Schedule();\par
00111         \}\par
00112         __hlt();\par
00113         {\cf20 //Schedule();}\par
00114     \}\par
00115 \}\par
00116 \par
00117 {\cf17 static} {\cf18 void} test(MUTEX* mut) \{\par
00118     PETHREAD currentThread = PsGetCurrentThread();\par
00119     gop_printf_forced(0xFF00FF00, {\cf22 "Hit Test! test thread ptr: %p\\n"}, currentThread);\par
00120     gop_printf(COLOR_GREEN, {\cf22 "(test) Acquiring Mutex Object: %p\\n"}, mut);\par
00121     MsAcquireMutexObject(mut);\par
00122     {\cf17 volatile} uint64_t z = 0;\par
00123 {\cf21 #ifdef GDB}\par
00124     {\cf19 for} (uint64_t i = 0; i < 0xA; i++) \{\par
00125 {\cf21 #else}\par
00126     {\cf19 for} (uint64_t i = 0; i < 0xFFFFFFF; i++) \{\par
00127 {\cf21 #endif}\par
00128         z++;\par
00129     \}\par
00130     gop_printf(COLOR_GREEN, {\cf22 "(test) Releasing Mutex Object: %p\\n"}, mut);\par
00131     MsReleaseMutexObject(mut);\par
00132     gop_printf_forced(0xFFA020F0, {\cf22 "**Ended Test.**\\n"});\par
00133 \}\par
00134 \par
00135 {\cf17 static} {\cf18 void} MeCreateInitialUserModeProcess({\cf18 void}) \{\par
00136     gop_printf(COLOR_OLIVE, {\cf22 "Starting initial user mode process.\\n"});\par
00137     HANDLE hProcess;\par
00138     PsCreateProcess({\cf22 "loop.mtexe"}, &hProcess, MT_PROCESS_ALL_ACCESS, 0);\par
00139     UNREFERENCED_PARAMETER(hProcess);\par
00140 \}\par
00141 \par
00142 {\cf20 // All CPUs}\par
00143 uint8_t apic_list[MAX_CPUS];\par
00144 uint32_t cpu_count = 0;\par
00145 uint32_t lapicAddress;\par
00146 {\cf18 bool} smpInitialized;\par
00147 \par
00150 {\cf21 #ifdef DEBUG}\par
00151 {\cf20 // Stack Canary GCC}\par
00152 {\cf17 volatile} uintptr_t __stack_chk_guard;\par
00153 \par
00154 __attribute__((noreturn))\par
00155 {\cf18 void} __stack_chk_fail({\cf18 void}) \{\par
00156     __cli();\par
00157     MeBugCheckEx(KERNEL_STACK_OVERFLOWN, ({\cf18 void}*)__builtin_return_address(0), NULL, NULL, NULL);\par
00158 \}\par
00159 {\cf21 #endif}\par
00160 \par
00161 {\cf20 // TODO allocate dynamically (use PsCreateProcess)}\par
00162 EPROCESS PsInitialSystemProcess;\par
00163 \par
00164 {\cf17 static} {\cf18 void} InitSystemProcess({\cf18 void}) \{\par
00165     PsInitialSystemProcess.PID = 4; {\cf20 // Initial PID, reserved.}\par
00166     PsInitialSystemProcess.ParentProcess = 0; {\cf20 // No creator process}\par
00167     kstrncpy(PsInitialSystemProcess.ImageName, {\cf22 "mtoskrnl.mtexe"}, {\cf17 sizeof}(PsInitialSystemProcess.ImageName)); {\cf20 // Name for the process}\par
00168     PsInitialSystemProcess.priority = 0; {\cf20 // TODO}\par
00169     PsInitialSystemProcess.InternalProcess.PageDirectoryPhysical = __read_cr3(); {\cf20 // The PML4 of the system process, is our kernel PML4.}\par
00170     PsInitialSystemProcess.CreationTime = MeGetEpoch();\par
00171     PsInitialSystemProcess.MainThread = MeGetCurrentProcessor()->idleThread; {\cf20 // The main thread for the SYSTEM process is the BSP's idle thread.}\par
00172     InitializeListHead(&PsInitialSystemProcess.AllThreads);\par
00173     PsInitialSystemProcess.ObjectTable = HtCreateHandleTable(&PsInitialSystemProcess);\par
00174 \}\par
00175 \par
00176 {\cf17 extern} uint8_t bss_start;\par
00177 {\cf17 extern} uint8_t bss_end;\par
00178 \par
00180 __attribute__((noreturn))\par
00181 {\cf18 void} kernel_main(BOOT_INFO* boot_info) \{\par
00182     {\cf20 // 1. CORE SYSTEM INITIALIZATION}\par
00183     __writemsr(IA32_GS_BASE, (uint64_t)&cpu0);\par
00184     __cli();\par
00185     {\cf20 // Zero the BSS.}\par
00186     {\cf18 size_t} len = &bss_end - &bss_start;\par
00187     RtlZeroMemory(&bss_start, len);\par
00188     {\cf20 // Create the local boot struct.}\par
00189     init_boot_info(boot_info);\par
00190     gop_clear_screen(&gop_local, 0); {\cf20 // 0 is just black. (0x0000000)}\par
00191     {\cf20 // Initialize the global CPU struct.}\par
00192     MeInitializeProcessor(&cpu0, {\cf17 false}, {\cf17 false});\par
00193     {\cf20 // Initialize interrupts & exceptions.}\par
00194     init_interrupts();\par
00195     {\cf20 // Initialize the memory manager}\par
00196     MmInitSystem(SYSTEM_PHASE_INITIALIZE_ALL, boot_info);\par
00197 \par
00198     {\cf20 // Initialize the TSS & GDT & New IDT with TSS}\par
00199     MeInitializeProcessor(&cpu0, {\cf17 true}, {\cf17 false});\par
00200 \par
00201     {\cf20 // Initialize ACPI after initializing Mm (since page faults will happen on pfn db if not).}\par
00202     MTSTATUS st = MhInitializeACPI();\par
00203     {\cf19 if} (MT_FAILURE(st)) \{\par
00204         gop_printf(COLOR_RED, {\cf22 "InitializeACPI Failure: %x\\n"}, st);\par
00205         __hlt();\par
00206     \}\par
00207 \par
00208     {\cf20 // Move all UEFI Pointers to kernel higher half (after physical memory offset)}\par
00209     {\cf20 // To allow copying PML4 of kernel to processes.}\par
00210     MiMoveUefiDataToHigherHalf(boot_info);\par
00211 \par
00212     {\cf20 // Initialize the object manager subsystem.}\par
00213     ObInitialize();\par
00214 \par
00215     {\cf20 // Initialize Ps subsystem.}\par
00216     st = PsInitializeSystem(PS_PHASE_INITIALIZE_SYSTEM);\par
00217     {\cf19 if} (MT_FAILURE(st)) \{\par
00218         MeBugCheckEx(PSMGR_INIT_FAILED, ({\cf18 void}*)(uintptr_t)st, NULL, NULL, NULL);\par
00219     \}\par
00220 \par
00221     {\cf20 // And, initialize our system process.}\par
00222     InitSystemProcess();\par
00223     _MeSetIrql(PASSIVE_LEVEL);\par
00224 {\cf21 #ifdef DEBUG}\par
00225     \{\par
00226         uint64_t temp_canary = 0;\par
00227         {\cf18 bool} rdrand_ok = {\cf17 false};\par
00228         {\cf19 for} ({\cf18 int} n = 0; n < 64; n++) \{\par
00229             {\cf19 if} (__rdrand64(&temp_canary)) \{\par
00230                 rdrand_ok = {\cf17 true};\par
00231                 {\cf19 break};\par
00232             \}\par
00233         \}\par
00234 \par
00235         {\cf19 if} (rdrand_ok) \{\par
00236             __stack_chk_guard = temp_canary;\par
00237         \}\par
00238         {\cf19 else} \{\par
00239             {\cf20 // rdrand didnt give a value, use timestamp of CPU cycles.}\par
00240             __stack_chk_guard = __rdtsc();\par
00241         \}\par
00242 \par
00243         {\cf20 // The canary should never be zero.}\par
00244         {\cf19 if} (__stack_chk_guard == 0) \{\par
00245             __stack_chk_guard = 0xDEADC0DEDEADC0DE; {\cf20 // fallback}\par
00246         \}\par
00247     \}\par
00248 {\cf21 #endif}\par
00249     {\cf20 /* Initiate Scheduler */}\par
00250     InitScheduler();\par
00251     uint64_t rip;\par
00252     __asm__ {\cf17 volatile} (\par
00253         {\cf22 "lea 1f(%%rip), %0\\n\\t"}  {\cf20 // Calculate the address of label 1 relative to RIP}\par
00254         {\cf22 "1:"}                     {\cf20 // The label whose address we want}\par
00255         : {\cf22 "=r"}(rip)              {\cf20 // Output to the 'rip' variable}\par
00256         );\par
00257 \par
00258     gop_printf_forced(0xFFFFFF00, {\cf22 "Current RIP: %p\\n"}, ({\cf18 void}*)(uintptr_t)rip);\par
00259 \par
00260     {\cf19 if} (rip >= KernelVaStart) \{\par
00261         gop_printf_forced(0x00FF00FF, {\cf22 "**[+] Running in higher-half**\\n"});\par
00262     \}\par
00263     {\cf19 else} \{\par
00264         gop_printf_forced(0xFF0000FF, {\cf22 "[-] Still identity-mapped\\n"});\par
00265     \}\par
00266 \par
00267     {\cf20 // Initialize worker threads. (all thread creation must be after sched init)}\par
00268     PsInitializeSystem(PS_PHASE_INITIALIZE_WORKER_THREADS);\par
00269 \par
00270     {\cf18 void}* buf = MmAllocatePoolWithTag(NonPagedPool, 64, {\cf22 'buf1'});\par
00271     gop_printf_forced(0xFFFFFF00, {\cf22 "buf addr: %p\\n"}, buf);\par
00272     {\cf18 void}* buf2 = MmAllocatePoolWithTag(NonPagedPool, 128, {\cf22 'buf2'});\par
00273     gop_printf_forced(0xFFFFFF00, {\cf22 "buf2 addr: %p\\n"}, buf2);\par
00274     MmFreePool(buf2);\par
00275     {\cf18 void}* buf3 = MmAllocatePoolWithTag(NonPagedPool, 128, {\cf22 'buf3'});\par
00276     gop_printf_forced(0xFFFFFF00, {\cf22 "buf3 addr (should be same as buf2): %p\\n"}, buf3);\par
00277     {\cf18 void}* buf4 = MmAllocatePoolWithTag(NonPagedPool, 2048, {\cf22 'buf4'});\par
00278     gop_printf_forced(0xFF964B00, {\cf22 "buf4 addr (should reside after buf3, allocated 2048 bytes): %p\\n"}, buf4);\par
00279     {\cf18 void}* buf5 = MmAllocatePoolWithTag(NonPagedPool, 64, {\cf22 'buf5'});\par
00280     gop_printf_forced(0xFF964B00, {\cf22 "buf5 addr (should be a larger addr): %p\\n"}, buf5);\par
00281     {\cf18 void}* buf6 = MmAllocatePoolWithTag(NonPagedPool, 5000, {\cf22 'buf6'});\par
00282     gop_printf_forced(0xFFFFFF00, {\cf22 "buf6 addr (should use dynamic memory): %p\\n"}, buf6);\par
00283     {\cf18 void}* buf7 = MmAllocatePoolWithTag(NonPagedPool, 10000, {\cf22 'buf7'});\par
00284     gop_printf_forced(0xFFFFFF00, {\cf22 "buf7 addr (should use dynamic memory, extremely larger): %p\\n"}, buf7);\par
00285 \par
00286     {\cf19 if} (checkcpuid()) \{\par
00287         {\cf18 char} str[256];\par
00288         getCpuName(str);\par
00289         gop_printf(COLOR_GREEN, {\cf22 "CPU Identified: %s\\n"}, str);\par
00290     \}\par
00291 \par
00292     MTSTATUS status = vfs_init();\par
00293     gop_printf(COLOR_RED, {\cf22 "vfs_init returned: %s\\n"}, MT_SUCCEEDED(status) ? {\cf22 "Success"} : {\cf22 "Unsuccessful"});\par
00294     {\cf19 if} (MT_FAILURE(status)) \{\par
00295         MeBugCheck(FILESYSTEM_PANIC);\par
00296     \}\par
00297 \par
00298     TIME_ENTRY currTime = get_time();\par
00299 {\cf21 #define ISRAEL_UTC_OFFSET 3}\par
00300     gop_printf(COLOR_GREEN, {\cf22 "Current Time: %d/%d/%d | %d:%d:%d\\n"}, currTime.year, currTime.month, currTime.day, currTime.hour + ISRAEL_UTC_OFFSET, currTime.minute, currTime.second);\par
00301     {\cf18 char} listings[256];\par
00302     status = vfs_listdir({\cf22 "/"}, listings, {\cf17 sizeof}(listings));\par
00303     gop_printf(COLOR_RED, {\cf22 "vfs_listdir returned: %x\\n"}, status);\par
00304     gop_printf(COLOR_RED, {\cf22 "root directory is: %s\\n"}, vfs_is_dir_empty({\cf22 "/"}) ? {\cf22 "Empty"} : {\cf22 "Not Empty"});\par
00305     gop_printf(COLOR_CYAN, {\cf22 "%s"}, listings);\par
00306     MUTEX* sharedMutex = MmAllocatePoolWithTag(NonPagedPool, {\cf17 sizeof}(MUTEX), {\cf22 ' TUM'});\par
00307     {\cf19 if} (!sharedMutex) \{ gop_printf(COLOR_RED, {\cf22 "It's null\\n"}); __hlt(); \}\par
00308     status = MsInitializeMutexObject(sharedMutex);\par
00309     PsCreateSystemThread((ThreadEntry)test, sharedMutex, DEFAULT_TIMESLICE_TICKS);\par
00310     PsCreateSystemThread((ThreadEntry)MeCreateInitialUserModeProcess, NULL, DEFAULT_TIMESLICE_TICKS); {\cf20 // I have tested 5+ threads, works perfectly as it should. ( SMP UPDATED - Tested with 4 threads, MUTEX and scheduling works perfectly :) )}\par
00311     {\cf20 /* Enable LAPIC & SMP Now. */}\par
00312     lapic_init_cpu();\par
00313     lapic_enable(); {\cf20 // call again.}\par
00314     lapic_timer_calibrate();\par
00315     init_lapic_timer(100); {\cf20 // 10ms, must be called before other APs}\par
00316 {\cf21 #ifndef MT_UP}\par
00317     {\cf20 /* Enable SMP */}\par
00318     status = MhParseLAPICs((uint8_t*)apic_list, MAX_CPUS, &cpu_count, &lapicAddress);\par
00319     {\cf19 if} (MT_FAILURE(status)) \{\par
00320         gop_printf(COLOR_RED, {\cf22 "**[MTSTATUS-FAILURE]** ParseLAPICs status returned: %x, continuing in UP mode.\\n"}, status);\par
00321     \}\par
00322     {\cf19 else} \{\par
00323         MhInitializeSMP(apic_list, 4, lapicAddress);\par
00324         IPI_PARAMS dummy = \{ 0 \}; {\cf20 // zero-initialize the struct}\par
00325         MhSendActionToCpusAndWait(CPU_ACTION_PRINT_ID, dummy);\par
00326         allApsInitialized = {\cf17 true}; {\cf20 // Toggle this flag after all CPUs printed their ID, since thats when it marks that all CPUs of the apic list have initialized fully.}\par
00327     \}\par
00328 {\cf21 #else}\par
00329     gop_printf(COLOR_RED, {\cf22 "System configured to run in UP mode.\\n"});\par
00330 {\cf21 #endif}\par
00331     {\cf20 // __sti(); STI Call commented out, this is what caused the scheduler assertion to fail, and guess how much time it took to debug? 2 days}\par
00332     {\cf20 // Thread creations (including idle threads) must come with the IF flag set.}\par
00333     Schedule();\par
00334     __builtin_unreachable();\par
00335 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\bkmkstart AAAAAAACTJ}
{\bkmkend AAAAAAACTJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include <stdatomic.h>}\par
{\f2 #include "includes/mtos.h"}\par
{\f2 #include "assert.h"}\par
{\f2 #include "intrinsics/intrin.h"}\par
{\f2 #include "filesystem/fat32/fat32.h"}\par
{\f2 #include "includes/stdarg_myos.h"}\par
{\f2 #include "drivers/blk/block.h"}\par
{\f2 #include "drivers/ahci/ahci.h"}\par
{\f2 #include "drivers/gop/gop.h"}\par
{\f2 #include "time.h"}\par
{\f2 #include "filesystem/vfs/vfs.h"}\par
{\f2 #include "includes/behavior.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b UNREFERENCED_PARAMETER}(x)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define CAUSE_BUGCHECK }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b gop_printf_forced}(color,  fmt, ...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b __attribute__} ((noreturn)) void __stack_chk_fail(void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_idle_checks} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b kernel_main} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_memory_map} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copy_gop} ({\b BOOT_INFO} *boot_info)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init_boot_info} ({\b BOOT_INFO} *boot_info)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isBugChecking}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACTK}
{\bkmkend AAAAAAACTK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v gop_printf_forced\:kernel.h}
{\xe \v kernel.h\:gop_printf_forced}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define gop_printf_forced( color,  fmt,  ...)}}
\par
{\bkmkstart AAAAAAACTL}
{\bkmkend AAAAAAACTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid gop_printf(color, fmt, ##__VA_ARGS__)\par
}
{
Definition at line {\b 58} of file {\b kernel.h}.}\par
}
{\xe \v UNREFERENCED_PARAMETER\:kernel.h}
{\xe \v kernel.h\:UNREFERENCED_PARAMETER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define UNREFERENCED_PARAMETER( x)}}
\par
{\bkmkstart AAAAAAACTM}
{\bkmkend AAAAAAACTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid (void)(x)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define CAUSE_BUGCHECK }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
#define REMINDER \par
}{
Definition at line {\b 37} of file {\b kernel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACTN}
{\bkmkend AAAAAAACTN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v __attribute__\:kernel.h}
{\xe \v kernel.h\:__attribute__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
__attribute__ ((noreturn) )}}
\par
{\bkmkstart AAAAAAACTO}
{\bkmkend AAAAAAACTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Remember that paging is on when this is called, as UEFI turned it on. \par
}{
Definition at line {\b 180} of file {\b kernel.c}.}\par
}
{\xe \v copy_gop\:kernel.h}
{\xe \v kernel.h\:copy_gop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_gop ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACTP}
{\bkmkend AAAAAAACTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b kernel.c}.}\par
}
{\xe \v copy_memory_map\:kernel.h}
{\xe \v kernel.h\:copy_memory_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void copy_memory_map ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACTQ}
{\bkmkend AAAAAAACTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b kernel.c}.}\par
}
{\xe \v init_boot_info\:kernel.h}
{\xe \v kernel.h\:init_boot_info}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void init_boot_info ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACTR}
{\bkmkend AAAAAAACTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b kernel.c}.}\par
}
{\xe \v kernel_idle_checks\:kernel.h}
{\xe \v kernel.h\:kernel_idle_checks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_idle_checks (void )}}
\par
{\bkmkstart AAAAAAACTS}
{\bkmkend AAAAAAACTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b kernel.c}.}\par
}
{\xe \v kernel_main\:kernel.h}
{\xe \v kernel.h\:kernel_main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void kernel_main ({\b BOOT_INFO} * boot_info)}}
\par
{\bkmkstart AAAAAAACTT}
{\bkmkend AAAAAAACTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACTU}
{\bkmkend AAAAAAACTU}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v isBugChecking\:kernel.h}
{\xe \v kernel.h\:isBugChecking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isBugChecking{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAACTV}
{\bkmkend AAAAAAACTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Global variables initialization \par
}{
Definition at line {\b 19} of file {\b kernel.c}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
kernel.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/kernel.h}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     Core Kernel Includes, includes all core and necessary header files.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_KERNEL_H}\par
00008 {\cf21 #define X86_KERNEL_H}\par
00009 \par
00010 {\cf20 // Standard headers, required.}\par
00011 {\cf21 #include <stddef.h>}\par
00012 {\cf21 #include <stdbool.h>}\par
00013 {\cf21 #include <stdint.h>}\par
00014 {\cf21 #include <stdatomic.h>}\par
00015 \par
00016 {\cf20 // forward declarations, i don't think i need them.}\par
00017 \par
00018 {\cf17 typedef} {\cf17 struct }_BLOCK_DEVICE BLOCK_DEVICE;\par
00019 {\cf17 typedef} {\cf17 struct }_BOOT_INFO BOOT_INFO;\par
00020 \par
00021 __attribute__((noreturn))\par
00022 {\cf18 void} __stack_chk_fail({\cf18 void});\par
00023 \par
00024 {\cf20 // Standard globals}\par
00025 {\cf17 extern} {\cf18 bool} isBugChecking;\par
00026 \par
00027 {\cf20 /* Definitions that change kernel behaviour below */}\par
00028 \par
00029 {\cf20 /* Uncomment to trigger a bugcheck on entry */}\par
00031 \par
00032 {\cf20 /* Uncomment to show all reminders in a static assertion */}\par
00034 \par
00035 {\cf20 /* To define DEBUG globally, use a compiler flag. I removed this since I now transitioned each header to iself and others instead of relying on kernel.h that caused circular includes. */}\par
00036 \par
00037 {\cf21 #define UNREFERENCED_PARAMETER(x) (void)(x)}\par
00038 {\cf21 #include "includes/mtos.h"}\par
00039 {\cf21 #include "assert.h"}\par
00040 {\cf21 #include "intrinsics/intrin.h"}\par
00041 {\cf21 #include "filesystem/fat32/fat32.h"}\par
00042 {\cf21 #include "includes/stdarg_myos.h"}\par
00043 {\cf21 #include "drivers/blk/block.h"}\par
00044 {\cf21 #include "drivers/ahci/ahci.h"}\par
00045 {\cf21 #include "drivers/gop/gop.h"}\par
00046 {\cf21 #include "time.h"}\par
00047 {\cf21 #include "filesystem/vfs/vfs.h"}\par
00048 {\cf21 #include "includes/behavior.h"}\par
00049 \par
00050 {\cf20 // Entry point in C}\par
00051 {\cf18 void} kernel_idle_checks({\cf18 void});\par
00052 {\cf18 void} kernel_main(BOOT_INFO* boot_info);\par
00053 {\cf20 // Function declarations.}\par
00054 {\cf18 void} copy_memory_map(BOOT_INFO* boot_info);\par
00055 {\cf18 void} copy_gop(BOOT_INFO* boot_info);\par
00056 {\cf18 void} init_boot_info(BOOT_INFO* boot_info);\par
00057 \par
00058 {\cf21 #define gop_printf_forced(color, fmt, ...) gop_printf(color, fmt, ##__VA_ARGS__)}\par
00059 \par
00060 {\cf21 #endif }{\cf20 // X86_KERNEL_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\bkmkstart AAAAAAACTW}
{\bkmkend AAAAAAACTW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_SUCCEEDED}(Status)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macros to test status. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAILURE}(Status)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_SUCCESS}\~ (({\b MTSTATUS})0x00000000L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NOT_IMPLEMENTED}\~ (({\b MTSTATUS})0xC0000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_PARAM}\~ (({\b MTSTATUS})0xC0000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_STATE}\~ (({\b MTSTATUS})0xC0000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_ACCESS_DENIED}\~ (({\b MTSTATUS})0xC0000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_TIMEOUT}\~ (({\b MTSTATUS})0xC0000005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_UNSUPPORTED_OP}\~ (({\b MTSTATUS})0xC0000006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_ALREADY_EXISTS}\~ (({\b MTSTATUS})0xC0000007L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NOT_FOUND}\~ (({\b MTSTATUS})0xC0000008L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC0000009L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NO_RESOURCES}\~ (({\b MTSTATUS})0xC0000010L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_CHECK}\~ (({\b MTSTATUS})0xC0000011L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_TYPE_MISMATCH}\~ (({\b MTSTATUS})0xC0000012L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_OBJECT_DELETED}\~ (({\b MTSTATUS})0xC0000013L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_HANDLE}\~ (({\b MTSTATUS})0xC0000014L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_NO_MEMORY}\~ (({\b MTSTATUS})0xC1000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_MEMORY_LIMIT}\~ (({\b MTSTATUS})0xC1000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PAGE_FAULT_ERROR}\~ (({\b MTSTATUS})0xC1000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_HEAP_CORRUPTION}\~ (({\b MTSTATUS})0xC1000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_ADDRESS}\~ (({\b MTSTATUS})0xC1000005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_CONFLICTING_ADDRESSES}\~ (({\b MTSTATUS})0xC1000006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_IO_ERROR}\~ (({\b MTSTATUS})0xC2000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_CORRUPTED}\~ (({\b MTSTATUS})0xC2000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_READ_ONLY}\~ (({\b MTSTATUS})0xC2000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_NO_SPACE}\~ (({\b MTSTATUS})0xC2000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_PERMISSION_DENIED}\~ (({\b MTSTATUS})0xC2000005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_INITIALIZATION_FAILURE}\~ (({\b MTSTATUS})0xC2000006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_VFS_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC2000007L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_CLUSTERS_FULL}\~ (({\b MTSTATUS})0xC2010001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_INVALID_CLUSTER}\~ (({\b MTSTATUS})0xC2010002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_DIR_FULL}\~ (({\b MTSTATUS})0xC2010003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_FILE_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_PATH_TOO_LONG}\~ (({\b MTSTATUS})0xC2010005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_INVALID_FILENAME}\~ (({\b MTSTATUS})0xC2010006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_EOF}\~ (({\b MTSTATUS})0xC2010007L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_DIRECTORY_ALREADY_EXISTS}\~ (({\b MTSTATUS})0xC2010008L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_PARENT_PATH_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010009L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_PARENT_PATH_NOT_DIR}\~ (({\b MTSTATUS})0xC2010010L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_INVALID_WRITE_MODE}\~ (({\b MTSTATUS})0xC2010011L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_CLUSTER_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010012L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_CLUSTER_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC2010013L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_DIRECTORY_NOT_FOUND}\~ (({\b MTSTATUS})0xC2010014L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_FAT32_FILENAME_TOO_LONG}\~ (({\b MTSTATUS})0xC2010015L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_NOT_READY}\~ (({\b MTSTATUS})0xC3000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_ERROR}\~ (({\b MTSTATUS})0xC3000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_TIMEOUT}\~ (({\b MTSTATUS})0xC3000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_DEVICE_UNSUPPORTED}\~ (({\b MTSTATUS})0xC3000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_INIT_FAILED}\~ (({\b MTSTATUS})0xC3010001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_PORT_FAILURE}\~ (({\b MTSTATUS})0xC3010002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_READ_FAILURE}\~ (({\b MTSTATUS})0xC3010003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_WRITE_FAILURE}\~ (({\b MTSTATUS})0xC3010004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_TIMEOUT}\~ (({\b MTSTATUS})0xC3010005L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_AHCI_GENERAL_FAILURE}\~ (({\b MTSTATUS})0xC3010006L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_NOT_FOUND}\~ (({\b MTSTATUS})0xC4000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_THREAD_CREATION_FAILURE}\~ (({\b MTSTATUS})0xC4000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_SCHEDULER_ERROR}\~ (({\b MTSTATUS})0xC4000003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_IRQL}\~ (({\b MTSTATUS})0xC4000004L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_MUTEX_ALREADY_OWNED}\~ (({\b MTSTATUS})0xC5000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_MUTEX_NOT_OWNED}\~ (({\b MTSTATUS})0xC5000002L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_INVALID_LOCK}\~ (({\b MTSTATUS})0xC500003L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_EVENT_ALREADY_SIGNALED}\~ (({\b MTSTATUS})0xC6000001L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_PROCESS_IS_TERMINATING}\~ (({\b MTSTATUS})0xC7000000L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_ACCESS_VIOLATION}\~ (({\b MTSTATUS})0xC8000000L)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MT_GUARD_PAGE_VIOLATION}\~ (({\b MTSTATUS})0xC8000001L)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int32_t {\b MTSTATUS}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACTX}
{\bkmkend AAAAAAACTX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MT_ACCESS_DENIED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_ACCESS_DENIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_ACCESS_DENIED\~ (({\b MTSTATUS})0xC0000004L)}}
\par
{\bkmkstart AAAAAAACTY}
{\bkmkend AAAAAAACTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_ACCESS_VIOLATION\:mtstatus.h}
{\xe \v mtstatus.h\:MT_ACCESS_VIOLATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_ACCESS_VIOLATION\~ (({\b MTSTATUS})0xC8000000L)}}
\par
{\bkmkstart AAAAAAACTZ}
{\bkmkend AAAAAAACTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 129} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC3010006L)}}
\par
{\bkmkstart AAAAAAACUA}
{\bkmkend AAAAAAACUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 94} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_INIT_FAILED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_INIT_FAILED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_INIT_FAILED\~ (({\b MTSTATUS})0xC3010001L)}}
\par
{\bkmkstart AAAAAAACUB}
{\bkmkend AAAAAAACUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 89} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_PORT_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_PORT_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_PORT_FAILURE\~ (({\b MTSTATUS})0xC3010002L)}}
\par
{\bkmkstart AAAAAAACUC}
{\bkmkend AAAAAAACUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 90} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_READ_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_READ_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_READ_FAILURE\~ (({\b MTSTATUS})0xC3010003L)}}
\par
{\bkmkstart AAAAAAACUD}
{\bkmkend AAAAAAACUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_TIMEOUT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_TIMEOUT\~ (({\b MTSTATUS})0xC3010005L)}}
\par
{\bkmkstart AAAAAAACUE}
{\bkmkend AAAAAAACUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_AHCI_WRITE_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_AHCI_WRITE_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_AHCI_WRITE_FAILURE\~ (({\b MTSTATUS})0xC3010004L)}}
\par
{\bkmkstart AAAAAAACUF}
{\bkmkend AAAAAAACUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 92} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_ALREADY_EXISTS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_ALREADY_EXISTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_ALREADY_EXISTS\~ (({\b MTSTATUS})0xC0000007L)}}
\par
{\bkmkstart AAAAAAACUG}
{\bkmkend AAAAAAACUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_CONFLICTING_ADDRESSES\:mtstatus.h}
{\xe \v mtstatus.h\:MT_CONFLICTING_ADDRESSES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_CONFLICTING_ADDRESSES\~ (({\b MTSTATUS})0xC1000006L)}}
\par
{\bkmkstart AAAAAAACUH}
{\bkmkend AAAAAAACUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 47} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_ERROR\~ (({\b MTSTATUS})0xC3000002L)}}
\par
{\bkmkstart AAAAAAACUI}
{\bkmkend AAAAAAACUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_NOT_READY\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_NOT_READY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_NOT_READY\~ (({\b MTSTATUS})0xC3000001L)}}
\par
{\bkmkstart AAAAAAACUJ}
{\bkmkend AAAAAAACUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 85} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_TIMEOUT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_TIMEOUT\~ (({\b MTSTATUS})0xC3000003L)}}
\par
{\bkmkstart AAAAAAACUK}
{\bkmkend AAAAAAACUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 87} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_DEVICE_UNSUPPORTED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_DEVICE_UNSUPPORTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_DEVICE_UNSUPPORTED\~ (({\b MTSTATUS})0xC3000004L)}}
\par
{\bkmkstart AAAAAAACUL}
{\bkmkend AAAAAAACUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 88} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_EVENT_ALREADY_SIGNALED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_EVENT_ALREADY_SIGNALED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_EVENT_ALREADY_SIGNALED\~ (({\b MTSTATUS})0xC6000001L)}}
\par
{\bkmkstart AAAAAAACUM}
{\bkmkend AAAAAAACUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 117} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAILURE( Status)}}
\par
{\bkmkstart AAAAAAACUN}
{\bkmkend AAAAAAACUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((Status) < 0)\par
}
{
Definition at line {\b 16} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_CLUSTER_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_CLUSTER_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_CLUSTER_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC2010013L)}}
\par
{\bkmkstart AAAAAAACUO}
{\bkmkend AAAAAAACUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 77} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_CLUSTER_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_CLUSTER_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_CLUSTER_NOT_FOUND\~ (({\b MTSTATUS})0xC2010012L)}}
\par
{\bkmkstart AAAAAAACUP}
{\bkmkend AAAAAAACUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_CLUSTERS_FULL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_CLUSTERS_FULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_CLUSTERS_FULL\~ (({\b MTSTATUS})0xC2010001L)}}
\par
{\bkmkstart AAAAAAACUQ}
{\bkmkend AAAAAAACUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_DIR_FULL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_DIR_FULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_DIR_FULL\~ (({\b MTSTATUS})0xC2010003L)}}
\par
{\bkmkstart AAAAAAACUR}
{\bkmkend AAAAAAACUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 67} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_DIRECTORY_ALREADY_EXISTS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_DIRECTORY_ALREADY_EXISTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_DIRECTORY_ALREADY_EXISTS\~ (({\b MTSTATUS})0xC2010008L)}}
\par
{\bkmkstart AAAAAAACUS}
{\bkmkend AAAAAAACUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_DIRECTORY_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_DIRECTORY_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_DIRECTORY_NOT_FOUND\~ (({\b MTSTATUS})0xC2010014L)}}
\par
{\bkmkstart AAAAAAACUT}
{\bkmkend AAAAAAACUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 78} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_EOF\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_EOF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_EOF\~ (({\b MTSTATUS})0xC2010007L)}}
\par
{\bkmkstart AAAAAAACUU}
{\bkmkend AAAAAAACUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_FILE_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_FILE_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_FILE_NOT_FOUND\~ (({\b MTSTATUS})0xC2010004L)}}
\par
{\bkmkstart AAAAAAACUV}
{\bkmkend AAAAAAACUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_FILENAME_TOO_LONG\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_FILENAME_TOO_LONG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_FILENAME_TOO_LONG\~ (({\b MTSTATUS})0xC2010015L)}}
\par
{\bkmkstart AAAAAAACUW}
{\bkmkend AAAAAAACUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 79} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_INVALID_CLUSTER\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_INVALID_CLUSTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_INVALID_CLUSTER\~ (({\b MTSTATUS})0xC2010002L)}}
\par
{\bkmkstart AAAAAAACUX}
{\bkmkend AAAAAAACUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_INVALID_FILENAME\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_INVALID_FILENAME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_INVALID_FILENAME\~ (({\b MTSTATUS})0xC2010006L)}}
\par
{\bkmkstart AAAAAAACUY}
{\bkmkend AAAAAAACUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_INVALID_WRITE_MODE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_INVALID_WRITE_MODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_INVALID_WRITE_MODE\~ (({\b MTSTATUS})0xC2010011L)}}
\par
{\bkmkstart AAAAAAACUZ}
{\bkmkend AAAAAAACUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 75} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_PARENT_PATH_NOT_DIR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_PARENT_PATH_NOT_DIR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_PARENT_PATH_NOT_DIR\~ (({\b MTSTATUS})0xC2010010L)}}
\par
{\bkmkstart AAAAAAACVA}
{\bkmkend AAAAAAACVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_PARENT_PATH_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_PARENT_PATH_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_PARENT_PATH_NOT_FOUND\~ (({\b MTSTATUS})0xC2010009L)}}
\par
{\bkmkstart AAAAAAACVB}
{\bkmkend AAAAAAACVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_FAT32_PATH_TOO_LONG\:mtstatus.h}
{\xe \v mtstatus.h\:MT_FAT32_PATH_TOO_LONG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_FAT32_PATH_TOO_LONG\~ (({\b MTSTATUS})0xC2010005L)}}
\par
{\bkmkstart AAAAAAACVC}
{\bkmkend AAAAAAACVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC0000009L)}}
\par
{\bkmkstart AAAAAAACVD}
{\bkmkend AAAAAAACVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_GUARD_PAGE_VIOLATION\:mtstatus.h}
{\xe \v mtstatus.h\:MT_GUARD_PAGE_VIOLATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_GUARD_PAGE_VIOLATION\~ (({\b MTSTATUS})0xC8000001L)}}
\par
{\bkmkstart AAAAAAACVE}
{\bkmkend AAAAAAACVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 130} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_HEAP_CORRUPTION\:mtstatus.h}
{\xe \v mtstatus.h\:MT_HEAP_CORRUPTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_HEAP_CORRUPTION\~ (({\b MTSTATUS})0xC1000004L)}}
\par
{\bkmkstart AAAAAAACVF}
{\bkmkend AAAAAAACVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_ADDRESS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_ADDRESS\~ (({\b MTSTATUS})0xC1000005L)}}
\par
{\bkmkstart AAAAAAACVG}
{\bkmkend AAAAAAACVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_CHECK\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_CHECK\~ (({\b MTSTATUS})0xC0000011L)}}
\par
{\bkmkstart AAAAAAACVH}
{\bkmkend AAAAAAACVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_HANDLE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_HANDLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_HANDLE\~ (({\b MTSTATUS})0xC0000014L)}}
\par
{\bkmkstart AAAAAAACVI}
{\bkmkend AAAAAAACVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_IRQL\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_IRQL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_IRQL\~ (({\b MTSTATUS})0xC4000004L)}}
\par
{\bkmkstart AAAAAAACVJ}
{\bkmkend AAAAAAACVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 103} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_LOCK\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_LOCK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_LOCK\~ (({\b MTSTATUS})0xC500003L)}}
\par
{\bkmkstart AAAAAAACVK}
{\bkmkend AAAAAAACVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_PARAM\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_PARAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_PARAM\~ (({\b MTSTATUS})0xC0000002L)}}
\par
{\bkmkstart AAAAAAACVL}
{\bkmkend AAAAAAACVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_INVALID_STATE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_INVALID_STATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_INVALID_STATE\~ (({\b MTSTATUS})0xC0000003L)}}
\par
{\bkmkstart AAAAAAACVM}
{\bkmkend AAAAAAACVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_IO_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_IO_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_IO_ERROR\~ (({\b MTSTATUS})0xC2000001L)}}
\par
{\bkmkstart AAAAAAACVN}
{\bkmkend AAAAAAACVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_MEMORY_LIMIT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_MEMORY_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_MEMORY_LIMIT\~ (({\b MTSTATUS})0xC1000002L)}}
\par
{\bkmkstart AAAAAAACVO}
{\bkmkend AAAAAAACVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 43} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_MUTEX_ALREADY_OWNED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_MUTEX_ALREADY_OWNED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_MUTEX_ALREADY_OWNED\~ (({\b MTSTATUS})0xC5000001L)}}
\par
{\bkmkstart AAAAAAACVP}
{\bkmkend AAAAAAACVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 109} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_MUTEX_NOT_OWNED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_MUTEX_NOT_OWNED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_MUTEX_NOT_OWNED\~ (({\b MTSTATUS})0xC5000002L)}}
\par
{\bkmkstart AAAAAAACVQ}
{\bkmkend AAAAAAACVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 110} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NO_MEMORY\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NO_MEMORY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NO_MEMORY\~ (({\b MTSTATUS})0xC1000001L)}}
\par
{\bkmkstart AAAAAAACVR}
{\bkmkend AAAAAAACVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NO_RESOURCES\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NO_RESOURCES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NO_RESOURCES\~ (({\b MTSTATUS})0xC0000010L)}}
\par
{\bkmkstart AAAAAAACVS}
{\bkmkend AAAAAAACVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NOT_FOUND\~ (({\b MTSTATUS})0xC0000008L)}}
\par
{\bkmkstart AAAAAAACVT}
{\bkmkend AAAAAAACVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_NOT_IMPLEMENTED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_NOT_IMPLEMENTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_NOT_IMPLEMENTED\~ (({\b MTSTATUS})0xC0000001L)}}
\par
{\bkmkstart AAAAAAACVU}
{\bkmkend AAAAAAACVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_OBJECT_DELETED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_OBJECT_DELETED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_OBJECT_DELETED\~ (({\b MTSTATUS})0xC0000013L)}}
\par
{\bkmkstart AAAAAAACVV}
{\bkmkend AAAAAAACVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_PAGE_FAULT_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_PAGE_FAULT_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PAGE_FAULT_ERROR\~ (({\b MTSTATUS})0xC1000003L)}}
\par
{\bkmkstart AAAAAAACVW}
{\bkmkend AAAAAAACVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_PROCESS_IS_TERMINATING\:mtstatus.h}
{\xe \v mtstatus.h\:MT_PROCESS_IS_TERMINATING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_PROCESS_IS_TERMINATING\~ (({\b MTSTATUS})0xC7000000L)}}
\par
{\bkmkstart AAAAAAACVX}
{\bkmkend AAAAAAACVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_SCHEDULER_ERROR\:mtstatus.h}
{\xe \v mtstatus.h\:MT_SCHEDULER_ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_SCHEDULER_ERROR\~ (({\b MTSTATUS})0xC4000003L)}}
\par
{\bkmkstart AAAAAAACVY}
{\bkmkend AAAAAAACVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_SUCCEEDED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_SUCCEEDED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_SUCCEEDED( Status)}}
\par
{\bkmkstart AAAAAAACVZ}
{\bkmkend AAAAAAACVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ((Status) >= 0)\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Macros to test status. }}\par
{
Definition at line {\b 15} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_SUCCESS\:mtstatus.h}
{\xe \v mtstatus.h\:MT_SUCCESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_SUCCESS\~ (({\b MTSTATUS})0x00000000L)}}
\par
{\bkmkstart AAAAAAACWA}
{\bkmkend AAAAAAACWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_THREAD_CREATION_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_THREAD_CREATION_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_CREATION_FAILURE\~ (({\b MTSTATUS})0xC4000002L)}}
\par
{\bkmkstart AAAAAAACWB}
{\bkmkend AAAAAAACWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_THREAD_NOT_FOUND\:mtstatus.h}
{\xe \v mtstatus.h\:MT_THREAD_NOT_FOUND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_THREAD_NOT_FOUND\~ (({\b MTSTATUS})0xC4000001L)}}
\par
{\bkmkstart AAAAAAACWC}
{\bkmkend AAAAAAACWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_TIMEOUT\:mtstatus.h}
{\xe \v mtstatus.h\:MT_TIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_TIMEOUT\~ (({\b MTSTATUS})0xC0000005L)}}
\par
{\bkmkstart AAAAAAACWD}
{\bkmkend AAAAAAACWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_TYPE_MISMATCH\:mtstatus.h}
{\xe \v mtstatus.h\:MT_TYPE_MISMATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_TYPE_MISMATCH\~ (({\b MTSTATUS})0xC0000012L)}}
\par
{\bkmkstart AAAAAAACWE}
{\bkmkend AAAAAAACWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_UNSUPPORTED_OP\:mtstatus.h}
{\xe \v mtstatus.h\:MT_UNSUPPORTED_OP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_UNSUPPORTED_OP\~ (({\b MTSTATUS})0xC0000006L)}}
\par
{\bkmkstart AAAAAAACWF}
{\bkmkend AAAAAAACWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_CORRUPTED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_CORRUPTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_CORRUPTED\~ (({\b MTSTATUS})0xC2000002L)}}
\par
{\bkmkstart AAAAAAACWG}
{\bkmkend AAAAAAACWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 54} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_GENERAL_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_GENERAL_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_GENERAL_FAILURE\~ (({\b MTSTATUS})0xC2000007L)}}
\par
{\bkmkstart AAAAAAACWH}
{\bkmkend AAAAAAACWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 59} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_INITIALIZATION_FAILURE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_INITIALIZATION_FAILURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_INITIALIZATION_FAILURE\~ (({\b MTSTATUS})0xC2000006L)}}
\par
{\bkmkstart AAAAAAACWI}
{\bkmkend AAAAAAACWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_NO_SPACE\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_NO_SPACE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_NO_SPACE\~ (({\b MTSTATUS})0xC2000004L)}}
\par
{\bkmkstart AAAAAAACWJ}
{\bkmkend AAAAAAACWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_PERMISSION_DENIED\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_PERMISSION_DENIED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_PERMISSION_DENIED\~ (({\b MTSTATUS})0xC2000005L)}}
\par
{\bkmkstart AAAAAAACWK}
{\bkmkend AAAAAAACWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b mtstatus.h}.}\par
}
{\xe \v MT_VFS_READ_ONLY\:mtstatus.h}
{\xe \v mtstatus.h\:MT_VFS_READ_ONLY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MT_VFS_READ_ONLY\~ (({\b MTSTATUS})0xC2000003L)}}
\par
{\bkmkstart AAAAAAACWL}
{\bkmkend AAAAAAACWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 55} of file {\b mtstatus.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACWM}
{\bkmkend AAAAAAACWM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v MTSTATUS\:mtstatus.h}
{\xe \v mtstatus.h\:MTSTATUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int32_t {\b MTSTATUS}}}
\par
{\bkmkstart AAAAAAACWN}
{\bkmkend AAAAAAACWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b mtstatus.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mtstatus.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/mtstatus.h}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:      MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:      GPLv3}\par
00004 {\cf20  * PURPOSE:      MTStatus definitions per subsystem or kernel wide. (STATUS RETURNS)}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef MTSTATUS_H}\par
00008 {\cf21 #define MTSTATUS_H}\par
00009 \par
00010 {\cf21 #include <stdint.h>}\par
00011 \par
00012 {\cf17 typedef} int32_t MTSTATUS;\par
00013 \par
00015 {\cf21 #define MT_SUCCEEDED(Status) ((Status) >= 0)}\par
00016 {\cf21 #define MT_FAILURE(Status)    ((Status) < 0)}\par
00017 \par
00018 {\cf20 //}\par
00019 {\cf20 // ==========================}\par
00020 {\cf20 // GENERAL MTSTATUS}\par
00021 {\cf20 // ==========================}\par
00022 {\cf21 #define MT_SUCCESS              ((MTSTATUS)0x00000000L)}\par
00023 {\cf21 #define MT_NOT_IMPLEMENTED      ((MTSTATUS)0xC0000001L)}\par
00024 {\cf21 #define MT_INVALID_PARAM        ((MTSTATUS)0xC0000002L)}\par
00025 {\cf21 #define MT_INVALID_STATE        ((MTSTATUS)0xC0000003L)}\par
00026 {\cf21 #define MT_ACCESS_DENIED        ((MTSTATUS)0xC0000004L)}\par
00027 {\cf21 #define MT_TIMEOUT              ((MTSTATUS)0xC0000005L)}\par
00028 {\cf21 #define MT_UNSUPPORTED_OP       ((MTSTATUS)0xC0000006L)}\par
00029 {\cf21 #define MT_ALREADY_EXISTS       ((MTSTATUS)0xC0000007L)}\par
00030 {\cf21 #define MT_NOT_FOUND            ((MTSTATUS)0xC0000008L)}\par
00031 {\cf21 #define MT_GENERAL_FAILURE      ((MTSTATUS)0xC0000009L)}\par
00032 {\cf21 #define MT_NO_RESOURCES         ((MTSTATUS)0xC0000010L)}\par
00033 {\cf21 #define MT_INVALID_CHECK        ((MTSTATUS)0xC0000011L)}\par
00034 {\cf21 #define MT_TYPE_MISMATCH        ((MTSTATUS)0xC0000012L)}\par
00035 {\cf21 #define MT_OBJECT_DELETED       ((MTSTATUS)0xC0000013L)}\par
00036 {\cf21 #define MT_INVALID_HANDLE       ((MTSTATUS)0xC0000014L)}\par
00037 \par
00038 {\cf20 //}\par
00039 {\cf20 // ==========================}\par
00040 {\cf20 // MEMORY MTSTATUS}\par
00041 {\cf20 // ==========================}\par
00042 {\cf21 #define MT_NO_MEMORY            ((MTSTATUS)0xC1000001L)}\par
00043 {\cf21 #define MT_MEMORY_LIMIT         ((MTSTATUS)0xC1000002L)}\par
00044 {\cf21 #define MT_PAGE_FAULT_ERROR     ((MTSTATUS)0xC1000003L)}\par
00045 {\cf21 #define MT_HEAP_CORRUPTION      ((MTSTATUS)0xC1000004L)}\par
00046 {\cf21 #define MT_INVALID_ADDRESS      ((MTSTATUS)0xC1000005L)}\par
00047 {\cf21 #define MT_CONFLICTING_ADDRESSES ((MTSTATUS)0xC1000006L)}\par
00048 \par
00049 {\cf20 //}\par
00050 {\cf20 // ==========================}\par
00051 {\cf20 // VIRTUAL FILESYSTEM MTSTATUS}\par
00052 {\cf20 // ==========================}\par
00053 {\cf21 #define MT_IO_ERROR                     ((MTSTATUS)0xC2000001L)}\par
00054 {\cf21 #define MT_VFS_CORRUPTED                ((MTSTATUS)0xC2000002L)}\par
00055 {\cf21 #define MT_VFS_READ_ONLY                ((MTSTATUS)0xC2000003L)}\par
00056 {\cf21 #define MT_VFS_NO_SPACE                 ((MTSTATUS)0xC2000004L)}\par
00057 {\cf21 #define MT_VFS_PERMISSION_DENIED        ((MTSTATUS)0xC2000005L)}\par
00058 {\cf21 #define MT_VFS_INITIALIZATION_FAILURE   ((MTSTATUS)0xC2000006L)}\par
00059 {\cf21 #define MT_VFS_GENERAL_FAILURE          ((MTSTATUS)0xC2000007L)}\par
00060 \par
00061 {\cf20 //}\par
00062 {\cf20 // ==========================}\par
00063 {\cf20 // FAT32-specific MTSTATUS}\par
00064 {\cf20 // ==========================}\par
00065 {\cf21 #define MT_FAT32_CLUSTERS_FULL      ((MTSTATUS)0xC2010001L) }{\cf20 // No free clusters left}\par
00066 {\cf21 #define MT_FAT32_INVALID_CLUSTER    ((MTSTATUS)0xC2010002L) }{\cf20 // Invalid cluster reference}\par
00067 {\cf21 #define MT_FAT32_DIR_FULL           ((MTSTATUS)0xC2010003L) }{\cf20 // Directory has no free entries}\par
00068 {\cf21 #define MT_FAT32_FILE_NOT_FOUND     ((MTSTATUS)0xC2010004L)}\par
00069 {\cf21 #define MT_FAT32_PATH_TOO_LONG      ((MTSTATUS)0xC2010005L)}\par
00070 {\cf21 #define MT_FAT32_INVALID_FILENAME   ((MTSTATUS)0xC2010006L)}\par
00071 {\cf21 #define MT_FAT32_EOF                ((MTSTATUS)0xC2010007L) }{\cf20 // End of file reached}\par
00072 {\cf21 #define MT_FAT32_DIRECTORY_ALREADY_EXISTS ((MTSTATUS)0xC2010008L) }{\cf20 // The specified directory already exists in the path.}\par
00073 {\cf21 #define MT_FAT32_PARENT_PATH_NOT_FOUND ((MTSTATUS)0xC2010009L) }{\cf20 // The directory's parent path has not been found.}\par
00074 {\cf21 #define MT_FAT32_PARENT_PATH_NOT_DIR ((MTSTATUS)0xC2010010L) }{\cf20 // The directory's parent path is not a directory.}\par
00075 {\cf21 #define MT_FAT32_INVALID_WRITE_MODE ((MTSTATUS)0xC2010011L) }{\cf20 // The write mode given to the function is invalid. (Not in FAT32_WRITE_MODE enum)}\par
00076 {\cf21 #define MT_FAT32_CLUSTER_NOT_FOUND ((MTSTATUS)0xC2010012L) }{\cf20 // The directory's / file cluster couldn't have been found.}\par
00077 {\cf21 #define MT_FAT32_CLUSTER_GENERAL_FAILURE ((MTSTATUS)0xC2010013L) }{\cf20 // General failure on a cluster operation.}\par
00078 {\cf21 #define MT_FAT32_DIRECTORY_NOT_FOUND ((MTSTATUS)0xC2010014L) }{\cf20 // FAT32 Directory not found.}\par
00079 {\cf21 #define MT_FAT32_FILENAME_TOO_LONG  ((MTSTATUS)0xC2010015L) }{\cf20 // FAT32 Filename too long..}\par
00080 \par
00081 {\cf20 //}\par
00082 {\cf20 // ==========================}\par
00083 {\cf20 // DRIVER / DEVICE MTSTATUS}\par
00084 {\cf20 // ==========================}\par
00085 {\cf21 #define MT_DEVICE_NOT_READY     ((MTSTATUS)0xC3000001L)}\par
00086 {\cf21 #define MT_DEVICE_ERROR         ((MTSTATUS)0xC3000002L)}\par
00087 {\cf21 #define MT_DEVICE_TIMEOUT       ((MTSTATUS)0xC3000003L)}\par
00088 {\cf21 #define MT_DEVICE_UNSUPPORTED   ((MTSTATUS)0xC3000004L)}\par
00089 {\cf21 #define MT_AHCI_INIT_FAILED     ((MTSTATUS)0xC3010001L)}\par
00090 {\cf21 #define MT_AHCI_PORT_FAILURE    ((MTSTATUS)0xC3010002L)}\par
00091 {\cf21 #define MT_AHCI_READ_FAILURE    ((MTSTATUS)0xC3010003L)}\par
00092 {\cf21 #define MT_AHCI_WRITE_FAILURE   ((MTSTATUS)0xC3010004L)}\par
00093 {\cf21 #define MT_AHCI_TIMEOUT         ((MTSTATUS)0xC3010005L)}\par
00094 {\cf21 #define MT_AHCI_GENERAL_FAILURE ((MTSTATUS)0xC3010006L)}\par
00095 \par
00096 {\cf20 //}\par
00097 {\cf20 // ==========================}\par
00098 {\cf20 // THREAD / SCHEDULER MTSTATUS}\par
00099 {\cf20 // ==========================}\par
00100 {\cf21 #define MT_THREAD_NOT_FOUND     ((MTSTATUS)0xC4000001L)}\par
00101 {\cf21 #define MT_THREAD_CREATION_FAILURE ((MTSTATUS)0xC4000002L)}\par
00102 {\cf21 #define MT_SCHEDULER_ERROR      ((MTSTATUS)0xC4000003L)}\par
00103 {\cf21 #define MT_INVALID_IRQL         ((MTSTATUS)0xC4000004L)}\par
00104 \par
00105 {\cf20 //}\par
00106 {\cf20 // ==========================}\par
00107 {\cf20 // MUTEX MTSTATUS}\par
00108 {\cf20 // ==========================}\par
00109 {\cf21 #define MT_MUTEX_ALREADY_OWNED ((MTSTATUS)0xC5000001L)}\par
00110 {\cf21 #define MT_MUTEX_NOT_OWNED     ((MTSTATUS)0xC5000002L)}\par
00111 {\cf21 #define MT_INVALID_LOCK        ((MTSTATUS)0xC500003L)}\par
00112 \par
00113 {\cf20 //}\par
00114 {\cf20 // ==========================}\par
00115 {\cf20 // EVENT MTSTATUS}\par
00116 {\cf20 // ==========================}\par
00117 {\cf21 #define MT_EVENT_ALREADY_SIGNALED ((MTSTATUS)0xC6000001L)}\par
00118 \par
00119 {\cf20 //}\par
00120 {\cf20 // ==========================}\par
00121 {\cf20 // PROCESS MTSTATUS}\par
00122 {\cf20 // ==========================}\par
00123 {\cf21 #define MT_PROCESS_IS_TERMINATING ((MTSTATUS)0xC7000000L)}\par
00124 \par
00125 {\cf20 //}\par
00126 {\cf20 // ==========================}\par
00127 {\cf20 // EXCEPTION MTSTATUSES}\par
00128 {\cf20 // ==========================}\par
00129 {\cf21 #define MT_ACCESS_VIOLATION ((MTSTATUS)0xC8000000L)}\par
00130 {\cf21 #define MT_GUARD_PAGE_VIOLATION ((MTSTATUS)0xC8000001L)}\par
00131 \par
00132 {\cf21 #endif }{\cf20 // MTSTATUS_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h File Reference\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\bkmkstart AAAAAAACWO}
{\bkmkend AAAAAAACWO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
{\f2 #include <stdbool.h>}\par
{\f2 #include "intrinsics/intrin.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TIME_ENTRY}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CMOS_ADDRESS}\~ 0x70\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CMOS_DATA}\~ 0x71\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
{\bkmkstart AAAAAAACWP}
{\bkmkend AAAAAAACWP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v CMOS_ADDRESS\:time.h}
{\xe \v time.h\:CMOS_ADDRESS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CMOS_ADDRESS\~ 0x70}}
\par
{\bkmkstart AAAAAAACWQ}
{\bkmkend AAAAAAACWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b time.h}.}\par
}
{\xe \v CMOS_DATA\:time.h}
{\xe \v time.h\:CMOS_DATA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CMOS_DATA\~ 0x71}}
\par
{\bkmkstart AAAAAAACWR}
{\bkmkend AAAAAAACWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b time.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
time.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\xe \v C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/time.h}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20  * PROJECT:     MatanelOS Kernel}\par
00003 {\cf20  * LICENSE:     NONE}\par
00004 {\cf20  * PURPOSE:     CMOS Time implementation.}\par
00005 {\cf20  */}\par
00006 \par
00007 {\cf21 #ifndef X86_TIME_H}\par
00008 {\cf21 #define X86_TIME_H}\par
00009 {\cf21 #include <stdint.h>}\par
00010 {\cf21 #include <stdbool.h>}\par
00011 {\cf21 #include "intrinsics/intrin.h"}\par
00012 \par
00013 {\cf20 // RTC CMOS ports}\par
00014 {\cf21 #define CMOS_ADDRESS 0x70}\par
00015 {\cf21 #define CMOS_DATA    0x71}\par
00016 \par
00017 {\cf20 // TIME_ENTRY struct with full date}\par
00018 {\cf17 typedef} {\cf17 struct }\{\par
00019     uint8_t second;   {\cf20 // 0\'9659}\par
00020     uint8_t minute;   {\cf20 // 0\'9659}\par
00021     uint8_t hour;     {\cf20 // 0\'9623}\par
00022     uint8_t day;      {\cf20 // 1\'9631}\par
00023     uint8_t month;    {\cf20 // 1\'9612}\par
00024     uint16_t year;    {\cf20 // full year, e.g., 2025}\par
00025 \} TIME_ENTRY;\par
00026 \par
00027 {\cf20 // Read from CMOS}\par
00028 {\cf17 static} {\cf17 inline} uint8_t cmos_read(uint8_t reg) \{\par
00029     __outbyte(CMOS_ADDRESS, reg);\par
00030     {\cf19 return} __inbyte(CMOS_DATA);\par
00031 \}\par
00032 \par
00033 {\cf20 // Check if RTC is updating}\par
00034 {\cf17 static} {\cf17 inline} {\cf18 bool} rtc_updating({\cf18 void}) \{\par
00035     __outbyte(CMOS_ADDRESS, 0x0A);\par
00036     {\cf19 return} (__inbyte(CMOS_DATA) & 0x80) != 0;\par
00037 \}\par
00038 \par
00039 {\cf20 // Convert BCD \'E2\'86\'92 binary}\par
00040 {\cf17 static} {\cf17 inline} uint8_t bcd_to_bin(uint8_t val) \{\par
00041     {\cf19 return} ((val >> 4) * 10) + (val & 0x0F);\par
00042 \}\par
00043 \par
00044 {\cf20 // Get current time/date (GIVES UTC TIME)}\par
00045 {\cf17 static} TIME_ENTRY get_time({\cf18 void}) \{\par
00046     TIME_ENTRY t;\par
00047     uint8_t century = 0;\par
00048     uint8_t regB;\par
00049 \par
00050     {\cf20 // Wait until RTC is not updating}\par
00051     {\cf19 while} (rtc_updating());\par
00052 \par
00053     {\cf20 // Read raw values}\par
00054     t.second = cmos_read(0x00);\par
00055     t.minute = cmos_read(0x02);\par
00056     t.hour = cmos_read(0x04);\par
00057     t.day = cmos_read(0x07);\par
00058     t.month = cmos_read(0x08);\par
00059     uint8_t year = cmos_read(0x09);\par
00060 \par
00061     {\cf20 // Some BIOSes provide century register (0x32) if available}\par
00062     century = cmos_read(0x32);\par
00063 \par
00064     {\cf20 // Status register B tells us data format}\par
00065     regB = cmos_read(0x0B);\par
00066 \par
00067     {\cf20 // Convert from BCD if needed}\par
00068     {\cf19 if} (!(regB & 0x04)) \{\par
00069         t.second = bcd_to_bin(t.second);\par
00070         t.minute = bcd_to_bin(t.minute);\par
00071         t.hour = bcd_to_bin(t.hour & 0x7F);\par
00072         t.day = bcd_to_bin(t.day);\par
00073         t.month = bcd_to_bin(t.month);\par
00074         year = bcd_to_bin(year);\par
00075         {\cf19 if} (century) century = bcd_to_bin(century);\par
00076     \}\par
00077 \par
00078     {\cf20 // Convert 12h \'E2\'86\'92 24h if needed}\par
00079     {\cf19 if} (!(regB & 0x02) && (t.hour & 0x80)) \{\par
00080         t.hour = ((t.hour & 0x7F) + 12) % 24;\par
00081     \}\par
00082 \par
00083     {\cf20 // Build full year}\par
00084     {\cf19 if} (century != 0) \{\par
00085         t.year = (century * 100) + year;\par
00086     \}\par
00087     {\cf19 else} \{\par
00088         {\cf20 // Fallback: assume 20xx}\par
00089         t.year = 2000 + year;\par
00090     \}\par
00091 \par
00092     {\cf19 return} t;\par
00093 \}\par
00094 \par
00095 {\cf17 static} {\cf18 bool} is_leap_year(uint16_t year) \{\par
00096     {\cf19 return} (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\par
00097 \}\par
00098 \par
00099 {\cf17 static} {\cf17 const} {\cf18 int} days_in_month[12] = \{ 31,28,31,30,31,30,31,31,30,31,30,31 \};\par
00100 \par
00101 {\cf17 static} uint64_t MeGetEpoch({\cf18 void}) \{\par
00102     TIME_ENTRY t = get_time();\par
00103 \par
00104     {\cf20 // 1. count total days since 1970}\par
00105     uint64_t days = 0;\par
00106     {\cf19 for} (uint16_t y = 1970; y < t.year; y++)\par
00107         days += 365 + (is_leap_year(y) ? 1 : 0);\par
00108 \par
00109     {\cf19 for} (uint8_t m = 1; m < t.month; m++)\par
00110         days += days_in_month[m - 1] + (m == 2 && is_leap_year(t.year) ? 1 : 0);\par
00111 \par
00112     days += t.day - 1;\par
00113 \par
00114     {\cf20 // 2. convert to seconds}\par
00115     uint64_t seconds = days * 86400ULL;\par
00116     seconds += t.hour * 3600ULL;\par
00117     seconds += t.minute * 60ULL;\par
00118     seconds += t.second;\par
00119 \par
00120     {\cf19 return} seconds;\par
00121 \}\par
00122 {\cf21 #endif}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
