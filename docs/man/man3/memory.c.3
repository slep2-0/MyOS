.TH "C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c" 3 "MatanelOS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/memory/memory.c
.SH SYNOPSIS
.br
.PP
\fR#include 'memory\&.h'\fP
.br
\fR#include '\&.\&./drivers/gop/gop\&.h'\fP
.br
\fR#include '\&.\&./bugcheck/bugcheck\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBzero_bss\fP (void)"
.br
.RI "Zeroes out the BSS section (garbage data that might have left there) "
.ti -1c
.RI "void \fBinit_heap\fP (void)"
.br
.RI "Initializes the Kernel's HEAP for dynamic memory allocation\&. "
.ti -1c
.RI "void * \fBkmemset\fP (void *dest, int64_t val, uint64_t len)"
.br
.ti -1c
.RI "void * \fBkmemcpy\fP (void *dest, const void *src, uint32_t len)"
.br
.ti -1c
.RI "void * \fBMtAllocateVirtualMemory\fP (size_t wanted_size, size_t align)"
.br
.RI "Allocate \fRwanted_size\fP bytes with \fRalign\fP alignment\&. "
.ti -1c
.RI "bool \fBMtIsHeapAddressAllocated\fP (void *ptr)"
.br
.RI "Returns if the heap pointer given has been allocated by MtAllocateVirtualMemory or not\&. "
.ti -1c
.RI "void * \fBMtAllocateVirtualMemoryEx\fP (size_t wanted_size, size_t align, uint64_t flags)"
.br
.RI "\fBTHE USE OF THIS FUNCTION IS NOT RECOMMENDED -- TO ADD \fBFLAGS\fP TO AN ALLOCATED MEMORY BUFFER USE MtAddPageFlags TO ITS POINTER!!!\fP ** FREEING THE MEMORY OF THIS BUFFER WILL RESULT IN A PAGE FAULT ** Allocates a block of memory from the kernel's memory manager, and sets the paging flags according to the user\&. "
.ti -1c
.RI "void \fBMtFreeVirtualMemory\fP (void *ptr)"
.br
.RI "Releases (frees) a previously allocated block of memory back to the kernel’s memory manager\&. (DOES NOT UNMAP IF FUNCTION USED IS MtAllocateVirtualMemory !) "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBGOP_PARAMS\fP \fBgop_local\fP"
.br
.ti -1c
.RI "uintptr_t \fBheap_current_end\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void init_heap (void )"

.PP
Initializes the Kernel's HEAP for dynamic memory allocation\&. The function declares the globals for the heap current end, as well as setting up the free_list pointer\&. It first creates 1 initial 4KiB frame, maps it to be paged in virtual memory, and increases the heap current end by the frame size (4KiB), so that 1 starting page is allocated\&. 
.PP
Definition at line \fB36\fP of file \fBmemory\&.c\fP\&.
.SS "void * kmemcpy (void * dest, const void * src, uint32_t len)"

.PP
Definition at line \fB138\fP of file \fBmemory\&.c\fP\&.
.SS "void * kmemset (void * dest, int64_t val, uint64_t len)"

.PP
Definition at line \fB125\fP of file \fBmemory\&.c\fP\&.
.SS "void * MtAllocateVirtualMemory (size_t wanted_size, size_t align)"

.PP
Allocate \fRwanted_size\fP bytes with \fRalign\fP alignment\&. Allocates a block of memory from the kernel’s memory manager\&. Zero the new memory block out\&.
.PP
Definition at line \fB154\fP of file \fBmemory\&.c\fP\&.
.SS "void * MtAllocateVirtualMemoryEx (size_t size, size_t align, uint64_t flags)"

.PP
\fBTHE USE OF THIS FUNCTION IS NOT RECOMMENDED -- TO ADD \fBFLAGS\fP TO AN ALLOCATED MEMORY BUFFER USE MtAddPageFlags TO ITS POINTER!!!\fP ** FREEING THE MEMORY OF THIS BUFFER WILL RESULT IN A PAGE FAULT ** Allocates a block of memory from the kernel's memory manager, and sets the paging flags according to the user\&. 
.PP
\fBParameters\fP
.RS 4
\fIsize\fP Size in bytes to allocate
.br
\fIalign\fP Alignment for each byteblock (use internal structs for process \\ other - use _Alignof)
.br
\fIflags\fP PAGE_FLAGS flags\&.
.RE
.PP
\fBReturns\fP
.RS 4
Pointer to start of allocated memory
.RE
.PP

.PP
Definition at line \fB227\fP of file \fBmemory\&.c\fP\&.
.SS "void MtFreeVirtualMemory (void * ptr)"

.PP
Releases (frees) a previously allocated block of memory back to the kernel’s memory manager\&. (DOES NOT UNMAP IF FUNCTION USED IS MtAllocateVirtualMemory !) 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP Pointer to the allocated memory block to free
.RE
.PP

.PP
Definition at line \fB276\fP of file \fBmemory\&.c\fP\&.
.SS "bool MtIsHeapAddressAllocated (void * ptr)"

.PP
Returns if the heap pointer given has been allocated by MtAllocateVirtualMemory or not\&. 
.PP
\fBParameters\fP
.RS 4
\fIptr\fP Address of what is given from MtAllocateVirtualMemory\&.
.RE
.PP
\fBReturns\fP
.RS 4
.RE
.PP

.PP
Definition at line \fB220\fP of file \fBmemory\&.c\fP\&.
.SS "void zero_bss (void )"

.PP
Zeroes out the BSS section (garbage data that might have left there) The function takes the start and end address of the \fR\&.bss\fP section (provided by the linker script), and iterates over each byte from the start address up to (but not including) the end address, writing zero to each location\&. This ensures all global/static variables without initializers are zeroed\&. 
.PP
Definition at line \fB23\fP of file \fBmemory\&.c\fP\&.
.SH "Variable Documentation"
.PP 
.SS "\fBGOP_PARAMS\fP gop_local\fR [extern]\fP"

.PP
Definition at line \fB15\fP of file \fBkernel\&.c\fP\&.
.SS "uintptr_t heap_current_end"

.PP
Definition at line \fB13\fP of file \fBmemory\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for MatanelOS from the source code\&.
