.TH "C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/matanel/Desktop/Projects/KernelDevelopment/kernel/cpu/thread/thread.c
.SH SYNOPSIS
.br
.PP
\fR#include 'thread\&.h'\fP
.br
\fR#include '\&.\&./\&.\&./bugcheck/bugcheck\&.h'\fP
.br
\fR#include '\&.\&./\&.\&./assert\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMIN_TID\fP   4u"
.br
.ti -1c
.RI "#define \fBMAX_TID\fP   0xFFFFFFFCu"
.br
.ti -1c
.RI "#define \fBALIGN_DELTA\fP   4u"
.br
.ti -1c
.RI "#define \fBMAX_FREE_POOL\fP   1024u"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBMtCreateThread\fP (\fBThreadEntry\fP entry, \fBTHREAD_PARAMETER\fP parameter, \fBtimeSliceTicks\fP TIMESLICE, bool kernelThread)"
.br
.RI "Create a new thread with parameters\&. (if no parameters are supplied (NULL), it will be handled, so no worries) "
.ti -1c
.RI "\fBThread\fP * \fBMtGetCurrentThread\fP (void)"
.br
.RI "This function will return the current working thread\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBCPU\fP \fBcpu\fP"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ALIGN_DELTA   4u"

.PP
Definition at line \fB7\fP of file \fBthread\&.c\fP\&.
.SS "#define MAX_FREE_POOL   1024u"

.PP
Definition at line \fB8\fP of file \fBthread\&.c\fP\&.
.SS "#define MAX_TID   0xFFFFFFFCu"

.PP
Definition at line \fB6\fP of file \fBthread\&.c\fP\&.
.SS "#define MIN_TID   4u"

.PP
Definition at line \fB5\fP of file \fBthread\&.c\fP\&.
.SH "Function Documentation"
.PP 
.SS "void MtCreateThread (\fBThreadEntry\fP entry, \fBTHREAD_PARAMETER\fP parameter, \fBtimeSliceTicks\fP TIMESLICE, bool kernelThread)"

.PP
Create a new thread with parameters\&. (if no parameters are supplied (NULL), it will be handled, so no worries) 
.PP
\fBParameters\fP
.RS 4
\fIentry\fP The entry point address\&. (usually a function, I don't see any other use\&.)
.br
\fIparameters\fP The pointer to the parameters (passed as a pointer, the function itself must convert it back to its original parameter variable)
.br
\fIkernelThread\fP Specificies if the thread should be a kernel one or not\&. (If not, it will setup a process, idk how I would implement it, when I'll get on it) TODO
.RE
.PP
TODO implement user mode\&.

.PP
For when we context switch (this is why cfm is in stackTop), set the registers to all 0\&. (since the stack for the thread holds the registers when we context switch)

.PP
Here comes the actual part that separates between the normal and Ex version of creating the thread\&. - Remmber to use System V ABI as this is GCC\&.
.PP
Definition at line \fB84\fP of file \fBthread\&.c\fP\&.
.SS "\fBThread\fP * MtGetCurrentThread (void )"

.PP
This function will return the current working thread\&. 
.PP
\fBReturns\fP
.RS 4
Pointer to current \fBThread\fP (struct)
.RE
.PP

.PP
Definition at line \fB156\fP of file \fBthread\&.c\fP\&.
.SH "Variable Documentation"
.PP 
.SS "\fBCPU\fP cpu\fR [extern]\fP"

.PP
Definition at line \fB23\fP of file \fBkernel\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
